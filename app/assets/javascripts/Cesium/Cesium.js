/**
 * Cesium - https://github.com/AnalyticalGraphicsInc/cesium
 *
 * Copyright 2011-2013 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md for full licensing details.
 */
/**
 * @license
 * almond 0.2.5 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */

/**
 @license
 sprintf.js from the php.js project - https://github.com/kvz/phpjs
 Directly from https://github.com/kvz/phpjs/blob/master/functions/strings/sprintf.js

 php.js is copyright 2012 Kevin van Zonneveld.

 Portions copyright Brett Zamir (http://brett-zamir.me), Kevin van Zonneveld
 (http://kevin.vanzonneveld.net), Onno Marsman, Theriault, Michael White
 (http://getsprink.com), Waldo Malqui Silva, Paulo Freitas, Jack, Jonas
 Raoni Soares Silva (http://www.jsfromhell.com), Philip Peterson, Legaev
 Andrey, Ates Goral (http://magnetiq.com), Alex, Ratheous, Martijn Wieringa,
 Rafa? Kukawski (http://blog.kukawski.pl), lmeyrick
 (https://sourceforge.net/projects/bcmath-js/), Nate, Philippe Baumann,
 Enrique Gonzalez, Webtoolkit.info (http://www.webtoolkit.info/), Carlos R.
 L. Rodrigues (http://www.jsfromhell.com), Ash Searle
 (http://hexmen.com/blog/), Jani Hartikainen, travc, Ole Vrijenhoek,
 Erkekjetter, Michael Grier, Rafa? Kukawski (http://kukawski.pl), Johnny
 Mast (http://www.phpvrouwen.nl), T.Wild, d3x,
 http://stackoverflow.com/questions/57803/how-to-convert-decimal-to-hex-in-javascript,
 Rafa? Kukawski (http://blog.kukawski.pl/), stag019, pilus, WebDevHobo
 (http://webdevhobo.blogspot.com/), marrtins, GeekFG
 (http://geekfg.blogspot.com), Andrea Giammarchi
 (http://webreflection.blogspot.com), Arpad Ray (mailto:arpad@php.net),
 gorthaur, Paul Smith, Tim de Koning (http://www.kingsquare.nl), Joris, Oleg
 Eremeev, Steve Hilder, majak, gettimeofday, KELAN, Josh Fraser
 (http://onlineaspect.com/2007/06/08/auto-detect-a-time-zone-with-javascript/),
 Marc Palau, Martin
 (http://www.erlenwiese.de/), Breaking Par Consulting Inc
 (http://www.breakingpar.com/bkp/home.nsf/0/87256B280015193F87256CFB006C45F7),
 Chris, Mirek Slugen, saulius, Alfonso Jimenez
 (http://www.alfonsojimenez.com), Diplom@t (http://difane.com/), felix,
 Mailfaker (http://www.weedem.fr/), Tyler Akins (http://rumkin.com), Caio
 Ariede (http://caioariede.com), Robin, Kankrelune
 (http://www.webfaktory.info/), Karol Kowalski, Imgen Tata
 (http://www.myipdf.com/), mdsjack (http://www.mdsjack.bo.it), Dreamer,
 Felix Geisendoerfer (http://www.debuggable.com/felix), Lars Fischer, AJ,
 David, Aman Gupta, Michael White, Public Domain
 (http://www.json.org/json2.js), Steven Levithan
 (http://blog.stevenlevithan.com), Sakimori, Pellentesque Malesuada,
 Thunder.m, Dj (http://phpjs.org/functions/htmlentities:425#comment_134018),
 Steve Clay, David James, Francois, class_exists, nobbler, T. Wild, Itsacon
 (http://www.itsacon.net/), date, Ole Vrijenhoek (http://www.nervous.nl/),
 Fox, Raphael (Ao RUDLER), Marco, noname, Mateusz "loonquawl" Zalega, Frank
 Forte, Arno, ger, mktime, john (http://www.jd-tech.net), Nick Kolosov
 (http://sammy.ru), marc andreu, Scott Cariss, Douglas Crockford
 (http://javascript.crockford.com), madipta, Slawomir Kaniecki,
 ReverseSyntax, Nathan, Alex Wilson, kenneth, Bayron Guevara, Adam Wallner
 (http://web2.bitbaro.hu/), paulo kuong, jmweb, Lincoln Ramsay, djmix,
 Pyerre, Jon Hohle, Thiago Mata (http://thiagomata.blog.com), lmeyrick
 (https://sourceforge.net/projects/bcmath-js/this.), Linuxworld, duncan,
 Gilbert, Sanjoy Roy, Shingo, sankai, Oskar Larsson H?gfeldt
 (http://oskar-lh.name/), Denny Wardhana, 0m3r, Everlasto, Subhasis Deb,
 josh, jd, Pier Paolo Ramon (http://www.mastersoup.com/), P, merabi, Soren
 Hansen, Eugene Bulkin (http://doubleaw.com/), Der Simon
 (http://innerdom.sourceforge.net/), echo is bad, Ozh, XoraX
 (http://www.xorax.info), EdorFaus, JB, J A R, Marc Jansen, Francesco, LH,
 Stoyan Kyosev (http://www.svest.org/), nord_ua, omid
 (http://phpjs.org/functions/380:380#comment_137122), Brad Touesnard, MeEtc
 (http://yass.meetcweb.com), Peter-Paul Koch
 (http://www.quirksmode.org/js/beat.html), Olivier Louvignes
 (http://mg-crea.com/), T0bsn, Tim Wiel, Bryan Elliott, Jalal Berrami,
 Martin, JT, David Randall, Thomas Beaucourt (http://www.webapp.fr), taith,
 vlado houba, Pierre-Luc Paour, Kristof Coomans (SCK-CEN Belgian Nucleair
 Research Centre), Martin Pool, Kirk Strobeck, Rick Waldron, Brant Messenger
 (http://www.brantmessenger.com/), Devan Penner-Woelk, Saulo Vallory, Wagner
 B. Soares, Artur Tchernychev, Valentina De Rosa, Jason Wong
 (http://carrot.org/), Christoph, Daniel Esteban, strftime, Mick@el, rezna,
 Simon Willison (http://simonwillison.net), Anton Ongson, Gabriel Paderni,
 Marco van Oort, penutbutterjelly, Philipp Lenssen, Bjorn Roesbeke
 (http://www.bjornroesbeke.be/), Bug?, Eric Nagel, Tomasz Wesolowski,
 Evertjan Garretsen, Bobby Drake, Blues (http://tech.bluesmoon.info/), Luke
 Godfrey, Pul, uestla, Alan C, Ulrich, Rafal Kukawski, Yves Sucaet,
 sowberry, Norman "zEh" Fuchs, hitwork, Zahlii, johnrembo, Nick Callen,
 Steven Levithan (stevenlevithan.com), ejsanders, Scott Baker, Brian Tafoya
 (http://www.premasolutions.com/), Philippe Jausions
 (http://pear.php.net/user/jausions), Aidan Lister
 (http://aidanlister.com/), Rob, e-mike, HKM, ChaosNo1, metjay, strcasecmp,
 strcmp, Taras Bogach, jpfle, Alexander Ermolaev
 (http://snippets.dzone.com/user/AlexanderErmolaev), DxGx, kilops, Orlando,
 dptr1988, Le Torbi, James (http://www.james-bell.co.uk/), Pedro Tainha
 (http://www.pedrotainha.com), James, Arnout Kazemier
 (http://www.3rd-Eden.com), Chris McMacken, gabriel paderni, Yannoo,
 FGFEmperor, baris ozdil, Tod Gentille, Greg Frazier, jakes, 3D-GRAF, Allan
 Jensen (http://www.winternet.no), Howard Yeend, Benjamin Lupton, davook,
 daniel airton wermann (http://wermann.com.br), Atli T¨®r, Maximusya, Ryan
 W Tenney (http://ryan.10e.us), Alexander M Beedie, fearphage
 (http://http/my.opera.com/fearphage/), Nathan Sepulveda, Victor, Matteo,
 Billy, stensi, Cord, Manish, T.J. Leahy, Riddler
 (http://www.frontierwebdev.com/), Rafa? Kukawski, FremyCompany, Matt
 Bradley, Tim de Koning, Luis Salazar (http://www.freaky-media.com/), Diogo
 Resende, Rival, Andrej Pavlovic, Garagoth, Le Torbi
 (http://www.letorbi.de/), Dino, Josep Sanz (http://www.ws3.es/), rem,
 Russell Walker (http://www.nbill.co.uk/), Jamie Beck
 (http://www.terabit.ca/), setcookie, Michael, YUI Library:
 http://developer.yahoo.com/yui/docs/YAHOO.util.DateLocale.html, Blues at
 http://hacks.bluesmoon.info/strftime/strftime.js, Ben
 (http://benblume.co.uk/), DtTvB
 (http://dt.in.th/2008-09-16.string-length-in-bytes.html), Andreas, William,
 meo, incidence, Cagri Ekin, Amirouche, Amir Habibi
 (http://www.residence-mixte.com/), Luke Smith (http://lucassmith.name),
 Kheang Hok Chin (http://www.distantia.ca/), Jay Klehr, Lorenzo Pisani,
 Tony, Yen-Wei Liu, Greenseed, mk.keck, Leslie Hoare, dude, booeyOH, Ben
 Bryan

 Licensed under the MIT (MIT-LICENSE.txt) license.

 Permission is hereby granted, free of charge, to any person obtaining a
 copy of this software and associated documentation files (the
 "Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:

 The above copyright notice and this permission notice shall be included
 in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 IN NO EVENT SHALL KEVIN VAN ZONNEVELD BE LIABLE FOR ANY CLAIM, DAMAGES
 OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 @license
 when.js - https://github.com/cujojs/when

 MIT License (c) copyright B Cavalier & J Hann

 * A lightweight CommonJS Promises/A and when() implementation
 * when is part of the cujo.js family of libraries (http://cujojs.com/)
 *
 * Licensed under the MIT License at:
 * http://www.opensource.org/licenses/mit-license.php
 *
 * @version 1.7.1
 */

/**
 * @fileOverview
 * @license
 *
 * Grauw URI utilities
 *
 * See: http://hg.grauw.nl/grauw-lib/file/tip/src/uri.js
 *
 * @author Laurens Holst (http://www.grauw.nl/)
 *
 *   Copyright 2012 Laurens Holst
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */

/**
 @license
 fontmetrics.js - https://github.com/Pomax/fontmetrics.js

 This library rewrites the Canvas2D "measureText" function
 so that it returns a more complete metrics object.
 This library is licensed under the MIT (Expat) license,
 the text for which is included below.

 ** -----------------------------------------------------------------------------

 CHANGELOG:

 2012-01-21 - Whitespace handling added by Joe Turner
 (https://github.com/oampo)

 ** -----------------------------------------------------------------------------

 Copyright (C) 2011 by Mike "Pomax" Kamermans

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 **/

/**
 @license
 Copyright (c) 2012, Michael Bostock
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright notice, this
 list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright notice,
 this list of conditions and the following disclaimer in the documentation
 and/or other materials provided with the distribution.

 * The name Michael Bostock may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED. IN NO EVENT SHALL MICHAEL BOSTOCK BE LIABLE FOR ANY DIRECT,
 INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @license
 * Description : Array and textureless GLSL 2D/3D/4D simplex
 *               noise functions.
 *      Author : Ian McEwan, Ashima Arts.
 *  Maintainer : ijm
 *     Lastmod : 20110822 (ijm)
 *     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
 *               Distributed under the MIT License. See LICENSE file.
 *               https://github.com/ashima/webgl-noise
 */

/**
 * @license
 * Cellular noise ("Worley noise") in 2D in GLSL.
 * Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.
 * This code is released under the conditions of the MIT license.
 * See LICENSE file for details.
 */

/**
 @license
 tween.js - https://github.com/sole/tween.js

 Copyright (c) 2010-2012 Tween.js authors.

 Easing equations Copyright (c) 2001 Robert Penner http://robertpenner.com/easing/

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 */

/**
 * @license
 * Copyright (c) 2000-2005, Sean O'Neil (s_p_oneil@hotmail.com)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * * Neither the name of the project nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Modifications made by Analytical Graphics, Inc.
 */

/**
 @license
 Knockout JavaScript library v2.2.1
 (c) Steven Sanderson - http://knockoutjs.com/
 License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */

/**
 * @license
 * WeakMap shim
 * (The MIT License)
 *
 * Copyright (c) 2012 Brandon Benvie <http://bbenvie.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
 * associated documentation files (the 'Software'), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge, publish, distribute,
 * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included with all copies or
 * substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
 * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * @license
 * Knockout ES5 plugin - https://github.com/SteveSanderson/knockout-es5
 * Copyright (c) Steve Sanderson
 * MIT license
 */

!function () {
    var e, t, n;
    !function (i) {
        function r(e, t) {
            return w.call(e, t)
        }

        function o(e, t) {
            var n, i, r, o, a, s, u, l, c, d, f = t && t.split("/"), h = g.map, p = h && h["*"] || {};
            if (e && "." === e.charAt(0))if (t) {
                for (f = f.slice(0, f.length - 1), e = f.concat(e.split("/")), l = 0; l < e.length; l += 1)if (d = e[l], "." === d)e.splice(l, 1), l -= 1; else if (".." === d) {
                    if (1 === l && (".." === e[2] || ".." === e[0]))break;
                    l > 0 && (e.splice(l - 1, 2), l -= 2)
                }
                e = e.join("/")
            } else 0 === e.indexOf("./") && (e = e.substring(2));
            if ((f || p) && h) {
                for (n = e.split("/"), l = n.length; l > 0; l -= 1) {
                    if (i = n.slice(0, l).join("/"), f)for (c = f.length; c > 0; c -= 1)if (r = h[f.slice(0, c).join("/")], r && (r = r[i])) {
                        o = r, a = l;
                        break
                    }
                    if (o)break;
                    !s && p && p[i] && (s = p[i], u = l)
                }
                !o && s && (o = s, a = u), o && (n.splice(0, a, o), e = n.join("/"))
            }
            return e
        }

        function a(e, t) {
            return function () {
                return h.apply(i, C.call(arguments, 0).concat([e, t]))
            }
        }

        function s(e) {
            return function (t) {
                return o(t, e)
            }
        }

        function u(e) {
            return function (t) {
                y[e] = t
            }
        }

        function l(e) {
            if (r(v, e)) {
                var t = v[e];
                delete v[e], _[e] = !0, f.apply(i, t)
            }
            if (!r(y, e) && !r(_, e))throw new Error("No " + e);
            return y[e]
        }

        function c(e) {
            var t, n = e ? e.indexOf("!") : -1;
            return n > -1 && (t = e.substring(0, n), e = e.substring(n + 1, e.length)), [t, e]
        }

        function d(e) {
            return function () {
                return g && g.config && g.config[e] || {}
            }
        }

        var f, h, p, m, y = {}, v = {}, g = {}, _ = {}, w = Object.prototype.hasOwnProperty, C = [].slice;
        p = function (e, t) {
            var n, i = c(e), r = i[0];
            return e = i[1], r && (r = o(r, t), n = l(r)), r ? e = n && n.normalize ? n.normalize(e, s(t)) : o(e, t) : (e = o(e, t), i = c(e), r = i[0], e = i[1], r && (n = l(r))), {f: r ? r + "!" + e : e, n: e, pr: r, p: n}
        }, m = {require: function (e) {
            return a(e)
        }, exports: function (e) {
            var t = y[e];
            return"undefined" != typeof t ? t : y[e] = {}
        }, module: function (e) {
            return{id: e, uri: "", exports: y[e], config: d(e)}
        }}, f = function (e, t, n, o) {
            var s, c, d, f, h, g, w = [];
            if (o = o || e, "function" == typeof n) {
                for (t = !t.length && n.length ? ["require", "exports", "module"] : t, h = 0; h < t.length; h += 1)if (f = p(t[h], o), c = f.f, "require" === c)w[h] = m.require(e); else if ("exports" === c)w[h] = m.exports(e), g = !0; else if ("module" === c)s = w[h] = m.module(e); else if (r(y, c) || r(v, c) || r(_, c))w[h] = l(c); else {
                    if (!f.p)throw new Error(e + " missing " + c);
                    f.p.load(f.n, a(o, !0), u(c), {}), w[h] = y[c]
                }
                d = n.apply(y[e], w), e && (s && s.exports !== i && s.exports !== y[e] ? y[e] = s.exports : d === i && g || (y[e] = d))
            } else e && (y[e] = n)
        }, e = t = h = function (e, t, n, r, o) {
            return"string" == typeof e ? m[e] ? m[e](t) : l(p(e, t).f) : (e.splice || (g = e, t.splice ? (e = t, t = n, n = null) : e = i), t = t || function () {
            }, "function" == typeof n && (n = r, r = o), r ? f(i, e, t, n) : setTimeout(function () {
                f(i, e, t, n)
            }, 4), h)
        }, h.config = function (e) {
            return g = e, g.deps && h(g.deps, g.callback), h
        }, n = function (e, t, n) {
            t.splice || (n = t, t = []), r(y, e) || r(v, e) || (v[e] = [e, t, n])
        }, n.amd = {jQuery: !0}
    }(), n("Core/freezeObject", [], function () {
        "use strict";
        var e = Object.freeze;
        return"undefined" == typeof e && (e = function (e) {
            return e
        }), e
    }), n("Core/defaultValue", ["./freezeObject"], function (e) {
        "use strict";
        var t = function (e, t) {
            return void 0 !== e ? e : t
        };
        return t.EMPTY_OBJECT = e({}), t
    }), n("Core/DeveloperError", [], function () {
        "use strict";
        var e = function (e) {
            this.name = "DeveloperError", this.message = e, this.error = new Error, this.stack = this.error.stack
        };
        return e.prototype.toString = function () {
            var e = this.name + ": " + this.message;
            return e += "undefined" != typeof this.stack ? "\n" + this.stack.toString() : "\n" + this.error.toString()
        }, e
    }), n("Core/Cartesian3", ["./defaultValue", "./DeveloperError", "./freezeObject"], function (e, t, n) {
        "use strict";
        var i = function (t, n, i) {
            this.x = e(t, 0), this.y = e(n, 0), this.z = e(i, 0)
        };
        i.fromSpherical = function (n, r) {
            if ("undefined" == typeof n)throw new t("spherical is required");
            "undefined" == typeof r && (r = new i);
            var o = n.clock, a = n.cone, s = e(n.magnitude, 1), u = s * Math.sin(a);
            return r.x = u * Math.cos(o), r.y = u * Math.sin(o), r.z = s * Math.cos(a), r
        }, i.fromArray = function (n, r, o) {
            if ("undefined" == typeof n)throw new t("values is required.");
            if (r + 3 > n.length)throw new t("offset + 3 is greater than the length of the array.");
            return r = e(r, 0), "undefined" == typeof o && (o = new i), o.x = n[r + 0], o.y = n[r + 1], o.z = n[r + 2], o
        }, i.fromElements = function (e, t, n, r) {
            return"undefined" == typeof r ? new i(e, t, n) : (r.x = e, r.y = t, r.z = n, r)
        }, i.clone = function (e, t) {
            return"undefined" == typeof e ? void 0 : "undefined" == typeof t ? new i(e.x, e.y, e.z) : (t.x = e.x, t.y = e.y, t.z = e.z, t)
        }, i.fromCartesian4 = i.clone, i.getMaximumComponent = function (e) {
            if ("undefined" == typeof e)throw new t("cartesian is required");
            return Math.max(e.x, e.y, e.z)
        }, i.getMinimumComponent = function (e) {
            if ("undefined" == typeof e)throw new t("cartesian is required");
            return Math.min(e.x, e.y, e.z)
        }, i.magnitudeSquared = function (e) {
            if ("undefined" == typeof e)throw new t("cartesian is required");
            return e.x * e.x + e.y * e.y + e.z * e.z
        }, i.magnitude = function (e) {
            return Math.sqrt(i.magnitudeSquared(e))
        };
        var r = new i;
        i.distance = function (e, n) {
            if ("undefined" == typeof e || "undefined" == typeof n)throw new t("left and right are required.");
            return i.subtract(e, n, r), i.magnitude(r)
        }, i.normalize = function (e, n) {
            if ("undefined" == typeof e)throw new t("cartesian is required");
            var r = i.magnitude(e);
            return"undefined" == typeof n ? new i(e.x / r, e.y / r, e.z / r) : (n.x = e.x / r, n.y = e.y / r, n.z = e.z / r, n)
        }, i.dot = function (e, n) {
            if ("undefined" == typeof e)throw new t("left is required");
            if ("undefined" == typeof n)throw new t("right is required");
            return e.x * n.x + e.y * n.y + e.z * n.z
        }, i.multiplyComponents = function (e, n, r) {
            if ("undefined" == typeof e)throw new t("left is required");
            if ("undefined" == typeof n)throw new t("right is required");
            return"undefined" == typeof r ? new i(e.x * n.x, e.y * n.y, e.z * n.z) : (r.x = e.x * n.x, r.y = e.y * n.y, r.z = e.z * n.z, r)
        }, i.add = function (e, n, r) {
            if ("undefined" == typeof e)throw new t("left is required");
            if ("undefined" == typeof n)throw new t("right is required");
            return"undefined" == typeof r ? new i(e.x + n.x, e.y + n.y, e.z + n.z) : (r.x = e.x + n.x, r.y = e.y + n.y, r.z = e.z + n.z, r)
        }, i.subtract = function (e, n, r) {
            if ("undefined" == typeof e)throw new t("left is required");
            if ("undefined" == typeof n)throw new t("right is required");
            return"undefined" == typeof r ? new i(e.x - n.x, e.y - n.y, e.z - n.z) : (r.x = e.x - n.x, r.y = e.y - n.y, r.z = e.z - n.z, r)
        }, i.multiplyByScalar = function (e, n, r) {
            if ("undefined" == typeof e)throw new t("cartesian is required");
            if ("number" != typeof n)throw new t("scalar is required and must be a number.");
            return"undefined" == typeof r ? new i(e.x * n, e.y * n, e.z * n) : (r.x = e.x * n, r.y = e.y * n, r.z = e.z * n, r)
        }, i.divideByScalar = function (e, n, r) {
            if ("undefined" == typeof e)throw new t("cartesian is required");
            if ("number" != typeof n)throw new t("scalar is required and must be a number.");
            return"undefined" == typeof r ? new i(e.x / n, e.y / n, e.z / n) : (r.x = e.x / n, r.y = e.y / n, r.z = e.z / n, r)
        }, i.negate = function (e, n) {
            if ("undefined" == typeof e)throw new t("cartesian is required");
            return"undefined" == typeof n ? new i(-e.x, -e.y, -e.z) : (n.x = -e.x, n.y = -e.y, n.z = -e.z, n)
        }, i.abs = function (e, n) {
            if ("undefined" == typeof e)throw new t("cartesian is required");
            return"undefined" == typeof n ? new i(Math.abs(e.x), Math.abs(e.y), Math.abs(e.z)) : (n.x = Math.abs(e.x), n.y = Math.abs(e.y), n.z = Math.abs(e.z), n)
        };
        var o = new i;
        i.lerp = function (e, n, r, a) {
            if ("undefined" == typeof e)throw new t("start is required.");
            if ("undefined" == typeof n)throw new t("end is required.");
            if ("number" != typeof r)throw new t("t is required and must be a number.");
            return i.multiplyByScalar(n, r, o), a = i.multiplyByScalar(e, 1 - r, a), i.add(o, a, a)
        };
        var a = new i, s = new i;
        i.angleBetween = function (e, n) {
            if ("undefined" == typeof e)throw new t("left is required");
            if ("undefined" == typeof n)throw new t("right is required");
            i.normalize(e, a), i.normalize(n, s);
            var r = i.dot(a, s), o = i.cross(a, s, a).magnitude();
            return Math.atan2(o, r)
        };
        var u = new i;
        return i.mostOrthogonalAxis = function (e, n) {
            if ("undefined" == typeof e)throw new t("cartesian is required.");
            var r = i.normalize(e, u);
            return i.abs(r, r), n = r.x <= r.y ? r.x <= r.z ? i.clone(i.UNIT_X, n) : i.clone(i.UNIT_Z, n) : r.y <= r.z ? i.clone(i.UNIT_Y, n) : i.clone(i.UNIT_Z, n)
        }, i.equals = function (e, t) {
            return e === t || "undefined" != typeof e && "undefined" != typeof t && e.x === t.x && e.y === t.y && e.z === t.z
        }, i.equalsEpsilon = function (e, n, i) {
            if ("number" != typeof i)throw new t("epsilon is required and must be a number.");
            return e === n || "undefined" != typeof e && "undefined" != typeof n && Math.abs(e.x - n.x) <= i && Math.abs(e.y - n.y) <= i && Math.abs(e.z - n.z) <= i
        }, i.cross = function (e, n, r) {
            if ("undefined" == typeof e)throw new t("left is required");
            if ("undefined" == typeof n)throw new t("right is required");
            var o = e.x, a = e.y, s = e.z, u = n.x, l = n.y, c = n.z, d = a * c - s * l, f = s * u - o * c, h = o * l - a * u;
            return"undefined" == typeof r ? new i(d, f, h) : (r.x = d, r.y = f, r.z = h, r)
        }, i.ZERO = n(new i(0, 0, 0)), i.UNIT_X = n(new i(1, 0, 0)), i.UNIT_Y = n(new i(0, 1, 0)), i.UNIT_Z = n(new i(0, 0, 1)), i.prototype.getMaximumComponent = function () {
            return i.getMaximumComponent(this)
        }, i.prototype.getMinimumComponent = function () {
            return i.getMinimumComponent(this)
        }, i.prototype.clone = function (e) {
            return i.clone(this, e)
        }, i.prototype.magnitudeSquared = function () {
            return i.magnitudeSquared(this)
        }, i.prototype.magnitude = function () {
            return i.magnitude(this)
        }, i.prototype.normalize = function (e) {
            return i.normalize(this, e)
        }, i.prototype.dot = function (e) {
            return i.dot(this, e)
        }, i.prototype.multiplyComponents = function (e, t) {
            return i.multiplyComponents(this, e, t)
        }, i.prototype.add = function (e, t) {
            return i.add(this, e, t)
        }, i.prototype.subtract = function (e, t) {
            return i.subtract(this, e, t)
        }, i.prototype.multiplyByScalar = function (e, t) {
            return i.multiplyByScalar(this, e, t)
        }, i.prototype.divideByScalar = function (e, t) {
            return i.divideByScalar(this, e, t)
        }, i.prototype.negate = function (e) {
            return i.negate(this, e)
        }, i.prototype.abs = function (e) {
            return i.abs(this, e)
        }, i.prototype.lerp = function (e, t, n) {
            return i.lerp(this, e, t, n)
        }, i.prototype.angleBetween = function (e) {
            return i.angleBetween(this, e)
        }, i.prototype.mostOrthogonalAxis = function (e) {
            return i.mostOrthogonalAxis(this, e)
        }, i.prototype.equals = function (e) {
            return i.equals(this, e)
        }, i.prototype.equalsEpsilon = function (e, t) {
            return i.equalsEpsilon(this, e, t)
        }, i.prototype.toString = function () {
            return"(" + this.x + ", " + this.y + ", " + this.z + ")"
        }, i.prototype.cross = function (e, t) {
            return i.cross(this, e, t)
        }, i
    }), n("Core/Enumeration", [], function () {
        "use strict";
        var e = function (e, t, n) {
            if (this.value = e, this.name = t, "undefined" != typeof n)for (var i in n)n.hasOwnProperty(i) && (this[i] = n[i])
        };
        return e.prototype.valueOf = function () {
            return this.value
        }, e.prototype.toString = function () {
            return this.name
        }, e
    }), n("Core/Intersect", ["./Enumeration"], function (e) {
        "use strict";
        var t = {OUTSIDE: new e(-1, "OUTSIDE"), INTERSECTING: new e(0, "INTERSECTING"), INSIDE: new e(1, "INSIDE")};
        return t
    }), n("Core/AxisAlignedBoundingBox", ["./defaultValue", "./DeveloperError", "./Cartesian3", "./Intersect"], function (e, t, n, i) {
        "use strict";
        var r = function (t, i, r) {
            this.minimum = n.clone(e(t, n.ZERO)), this.maximum = n.clone(e(i, n.ZERO)), "undefined" == typeof r ? (r = n.add(this.minimum, this.maximum), n.multiplyByScalar(r, .5, r)) : r = n.clone(r), this.center = r
        };
        r.fromPoints = function (e, t) {
            if ("undefined" == typeof t && (t = new r), "undefined" == typeof e || 0 === e.length)return t.minimum = n.clone(n.ZERO, t.minimum), t.maximum = n.clone(n.ZERO, t.maximum), t.center = n.clone(n.ZERO, t.center), t;
            for (var i = e[0].x, o = e[0].y, a = e[0].z, s = e[0].x, u = e[0].y, l = e[0].z, c = e.length, d = 1; c > d; d++) {
                var f = e[d], h = f.x, p = f.y, m = f.z;
                i = Math.min(h, i), s = Math.max(h, s), o = Math.min(p, o), u = Math.max(p, u), a = Math.min(m, a), l = Math.max(m, l)
            }
            var y = t.minimum;
            y.x = i, y.y = o, y.z = a;
            var v = t.maximum;
            v.x = s, v.y = u, v.z = l;
            var g = n.add(y, v, t.center);
            return n.multiplyByScalar(g, .5, g), t
        }, r.clone = function (e, t) {
            return"undefined" == typeof e ? void 0 : "undefined" == typeof t ? new r(e.minimum, e.maximum) : (t.minimum = n.clone(e.minimum, t.minimum), t.maximum = n.clone(e.maximum, t.maximum), t.center = n.clone(e.center, t.center), t)
        }, r.equals = function (e, t) {
            return e === t || "undefined" != typeof e && "undefined" != typeof t && n.equals(e.center, t.center) && n.equals(e.minimum, t.minimum) && n.equals(e.maximum, t.maximum)
        };
        var o = new n;
        return r.intersect = function (e, r) {
            if ("undefined" == typeof e)throw new t("box is required.");
            if ("undefined" == typeof r)throw new t("plane is required.");
            o = n.subtract(e.maximum, e.minimum, o);
            var a = n.multiplyByScalar(o, .5, o), s = a.x * Math.abs(r.x) + a.y * Math.abs(r.y) + a.z * Math.abs(r.z), u = n.dot(e.center, r) + r.w;
            return u - s > 0 ? i.INSIDE : 0 > u + s ? i.OUTSIDE : i.INTERSECTING
        }, r.prototype.clone = function (e) {
            return r.clone(this, e)
        }, r.prototype.intersect = function (e) {
            return r.intersect(this, e)
        }, r.prototype.equals = function (e) {
            return r.equals(this, e)
        }, r
    }), n("Core/Math", ["./defaultValue", "./DeveloperError"], function (e, t) {
        "use strict";
        var n = {};
        n.EPSILON1 = .1, n.EPSILON2 = .01, n.EPSILON3 = .001, n.EPSILON4 = 1e-4, n.EPSILON5 = 1e-5, n.EPSILON6 = 1e-6, n.EPSILON7 = 1e-7, n.EPSILON8 = 1e-8, n.EPSILON9 = 1e-9, n.EPSILON10 = 1e-10, n.EPSILON11 = 1e-11, n.EPSILON12 = 1e-12, n.EPSILON13 = 1e-13, n.EPSILON14 = 1e-14, n.EPSILON15 = 1e-15, n.EPSILON16 = 1e-16, n.EPSILON17 = 1e-17, n.EPSILON18 = 1e-18, n.EPSILON19 = 1e-19, n.EPSILON20 = 1e-20, n.GRAVITATIONALPARAMETER = 3986004418e5, n.SOLAR_RADIUS = 6995e5, n.SIXTY_FOUR_KILOBYTES = 65536, n.sign = function (e) {
            return e > 0 ? 1 : 0 > e ? -1 : 0
        }, n.sinh = function (e) {
            var t = Math.pow(Math.E, e), n = Math.pow(Math.E, -1 * e);
            return.5 * (t - n)
        }, n.cosh = function (e) {
            var t = Math.pow(Math.E, e), n = Math.pow(Math.E, -1 * e);
            return.5 * (t + n)
        }, n.lerp = function (e, t, n) {
            return(1 - n) * e + n * t
        }, n.PI = Math.PI, n.ONE_OVER_PI = 1 / Math.PI, n.PI_OVER_TWO = .5 * Math.PI, n.PI_OVER_THREE = Math.PI / 3, n.PI_OVER_FOUR = Math.PI / 4, n.PI_OVER_SIX = Math.PI / 6, n.THREE_PI_OVER_TWO = .5 * 3 * Math.PI, n.TWO_PI = 2 * Math.PI, n.ONE_OVER_TWO_PI = 1 / (2 * Math.PI), n.RADIANS_PER_DEGREE = Math.PI / 180, n.DEGREES_PER_RADIAN = 180 / Math.PI, n.RADIANS_PER_ARCSECOND = n.RADIANS_PER_DEGREE / 3600, n.toRadians = function (e) {
            return e * n.RADIANS_PER_DEGREE
        }, n.toDegrees = function (e) {
            return e * n.DEGREES_PER_RADIAN
        }, n.convertLongitudeRange = function (e) {
            var t = n.TWO_PI, i = e - Math.floor(e / t) * t;
            return i < -Math.PI ? i + t : i >= Math.PI ? i - t : i
        }, n.negativePiToPi = function (e) {
            for (var t = n.EPSILON10, i = n.PI, r = n.TWO_PI; -(i + t) > e;)e += r;
            if (-i > e)return-i;
            for (; e > i + t;)e -= r;
            return e > i ? i : e
        }, n.zeroToTwoPi = function (e) {
            var t = e % n.TWO_PI;
            return 0 > t ? (t + n.TWO_PI) % n.TWO_PI : t
        }, n.equalsEpsilon = function (t, n, i) {
            return i = e(i, 0), Math.abs(t - n) <= i
        };
        var i = [1];
        return n.factorial = function (e) {
            if ("number" != typeof e || 0 > e)throw new t("A number greater than or equal to 0 is required.");
            var n = i.length;
            if (e >= n)for (var r = i[n - 1], o = n; e >= o; o++)i.push(r * o);
            return i[e]
        }, n.incrementWrap = function (n, i, r) {
            if (r = e(r, 0), r >= i)throw new t("Maximum value must be greater than minimum value.");
            return++n, n > i && (n = r), n
        }, n.isPowerOfTwo = function (n) {
            if ("number" != typeof n || 0 > n)throw new t("A number greater than or equal to 0 is required.");
            var i = e(n, 0);
            return 0 !== i && 0 === (i & i - 1)
        }, n.clamp = function (e, t, n) {
            return t > e ? t : e > n ? n : e
        }, n
    }), n("Core/Cartographic", ["./defaultValue", "./DeveloperError", "./freezeObject", "./Math"], function (e, t, n, i) {
        "use strict";
        var r = function (t, n, i) {
            this.longitude = e(t, 0), this.latitude = e(n, 0), this.height = e(i, 0)
        };
        return r.fromDegrees = function (t, n, o, a) {
            return t = i.toRadians(e(t, 0)), n = i.toRadians(e(n, 0)), o = e(o, 0), "undefined" == typeof a ? new r(t, n, o) : (a.longitude = t, a.latitude = n, a.height = o, a)
        }, r.clone = function (e, t) {
            return"undefined" == typeof e ? void 0 : "undefined" == typeof t ? new r(e.longitude, e.latitude, e.height) : (t.longitude = e.longitude, t.latitude = e.latitude, t.height = e.height, t)
        }, r.equals = function (e, t) {
            return e === t || "undefined" != typeof e && "undefined" != typeof t && e.longitude === t.longitude && e.latitude === t.latitude && e.height === t.height
        }, r.equalsEpsilon = function (e, n, i) {
            if ("number" != typeof i)throw new t("epsilon is required and must be a number.");
            return e === n || "undefined" != typeof e && "undefined" != typeof n && Math.abs(e.longitude - n.longitude) <= i && Math.abs(e.latitude - n.latitude) <= i && Math.abs(e.height - n.height) <= i
        }, r.toString = function (e) {
            if ("undefined" == typeof e)throw new t("cartographic is required");
            return"(" + e.longitude + ", " + e.latitude + ", " + e.height + ")"
        }, r.ZERO = n(new r(0, 0, 0)), r.prototype.clone = function (e) {
            return r.clone(this, e)
        }, r.prototype.equals = function (e) {
            return r.equals(this, e)
        }, r.prototype.equalsEpsilon = function (e, t) {
            return r.equalsEpsilon(this, e, t)
        }, r.prototype.toString = function () {
            return r.toString(this)
        }, r
    }), n("Core/Ellipsoid", ["./freezeObject", "./defaultValue", "./DeveloperError", "./Math", "./Cartesian3", "./Cartographic"], function (e, t, n, i, r, o) {
        "use strict";
        var a = function (e, o, a) {
            if (e = t(e, 0), o = t(o, 0), a = t(a, 0), 0 > e || 0 > o || 0 > a)throw new n("All radii components must be greater than or equal to zero.");
            this._radii = new r(e, o, a), this._radiiSquared = new r(e * e, o * o, a * a), this._radiiToTheFourth = new r(e * e * e * e, o * o * o * o, a * a * a * a), this._oneOverRadii = new r(0 === e ? 0 : 1 / e, 0 === o ? 0 : 1 / o, 0 === a ? 0 : 1 / a), this._oneOverRadiiSquared = new r(0 === e ? 0 : 1 / (e * e), 0 === o ? 0 : 1 / (o * o), 0 === a ? 0 : 1 / (a * a)), this._minimumRadius = Math.min(e, o, a), this._maximumRadius = Math.max(e, o, a), this._centerToleranceSquared = i.EPSILON1
        };
        a.clone = function (e, t) {
            if ("undefined" == typeof e)return void 0;
            var n = e._radii;
            return"undefined" == typeof t ? new a(n.x, n.y, n.z) : (r.clone(n, t._radii), r.clone(e._radiiSquared, t._radiiSquared), r.clone(e._radiiToTheFourth, t._radiiToTheFourth), r.clone(e._oneOverRadii, t._oneOverRadii), r.clone(e._oneOverRadiiSquared, t._oneOverRadiiSquared), t._minimumRadius = e._minimumRadius, t._maximumRadius = e._maximumRadius, t._centerToleranceSquared = e._centerToleranceSquared, t)
        }, a.fromCartesian3 = function (e) {
            return"undefined" == typeof e ? new a : new a(e.x, e.y, e.z)
        }, a.WGS84 = e(new a(6378137, 6378137, 6356752.314245179)), a.UNIT_SPHERE = e(new a(1, 1, 1)), a.prototype.getRadii = function () {
            return this._radii
        }, a.prototype.getRadiiSquared = function () {
            return this._radiiSquared
        }, a.prototype.getRadiiToTheFourth = function () {
            return this._radiiToTheFourth
        }, a.prototype.getOneOverRadii = function () {
            return this._oneOverRadii
        }, a.prototype.getOneOverRadiiSquared = function () {
            return this._oneOverRadiiSquared
        }, a.prototype.getMinimumRadius = function () {
            return this._minimumRadius
        }, a.prototype.getMaximumRadius = function () {
            return this._maximumRadius
        }, a.prototype.clone = function (e) {
            return a.clone(this, e)
        }, a.prototype.geocentricSurfaceNormal = r.normalize, a.prototype.geodeticSurfaceNormalCartographic = function (e, t) {
            if ("undefined" == typeof e)throw new n("cartographic is required.");
            var i = e.longitude, o = e.latitude, a = Math.cos(o), s = a * Math.cos(i), u = a * Math.sin(i), l = Math.sin(o);
            return"undefined" == typeof t && (t = new r), t.x = s, t.y = u, t.z = l, r.normalize(t, t)
        }, a.prototype.geodeticSurfaceNormal = function (e, t) {
            return t = r.multiplyComponents(e, this._oneOverRadiiSquared, t), r.normalize(t, t)
        };
        var s = new r, u = new r;
        a.prototype.cartographicToCartesian = function (e, t) {
            var n = s, i = u;
            this.geodeticSurfaceNormalCartographic(e, n), r.multiplyComponents(this._radiiSquared, n, i);
            var o = Math.sqrt(r.dot(n, i));
            return r.divideByScalar(i, o, i), r.multiplyByScalar(n, e.height, n), r.add(i, n, t)
        }, a.prototype.cartographicArrayToCartesianArray = function (e, t) {
            if ("undefined" == typeof e)throw new n("cartographics is required.");
            var i = e.length;
            "undefined" == typeof t ? t = new Array(i) : t.length = i;
            for (var r = 0; i > r; r++)t[r] = this.cartographicToCartesian(e[r], t[r]);
            return t
        };
        var l = new r, c = new r, d = new r;
        a.prototype.cartesianToCartographic = function (e, t) {
            var n = this.scaleToGeodeticSurface(e, c);
            if ("undefined" == typeof n)return void 0;
            var a = this.geodeticSurfaceNormal(n, l), s = r.subtract(e, n, d), u = Math.atan2(a.y, a.x), f = Math.asin(a.z), h = i.sign(r.dot(s, e)) * r.magnitude(s);
            return"undefined" == typeof t ? new o(u, f, h) : (t.longitude = u, t.latitude = f, t.height = h, t)
        }, a.prototype.cartesianArrayToCartographicArray = function (e, t) {
            if ("undefined" == typeof e)throw new n("cartesians is required.");
            var i = e.length;
            "undefined" == typeof t ? t = new Array(i) : t.length = i;
            for (var r = 0; i > r; ++r)t[r] = this.cartesianToCartographic(e[r], t[r]);
            return t
        };
        var f, h = new r;
        return a.prototype.scaleToGeodeticSurface = function (e, t) {
            if ("undefined" == typeof e)throw new n("cartesian is required.");
            var o = e.x, a = e.y, s = e.z, u = this._oneOverRadii, l = u.x, c = u.y, d = u.z, p = o * o * l * l, m = a * a * c * c, y = s * s * d * d, v = p + m + y, g = Math.sqrt(1 / v), _ = r.multiplyByScalar(e, g, f);
            if (v < this._centerToleranceSquared)return isFinite(g) ? r.clone(_, t) : void 0;
            var w = this._oneOverRadiiSquared, C = w.x, x = w.y, S = w.z, b = h;
            b.x = 2 * _.x * C, b.y = 2 * _.y * x, b.z = 2 * _.z * S;
            var T, E, A, M, D, I, P, O, R, z, L, N = (1 - g) * r.magnitude(e) / (.5 * r.magnitude(b)), F = 0;
            do {
                N -= F, A = 1 / (1 + N * C), M = 1 / (1 + N * x), D = 1 / (1 + N * S), I = A * A, P = M * M, O = D * D, R = I * A, z = P * M, L = O * D, T = p * I + m * P + y * O - 1, E = p * R * C + m * z * x + y * L * S;
                var V = -2 * E;
                F = T / V
            } while (Math.abs(T) > i.EPSILON12);
            return"undefined" == typeof t ? new r(o * A, a * M, s * D) : (t.x = o * A, t.y = a * M, t.z = s * D, t)
        }, a.prototype.scaleToGeocentricSurface = function (e, t) {
            if ("undefined" == typeof e)throw new n("cartesian is required.");
            var i = e.x, o = e.y, a = e.z, s = this._oneOverRadiiSquared, u = 1 / Math.sqrt(i * i * s.x + o * o * s.y + a * a * s.z);
            return r.multiplyByScalar(e, u, t)
        }, a.prototype.transformPositionToScaledSpace = function (e, t) {
            return r.multiplyComponents(e, this._oneOverRadii, t)
        }, a.prototype.equals = function (e) {
            return this === e || "undefined" != typeof e && r.equals(this._radii, e._radii)
        }, a.prototype.toString = function () {
            return this._radii.toString()
        }, a
    }), n("Core/GeographicProjection", ["./defaultValue", "./Cartesian3", "./Cartographic", "./Ellipsoid"], function (e, t, n, i) {
        "use strict";
        var r = function (t) {
            this._ellipsoid = e(t, i.WGS84), this._semimajorAxis = this._ellipsoid.getMaximumRadius(), this._oneOverSemimajorAxis = 1 / this._semimajorAxis
        };
        return r.prototype.getEllipsoid = function () {
            return this._ellipsoid
        }, r.prototype.project = function (e, n) {
            var i = this._semimajorAxis, r = e.longitude * i, o = e.latitude * i, a = e.height;
            return"undefined" == typeof n ? new t(r, o, a) : (n.x = r, n.y = o, n.z = a, n)
        }, r.prototype.unproject = function (e, t) {
            var i = this._oneOverSemimajorAxis, r = e.x * i, o = e.y * i, a = e.z;
            return"undefined" == typeof t ? new n(r, o, a) : (t.longitude = r, t.latitude = o, t.height = a, t)
        }, r
    }), n("Core/BoundingRectangle", ["./defaultValue", "./DeveloperError", "./Cartographic", "./GeographicProjection", "./Intersect"], function (e, t, n, i, r) {
        "use strict";
        var o = function (t, n, i, r) {
            this.x = e(t, 0), this.y = e(n, 0), this.width = e(i, 0), this.height = e(r, 0)
        };
        o.fromPoints = function (e, t) {
            if ("undefined" == typeof t && (t = new o), "undefined" == typeof e || 0 === e.length)return t.x = 0, t.y = 0, t.width = 0, t.height = 0, t;
            for (var n = e.length, i = e[0].x, r = e[0].y, a = e[0].x, s = e[0].y, u = 1; n > u; u++) {
                var l = e[u], c = l.x, d = l.y;
                i = Math.min(c, i), a = Math.max(c, a), r = Math.min(d, r), s = Math.max(d, s)
            }
            return t.x = i, t.y = r, t.width = a - i, t.height = s - r, t
        };
        var a = new i, s = new n, u = new n;
        return o.fromExtent = function (t, n, i) {
            if ("undefined" == typeof i && (i = new o), "undefined" == typeof t)return i.x = 0, i.y = 0, i.width = 0, i.height = 0, i;
            n = e(n, a);
            var r = n.project(t.getSouthwest(s)), l = n.project(t.getNortheast(u));
            return l.subtract(r, l), i.x = r.x, i.y = r.y, i.width = l.x, i.height = l.y, i
        }, o.clone = function (e, t) {
            return"undefined" == typeof e ? void 0 : "undefined" == typeof t ? new o(e.x, e.y, e.width, e.height) : (t.x = e.x, t.y = e.y, t.width = e.width, t.height = e.height, t)
        }, o.union = function (e, n, i) {
            if ("undefined" == typeof e)throw new t("left is required.");
            if ("undefined" == typeof n)throw new t("right is required.");
            "undefined" == typeof i && (i = new o);
            var r = Math.min(e.x, n.x), a = Math.min(e.y, n.y), s = Math.max(e.x + e.width, n.x + n.width), u = Math.max(e.y + e.height, n.y + n.height);
            return i.x = r, i.y = a, i.width = s - r, i.height = u - a, i
        }, o.expand = function (e, n, i) {
            if ("undefined" == typeof e)throw new t("rectangle is required.");
            if ("undefined" == typeof n)throw new t("point is required.");
            i = o.clone(e, i);
            var r = n.x - i.x, a = n.y - i.y;
            return r > i.width ? i.width = r : 0 > r && (i.width -= r, i.x = n.x), a > i.height ? i.height = a : 0 > a && (i.height -= a, i.y = n.y), i
        }, o.intersect = function (e, n) {
            if ("undefined" == typeof e)throw new t("left is required.");
            if ("undefined" == typeof n)throw new t("right is required.");
            var i = e.x, o = e.y, a = n.x, s = n.y;
            return i > a + n.width || i + e.width < a || o + e.height < s || o > s + n.height ? r.OUTSIDE : r.INTERSECTING
        }, o.equals = function (e, t) {
            return e === t || "undefined" != typeof e && "undefined" != typeof t && e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height
        }, o.prototype.clone = function (e) {
            return o.clone(this, e)
        }, o.prototype.union = function (e, t) {
            return o.union(this, e, t)
        }, o.prototype.expand = function (e, t) {
            return o.expand(this, e, t)
        }, o.prototype.intersect = function (e) {
            return o.intersect(this, e)
        }, o.prototype.equals = function (e) {
            return o.equals(this, e)
        }, o
    }), n("Core/Cartesian4", ["./defaultValue", "./DeveloperError", "./freezeObject"], function (e, t, n) {
        "use strict";
        var i = function (t, n, i, r) {
            this.x = e(t, 0), this.y = e(n, 0), this.z = e(i, 0), this.w = e(r, 0)
        };
        i.fromArray = function (n, r, o) {
            if ("undefined" == typeof n)throw new t("values is required.");
            if (r + 4 > n.length)throw new t("offset + 4 is greater than the length of the array.");
            return r = e(r, 0), "undefined" == typeof o && (o = new i), o.x = n[r + 0], o.y = n[r + 1], o.z = n[r + 2], o.w = n[r + 3], o
        }, i.fromElements = function (e, t, n, r, o) {
            return"undefined" == typeof o ? new i(e, t, n, r) : (o.x = e, o.y = t, o.z = n, o.w = r, o)
        }, i.clone = function (e, t) {
            return"undefined" == typeof e ? void 0 : "undefined" == typeof t ? new i(e.x, e.y, e.z, e.w) : (t.x = e.x, t.y = e.y, t.z = e.z, t.w = e.w, t)
        }, i.getMaximumComponent = function (e) {
            if ("undefined" == typeof e)throw new t("cartesian is required");
            return Math.max(e.x, e.y, e.z, e.w)
        }, i.getMinimumComponent = function (e) {
            if ("undefined" == typeof e)throw new t("cartesian is required");
            return Math.min(e.x, e.y, e.z, e.w)
        }, i.magnitudeSquared = function (e) {
            if ("undefined" == typeof e)throw new t("cartesian is required");
            return e.x * e.x + e.y * e.y + e.z * e.z + e.w * e.w
        }, i.magnitude = function (e) {
            return Math.sqrt(i.magnitudeSquared(e))
        };
        var r = new i;
        i.distance = function (e, n) {
            if ("undefined" == typeof e || "undefined" == typeof n)throw new t("left and right are required.");
            return i.subtract(e, n, r), i.magnitude(r)
        }, i.normalize = function (e, n) {
            if ("undefined" == typeof e)throw new t("cartesian is required");
            var r = i.magnitude(e);
            return"undefined" == typeof n ? new i(e.x / r, e.y / r, e.z / r, e.w / r) : (n.x = e.x / r, n.y = e.y / r, n.z = e.z / r, n.w = e.w / r, n)
        }, i.dot = function (e, n) {
            if ("undefined" == typeof e)throw new t("left is required");
            if ("undefined" == typeof n)throw new t("right is required");
            return e.x * n.x + e.y * n.y + e.z * n.z + e.w * n.w
        }, i.multiplyComponents = function (e, n, r) {
            if ("undefined" == typeof e)throw new t("left is required");
            if ("undefined" == typeof n)throw new t("right is required");
            return"undefined" == typeof r ? new i(e.x * n.x, e.y * n.y, e.z * n.z, e.w * n.w) : (r.x = e.x * n.x, r.y = e.y * n.y, r.z = e.z * n.z, r.w = e.w * n.w, r)
        }, i.add = function (e, n, r) {
            if ("undefined" == typeof e)throw new t("left is required");
            if ("undefined" == typeof n)throw new t("right is required");
            return"undefined" == typeof r ? new i(e.x + n.x, e.y + n.y, e.z + n.z, e.w + n.w) : (r.x = e.x + n.x, r.y = e.y + n.y, r.z = e.z + n.z, r.w = e.w + n.w, r)
        }, i.subtract = function (e, n, r) {
            if ("undefined" == typeof e)throw new t("left is required");
            if ("undefined" == typeof n)throw new t("right is required");
            return"undefined" == typeof r ? new i(e.x - n.x, e.y - n.y, e.z - n.z, e.w - n.w) : (r.x = e.x - n.x, r.y = e.y - n.y, r.z = e.z - n.z, r.w = e.w - n.w, r)
        }, i.multiplyByScalar = function (e, n, r) {
            if ("undefined" == typeof e)throw new t("cartesian is required");
            if ("number" != typeof n)throw new t("scalar is required and must be a number.");
            return"undefined" == typeof r ? new i(e.x * n, e.y * n, e.z * n, e.w * n) : (r.x = e.x * n, r.y = e.y * n, r.z = e.z * n, r.w = e.w * n, r)
        }, i.divideByScalar = function (e, n, r) {
            if ("undefined" == typeof e)throw new t("cartesian is required");
            if ("number" != typeof n)throw new t("scalar is required and must be a number.");
            return"undefined" == typeof r ? new i(e.x / n, e.y / n, e.z / n, e.w / n) : (r.x = e.x / n, r.y = e.y / n, r.z = e.z / n, r.w = e.w / n, r)
        }, i.negate = function (e, n) {
            if ("undefined" == typeof e)throw new t("cartesian is required");
            return"undefined" == typeof n ? new i(-e.x, -e.y, -e.z, -e.w) : (n.x = -e.x, n.y = -e.y, n.z = -e.z, n.w = -e.w, n)
        }, i.abs = function (e, n) {
            if ("undefined" == typeof e)throw new t("cartesian is required");
            return"undefined" == typeof n ? new i(Math.abs(e.x), Math.abs(e.y), Math.abs(e.z), Math.abs(e.w)) : (n.x = Math.abs(e.x), n.y = Math.abs(e.y), n.z = Math.abs(e.z), n.w = Math.abs(e.w), n)
        };
        var o = new i;
        i.lerp = function (e, n, r, a) {
            if ("undefined" == typeof e)throw new t("start is required.");
            if ("undefined" == typeof n)throw new t("end is required.");
            if ("number" != typeof r)throw new t("t is required and must be a number.");
            return i.multiplyByScalar(n, r, o), a = i.multiplyByScalar(e, 1 - r, a), i.add(o, a, a)
        };
        var a = new i;
        return i.mostOrthogonalAxis = function (e, n) {
            if ("undefined" == typeof e)throw new t("cartesian is required.");
            var r = i.normalize(e, a);
            return i.abs(r, r), n = r.x <= r.y ? r.x <= r.z ? r.x <= r.w ? i.clone(i.UNIT_X, n) : i.clone(i.UNIT_W, n) : r.z <= r.w ? i.clone(i.UNIT_Z, n) : i.clone(i.UNIT_W, n) : r.y <= r.z ? r.y <= r.w ? i.clone(i.UNIT_Y, n) : i.clone(i.UNIT_W, n) : r.z <= r.w ? i.clone(i.UNIT_Z, n) : i.clone(i.UNIT_W, n)
        }, i.equals = function (e, t) {
            return e === t || "undefined" != typeof e && "undefined" != typeof t && e.x === t.x && e.y === t.y && e.z === t.z && e.w === t.w
        }, i.equalsEpsilon = function (e, n, i) {
            if ("number" != typeof i)throw new t("epsilon is required and must be a number.");
            return e === n || "undefined" != typeof e && "undefined" != typeof n && Math.abs(e.x - n.x) <= i && Math.abs(e.y - n.y) <= i && Math.abs(e.z - n.z) <= i && Math.abs(e.w - n.w) <= i
        }, i.ZERO = n(new i(0, 0, 0, 0)), i.UNIT_X = n(new i(1, 0, 0, 0)), i.UNIT_Y = n(new i(0, 1, 0, 0)), i.UNIT_Z = n(new i(0, 0, 1, 0)), i.UNIT_W = n(new i(0, 0, 0, 1)), i.prototype.getMaximumComponent = function () {
            return i.getMaximumComponent(this)
        }, i.prototype.getMinimumComponent = function () {
            return i.getMinimumComponent(this)
        }, i.prototype.clone = function (e) {
            return i.clone(this, e)
        }, i.prototype.magnitudeSquared = function () {
            return i.magnitudeSquared(this)
        }, i.prototype.magnitude = function () {
            return i.magnitude(this)
        }, i.prototype.normalize = function (e) {
            return i.normalize(this, e)
        }, i.prototype.dot = function (e) {
            return i.dot(this, e)
        }, i.prototype.multiplyComponents = function (e, t) {
            return i.multiplyComponents(this, e, t)
        }, i.prototype.add = function (e, t) {
            return i.add(this, e, t)
        }, i.prototype.subtract = function (e, t) {
            return i.subtract(this, e, t)
        }, i.prototype.multiplyByScalar = function (e, t) {
            return i.multiplyByScalar(this, e, t)
        }, i.prototype.divideByScalar = function (e, t) {
            return i.divideByScalar(this, e, t)
        }, i.prototype.negate = function (e) {
            return i.negate(this, e)
        }, i.prototype.abs = function (e) {
            return i.abs(this, e)
        }, i.prototype.lerp = function (e, t, n) {
            return i.lerp(this, e, t, n)
        }, i.prototype.mostOrthogonalAxis = function (e) {
            return i.mostOrthogonalAxis(this, e)
        }, i.prototype.equals = function (e) {
            return i.equals(this, e)
        }, i.prototype.equalsEpsilon = function (e, t) {
            return i.equalsEpsilon(this, e, t)
        }, i.prototype.toString = function () {
            return"(" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + ")"
        }, i
    }), n("Core/Interval", ["./defaultValue"], function (e) {
        "use strict";
        var t = function (t, n) {
            this.start = e(t, 0), this.stop = e(n, 0)
        };
        return t
    }), n("Core/Matrix3", ["./Cartesian3", "./defaultValue", "./DeveloperError", "./freezeObject"], function (e, t, n, i) {
        "use strict";
        var r = function (e, n, i, r, o, a, s, u, l) {
            this[0] = t(e, 0), this[1] = t(r, 0), this[2] = t(s, 0), this[3] = t(n, 0), this[4] = t(o, 0), this[5] = t(u, 0), this[6] = t(i, 0), this[7] = t(a, 0), this[8] = t(l, 0)
        };
        return r.clone = function (e, t) {
            return"undefined" == typeof e ? void 0 : "undefined" == typeof t ? new r(e[0], e[3], e[6], e[1], e[4], e[7], e[2], e[5], e[8]) : (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t)
        }, r.fromColumnMajorArray = function (e, t) {
            if ("undefined" == typeof e)throw new n("values parameter is required");
            return r.clone(e, t)
        }, r.fromRowMajorArray = function (e, t) {
            if ("undefined" == typeof e)throw new n("values is required.");
            return"undefined" == typeof t ? new r(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]) : (t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], t)
        }, r.fromQuaternion = function (e, t) {
            if ("undefined" == typeof e)throw new n("quaternion is required");
            var i = e.x * e.x, o = e.x * e.y, a = e.x * e.z, s = e.x * e.w, u = e.y * e.y, l = e.y * e.z, c = e.y * e.w, d = e.z * e.z, f = e.z * e.w, h = e.w * e.w, p = i - u - d + h, m = 2 * (o + f), y = 2 * (a - c), v = 2 * (o - f), g = -i + u - d + h, _ = 2 * (l + s), w = 2 * (a + c), C = 2 * (l - s), x = -i - u + d + h;
            return"undefined" == typeof t ? new r(p, m, y, v, g, _, w, C, x) : (t[0] = p, t[1] = v, t[2] = w, t[3] = m, t[4] = g, t[5] = C, t[6] = y, t[7] = _, t[8] = x, t)
        }, r.fromScale = function (e, t) {
            if ("undefined" == typeof e)throw new n("scale is required.");
            return"undefined" == typeof t ? new r(e.x, 0, 0, 0, e.y, 0, 0, 0, e.z) : (t[0] = e.x, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = e.y, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = e.z, t)
        }, r.fromUniformScale = function (e, t) {
            if ("number" != typeof e)throw new n("scale is required.");
            return"undefined" == typeof t ? new r(e, 0, 0, 0, e, 0, 0, 0, e) : (t[0] = e, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = e, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = e, t)
        }, r.fromRotationX = function (e, t) {
            if ("undefined" == typeof e)throw new n("angle is required.");
            var i = Math.cos(e), o = Math.sin(e);
            return"undefined" == typeof t ? new r(1, 0, 0, 0, i, -o, 0, o, i) : (t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = i, t[5] = o, t[6] = 0, t[7] = -o, t[8] = i, t)
        }, r.fromRotationY = function (e, t) {
            if ("undefined" == typeof e)throw new n("angle is required.");
            var i = Math.cos(e), o = Math.sin(e);
            return"undefined" == typeof t ? new r(i, 0, o, 0, 1, 0, -o, 0, i) : (t[0] = i, t[1] = 0, t[2] = -o, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = o, t[7] = 0, t[8] = i, t)
        }, r.fromRotationZ = function (e, t) {
            if ("undefined" == typeof e)throw new n("angle is required.");
            var i = Math.cos(e), o = Math.sin(e);
            return"undefined" == typeof t ? new r(i, -o, 0, o, i, 0, 0, 0, 1) : (t[0] = i, t[1] = o, t[2] = 0, t[3] = -o, t[4] = i, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t)
        }, r.toArray = function (e, t) {
            if ("undefined" == typeof e)throw new n("matrix is required");
            return"undefined" == typeof t ? [e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]] : (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t)
        }, r.getElementIndex = function (e, t) {
            if ("number" != typeof t || 0 > t || t > 2)throw new n("row is required and must be 0, 1, or 2.");
            if ("number" != typeof e || 0 > e || e > 2)throw new n("column is required and must be 0, 1, or 2.");
            return 3 * e + t
        }, r.getColumn = function (t, i, r) {
            if ("undefined" == typeof t)throw new n("matrix is required.");
            if ("number" != typeof i || 0 > i || i > 2)throw new n("index is required and must be 0, 1, or 2.");
            var o = 3 * i, a = t[o], s = t[o + 1], u = t[o + 2];
            return"undefined" == typeof r ? new e(a, s, u) : (r.x = a, r.y = s, r.z = u, r)
        }, r.setColumn = function (e, t, i, o) {
            if ("undefined" == typeof e)throw new n("matrix is required");
            if ("undefined" == typeof i)throw new n("cartesian is required");
            if ("number" != typeof t || 0 > t || t > 2)throw new n("index is required and must be 0, 1, or 2.");
            o = r.clone(e, o);
            var a = 3 * t;
            return o[a] = i.x, o[a + 1] = i.y, o[a + 2] = i.z, o
        }, r.getRow = function (t, i, r) {
            if ("undefined" == typeof t)throw new n("matrix is required.");
            if ("number" != typeof i || 0 > i || i > 2)throw new n("index is required and must be 0, 1, or 2.");
            var o = t[i], a = t[i + 3], s = t[i + 6];
            return"undefined" == typeof r ? new e(o, a, s) : (r.x = o, r.y = a, r.z = s, r)
        }, r.setRow = function (e, t, i, o) {
            if ("undefined" == typeof e)throw new n("matrix is required");
            if ("undefined" == typeof i)throw new n("cartesian is required");
            if ("number" != typeof t || 0 > t || t > 2)throw new n("index is required and must be 0, 1, or 2.");
            return o = r.clone(e, o), o[t] = i.x, o[t + 3] = i.y, o[t + 6] = i.z, o
        }, r.multiply = function (e, t, i) {
            if ("undefined" == typeof e)throw new n("left is required");
            if ("undefined" == typeof t)throw new n("right is required");
            var o = e[0] * t[0] + e[3] * t[1] + e[6] * t[2], a = e[1] * t[0] + e[4] * t[1] + e[7] * t[2], s = e[2] * t[0] + e[5] * t[1] + e[8] * t[2], u = e[0] * t[3] + e[3] * t[4] + e[6] * t[5], l = e[1] * t[3] + e[4] * t[4] + e[7] * t[5], c = e[2] * t[3] + e[5] * t[4] + e[8] * t[5], d = e[0] * t[6] + e[3] * t[7] + e[6] * t[8], f = e[1] * t[6] + e[4] * t[7] + e[7] * t[8], h = e[2] * t[6] + e[5] * t[7] + e[8] * t[8];
            return"undefined" == typeof i ? new r(o, u, d, a, l, f, s, c, h) : (i[0] = o, i[1] = a, i[2] = s, i[3] = u, i[4] = l, i[5] = c, i[6] = d, i[7] = f, i[8] = h, i)
        }, r.multiplyByVector = function (t, i, r) {
            if ("undefined" == typeof t)throw new n("matrix is required");
            if ("undefined" == typeof i)throw new n("cartesian is required");
            var o = i.x, a = i.y, s = i.z, u = t[0] * o + t[3] * a + t[6] * s, l = t[1] * o + t[4] * a + t[7] * s, c = t[2] * o + t[5] * a + t[8] * s;
            return"undefined" == typeof r ? new e(u, l, c) : (r.x = u, r.y = l, r.z = c, r)
        }, r.multiplyByScalar = function (e, t, i) {
            if ("undefined" == typeof e)throw new n("matrix is required");
            if ("number" != typeof t)throw new n("scalar is required and must be a number");
            return"undefined" == typeof i ? new r(e[0] * t, e[3] * t, e[6] * t, e[1] * t, e[4] * t, e[7] * t, e[2] * t, e[5] * t, e[8] * t) : (i[0] = e[0] * t, i[1] = e[1] * t, i[2] = e[2] * t, i[3] = e[3] * t, i[4] = e[4] * t, i[5] = e[5] * t, i[6] = e[6] * t, i[7] = e[7] * t, i[8] = e[8] * t, i)
        }, r.negate = function (e, t) {
            if ("undefined" == typeof e)throw new n("matrix is required");
            return"undefined" == typeof t ? new r(-e[0], -e[3], -e[6], -e[1], -e[4], -e[7], -e[2], -e[5], -e[8]) : (t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = -e[3], t[4] = -e[4], t[5] = -e[5], t[6] = -e[6], t[7] = -e[7], t[8] = -e[8], t)
        }, r.transpose = function (e, t) {
            if ("undefined" == typeof e)throw new n("matrix is required");
            var i = e[0], o = e[3], a = e[6], s = e[1], u = e[4], l = e[7], c = e[2], d = e[5], f = e[8];
            return"undefined" == typeof t ? new r(i, s, c, o, u, d, a, l, f) : (t[0] = i, t[1] = o, t[2] = a, t[3] = s, t[4] = u, t[5] = l, t[6] = c, t[7] = d, t[8] = f, t)
        }, r.equals = function (e, t) {
            return e === t || "undefined" != typeof e && "undefined" != typeof t && e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8]
        }, r.equalsEpsilon = function (e, t, i) {
            if ("number" != typeof i)throw new n("epsilon is required and must be a number");
            return e === t || "undefined" != typeof e && "undefined" != typeof t && Math.abs(e[0] - t[0]) <= i && Math.abs(e[1] - t[1]) <= i && Math.abs(e[2] - t[2]) <= i && Math.abs(e[3] - t[3]) <= i && Math.abs(e[4] - t[4]) <= i && Math.abs(e[5] - t[5]) <= i && Math.abs(e[6] - t[6]) <= i && Math.abs(e[7] - t[7]) <= i && Math.abs(e[8] - t[8]) <= i
        }, r.IDENTITY = i(new r(1, 0, 0, 0, 1, 0, 0, 0, 1)), r.COLUMN0ROW0 = 0, r.COLUMN0ROW1 = 1, r.COLUMN0ROW2 = 2, r.COLUMN1ROW0 = 3, r.COLUMN1ROW1 = 4, r.COLUMN1ROW2 = 5, r.COLUMN2ROW0 = 6, r.COLUMN2ROW1 = 7, r.COLUMN2ROW2 = 8, r.prototype.clone = function (e) {
            return r.clone(this, e)
        }, r.prototype.toArray = function (e) {
            return r.toArray(this, e)
        }, r.prototype.getColumn = function (e, t) {
            return r.getColumn(this, e, t)
        }, r.prototype.setColumn = function (e, t, n) {
            return r.setColumn(this, e, t, n)
        }, r.prototype.getRow = function (e, t) {
            return r.getRow(this, e, t)
        }, r.prototype.setRow = function (e, t, n) {
            return r.setRow(this, e, t, n)
        }, r.prototype.multiply = function (e, t) {
            return r.multiply(this, e, t)
        }, r.prototype.multiplyByVector = function (e, t) {
            return r.multiplyByVector(this, e, t)
        }, r.prototype.multiplyByScalar = function (e, t) {
            return r.multiplyByScalar(this, e, t)
        }, r.prototype.negate = function (e) {
            return r.negate(this, e)
        }, r.prototype.transpose = function (e) {
            return r.transpose(this, e)
        }, r.prototype.equals = function (e) {
            return r.equals(this, e)
        }, r.prototype.equalsEpsilon = function (e, t) {
            return r.equalsEpsilon(this, e, t)
        }, r.prototype.toString = function () {
            return"(" + this[0] + ", " + this[3] + ", " + this[6] + ")\n" + "(" + this[1] + ", " + this[4] + ", " + this[7] + ")\n" + "(" + this[2] + ", " + this[5] + ", " + this[8] + ")"
        }, r
    }), n("Core/RuntimeError", [], function () {
        "use strict";
        var e = function (e) {
            this.name = "RuntimeError", this.message = e, this.error = new Error, this.stack = this.error.stack
        };
        return e.prototype.toString = function () {
            var e = this.name + ": " + this.message;
            return e += "undefined" != typeof this.stack ? "\n" + this.stack.toString() : "\n" + this.error.toString()
        }, e
    }), n("Core/Matrix4", ["./Cartesian3", "./Cartesian4", "./defaultValue", "./DeveloperError", "./freezeObject", "./Math", "./Matrix3", "./RuntimeError"], function (e, t, n, i, r, o, a, s) {
        "use strict";
        var u = function (e, t, i, r, o, a, s, u, l, c, d, f, h, p, m, y) {
            this[0] = n(e, 0), this[1] = n(o, 0), this[2] = n(l, 0), this[3] = n(h, 0), this[4] = n(t, 0), this[5] = n(a, 0), this[6] = n(c, 0), this[7] = n(p, 0), this[8] = n(i, 0), this[9] = n(s, 0), this[10] = n(d, 0), this[11] = n(m, 0), this[12] = n(r, 0), this[13] = n(u, 0), this[14] = n(f, 0), this[15] = n(y, 0)
        };
        u.clone = function (e, t) {
            return"undefined" == typeof e ? void 0 : "undefined" == typeof t ? new u(e[0], e[4], e[8], e[12], e[1], e[5], e[9], e[13], e[2], e[6], e[10], e[14], e[3], e[7], e[11], e[15]) : (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t)
        }, u.fromColumnMajorArray = function (e, t) {
            if ("undefined" == typeof e)throw new i("values parameter is required");
            return u.clone(e, t)
        }, u.fromRowMajorArray = function (e, t) {
            if ("undefined" == typeof e)throw new i("values is required.");
            return"undefined" == typeof t ? new u(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]) : (t[0] = e[0], t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = e[1], t[5] = e[5], t[6] = e[9], t[7] = e[13], t[8] = e[2], t[9] = e[6], t[10] = e[10], t[11] = e[14], t[12] = e[3], t[13] = e[7], t[14] = e[11], t[15] = e[15], t)
        }, u.fromRotationTranslation = function (e, t, n) {
            if ("undefined" == typeof e)throw new i("rotation is required.");
            if ("undefined" == typeof t)throw new i("translation is required.");
            return"undefined" == typeof n ? new u(e[0], e[3], e[6], t.x, e[1], e[4], e[7], t.y, e[2], e[5], e[8], t.z, 0, 0, 0, 1) : (n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = 0, n[4] = e[3], n[5] = e[4], n[6] = e[5], n[7] = 0, n[8] = e[6], n[9] = e[7], n[10] = e[8], n[11] = 0, n[12] = t.x, n[13] = t.y, n[14] = t.z, n[15] = 1, n)
        }, u.fromTranslation = function (e, t) {
            return u.fromRotationTranslation(a.IDENTITY, e, t)
        }, u.fromScale = function (e, t) {
            if ("undefined" == typeof e)throw new i("scale is required.");
            return"undefined" == typeof t ? new u(e.x, 0, 0, 0, 0, e.y, 0, 0, 0, 0, e.z, 0, 0, 0, 0, 1) : (t[0] = e.x, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = e.y, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = e.z, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t)
        }, u.fromUniformScale = function (e, t) {
            if ("number" != typeof e)throw new i("scale is required.");
            return"undefined" == typeof t ? new u(e, 0, 0, 0, 0, e, 0, 0, 0, 0, e, 0, 0, 0, 0, 1) : (t[0] = e, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = e, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = e, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t)
        };
        var l = new e, c = new e, d = new e;
        u.fromCamera = function (t, n) {
            if ("undefined" == typeof t)throw new i("camera is required.");
            var r = t.eye, o = t.target, a = t.up;
            if ("undefined" == typeof r)throw new i("camera.eye is required.");
            if ("undefined" == typeof o)throw new i("camera.target is required.");
            if ("undefined" == typeof a)throw new i("camera.up is required.");
            e.subtract(o, r, l).normalize(l), e.cross(l, a, c).normalize(c), e.cross(c, l, d).normalize(d);
            var s = c.x, f = c.y, h = c.z, p = l.x, m = l.y, y = l.z, v = d.x, g = d.y, _ = d.z, w = r.x, C = r.y, x = r.z, S = s * -w + f * -C + h * -x, b = v * -w + g * -C + _ * -x, T = p * w + m * C + y * x;
            return"undefined" == typeof n ? new u(s, f, h, S, v, g, _, b, -p, -m, -y, T, 0, 0, 0, 1) : (n[0] = s, n[1] = v, n[2] = -p, n[3] = 0, n[4] = f, n[5] = g, n[6] = -m, n[7] = 0, n[8] = h, n[9] = _, n[10] = -y, n[11] = 0, n[12] = S, n[13] = b, n[14] = T, n[15] = 1, n)
        }, u.computePerspectiveFieldOfView = function (e, t, n, r, o) {
            if (0 >= e || e > Math.PI)throw new i("fovY must be in [0, PI).");
            if (0 >= t)throw new i("aspectRatio must be greater than zero.");
            if (0 >= n)throw new i("near must be greater than zero.");
            if (0 >= r)throw new i("far must be greater than zero.");
            var a = Math.tan(.5 * e), s = 1 / a, l = s / t, c = (r + n) / (n - r), d = 2 * r * n / (n - r);
            return"undefined" == typeof o ? new u(l, 0, 0, 0, 0, s, 0, 0, 0, 0, c, d, 0, 0, -1, 0) : (o[0] = l, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = s, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = c, o[11] = -1, o[12] = 0, o[13] = 0, o[14] = d, o[15] = 0, o)
        }, u.computeOrthographicOffCenter = function (e, t, n, r, o, a, s) {
            if ("undefined" == typeof e)throw new i("left is required.");
            if ("undefined" == typeof t)throw new i("right is required.");
            if ("undefined" == typeof n)throw new i("bottom is required.");
            if ("undefined" == typeof r)throw new i("top is required.");
            if ("undefined" == typeof o)throw new i("near is required.");
            if ("undefined" == typeof a)throw new i("far is required.");
            var l = 1 / (t - e), c = 1 / (r - n), d = 1 / (a - o), f = -(t + e) * l, h = -(r + n) * c, p = -(a + o) * d;
            return l *= 2, c *= 2, d *= -2, "undefined" == typeof s ? new u(l, 0, 0, f, 0, c, 0, h, 0, 0, d, p, 0, 0, 0, 1) : (s[0] = l, s[1] = 0, s[2] = 0, s[3] = 0, s[4] = 0, s[5] = c, s[6] = 0, s[7] = 0, s[8] = 0, s[9] = 0, s[10] = d, s[11] = 0, s[12] = f, s[13] = h, s[14] = p, s[15] = 1, s)
        }, u.computePerspectiveOffCenter = function (e, t, n, r, o, a, s) {
            if ("undefined" == typeof e)throw new i("left is required.");
            if ("undefined" == typeof t)throw new i("right is required.");
            if ("undefined" == typeof n)throw new i("bottom is required.");
            if ("undefined" == typeof r)throw new i("top is required.");
            if ("undefined" == typeof o)throw new i("near is required.");
            if ("undefined" == typeof a)throw new i("far is required.");
            var l = 2 * o / (t - e), c = 2 * o / (r - n), d = (t + e) / (t - e), f = (r + n) / (r - n), h = -(a + o) / (a - o), p = -1, m = -2 * a * o / (a - o);
            return"undefined" == typeof s ? new u(l, 0, d, 0, 0, c, f, 0, 0, 0, h, m, 0, 0, p, 0) : (s[0] = l, s[1] = 0, s[2] = 0, s[3] = 0, s[4] = 0, s[5] = c, s[6] = 0, s[7] = 0, s[8] = d, s[9] = f, s[10] = h, s[11] = p, s[12] = 0, s[13] = 0, s[14] = m, s[15] = 0, s)
        }, u.computeInfinitePerspectiveOffCenter = function (e, t, n, r, o, a) {
            if ("undefined" == typeof e)throw new i("left is required.");
            if ("undefined" == typeof t)throw new i("right is required.");
            if ("undefined" == typeof n)throw new i("bottom is required.");
            if ("undefined" == typeof r)throw new i("top is required.");
            if ("undefined" == typeof o)throw new i("near is required.");
            var s = 2 * o / (t - e), l = 2 * o / (r - n), c = (t + e) / (t - e), d = (r + n) / (r - n), f = -1, h = -1, p = -2 * o;
            return"undefined" == typeof a ? new u(s, 0, c, 0, 0, l, d, 0, 0, 0, f, p, 0, 0, h, 0) : (a[0] = s, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = l, a[6] = 0, a[7] = 0, a[8] = c, a[9] = d, a[10] = f, a[11] = h, a[12] = 0, a[13] = 0, a[14] = p, a[15] = 0, a)
        }, u.computeViewportTransformation = function (e, t, i, r) {
            e = n(e, n.EMPTY_OBJECT);
            var o = n(e.x, 0), a = n(e.y, 0), s = n(e.width, 0), l = n(e.height, 0);
            t = n(t, 0), i = n(i, 1);
            var c = .5 * s, d = .5 * l, f = .5 * (i - t), h = c, p = d, m = f, y = o + c, v = a + d, g = t + f, _ = 1;
            return"undefined" == typeof r ? new u(h, 0, 0, y, 0, p, 0, v, 0, 0, m, g, 0, 0, 0, _) : (r[0] = h, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = p, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = m, r[11] = 0, r[12] = y, r[13] = v, r[14] = g, r[15] = _, r)
        }, u.toArray = function (e, t) {
            if ("undefined" == typeof e)throw new i("matrix is required");
            return"undefined" == typeof t ? [e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]] : (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t)
        }, u.getElementIndex = function (e, t) {
            if ("number" != typeof t || 0 > t || t > 3)throw new i("row is required and must be 0, 1, 2, or 3.");
            if ("number" != typeof e || 0 > e || e > 3)throw new i("column is required and must be 0, 1, 2, or 3.");
            return 4 * e + t
        }, u.getColumn = function (e, n, r) {
            if ("undefined" == typeof e)throw new i("matrix is required.");
            if ("number" != typeof n || 0 > n || n > 3)throw new i("index is required and must be 0, 1, 2, or 3.");
            var o = 4 * n, a = e[o], s = e[o + 1], u = e[o + 2], l = e[o + 3];
            return"undefined" == typeof r ? new t(a, s, u, l) : (r.x = a, r.y = s, r.z = u, r.w = l, r)
        }, u.setColumn = function (e, t, n, r) {
            if ("undefined" == typeof e)throw new i("matrix is required");
            if ("undefined" == typeof n)throw new i("cartesian is required");
            if ("number" != typeof t || 0 > t || t > 3)throw new i("index is required and must be 0, 1, 2, or 3.");
            r = u.clone(e, r);
            var o = 4 * t;
            return r[o] = n.x, r[o + 1] = n.y, r[o + 2] = n.z, r[o + 3] = n.w, r
        }, u.getRow = function (e, n, r) {
            if ("undefined" == typeof e)throw new i("matrix is required.");
            if ("number" != typeof n || 0 > n || n > 3)throw new i("index is required and must be 0, 1, 2, or 3.");
            var o = e[n], a = e[n + 4], s = e[n + 8], u = e[n + 12];
            return"undefined" == typeof r ? new t(o, a, s, u) : (r.x = o, r.y = a, r.z = s, r.w = u, r)
        }, u.setRow = function (e, t, n, r) {
            if ("undefined" == typeof e)throw new i("matrix is required");
            if ("undefined" == typeof n)throw new i("cartesian is required");
            if ("number" != typeof t || 0 > t || t > 3)throw new i("index is required and must be 0, 1, 2, or 3.");
            return r = u.clone(e, r), r[t] = n.x, r[t + 4] = n.y, r[t + 8] = n.z, r[t + 12] = n.w, r
        }, u.multiply = function (e, t, n) {
            if ("undefined" == typeof e)throw new i("left is required");
            if ("undefined" == typeof t)throw new i("right is required");
            var r = e[0], o = e[1], a = e[2], s = e[3], l = e[4], c = e[5], d = e[6], f = e[7], h = e[8], p = e[9], m = e[10], y = e[11], v = e[12], g = e[13], _ = e[14], w = e[15], C = t[0], x = t[1], S = t[2], b = t[3], T = t[4], E = t[5], A = t[6], M = t[7], D = t[8], I = t[9], P = t[10], O = t[11], R = t[12], z = t[13], L = t[14], N = t[15], F = r * C + l * x + h * S + v * b, V = o * C + c * x + p * S + g * b, B = a * C + d * x + m * S + _ * b, k = s * C + f * x + y * S + w * b, U = r * T + l * E + h * A + v * M, q = o * T + c * E + p * A + g * M, W = a * T + d * E + m * A + _ * M, H = s * T + f * E + y * A + w * M, G = r * D + l * I + h * P + v * O, j = o * D + c * I + p * P + g * O, Y = a * D + d * I + m * P + _ * O, X = s * D + f * I + y * P + w * O, Z = r * R + l * z + h * L + v * N, K = o * R + c * z + p * L + g * N, J = a * R + d * z + m * L + _ * N, Q = s * R + f * z + y * L + w * N;
            return"undefined" == typeof n ? new u(F, U, G, Z, V, q, j, K, B, W, Y, J, k, H, X, Q) : (n[0] = F, n[1] = V, n[2] = B, n[3] = k, n[4] = U, n[5] = q, n[6] = W, n[7] = H, n[8] = G, n[9] = j, n[10] = Y, n[11] = X, n[12] = Z, n[13] = K, n[14] = J, n[15] = Q, n)
        }, u.multiplyByTranslation = function (e, t, n) {
            if ("undefined" == typeof e)throw new i("matrix is required");
            if ("undefined" == typeof t)throw new i("translation is required");
            var r = t.x, o = t.y, a = t.z, s = r * e[0] + o * e[4] + a * e[8] + e[12], l = r * e[1] + o * e[5] + a * e[9] + e[13], c = r * e[2] + o * e[6] + a * e[10] + e[14];
            return"undefined" == typeof n ? new u(e[0], e[4], e[8], s, e[1], e[5], e[9], l, e[2], e[6], e[10], c, e[3], e[7], e[11], e[15]) : (n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = e[3], n[4] = e[4], n[5] = e[5], n[6] = e[6], n[7] = e[7], n[8] = e[8], n[9] = e[9], n[10] = e[10], n[11] = e[11], n[12] = s, n[13] = l, n[14] = c, n[15] = e[15], n)
        }, u.multiplyByUniformScale = function (e, t, n) {
            if ("undefined" == typeof e)throw new i("matrix is required");
            if ("number" != typeof t)throw new i("scale is required");
            return 1 === t ? u.clone(e, n) : "undefined" == typeof n ? new u(t * e[0], t * e[4], t * e[8], e[12], t * e[1], t * e[5], t * e[9], e[13], t * e[2], t * e[6], t * e[10], e[14], 0, 0, 0, 1) : (n[0] = t * e[0], n[1] = t * e[1], n[2] = t * e[2], n[3] = 0, n[4] = t * e[4], n[5] = t * e[5], n[6] = t * e[6], n[7] = 0, n[8] = t * e[8], n[9] = t * e[9], n[10] = t * e[10], n[11] = 0, n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = 1, n)
        }, u.multiplyByVector = function (e, n, r) {
            if ("undefined" == typeof e)throw new i("matrix is required");
            if ("undefined" == typeof n)throw new i("cartesian is required");
            var o = n.x, a = n.y, s = n.z, u = n.w, l = e[0] * o + e[4] * a + e[8] * s + e[12] * u, c = e[1] * o + e[5] * a + e[9] * s + e[13] * u, d = e[2] * o + e[6] * a + e[10] * s + e[14] * u, f = e[3] * o + e[7] * a + e[11] * s + e[15] * u;
            return"undefined" == typeof r ? new t(l, c, d, f) : (r.x = l, r.y = c, r.z = d, r.w = f, r)
        };
        var f = new t(0, 0, 0, 1);
        return u.multiplyByPoint = function (e, t, n) {
            if ("undefined" == typeof t)throw new i("cartesian is required");
            return f.x = t.x, f.y = t.y, f.z = t.z, u.multiplyByVector(e, f, n)
        }, u.multiplyByScalar = function (e, t, n) {
            if ("undefined" == typeof e)throw new i("matrix is required");
            if ("number" != typeof t)throw new i("scalar is required and must be a number");
            return"undefined" == typeof n ? new u(e[0] * t, e[4] * t, e[8] * t, e[12] * t, e[1] * t, e[5] * t, e[9] * t, e[13] * t, e[2] * t, e[6] * t, e[10] * t, e[14] * t, e[3] * t, e[7] * t, e[11] * t, e[15] * t) : (n[0] = e[0] * t, n[1] = e[1] * t, n[2] = e[2] * t, n[3] = e[3] * t, n[4] = e[4] * t, n[5] = e[5] * t, n[6] = e[6] * t, n[7] = e[7] * t, n[8] = e[8] * t, n[9] = e[9] * t, n[10] = e[10] * t, n[11] = e[11] * t, n[12] = e[12] * t, n[13] = e[13] * t, n[14] = e[14] * t, n[15] = e[15] * t, n)
        }, u.negate = function (e, t) {
            if ("undefined" == typeof e)throw new i("matrix is required");
            return"undefined" == typeof t ? new u(-e[0], -e[4], -e[8], -e[12], -e[1], -e[5], -e[9], -e[13], -e[2], -e[6], -e[10], -e[14], -e[3], -e[7], -e[11], -e[15]) : (t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = -e[3], t[4] = -e[4], t[5] = -e[5], t[6] = -e[6], t[7] = -e[7], t[8] = -e[8], t[9] = -e[9], t[10] = -e[10], t[11] = -e[11], t[12] = -e[12], t[13] = -e[13], t[14] = -e[14], t[15] = -e[15], t)
        }, u.transpose = function (e, t) {
            if ("undefined" == typeof e)throw new i("matrix is required");
            if ("undefined" == typeof t)return new u(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]);
            var n = e[1], r = e[2], o = e[3], a = e[6], s = e[7], l = e[11];
            return t[0] = e[0], t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = n, t[5] = e[5], t[6] = e[9], t[7] = e[13], t[8] = r, t[9] = a, t[10] = e[10], t[11] = e[14], t[12] = o, t[13] = s, t[14] = l, t[15] = e[15], t
        }, u.equals = function (e, t) {
            return e === t || "undefined" != typeof e && "undefined" != typeof t && e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8] && e[9] === t[9] && e[10] === t[10] && e[11] === t[11] && e[12] === t[12] && e[13] === t[13] && e[14] === t[14] && e[15] === t[15]
        }, u.equalsEpsilon = function (e, t, n) {
            if ("number" != typeof n)throw new i("epsilon is required and must be a number");
            return e === t || "undefined" != typeof e && "undefined" != typeof t && Math.abs(e[0] - t[0]) <= n && Math.abs(e[1] - t[1]) <= n && Math.abs(e[2] - t[2]) <= n && Math.abs(e[3] - t[3]) <= n && Math.abs(e[4] - t[4]) <= n && Math.abs(e[5] - t[5]) <= n && Math.abs(e[6] - t[6]) <= n && Math.abs(e[7] - t[7]) <= n && Math.abs(e[8] - t[8]) <= n && Math.abs(e[9] - t[9]) <= n && Math.abs(e[10] - t[10]) <= n && Math.abs(e[11] - t[11]) <= n && Math.abs(e[12] - t[12]) <= n && Math.abs(e[13] - t[13]) <= n && Math.abs(e[14] - t[14]) <= n && Math.abs(e[15] - t[15]) <= n
        }, u.getTranslation = function (t, n) {
            if ("undefined" == typeof t)throw new i("matrix is required");
            return"undefined" == typeof n ? new e(t[12], t[13], t[14]) : (n.x = t[12], n.y = t[13], n.z = t[14], n)
        }, u.getRotation = function (e, t) {
            if ("undefined" == typeof e)throw new i("matrix is required");
            return"undefined" == typeof t ? new a(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]) : (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[4], t[4] = e[5], t[5] = e[6], t[6] = e[8], t[7] = e[9], t[8] = e[10], t)
        }, u.inverse = function (e, t) {
            if ("undefined" == typeof e)throw new i("matrix is required");
            var n = e[0], r = e[4], a = e[8], l = e[12], c = e[1], d = e[5], f = e[9], h = e[13], p = e[2], m = e[6], y = e[10], v = e[14], g = e[3], _ = e[7], w = e[11], C = e[15], x = y * C, S = v * w, b = m * C, T = v * _, E = m * w, A = y * _, M = p * C, D = v * g, I = p * w, P = y * g, O = p * _, R = m * g, z = x * d + T * f + E * h - (S * d + b * f + A * h), L = S * c + M * f + P * h - (x * c + D * f + I * h), N = b * c + D * d + O * h - (T * c + M * d + R * h), F = A * c + I * d + R * f - (E * c + P * d + O * f), V = S * r + b * a + A * l - (x * r + T * a + E * l), B = x * n + D * a + I * l - (S * n + M * a + P * l), k = T * n + M * r + R * l - (b * n + D * r + O * l), U = E * n + P * r + O * a - (A * n + I * r + R * a);
            x = a * h, S = l * f, b = r * h, T = l * d, E = r * f, A = a * d, M = n * h, D = l * c, I = n * f, P = a * c, O = n * d, R = r * c;
            var q = x * _ + T * w + E * C - (S * _ + b * w + A * C), W = S * g + M * w + P * C - (x * g + D * w + I * C), H = b * g + D * _ + O * C - (T * g + M * _ + R * C), G = A * g + I * _ + R * w - (E * g + P * _ + O * w), j = b * y + A * v + S * m - (E * v + x * m + T * y), Y = I * v + x * p + D * y - (M * y + P * v + S * p), X = M * m + R * v + T * p - (O * v + b * p + D * m), Z = O * y + E * p + P * m - (I * m + R * y + A * p), K = n * z + r * L + a * N + l * F;
            if (Math.abs(K) < o.EPSILON20)throw new s("matrix is not invertible because its determinate is zero.");
            return K = 1 / K, "undefined" == typeof t ? new u(z * K, V * K, q * K, j * K, L * K, B * K, W * K, Y * K, N * K, k * K, H * K, X * K, F * K, U * K, G * K, Z * K) : (t[0] = z * K, t[1] = L * K, t[2] = N * K, t[3] = F * K, t[4] = V * K, t[5] = B * K, t[6] = k * K, t[7] = U * K, t[8] = q * K, t[9] = W * K, t[10] = H * K, t[11] = G * K, t[12] = j * K, t[13] = Y * K, t[14] = X * K, t[15] = Z * K, t)
        }, u.inverseTransformation = function (e, t) {
            if ("undefined" == typeof e)throw new i("matrix is required");
            var n = e[0], r = e[1], o = e[2], a = e[4], s = e[5], l = e[6], c = e[8], d = e[9], f = e[10], h = e[12], p = e[13], m = e[14], y = -n * h - r * p - o * m, v = -a * h - s * p - l * m, g = -c * h - d * p - f * m;
            return"undefined" == typeof t ? new u(n, r, o, y, a, s, l, v, c, d, f, g, 0, 0, 0, 1) : (t[0] = n, t[1] = a, t[2] = c, t[3] = 0, t[4] = r, t[5] = s, t[6] = d, t[7] = 0, t[8] = o, t[9] = l, t[10] = f, t[11] = 0, t[12] = y, t[13] = v, t[14] = g, t[15] = 1, t)
        }, u.IDENTITY = r(new u(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)), u.COLUMN0ROW0 = 0, u.COLUMN0ROW1 = 1, u.COLUMN0ROW2 = 2, u.COLUMN0ROW3 = 3, u.COLUMN1ROW0 = 4, u.COLUMN1ROW1 = 5, u.COLUMN1ROW2 = 6, u.COLUMN1ROW3 = 7, u.COLUMN2ROW0 = 8, u.COLUMN2ROW1 = 9, u.COLUMN2ROW2 = 10, u.COLUMN2ROW3 = 11, u.COLUMN3ROW0 = 12, u.COLUMN3ROW1 = 13, u.COLUMN3ROW2 = 14, u.COLUMN3ROW3 = 15, u.prototype.clone = function (e) {
            return u.clone(this, e)
        }, u.prototype.toArray = function (e) {
            return u.toArray(this, e)
        }, u.prototype.getColumn = function (e, t) {
            return u.getColumn(this, e, t)
        }, u.prototype.setColumn = function (e, t, n) {
            return u.setColumn(this, e, t, n)
        }, u.prototype.getRow = function (e, t) {
            return u.getRow(this, e, t)
        }, u.prototype.setRow = function (e, t, n) {
            return u.setRow(this, e, t, n)
        }, u.prototype.multiply = function (e, t) {
            return u.multiply(this, e, t)
        }, u.prototype.multiplyByTranslation = function (e, t) {
            return u.multiplyByTranslation(this, e, t)
        }, u.prototype.multiplyByUniformScale = function (e, t) {
            return u.multiplyByUniformScale(this, e, t)
        }, u.prototype.multiplyByVector = function (e, t) {
            return u.multiplyByVector(this, e, t)
        }, u.prototype.multiplyByPoint = function (e, t) {
            return u.multiplyByPoint(this, e, t)
        }, u.prototype.multiplyByScalar = function (e, t) {
            return u.multiplyByScalar(this, e, t)
        }, u.prototype.negate = function (e) {
            return u.negate(this, e)
        }, u.prototype.transpose = function (e) {
            return u.transpose(this, e)
        }, u.prototype.equals = function (e) {
            return u.equals(this, e)
        }, u.prototype.equalsEpsilon = function (e, t) {
            return u.equalsEpsilon(this, e, t)
        }, u.prototype.toString = function () {
            return"(" + this[0] + ", " + this[4] + ", " + this[8] + ", " + this[12] + ")\n" + "(" + this[1] + ", " + this[5] + ", " + this[9] + ", " + this[13] + ")\n" + "(" + this[2] + ", " + this[6] + ", " + this[10] + ", " + this[14] + ")\n" + "(" + this[3] + ", " + this[7] + ", " + this[11] + ", " + this[15] + ")"
        }, u.prototype.getTranslation = function (e) {
            return u.getTranslation(this, e)
        }, u.prototype.getRotation = function (e) {
            return u.getRotation(this, e)
        }, u.prototype.inverse = function (e) {
            return u.inverse(this, e)
        }, u.prototype.inverseTransformation = function (e) {
            return u.inverseTransformation(this, e)
        }, u
    }), n("Core/BoundingSphere", ["./defaultValue", "./DeveloperError", "./Cartesian3", "./Cartesian4", "./Cartographic", "./Ellipsoid", "./GeographicProjection", "./Intersect", "./Interval", "./Matrix4"], function (e, t, n, i, r, o, a, s, u, l) {
        "use strict";
        var c = function (t, i) {
            this.center = n.clone(e(t, n.ZERO)), this.radius = e(i, 0)
        }, d = new n, f = new n, h = new n, p = new n, m = new n, y = new n, v = new n, g = new n, _ = new n, w = new n, C = new n, x = new n;
        c.fromPoints = function (e, t) {
            if ("undefined" == typeof t && (t = new c), "undefined" == typeof e || 0 === e.length)return t.center = n.ZERO.clone(t.center), t.radius = 0, t;
            for (var i = n.clone(e[0], v), r = n.clone(i, d), o = n.clone(i, f), a = n.clone(i, h), s = n.clone(i, p), u = n.clone(i, m), l = n.clone(i, y), S = e.length, b = 1; S > b; b++) {
                n.clone(e[b], i);
                var T = i.x, E = i.y, A = i.z;
                T < r.x && n.clone(i, r), T > s.x && n.clone(i, s), E < o.y && n.clone(i, o), E > u.y && n.clone(i, u), A < a.z && n.clone(i, a), A > l.z && n.clone(i, l)
            }
            var M = n.magnitudeSquared(n.subtract(s, r, g)), D = n.magnitudeSquared(n.subtract(u, o, g)), I = n.magnitudeSquared(n.subtract(l, a, g)), P = r, O = s, R = M;
            D > R && (R = D, P = o, O = u), I > R && (R = I, P = a, O = l);
            var z = _;
            z.x = .5 * (P.x + O.x), z.y = .5 * (P.y + O.y), z.z = .5 * (P.z + O.z);
            var L = n.magnitudeSquared(n.subtract(O, z, g)), N = Math.sqrt(L), F = w;
            F.x = r.x, F.y = o.y, F.z = a.z;
            var V = C;
            V.x = s.x, V.y = u.y, V.z = l.z;
            var B = n.multiplyByScalar(n.add(F, V, g), .5, x), k = 0;
            for (b = 0; S > b; b++) {
                n.clone(e[b], i);
                var U = n.magnitude(n.subtract(i, B, g));
                U > k && (k = U);
                var q = n.magnitudeSquared(n.subtract(i, z, g));
                if (q > L) {
                    var W = Math.sqrt(q);
                    N = .5 * (N + W), L = N * N;
                    var H = W - N;
                    z.x = (N * z.x + H * i.x) / W, z.y = (N * z.y + H * i.y) / W, z.z = (N * z.z + H * i.z) / W
                }
            }
            return k > N ? (n.clone(z, t.center), t.radius = N) : (n.clone(B, t.center), t.radius = k), t
        };
        var S = new a, b = new n, T = new n, E = new r, A = new r;
        c.fromExtent2D = function (e, t, n) {
            return c.fromExtentWithHeights2D(e, t, 0, 0, n)
        }, c.fromExtentWithHeights2D = function (t, i, r, o, a) {
            if ("undefined" == typeof a && (a = new c), "undefined" == typeof t)return a.center = n.ZERO.clone(a.center), a.radius = 0, a;
            i = e(i, S), t.getSouthwest(E), E.height = r, t.getNortheast(A), A.height = o;
            var s = i.project(E, b), u = i.project(A, T), l = u.x - s.x, d = u.y - s.y, f = u.z - s.z;
            a.radius = .5 * Math.sqrt(l * l + d * d + f * f);
            var h = a.center;
            return h.x = s.x + .5 * l, h.y = s.y + .5 * d, h.z = s.z + .5 * f, a
        };
        var M = [];
        c.fromExtent3D = function (t, n, i, r) {
            n = e(n, o.WGS84), i = e(i, 0);
            var a;
            return"undefined" != typeof t && (a = t.subsample(n, i, M)), c.fromPoints(a, r)
        }, c.fromVertices = function (e, i, r, o) {
            if ("undefined" == typeof o && (o = new c), "undefined" == typeof e || 0 === e.length)return o.center = n.ZERO.clone(o.center), o.radius = 0, o;
            if ("undefined" == typeof i && (i = n.ZERO), "undefined" == typeof r && (r = 3), 3 > r)throw new t("stride must be 3 or greater.");
            var a = v;
            a.x = e[0] + i.x, a.y = e[1] + i.y, a.z = e[2] + i.z;
            for (var s = n.clone(a, d), u = n.clone(a, f), l = n.clone(a, h), S = n.clone(a, p), b = n.clone(a, m), T = n.clone(a, y), E = e.length, A = 0; E > A; A += r) {
                var M = e[A] + i.x, D = e[A + 1] + i.y, I = e[A + 2] + i.z;
                a.x = M, a.y = D, a.z = I, M < s.x && n.clone(a, s), M > S.x && n.clone(a, S), D < u.y && n.clone(a, u), D > b.y && n.clone(a, b), I < l.z && n.clone(a, l), I > T.z && n.clone(a, T)
            }
            var P = n.magnitudeSquared(n.subtract(S, s, g)), O = n.magnitudeSquared(n.subtract(b, u, g)), R = n.magnitudeSquared(n.subtract(T, l, g)), z = s, L = S, N = P;
            O > N && (N = O, z = u, L = b), R > N && (N = R, z = l, L = T);
            var F = _;
            F.x = .5 * (z.x + L.x), F.y = .5 * (z.y + L.y), F.z = .5 * (z.z + L.z);
            var V = n.magnitudeSquared(n.subtract(L, F, g)), B = Math.sqrt(V), k = w;
            k.x = s.x, k.y = u.y, k.z = l.z;
            var U = C;
            U.x = S.x, U.y = b.y, U.z = T.z;
            var q = n.multiplyByScalar(n.add(k, U, g), .5, x), W = 0;
            for (A = 0; E > A; A += r) {
                a.x = e[A] + i.x, a.y = e[A + 1] + i.y, a.z = e[A + 2] + i.z;
                var H = n.magnitude(n.subtract(a, q, g));
                H > W && (W = H);
                var G = n.magnitudeSquared(n.subtract(a, F, g));
                if (G > V) {
                    var j = Math.sqrt(G);
                    B = .5 * (B + j), V = B * B;
                    var Y = j - B;
                    F.x = (B * F.x + Y * a.x) / j, F.y = (B * F.y + Y * a.y) / j, F.z = (B * F.z + Y * a.z) / j
                }
            }
            return W > B ? (n.clone(F, o.center), o.radius = B) : (n.clone(q, o.center), o.radius = W), o
        }, c.fromCornerPoints = function (e, i, r) {
            if ("undefined" == typeof e || "undefined" == typeof i)throw new t("corner and oppositeCorner are required.");
            "undefined" == typeof r && (r = new c);
            var o = r.center;
            return n.add(e, i, o), n.multiplyByScalar(o, .5, o), r.radius = n.distance(o, i), r
        }, c.fromEllipsoid = function (e, i) {
            if ("undefined" == typeof e)throw new t("ellipsoid is required.");
            return"undefined" == typeof i && (i = new c), n.clone(n.ZERO, i.center), i.radius = e.getMaximumRadius(), i
        }, c.clone = function (e, t) {
            return"undefined" == typeof e ? void 0 : "undefined" == typeof t ? new c(e.center, e.radius) : (t.center = n.clone(e.center, t.center), t.radius = e.radius, t)
        };
        var D = new n, I = new n;
        c.union = function (e, i, r) {
            if ("undefined" == typeof e)throw new t("left is required.");
            if ("undefined" == typeof i)throw new t("right is required.");
            "undefined" == typeof r && (r = new c);
            var o = e.center, a = i.center;
            n.add(o, a, I);
            var s = n.multiplyByScalar(I, .5, I), u = n.subtract(o, s, D).magnitude() + e.radius, l = n.subtract(a, s, D).magnitude() + i.radius;
            return r.radius = Math.max(u, l), n.clone(s, r.center), r
        };
        var P = new n;
        c.expand = function (e, i, r) {
            if ("undefined" == typeof e)throw new t("sphere is required.");
            if ("undefined" == typeof i)throw new t("point is required.");
            r = c.clone(e, r);
            var o = n.subtract(i, r.center, P).magnitude();
            return o > r.radius && (r.radius = o), r
        }, c.intersect = function (e, i) {
            if ("undefined" == typeof e)throw new t("sphere is required.");
            if ("undefined" == typeof i)throw new t("plane is required.");
            var r = e.center, o = e.radius, a = n.dot(i, r) + i.w;
            return-o > a ? s.OUTSIDE : o > a ? s.INTERSECTING : s.INSIDE
        };
        var O = i.UNIT_W.clone();
        c.transform = function (e, i, r) {
            if ("undefined" == typeof e)throw new t("sphere is required.");
            if ("undefined" == typeof i)throw new t("transform is required.");
            return"undefined" == typeof r && (r = new c), l.multiplyByPoint(i, e.center, O), n.clone(O, r.center), r.radius = e.radius, r
        };
        var R = new n;
        c.getPlaneDistances = function (e, i, r, o) {
            if ("undefined" == typeof e)throw new t("sphere is required.");
            if ("undefined" == typeof i)throw new t("position is required.");
            if ("undefined" == typeof r)throw new t("direction is required.");
            "undefined" == typeof o && (o = new u);
            var a = n.subtract(e.center, i, R), s = n.multiplyByScalar(r, r.dot(a), R), l = s.magnitude();
            return o.start = l - e.radius, o.stop = l + e.radius, o
        };
        for (var z = new n, L = new n, N = new n, F = new n, V = new n, B = new r, k = new Array(8), U = 0; 8 > U; ++U)k[U] = new n;
        var q = new a;
        return c.projectTo2D = function (i, r, o) {
            if ("undefined" == typeof i)throw new t("sphere is required.");
            r = e(r, q);
            var a = r.getEllipsoid(), s = i.center, u = i.radius, l = a.geodeticSurfaceNormal(s, z), d = n.cross(n.UNIT_Z, l, L);
            n.normalize(d, d);
            var f = n.cross(l, d, N);
            n.normalize(f, f), n.multiplyByScalar(l, u, l), n.multiplyByScalar(f, u, f), n.multiplyByScalar(d, u, d);
            var h = n.negate(f, V), p = n.negate(d, F), m = k, y = m[0];
            n.add(l, f, y), n.add(y, d, y), y = m[1], n.add(l, f, y), n.add(y, p, y), y = m[2], n.add(l, h, y), n.add(y, p, y), y = m[3], n.add(l, h, y), n.add(y, d, y), n.negate(l, l), y = m[4], n.add(l, f, y), n.add(y, d, y), y = m[5], n.add(l, f, y), n.add(y, p, y), y = m[6], n.add(l, h, y), n.add(y, p, y), y = m[7], n.add(l, h, y), n.add(y, d, y);
            for (var v = m.length, g = 0; v > g; ++g) {
                var _ = m[g];
                n.add(s, _, _);
                var w = a.cartesianToCartographic(_, B);
                r.project(w, _)
            }
            o = c.fromPoints(m, o), s = o.center;
            var C = s.x, x = s.y, S = s.z;
            return s.x = S, s.y = C, s.z = x, o
        }, c.equals = function (e, t) {
            return e === t || "undefined" != typeof e && "undefined" != typeof t && n.equals(e.center, t.center) && e.radius === t.radius
        }, c.prototype.clone = function (e) {
            return c.clone(this, e)
        }, c.prototype.union = function (e, t) {
            return c.union(this, e, t)
        }, c.prototype.expand = function (e, t) {
            return c.expand(this, e, t)
        }, c.prototype.intersect = function (e) {
            return c.intersect(this, e)
        }, c.prototype.transform = function (e, t) {
            return c.transform(this, e, t)
        }, c.prototype.getPlaneDistances = function (e, t, n) {
            return c.getPlaneDistances(this, e, t, n)
        }, c.prototype.projectTo2D = function (e, t) {
            return c.projectTo2D(this, e, t)
        }, c.prototype.equals = function (e) {
            return c.equals(this, e)
        }, c
    }), n("Core/ComponentDatatype", ["./Enumeration"], function (e) {
        "use strict";
        if ("undefined" == typeof Int8Array)return{};
        var t = {BYTE: new e(5120, "BYTE", {sizeInBytes: Int8Array.BYTES_PER_ELEMENT, createTypedArray: function (e) {
            return new Int8Array(e)
        }, createArrayBufferView: function (e, t) {
            return new Int8Array(e, t)
        }}), UNSIGNED_BYTE: new e(5121, "UNSIGNED_BYTE", {sizeInBytes: Uint8Array.BYTES_PER_ELEMENT, createTypedArray: function (e) {
            return new Uint8Array(e)
        }, createArrayBufferView: function (e, t) {
            return new Uint8Array(e, t)
        }}), SHORT: new e(5122, "SHORT", {sizeInBytes: Int16Array.BYTES_PER_ELEMENT, createTypedArray: function (e) {
            return new Int16Array(e)
        }, createArrayBufferView: function (e, t) {
            return new Int16Array(e, t)
        }}), UNSIGNED_SHORT: new e(5123, "UNSIGNED_SHORT", {sizeInBytes: Uint16Array.BYTES_PER_ELEMENT, createTypedArray: function (e) {
            return new Uint16Array(e)
        }, createArrayBufferView: function (e, t) {
            return new Uint16Array(e, t)
        }}), FLOAT: new e(5126, "FLOAT", {sizeInBytes: Float32Array.BYTES_PER_ELEMENT, createTypedArray: function (e) {
            return new Float32Array(e)
        }, createArrayBufferView: function (e, t) {
            return new Float32Array(e, t)
        }}), DOUBLE: new e(5130, "DOUBLE", {sizeInBytes: Float64Array.BYTES_PER_ELEMENT, createTypedArray: function (e) {
            return new Float64Array(e)
        }, createArrayBufferView: function (e, t) {
            return new Float64Array(e, t)
        }})};
        return t.validate = function (e) {
            return e === t.BYTE || e === t.UNSIGNED_BYTE || e === t.SHORT || e === t.UNSIGNED_SHORT || e === t.FLOAT || e === t.DOUBLE
        }, t
    }), n("Core/PrimitiveType", ["./Enumeration"], function (e) {
        "use strict";
        var t = {POINTS: new e(0, "POINTS"), LINES: new e(1, "LINES"), LINE_LOOP: new e(2, "LINE_LOOP"), LINE_STRIP: new e(3, "LINE_STRIP"), TRIANGLES: new e(4, "TRIANGLES"), TRIANGLE_STRIP: new e(5, "TRIANGLE_STRIP"), TRIANGLE_FAN: new e(6, "TRIANGLE_FAN"), validate: function (e) {
            return e === t.POINTS || e === t.LINES || e === t.LINE_LOOP || e === t.LINE_STRIP || e === t.TRIANGLES || e === t.TRIANGLE_STRIP || e === t.TRIANGLE_FAN
        }};
        return t
    }), n("Core/GeometryAttribute", ["./defaultValue", "./DeveloperError"], function (e, t) {
        "use strict";
        var n = function (n) {
            if (n = e(n, e.EMPTY_OBJECT), "undefined" == typeof n.componentDatatype)throw new t("options.componentDatatype is required.");
            if ("undefined" == typeof n.componentsPerAttribute)throw new t("options.componentsPerAttribute is required.");
            if (n.componentsPerAttribute < 1 || n.componentsPerAttribute > 4)throw new t("options.componentsPerAttribute must be between 1 and 4.");
            if ("undefined" == typeof n.values)throw new t("options.values is required.");
            this.componentDatatype = n.componentDatatype, this.componentsPerAttribute = n.componentsPerAttribute, this.normalize = e(n.normalize, !1), this.values = n.values
        };
        return n
    }), n("Core/GeometryAttributes", ["./defaultValue"], function (e) {
        "use strict";
        var t = function (t) {
            t = e(t, e.EMPTY_OBJECT), this.position = t.position, this.normal = t.normal, this.st = t.st, this.binormal = t.binormal, this.tangent = t.tangent
        };
        return t
    }), n("Core/VertexFormat", ["./defaultValue", "./freezeObject"], function (e, t) {
        "use strict";
        var n = function (t) {
            t = e(t, e.EMPTY_OBJECT), this.position = e(t.position, !1), this.normal = e(t.normal, !1), this.st = e(t.st, !1), this.binormal = e(t.binormal, !1), this.tangent = e(t.tangent, !1)
        };
        return n.POSITION_ONLY = t(new n({position: !0})), n.POSITION_AND_NORMAL = t(new n({position: !0, normal: !0})), n.POSITION_NORMAL_AND_ST = t(new n({position: !0, normal: !0, st: !0})), n.POSITION_AND_ST = t(new n({position: !0, st: !0})), n.ALL = t(new n({position: !0, normal: !0, st: !0, binormal: !0, tangent: !0})), n.DEFAULT = n.POSITION_NORMAL_AND_ST, n
    }), n("Core/BoxGeometry", ["./DeveloperError", "./Cartesian3", "./ComponentDatatype", "./PrimitiveType", "./defaultValue", "./BoundingSphere", "./GeometryAttribute", "./GeometryAttributes", "./VertexFormat"], function (e, t, n, i, r, o, a, s, u) {
        "use strict";
        var l = new t, c = function (c) {
            c = r(c, r.EMPTY_OBJECT);
            var d = c.minimumCorner, f = c.maximumCorner;
            if ("undefined" == typeof d)throw new e("options.minimumCorner is required.");
            if ("undefined" == typeof f)throw new e("options.maximumCorner is required");
            var h, p, m = r(c.vertexFormat, u.DEFAULT), y = new s;
            if (m !== u.POSITION_ONLY) {
                if (m.position && (p = new Float64Array(72), p[0] = d.x, p[1] = d.y, p[2] = f.z, p[3] = f.x, p[4] = d.y, p[5] = f.z, p[6] = f.x, p[7] = f.y, p[8] = f.z, p[9] = d.x, p[10] = f.y, p[11] = f.z, p[12] = d.x, p[13] = d.y, p[14] = d.z, p[15] = f.x, p[16] = d.y, p[17] = d.z, p[18] = f.x, p[19] = f.y, p[20] = d.z, p[21] = d.x, p[22] = f.y, p[23] = d.z, p[24] = f.x, p[25] = d.y, p[26] = d.z, p[27] = f.x, p[28] = f.y, p[29] = d.z, p[30] = f.x, p[31] = f.y, p[32] = f.z, p[33] = f.x, p[34] = d.y, p[35] = f.z, p[36] = d.x, p[37] = d.y, p[38] = d.z, p[39] = d.x, p[40] = f.y, p[41] = d.z, p[42] = d.x, p[43] = f.y, p[44] = f.z, p[45] = d.x, p[46] = d.y, p[47] = f.z, p[48] = d.x, p[49] = f.y, p[50] = d.z, p[51] = f.x, p[52] = f.y, p[53] = d.z, p[54] = f.x, p[55] = f.y, p[56] = f.z, p[57] = d.x, p[58] = f.y, p[59] = f.z, p[60] = d.x, p[61] = d.y, p[62] = d.z, p[63] = f.x, p[64] = d.y, p[65] = d.z, p[66] = f.x, p[67] = d.y, p[68] = f.z, p[69] = d.x, p[70] = d.y, p[71] = f.z, y.position = new a({componentDatatype: n.DOUBLE, componentsPerAttribute: 3, values: p})), m.normal) {
                    var v = new Float32Array(72);
                    v[0] = 0, v[1] = 0, v[2] = 1, v[3] = 0, v[4] = 0, v[5] = 1, v[6] = 0, v[7] = 0, v[8] = 1, v[9] = 0, v[10] = 0, v[11] = 1, v[12] = 0, v[13] = 0, v[14] = -1, v[15] = 0, v[16] = 0, v[17] = -1, v[18] = 0, v[19] = 0, v[20] = -1, v[21] = 0, v[22] = 0, v[23] = -1, v[24] = 1, v[25] = 0, v[26] = 0, v[27] = 1, v[28] = 0, v[29] = 0, v[30] = 1, v[31] = 0, v[32] = 0, v[33] = 1, v[34] = 0, v[35] = 0, v[36] = -1, v[37] = 0, v[38] = 0, v[39] = -1, v[40] = 0, v[41] = 0, v[42] = -1, v[43] = 0, v[44] = 0, v[45] = -1, v[46] = 0, v[47] = 0, v[48] = 0, v[49] = 1, v[50] = 0, v[51] = 0, v[52] = 1, v[53] = 0, v[54] = 0, v[55] = 1, v[56] = 0, v[57] = 0, v[58] = 1, v[59] = 0, v[60] = 0, v[61] = -1, v[62] = 0, v[63] = 0, v[64] = -1, v[65] = 0, v[66] = 0, v[67] = -1, v[68] = 0, v[69] = 0, v[70] = -1, v[71] = 0, y.normal = new a({componentDatatype: n.FLOAT, componentsPerAttribute: 3, values: v})
                }
                if (m.st) {
                    var g = new Float32Array(48);
                    g[0] = 0, g[1] = 0, g[2] = 1, g[3] = 0, g[4] = 1, g[5] = 1, g[6] = 0, g[7] = 1, g[8] = 1, g[9] = 0, g[10] = 0, g[11] = 0, g[12] = 0, g[13] = 1, g[14] = 1, g[15] = 1, g[16] = 0, g[17] = 0, g[18] = 1, g[19] = 0, g[20] = 1, g[21] = 1, g[22] = 0, g[23] = 1, g[24] = 1, g[25] = 0, g[26] = 0, g[27] = 0, g[28] = 0, g[29] = 1, g[30] = 1, g[31] = 1, g[32] = 1, g[33] = 0, g[34] = 0, g[35] = 0, g[36] = 0, g[37] = 1, g[38] = 1, g[39] = 1, g[40] = 0, g[41] = 0, g[42] = 1, g[43] = 0, g[44] = 1, g[45] = 1, g[46] = 0, g[47] = 1, y.st = new a({componentDatatype: n.FLOAT, componentsPerAttribute: 2, values: g})
                }
                if (m.tangent) {
                    var _ = new Float32Array(72);
                    _[0] = 1, _[1] = 0, _[2] = 0, _[3] = 1, _[4] = 0, _[5] = 0, _[6] = 1, _[7] = 0, _[8] = 0, _[9] = 1, _[10] = 0, _[11] = 0, _[12] = -1, _[13] = 0, _[14] = 0, _[15] = -1, _[16] = 0, _[17] = 0, _[18] = -1, _[19] = 0, _[20] = 0, _[21] = -1, _[22] = 0, _[23] = 0, _[24] = 0, _[25] = 1, _[26] = 0, _[27] = 0, _[28] = 1, _[29] = 0, _[30] = 0, _[31] = 1, _[32] = 0, _[33] = 0, _[34] = 1, _[35] = 0, _[36] = 0, _[37] = -1, _[38] = 0, _[39] = 0, _[40] = -1, _[41] = 0, _[42] = 0, _[43] = -1, _[44] = 0, _[45] = 0, _[46] = -1, _[47] = 0, _[48] = -1, _[49] = 0, _[50] = 0, _[51] = -1, _[52] = 0, _[53] = 0, _[54] = -1, _[55] = 0, _[56] = 0, _[57] = -1, _[58] = 0, _[59] = 0, _[60] = 1, _[61] = 0, _[62] = 0, _[63] = 1, _[64] = 0, _[65] = 0, _[66] = 1, _[67] = 0, _[68] = 0, _[69] = 1, _[70] = 0, _[71] = 0, y.tangent = new a({componentDatatype: n.FLOAT, componentsPerAttribute: 3, values: _})
                }
                if (m.binormal) {
                    var w = new Float32Array(72);
                    w[0] = 0, w[1] = 1, w[2] = 0, w[3] = 0, w[4] = 1, w[5] = 0, w[6] = 0, w[7] = 1, w[8] = 0, w[9] = 0, w[10] = 1, w[11] = 0, w[12] = 0, w[13] = 1, w[14] = 0, w[15] = 0, w[16] = 1, w[17] = 0, w[18] = 0, w[19] = 1, w[20] = 0, w[21] = 0, w[22] = 1, w[23] = 0, w[24] = 0, w[25] = 0, w[26] = 1, w[27] = 0, w[28] = 0, w[29] = 1, w[30] = 0, w[31] = 0, w[32] = 1, w[33] = 0, w[34] = 0, w[35] = 1, w[36] = 0, w[37] = 0, w[38] = 1, w[39] = 0, w[40] = 0, w[41] = 1, w[42] = 0, w[43] = 0, w[44] = 1, w[45] = 0, w[46] = 0, w[47] = 1, w[48] = 0, w[49] = 0, w[50] = 1, w[51] = 0, w[52] = 0, w[53] = 1, w[54] = 0, w[55] = 0, w[56] = 1, w[57] = 0, w[58] = 0, w[59] = 1, w[60] = 0, w[61] = 0, w[62] = 1, w[63] = 0, w[64] = 0, w[65] = 1, w[66] = 0, w[67] = 0, w[68] = 1, w[69] = 0, w[70] = 0, w[71] = 1, y.binormal = new a({componentDatatype: n.FLOAT, componentsPerAttribute: 3, values: w})
                }
                h = new Uint16Array(36), h[0] = 0, h[1] = 1, h[2] = 2, h[3] = 0, h[4] = 2, h[5] = 3, h[6] = 6, h[7] = 5, h[8] = 4, h[9] = 7, h[10] = 6, h[11] = 4, h[12] = 8, h[13] = 9, h[14] = 10, h[15] = 8, h[16] = 10, h[17] = 11, h[18] = 14, h[19] = 13, h[20] = 12, h[21] = 15, h[22] = 14, h[23] = 12, h[24] = 18, h[25] = 17, h[26] = 16, h[27] = 19, h[28] = 18, h[29] = 16, h[30] = 20, h[31] = 21, h[32] = 22, h[33] = 20, h[34] = 22, h[35] = 23
            } else p = new Float64Array(24), p[0] = d.x, p[1] = d.y, p[2] = d.z, p[3] = f.x, p[4] = d.y, p[5] = d.z, p[6] = f.x, p[7] = f.y, p[8] = d.z, p[9] = d.x, p[10] = f.y, p[11] = d.z, p[12] = d.x, p[13] = d.y, p[14] = f.z, p[15] = f.x, p[16] = d.y, p[17] = f.z, p[18] = f.x, p[19] = f.y, p[20] = f.z, p[21] = d.x, p[22] = f.y, p[23] = f.z, y.position = new a({componentDatatype: n.DOUBLE, componentsPerAttribute: 3, values: p}), h = new Uint16Array(36), h[0] = 4, h[1] = 5, h[2] = 6, h[3] = 4, h[4] = 6, h[5] = 7, h[6] = 1, h[7] = 0, h[8] = 3, h[9] = 1, h[10] = 3, h[11] = 2, h[12] = 1, h[13] = 6, h[14] = 5, h[15] = 1, h[16] = 2, h[17] = 6, h[18] = 2, h[19] = 3, h[20] = 7, h[21] = 2, h[22] = 7, h[23] = 6, h[24] = 3, h[25] = 0, h[26] = 4, h[27] = 3, h[28] = 4, h[29] = 7, h[30] = 0, h[31] = 1, h[32] = 5, h[33] = 0, h[34] = 5, h[35] = 4;
            var C = t.subtract(f, d, l), x = .5 * C.magnitude();
            this.attributes = y, this.indices = h, this.primitiveType = i.TRIANGLES, this.boundingSphere = new o(t.ZERO, x)
        };
        return c.fromDimensions = function (t) {
            t = r(t, r.EMPTY_OBJECT);
            var n = t.dimensions;
            if ("undefined" == typeof n)throw new e("options.dimensions is required.");
            if (n.x < 0 || n.y < 0 || n.z < 0)throw new e("All dimensions components must be greater than or equal to zero.");
            var i = n.multiplyByScalar(.5), o = i.negate(), a = i, s = {minimumCorner: o, maximumCorner: a, vertexFormat: t.vertexFormat};
            return new c(s)
        }, c
    }), n("Core/Cartesian2", ["./defaultValue", "./DeveloperError", "./freezeObject"], function (e, t, n) {
        "use strict";
        var i = function (t, n) {
            this.x = e(t, 0), this.y = e(n, 0)
        };
        i.fromArray = function (n, r, o) {
            if ("undefined" == typeof n)throw new t("values is required.");
            if (r + 2 > n.length)throw new t("offset + 2 is greater than the length of the array.");
            return r = e(r, 0), "undefined" == typeof o && (o = new i), o.x = n[r + 0], o.y = n[r + 1], o
        }, i.fromElements = function (e, t, n) {
            return"undefined" == typeof n ? new i(e, t) : (n.x = e, n.y = t, n)
        }, i.clone = function (e, t) {
            return"undefined" == typeof e ? void 0 : "undefined" == typeof t ? new i(e.x, e.y) : (t.x = e.x, t.y = e.y, t)
        }, i.fromCartesian3 = i.clone, i.fromCartesian4 = i.clone, i.getMaximumComponent = function (e) {
            if ("undefined" == typeof e)throw new t("cartesian is required");
            return Math.max(e.x, e.y)
        }, i.getMinimumComponent = function (e) {
            if ("undefined" == typeof e)throw new t("cartesian is required");
            return Math.min(e.x, e.y)
        }, i.magnitudeSquared = function (e) {
            if ("undefined" == typeof e)throw new t("cartesian is required");
            return e.x * e.x + e.y * e.y
        }, i.magnitude = function (e) {
            return Math.sqrt(i.magnitudeSquared(e))
        };
        var r = new i;
        i.distance = function (e, n) {
            if ("undefined" == typeof e || "undefined" == typeof n)throw new t("left and right are required.");
            return i.subtract(e, n, r), i.magnitude(r)
        }, i.normalize = function (e, n) {
            if ("undefined" == typeof e)throw new t("cartesian is required");
            var r = i.magnitude(e);
            return"undefined" == typeof n ? new i(e.x / r, e.y / r) : (n.x = e.x / r, n.y = e.y / r, n)
        }, i.dot = function (e, n) {
            if ("undefined" == typeof e)throw new t("left is required");
            if ("undefined" == typeof n)throw new t("right is required");
            return e.x * n.x + e.y * n.y
        }, i.multiplyComponents = function (e, n, r) {
            if ("undefined" == typeof e)throw new t("left is required");
            if ("undefined" == typeof n)throw new t("right is required");
            return"undefined" == typeof r ? new i(e.x * n.x, e.y * n.y) : (r.x = e.x * n.x, r.y = e.y * n.y, r)
        }, i.add = function (e, n, r) {
            if ("undefined" == typeof e)throw new t("left is required");
            if ("undefined" == typeof n)throw new t("right is required");
            return"undefined" == typeof r ? new i(e.x + n.x, e.y + n.y) : (r.x = e.x + n.x, r.y = e.y + n.y, r)
        }, i.subtract = function (e, n, r) {
            if ("undefined" == typeof e)throw new t("left is required");
            if ("undefined" == typeof n)throw new t("right is required");
            return"undefined" == typeof r ? new i(e.x - n.x, e.y - n.y) : (r.x = e.x - n.x, r.y = e.y - n.y, r)
        }, i.multiplyByScalar = function (e, n, r) {
            if ("undefined" == typeof e)throw new t("cartesian is required");
            if ("number" != typeof n)throw new t("scalar is required and must be a number.");
            return"undefined" == typeof r ? new i(e.x * n, e.y * n) : (r.x = e.x * n, r.y = e.y * n, r)
        }, i.divideByScalar = function (e, n, r) {
            if ("undefined" == typeof e)throw new t("cartesian is required");
            if ("number" != typeof n)throw new t("scalar is required and must be a number.");
            return"undefined" == typeof r ? new i(e.x / n, e.y / n) : (r.x = e.x / n, r.y = e.y / n, r)
        }, i.negate = function (e, n) {
            if ("undefined" == typeof e)throw new t("cartesian is required");
            return"undefined" == typeof n ? new i(-e.x, -e.y) : (n.x = -e.x, n.y = -e.y, n)
        }, i.abs = function (e, n) {
            if ("undefined" == typeof e)throw new t("cartesian is required");
            return"undefined" == typeof n ? new i(Math.abs(e.x), Math.abs(e.y)) : (n.x = Math.abs(e.x), n.y = Math.abs(e.y), n)
        };
        var o = new i;
        i.lerp = function (e, n, r, a) {
            if ("undefined" == typeof e)throw new t("start is required.");
            if ("undefined" == typeof n)throw new t("end is required.");
            if ("number" != typeof r)throw new t("t is required and must be a number.");
            return i.multiplyByScalar(n, r, o), a = i.multiplyByScalar(e, 1 - r, a), i.add(o, a, a)
        };
        var a = new i, s = new i;
        i.angleBetween = function (e, n) {
            if ("undefined" == typeof e)throw new t("left is required");
            if ("undefined" == typeof n)throw new t("right is required");
            return i.normalize(e, a), i.normalize(n, s), Math.acos(i.dot(a, s))
        };
        var u = new i;
        return i.mostOrthogonalAxis = function (e, n) {
            if ("undefined" == typeof e)throw new t("cartesian is required.");
            var r = i.normalize(e, u);
            return i.abs(r, r), n = r.x <= r.y ? i.clone(i.UNIT_X, n) : i.clone(i.UNIT_Y, n)
        }, i.equals = function (e, t) {
            return e === t || "undefined" != typeof e && "undefined" != typeof t && e.x === t.x && e.y === t.y
        }, i.equalsEpsilon = function (e, n, i) {
            if ("number" != typeof i)throw new t("epsilon is required and must be a number.");
            return e === n || "undefined" != typeof e && "undefined" != typeof n && Math.abs(e.x - n.x) <= i && Math.abs(e.y - n.y) <= i
        }, i.ZERO = n(new i(0, 0)), i.UNIT_X = n(new i(1, 0)), i.UNIT_Y = n(new i(0, 1)), i.prototype.getMaximumComponent = function () {
            return i.getMaximumComponent(this)
        }, i.prototype.getMinimumComponent = function () {
            return i.getMinimumComponent(this)
        }, i.prototype.clone = function (e) {
            return i.clone(this, e)
        }, i.prototype.magnitudeSquared = function () {
            return i.magnitudeSquared(this)
        }, i.prototype.magnitude = function () {
            return i.magnitude(this)
        }, i.prototype.normalize = function (e) {
            return i.normalize(this, e)
        }, i.prototype.dot = function (e) {
            return i.dot(this, e)
        }, i.prototype.multiplyComponents = function (e, t) {
            return i.multiplyComponents(this, e, t)
        }, i.prototype.add = function (e, t) {
            return i.add(this, e, t)
        }, i.prototype.subtract = function (e, t) {
            return i.subtract(this, e, t)
        }, i.prototype.multiplyByScalar = function (e, t) {
            return i.multiplyByScalar(this, e, t)
        }, i.prototype.divideByScalar = function (e, t) {
            return i.divideByScalar(this, e, t)
        }, i.prototype.negate = function (e) {
            return i.negate(this, e)
        }, i.prototype.abs = function (e) {
            return i.abs(this, e)
        }, i.prototype.lerp = function (e, t, n) {
            return i.lerp(this, e, t, n)
        }, i.prototype.angleBetween = function (e) {
            return i.angleBetween(this, e)
        }, i.prototype.mostOrthogonalAxis = function (e) {
            return i.mostOrthogonalAxis(this, e)
        }, i.prototype.equals = function (e) {
            return i.equals(this, e)
        }, i.prototype.equalsEpsilon = function (e, t) {
            return i.equalsEpsilon(this, e, t)
        }, i.prototype.toString = function () {
            return"(" + this.x + ", " + this.y + ")"
        }, i
    }), n("Core/TridiagonalSystemSolver", ["./DeveloperError"], function (e) {
        "use strict";
        var t = {};
        return t.solve = function (t, n, i, r) {
            if ("undefined" == typeof t || !(t instanceof Array))throw new e("The array lower is required.");
            if ("undefined" == typeof n || !(n instanceof Array))throw new e("The array diagonal is required.");
            if ("undefined" == typeof i || !(i instanceof Array))throw new e("The array upper is required.");
            if ("undefined" == typeof r || !(r instanceof Array))throw new e("The array right is required.");
            if (n.length !== r.length)throw new e("diagonal and right must have the same lengths.");
            if (t.length !== i.length)throw new e("lower and upper must have the same lengths.");
            if (t.length !== n.length - 1)throw new e("lower and upper must be one less than the length of diagonal.");
            var o = [], a = [], s = [];
            o.length = i.length, a.length = s.length = r.length, o[0] = i[0] / n[0], a[0] = r[0].multiplyByScalar(1 / n[0]);
            for (var u, l = 1; l < o.length; ++l)u = 1 / (n[l] - o[l - 1] * t[l - 1]), o[l] = i[l] * u, a[l] = r[l].subtract(a[l - 1].multiplyByScalar(t[l - 1])), a[l] = a[l].multiplyByScalar(u);
            for (u = 1 / (n[l] - o[l - 1] * t[l - 1]), a[l] = r[l].subtract(a[l - 1].multiplyByScalar(t[l - 1])), a[l] = a[l].multiplyByScalar(u), s[s.length - 1] = a[a.length - 1], l = s.length - 2; l >= 0; --l)s[l] = a[l].subtract(s[l + 1].multiplyByScalar(o[l]));
            return s
        }, t
    }), n("Core/HermiteSpline", ["./defaultValue", "./DeveloperError", "./Matrix4", "./Cartesian4", "./TridiagonalSystemSolver"], function (e, t, n, i, r) {
        "use strict";
        function o(t, n) {
            var i = e(t._lastTimeIndex, 0);
            if (n >= t._points[i].time) {
                if (i + 1 < t._points.length && n < t._points[i + 1].time)return i;
                if (i + 2 < t._points.length && n < t._points[i + 2].time)return t._lastTimeIndex = i + 1, t._lastTimeIndex
            } else if (i - 1 >= 0 && n >= t._points[i - 1].time)return t._lastTimeIndex = i - 1, t._lastTimeIndex;
            for (i = 0; i < t._points.length - 1 && !(n >= t._points[i].time && n < t._points[i + 1].time); ++i);
            return i === t._points.length - 1 && (i = t._points.length - 2), t._lastTimeIndex = i, t._lastTimeIndex
        }

        function a(e) {
            var t = [], n = [], i = [], o = [];
            t.length = i.length = e._points.length - 1, n.length = o.length = e._points.length;
            var a;
            for (t[0] = n[0] = 1, i[0] = 0, o[0] = e._points[0].tangent, a = 1; a < t.length - 1; ++a)t[a] = i[a] = 1, n[a] = 4, o[a] = e._points[a + 1].point.subtract(e._points[a - 1].point).multiplyByScalar(3);
            t[a] = 0, i[a] = 1, n[a] = 4, o[a] = e._points[a + 1].point.subtract(e._points[a - 1].point).multiplyByScalar(3), n[a + 1] = 1, o[a + 1] = e._points[a + 1].tangent;
            var s = r.solve(t, n, i, o);
            for (a = 0; a < e._points.length; ++a)e._points[a].tangent = s[a]
        }

        function s(e) {
            var t = [], n = [], i = [], o = [];
            t.length = i.length = e._points.length - 1, n.length = o.length = e._points.length;
            var a;
            for (t[0] = i[0] = 1, n[0] = 2, o[0] = e._points[1].point.subtract(e._points[0].point).multiplyByScalar(3), a = 1; a < t.length; ++a)t[a] = i[a] = 1, n[a] = 4, o[a] = e._points[a + 1].point.subtract(e._points[a - 1].point).multiplyByScalar(3);
            n[a] = 2, o[a] = e._points[a].point.subtract(e._points[a - 1].point).multiplyByScalar(3);
            var s = r.solve(t, n, i, o);
            for (a = 0; a < e._points.length; ++a)e._points[a].tangent = s[a]
        }

        var u = function (e) {
            if ("undefined" == typeof e || !(e instanceof Array) || e.length < 3)throw new t("controlPoints is required. It must be an array with at least a length of 3.");
            this._points = e, this._lastTimeIndex = 0, "undefined" == typeof this._points[0].tangent || "undefined" == typeof this._points[this._points.length - 1].tangent ? s(this) : "undefined" != typeof this._points[0].tangent && "undefined" == typeof this._points[1].tangent && "undefined" != typeof this._points[this._points.length - 1].tangent && "undefined" == typeof this._points[this._points.length - 2].tangent && a(this)
        };
        return u.hermiteCoefficientMatrix = new n(2, -3, 0, 1, -2, 3, 0, 0, 1, -2, 1, 0, 1, -1, 0, 0), u.prototype.getControlPoints = function () {
            return this._points
        }, u.prototype.evaluate = function (e) {
            if ("undefined" == typeof e)throw new t("time is required.");
            if (e < this._points[0].time || e > this._points[this._points.length - 1].time)throw new t("time is out of range.");
            var n = o(this, e), r = (e - this._points[n].time) / (this._points[n + 1].time - this._points[n].time), a = new i(0, r * r, r);
            a.x = a.y * r;
            var s = u.hermiteCoefficientMatrix.multiplyByPoint(a), l = this._points[n].point.multiplyByScalar(s.x), c = this._points[n + 1].point.multiplyByScalar(s.y), d = this._points[n].tangent.multiplyByScalar(s.z), f = this._points[n + 1].tangent.multiplyByScalar(s.w);
            return l.add(c.add(d.add(f)))
        }, u
    }), n("Core/CatmullRomSpline", ["./defaultValue", "./DeveloperError", "./Matrix4", "./Cartesian3", "./HermiteSpline"], function (e, t, n, i, r) {
        "use strict";
        function o(t, n) {
            var i = e(t._lastTimeIndex, 0);
            if (n >= t._points[i].time) {
                if (i + 1 < t._points.length && n < t._points[i + 1].time)return i;
                if (i + 2 < t._points.length && n < t._points[i + 2].time)return t._lastTimeIndex = i + 1, t._lastTimeIndex
            } else if (i - 1 >= 0 && n >= t._points[i - 1].time)return t._lastTimeIndex = i - 1, t._lastTimeIndex;
            for (i = 0; i < t._points.length - 1 && !(n >= t._points[i].time && n < t._points[i + 1].time); ++i);
            return i === t._points.length - 1 && (i = t._points.length - 2), t._lastTimeIndex = i, t._lastTimeIndex
        }

        var a = function (e, n, r) {
            if ("undefined" == typeof e || !(e instanceof Array) || e.length < 3)throw new t("controlPoints is required and must be an array of objects with point and time properties, with a length of at least 3.");
            if (this._points = e, this._lastTimeIndex = 0, "undefined" != typeof n)this._ti = i.clone(n); else {
                var o = i.clone(e[0].point), a = i.clone(e[1].point), s = i.clone(e[2].point);
                this._ti = a.multiplyByScalar(2).subtract(s).subtract(o).multiplyByScalar(.5)
            }
            if ("undefined" != typeof r)this._to = i.clone(r); else {
                var u = e.length - 1, l = i.clone(e[u].point), c = i.clone(e[u - 1].point), d = i.clone(e[u - 2].point);
                this._to = l.subtract(c.multiplyByScalar(2)).add(d).multiplyByScalar(.5)
            }
        };
        return a.catmullRomCoefficientMatrix = new n(-.5, 1, -.5, 0, 1.5, -2.5, 0, 1, -1.5, 2, .5, 0, .5, -.5, 0, 0), a.prototype.getControlPoints = function () {
            return this._points
        }, a.prototype.getStartTangent = function () {
            return this._ti
        }, a.prototype.getEndTangent = function () {
            return this._to
        }, a.prototype.evaluate = function (e) {
            if ("undefined" == typeof e)throw new t("time is required.");
            if (e < this._points[0].time || e > this._points[this._points.length - 1].time)throw new t("time is out of range.");
            var n = o(this, e), s = (e - this._points[n].time) / (this._points[n + 1].time - this._points[n].time), u = new i(0, s * s, s);
            u.x = u.y * s;
            var l, c, d, f, h;
            return 0 === n ? (l = this._points[0].point, c = this._points[1].point, d = this._ti, f = this._points[2].point.subtract(l).multiplyByScalar(.5), h = r.hermiteCoefficientMatrix.multiplyByPoint(u)) : n === this._points.length - 2 ? (l = this._points[n].point, c = this._points[n + 1].point, d = c.subtract(this._points[n - 1].point).multiplyByScalar(.5), f = this._to, h = r.hermiteCoefficientMatrix.multiplyByPoint(u)) : (l = this._points[n - 1].point, c = this._points[n].point, d = this._points[n + 1].point, f = this._points[n + 2].point, h = a.catmullRomCoefficientMatrix.multiplyByPoint(u)), l = l.multiplyByScalar(h.x), c = c.multiplyByScalar(h.y), d = d.multiplyByScalar(h.z), f = f.multiplyByScalar(h.w), l.add(c.add(d.add(f)))
        }, a
    }), n("Core/clone", ["./defaultValue"], function (e) {
        "use strict";
        var t = function (n, i) {
            if (null === n || "object" != typeof n)return n;
            i = e(i, !1);
            var r = new n.constructor;
            for (var o in n)if (n.hasOwnProperty(o)) {
                var a = n[o];
                i && (a = t(a, i)), r[o] = a
            }
            return r
        };
        return t
    }), n("Core/IndexDatatype", ["./Enumeration", "./DeveloperError", "./Math"], function (e, t, n) {
        "use strict";
        if ("undefined" == typeof Int8Array)return{};
        var i = {UNSIGNED_BYTE: new e(5121, "UNSIGNED_BYTE", {sizeInBytes: Uint8Array.BYTES_PER_ELEMENT}), UNSIGNED_SHORT: new e(5123, "UNSIGNED_SHORT", {sizeInBytes: Uint16Array.BYTES_PER_ELEMENT}), UNSIGNED_INT: new e(5125, "UNSIGNED_INT", {sizeInBytes: Uint32Array.BYTES_PER_ELEMENT})};
        return i.validate = function (e) {
            return e === i.UNSIGNED_BYTE || e === i.UNSIGNED_SHORT || e === i.UNSIGNED_INT
        }, i.createTypedArray = function (e, i) {
            if ("undefined" == typeof e)throw new t("numberOfVertices is required.");
            return e > n.SIXTY_FOUR_KILOBYTES ? new Uint32Array(i) : new Uint16Array(i)
        }, i
    }), n("Core/Geometry", ["./defaultValue", "./DeveloperError", "./BoundingSphere"], function (e, t) {
        "use strict";
        var n = function (n) {
            if (n = e(n, e.EMPTY_OBJECT), "undefined" == typeof n.attributes)throw new t("options.attributes is required.");
            if ("undefined" == typeof n.primitiveType)throw new t("options.primitiveType is required.");
            this.attributes = n.attributes, this.indices = n.indices, this.primitiveType = n.primitiveType, this.boundingSphere = n.boundingSphere
        };
        return n.computeNumberOfVertices = function (e) {
            if ("undefined" == typeof e)throw new t("geometry is required.");
            var n = -1;
            for (var i in e.attributes)if (e.attributes.hasOwnProperty(i) && "undefined" != typeof e.attributes[i] && "undefined" != typeof e.attributes[i].values) {
                var r = e.attributes[i], o = r.values.length / r.componentsPerAttribute;
                if (n !== o && -1 !== n)throw new t("All attribute lists must have the same number of attributes.");
                n = o
            }
            return n
        }, n
    }), n("Core/barycentricCoordinates", ["./Cartesian3", "./DeveloperError"], function (e, t) {
        "use strict";
        var n = new e, i = new e, r = new e, o = function (o, a, s, u, l) {
            if ("undefined" == typeof o || "undefined" == typeof a || "undefined" == typeof s || "undefined" == typeof u)throw new t("point, p0, p1, and p2 are required.");
            "undefined" == typeof l && (l = new e);
            var c = s.subtract(a, n), d = u.subtract(a, i), f = o.subtract(a, r), h = c.dot(c), p = c.dot(d), m = c.dot(f), y = d.dot(d), v = d.dot(f), g = 1 / (h * y - p * p);
            return l.y = (y * m - p * v) * g, l.z = (h * v - p * m) * g, l.x = 1 - l.y - l.z, l
        };
        return o
    }), n("Core/EncodedCartesian3", ["./Cartesian3", "./DeveloperError"], function (e, t) {
        "use strict";
        var n = function () {
            this.high = e.ZERO.clone(), this.low = e.ZERO.clone()
        };
        n.encode = function (e, n) {
            if ("undefined" == typeof e)throw new t("value is required");
            "undefined" == typeof n && (n = {high: 0, low: 0});
            var i;
            return e >= 0 ? (i = 65536 * Math.floor(e / 65536), n.high = i, n.low = e - i) : (i = 65536 * Math.floor(-e / 65536), n.high = -i, n.low = e + i), n
        };
        var i = {high: 0, low: 0};
        n.fromCartesian = function (e, r) {
            if ("undefined" == typeof e)throw new t("cartesian is required");
            "undefined" == typeof r && (r = new n);
            var o = r.high, a = r.low;
            return n.encode(e.x, i), o.x = i.high, a.x = i.low, n.encode(e.y, i), o.y = i.high, a.y = i.low, n.encode(e.z, i), o.z = i.high, a.z = i.low, r
        };
        var r = new n;
        return n.writeElements = function (e, i, o) {
            if ("undefined" == typeof e)throw new t("cartesian is required");
            if ("undefined" == typeof i)throw new t("cartesianArray is required");
            if ("number" != typeof o || 0 > o)throw new t("index must be a number greater than or equal to 0.");
            n.fromCartesian(e, r);
            var a = r.high, s = r.low;
            i[o] = a.x, i[o + 1] = a.y, i[o + 2] = a.z, i[o + 3] = s.x, i[o + 4] = s.y, i[o + 5] = s.z
        }, n
    }), n("Core/QuadraticRealPolynomial", ["./DeveloperError", "./Math"], function (e, t) {
        "use strict";
        function n(e, n, i) {
            var r = e + n;
            return t.sign(e) !== t.sign(n) && Math.abs(r / Math.max(Math.abs(e), Math.abs(n))) < i ? 0 : r
        }

        var i = {};
        return i.discriminant = function (t, n, i) {
            if ("number" != typeof t)throw new e("a is a required number.");
            if ("number" != typeof n)throw new e("b is a required number.");
            if ("number" != typeof i)throw new e("c is a required number.");
            var r = n * n - 4 * t * i;
            return r
        }, i.realRoots = function (i, r, o) {
            if ("number" != typeof i)throw new e("a is a required number.");
            if ("number" != typeof r)throw new e("b is a required number.");
            if ("number" != typeof o)throw new e("c is a required number.");
            var a;
            if (0 === i)return 0 === r ? [] : [-o / r];
            if (0 === r) {
                if (0 === o)return[0, 0];
                var s = Math.abs(o), u = Math.abs(i);
                if (u > s && s / u < t.EPSILON14)return[0, 0];
                if (s > u && u / s < t.EPSILON14)return[];
                if (a = -o / i, 0 > a)return[];
                var l = Math.sqrt(a);
                return[-l, l]
            }
            if (0 === o)return a = -r / i, 0 > a ? [a, 0] : [0, a];
            var c = r * r, d = 4 * i * o, f = n(c, -d, t.EPSILON14);
            if (0 > f)return[];
            var h = -.5 * n(r, t.sign(r) * Math.sqrt(f), t.EPSILON14);
            return r > 0 ? [h / i, o / h] : [o / h, h / i]
        }, i
    }), n("Core/CubicRealPolynomial", ["./DeveloperError", "./QuadraticRealPolynomial"], function (e, t) {
        "use strict";
        function n(e, t, n, i) {
            var r, o, a = e, s = t / 3, u = n / 3, l = i, c = a * u, d = s * l, f = s * s, h = u * u, p = a * u - f, m = a * l - s * u, y = s * l - h, v = 4 * p * y - m * m;
            if (0 > v) {
                var g, _, w;
                f * d >= c * h ? (g = a, _ = p, w = -2 * s * p + a * m) : (g = l, _ = y, w = -l * m + 2 * u * y);
                var C = 0 > w ? -1 : 1, x = -C * Math.abs(g) * Math.sqrt(-v);
                o = -w + x;
                var S = o / 2, b = 0 > S ? -Math.pow(-S, 1 / 3) : Math.pow(S, 1 / 3), T = o === x ? -b : -_ / b;
                return r = 0 >= _ ? b + T : -w / (b * b + T * T + _), f * d >= c * h ? [(r - s) / a] : [-l / (r + u)]
            }
            var E = p, A = -2 * s * p + a * m, M = y, D = -l * m + 2 * u * y, I = Math.sqrt(v), P = Math.sqrt(3) / 2, O = Math.abs(Math.atan2(a * I, -A) / 3);
            r = 2 * Math.sqrt(-E);
            var R = Math.cos(O);
            o = r * R;
            var z = r * (-R / 2 - P * Math.sin(O)), L = o + z > 2 * s ? o - s : z - s, N = a, F = L / N;
            O = Math.abs(Math.atan2(l * I, -D) / 3), r = 2 * Math.sqrt(-M), R = Math.cos(O), o = r * R, z = r * (-R / 2 - P * Math.sin(O));
            var V = -l, B = 2 * u > o + z ? o + u : z + u, k = V / B, U = N * B, q = -L * B - N * V, W = L * V, H = (u * q - s * W) / (-s * q + u * U);
            return H >= F ? k >= F ? k >= H ? [F, H, k] : [F, k, H] : [k, F, H] : k >= F ? [H, F, k] : k >= H ? [H, k, F] : [k, H, F]
        }

        var i = {};
        return i.discriminant = function (t, n, i, r) {
            if ("number" != typeof t)throw new e("a is a required number.");
            if ("number" != typeof n)throw new e("b is a required number.");
            if ("number" != typeof i)throw new e("c is a required number.");
            if ("number" != typeof r)throw new e("d is a required number.");
            var o = t * t, a = n * n, s = i * i, u = r * r, l = 18 * t * n * i * r + a * s - 27 * o * u - 4 * (t * s * i + a * n * r);
            return l
        }, i.realRoots = function (i, r, o, a) {
            if ("number" != typeof i)throw new e("a is a required number.");
            if ("number" != typeof r)throw new e("b is a required number.");
            if ("number" != typeof o)throw new e("c is a required number.");
            if ("number" != typeof a)throw new e("d is a required number.");
            var s, u;
            if (0 === i)return t.realRoots(r, o, a);
            if (0 === r) {
                if (0 === o) {
                    if (0 === a)return[0, 0, 0];
                    u = -a / i;
                    var l = 0 > u ? -Math.pow(-u, 1 / 3) : Math.pow(u, 1 / 3);
                    return[l, l, l]
                }
                return 0 === a ? (s = t.realRoots(i, 0, o), 0 === s.Length ? [0] : [s[0], 0, s[1]]) : n(i, 0, o, a)
            }
            return 0 === o ? 0 === a ? (u = -r / i, 0 > u ? [u, 0, 0] : [0, 0, u]) : n(i, r, 0, a) : 0 === a ? (s = t.realRoots(i, r, o), 0 === s.length ? [0] : s[1] <= 0 ? [s[0], s[1], 0] : s[0] >= 0 ? [0, s[0], s[1]] : [s[0], 0, s[1]]) : n(i, r, o, a)
        }, i
    }), n("Core/QuarticRealPolynomial", ["./DeveloperError", "./Math", "./CubicRealPolynomial", "./QuadraticRealPolynomial"], function (e, t, n, i) {
        "use strict";
        function r(e, r, o, a) {
            var s = e * e, u = r - 3 * s / 8, l = o - r * e / 2 + s * e / 8, c = a - o * e / 4 + r * s / 16 - 3 * s * s / 256, d = n.realRoots(1, 2 * u, u * u - 4 * c, -l * l);
            if (d.length > 0) {
                var f = -e / 4, h = d[d.length - 1];
                if (Math.abs(h) < t.EPSILON14) {
                    var p = i.realRoots(1, u, c);
                    if (2 === p.length) {
                        var m, y = p[0], v = p[1];
                        if (y >= 0 && v >= 0) {
                            var g = Math.sqrt(y), _ = Math.sqrt(v);
                            return[f - _, f - g, f + g, f + _]
                        }
                        if (y >= 0 && 0 > v)return m = Math.sqrt(y), [f - m, f + m];
                        if (0 > y && v >= 0)return m = Math.sqrt(v), [f - m, f + m]
                    }
                    return[]
                }
                if (h > 0) {
                    var w = Math.sqrt(h), C = (u + h - l / w) / 2, x = (u + h + l / w) / 2, S = i.realRoots(1, w, C), b = i.realRoots(1, -w, x);
                    return 0 !== S.length ? (S[0] += f, S[1] += f, 0 !== b.length ? (b[0] += f, b[1] += f, S[1] <= b[0] ? [S[0], S[1], b[0], b[1]] : b[1] <= S[0] ? [b[0], b[1], S[0], S[1]] : S[0] >= b[0] && S[1] <= b[1] ? [b[0], S[0], S[1], b[1]] : b[0] >= S[0] && b[1] <= S[1] ? [S[0], b[0], b[1], S[1]] : S[0] > b[0] && S[0] < b[1] ? [b[0], S[0], b[1], S[1]] : [S[0], b[0], S[1], b[1]]) : S) : 0 !== b.length ? (b[0] += f, b[1] += f, b) : []
                }
            }
            return[]
        }

        function o(e, r, o, a) {
            var s = o * o, u = r * r, l = e * e, c = -2 * r, d = o * e + u - 4 * a, f = l * a - o * r * e + s, h = n.realRoots(1, c, d, f);
            if (h.length > 0) {
                var p, m, y = h[0], v = r - y, g = v * v, _ = e / 2, w = v / 2, C = g - 4 * a, x = g + 4 * Math.abs(a), S = l - 4 * y, b = l + 4 * Math.abs(y);
                if (0 > y || S * x > C * b) {
                    var T = Math.sqrt(S);
                    p = T / 2, m = 0 === T ? 0 : (e * w - o) / T
                } else {
                    var E = Math.sqrt(C);
                    p = 0 === E ? 0 : (e * w - o) / E, m = E / 2
                }
                var A, M;
                0 === _ && 0 === p ? (A = 0, M = 0) : t.sign(_) === t.sign(p) ? (A = _ + p, M = y / A) : (M = _ - p, A = y / M);
                var D, I;
                0 === w && 0 === m ? (D = 0, I = 0) : t.sign(w) === t.sign(m) ? (D = w + m, I = a / D) : (I = w - m, D = a / I);
                var P = i.realRoots(1, A, D), O = i.realRoots(1, M, I);
                if (0 !== P.length)return 0 !== O.length ? P[1] <= O[0] ? [P[0], P[1], O[0], O[1]] : O[1] <= P[0] ? [O[0], O[1], P[0], P[1]] : P[0] >= O[0] && P[1] <= O[1] ? [O[0], P[0], P[1], O[1]] : O[0] >= P[0] && O[1] <= P[1] ? [P[0], O[0], O[1], P[1]] : P[0] > O[0] && P[0] < O[1] ? [O[0], P[0], O[1], P[1]] : [P[0], O[0], P[1], O[1]] : P;
                if (0 !== O.length)return O
            }
            return[]
        }

        var a = {};
        return a.discriminant = function (t, n, i, r, o) {
            if ("number" != typeof t)throw new e("a is a required number.");
            if ("number" != typeof n)throw new e("b is a required number.");
            if ("number" != typeof i)throw new e("c is a required number.");
            if ("number" != typeof r)throw new e("d is a required number.");
            if ("number" != typeof o)throw new e("e is a required number.");
            var a = t * t, s = a * t, u = n * n, l = u * n, c = i * i, d = c * i, f = r * r, h = f * r, p = o * o, m = p * o, y = u * c * f - 4 * l * h - 4 * t * d * f + 18 * t * n * i * h - 27 * a * f * f + 256 * s * m + o * (18 * l * i * r - 4 * u * d + 16 * t * c * c - 80 * t * n * c * r - 6 * t * u * f + 144 * a * i * f) + p * (144 * t * u * i - 27 * u * u - 128 * a * c - 192 * a * n * r);
            return y
        }, a.realRoots = function (i, a, s, u, l) {
            if ("number" != typeof i)throw new e("a is a required number.");
            if ("number" != typeof a)throw new e("b is a required number.");
            if ("number" != typeof s)throw new e("c is a required number.");
            if ("number" != typeof u)throw new e("d is a required number.");
            if ("number" != typeof l)throw new e("e is a required number.");
            if (Math.abs(i) < t.EPSILON15)return n.realRoots(a, s, u, l);
            var c = a / i, d = s / i, f = u / i, h = l / i, p = 0 > c ? 1 : 0;
            switch (p += 0 > d ? p + 1 : p, p += 0 > f ? p + 1 : p, p += 0 > h ? p + 1 : p) {
                case 0:
                    return r(c, d, f, h);
                case 1:
                    return o(c, d, f, h);
                case 2:
                    return o(c, d, f, h);
                case 3:
                    return r(c, d, f, h);
                case 4:
                    return r(c, d, f, h);
                case 5:
                    return o(c, d, f, h);
                case 6:
                    return r(c, d, f, h);
                case 7:
                    return r(c, d, f, h);
                case 8:
                    return o(c, d, f, h);
                case 9:
                    return r(c, d, f, h);
                case 10:
                    return r(c, d, f, h);
                case 11:
                    return o(c, d, f, h);
                case 12:
                    return r(c, d, f, h);
                case 13:
                    return r(c, d, f, h);
                case 14:
                    return r(c, d, f, h);
                case 15:
                    return r(c, d, f, h);
                default:
                    return void 0
            }
        }, a
    }), n("Core/IntersectionTests", ["./DeveloperError", "./Math", "./Cartesian3", "./Cartographic", "./Matrix3", "./QuadraticRealPolynomial", "./QuarticRealPolynomial"], function (e, t, n, i, r, o, a) {
        "use strict";
        function s(e, n, i) {
            var r = e + n;
            return t.sign(e) !== t.sign(n) && Math.abs(r / Math.max(Math.abs(e), Math.abs(n))) < i ? 0 : r
        }

        function u(e, i, u, l, c) {
            var d, f = l * l, h = c * c, p = (e[r.COLUMN1ROW1] - e[r.COLUMN2ROW2]) * h, m = c * (l * s(e[r.COLUMN1ROW0], e[r.COLUMN0ROW1], t.EPSILON15) + i.y), y = e[r.COLUMN0ROW0] * f + e[r.COLUMN2ROW2] * h + l * i.x + u, v = h * s(e[r.COLUMN2ROW1], e[r.COLUMN1ROW2], t.EPSILON15), g = c * (l * s(e[r.COLUMN2ROW0], e[r.COLUMN0ROW2]) + i.z), _ = [];
            if (0 === g && 0 === v) {
                if (d = o.realRoots(p, m, y), 0 === d.length)return _;
                var w = d[0], C = Math.sqrt(Math.max(1 - w * w, 0));
                if (_.push(new n(l, c * w, c * -C)), _.push(new n(l, c * w, c * C)), 2 === d.length) {
                    var x = d[1], S = Math.sqrt(Math.max(1 - x * x, 0));
                    _.push(new n(l, c * x, c * -S)), _.push(new n(l, c * x, c * S))
                }
                return _
            }
            var b = g * g, T = v * v, E = p * p, A = g * v, M = E + T, D = 2 * (m * p + A), I = 2 * y * p + m * m - T + b, P = 2 * (y * m - A), O = y * y - b;
            if (0 === M && 0 === D && 0 === I && 0 === P)return _;
            d = a.realRoots(M, D, I, P, O);
            var R = d.length;
            if (0 === R)return _;
            for (var z = 0; R > z; ++z) {
                var L, N = d[z], F = N * N, V = Math.max(1 - F, 0), B = Math.sqrt(V);
                L = t.sign(p) === t.sign(y) ? s(p * F + y, m * N, t.EPSILON12) : t.sign(y) === t.sign(m * N) ? s(p * F, m * N + y, t.EPSILON12) : s(p * F + m * N, y, t.EPSILON12);
                var k = s(v * N, g, t.EPSILON15), U = L * k;
                0 > U ? _.push(new n(l, c * N, c * B)) : U > 0 ? _.push(new n(l, c * N, c * -B)) : 0 !== B ? (_.push(new n(l, c * N, c * -B)), _.push(new n(l, c * N, c * B)), ++z) : _.push(new n(l, c * N, c * B))
            }
            return _
        }

        var l = {};
        l.rayPlane = function (i, r, o) {
            if ("undefined" == typeof i)throw new e("ray is required.");
            if ("undefined" == typeof r)throw new e("plane is required.");
            var a = i.origin, s = i.direction, u = r.normal, l = n.dot(u, s);
            if (Math.abs(l) < t.EPSILON15)return void 0;
            var c = (-r.distance - n.dot(u, a)) / l;
            return 0 > c ? void 0 : (o = s.multiplyByScalar(c, o), n.add(a, o))
        }, l.rayEllipsoid = function (t, n) {
            if ("undefined" == typeof t)throw new e("ray is required.");
            if ("undefined" == typeof n)throw new e("ellipsoid is required.");
            var i, r, o, a, s, u = n.getOneOverRadii(), l = u.multiplyComponents(t.origin), c = u.multiplyComponents(t.direction), d = l.magnitudeSquared(), f = l.dot(c);
            if (d > 1) {
                if (f >= 0)return void 0;
                var h = f * f;
                if (i = d - 1, r = c.magnitudeSquared(), o = r * i, o > h)return void 0;
                if (h > o) {
                    a = f * f - o, s = -f + Math.sqrt(a);
                    var p = s / r, m = i / s;
                    return m > p ? {start: p, stop: m} : {start: m, stop: p}
                }
                var y = Math.sqrt(i / r);
                return{start: y, stop: y}
            }
            return 1 > d ? (i = d - 1, r = c.magnitudeSquared(), o = r * i, a = f * f - o, s = -f + Math.sqrt(a), {start: 0, stop: s / r}) : 0 > f ? (r = c.magnitudeSquared(), {start: 0, stop: -f / r}) : void 0
        }, l.grazingAltitudeLocation = function (o, a) {
            if ("undefined" == typeof o)throw new e("ray is required.");
            if ("undefined" == typeof a)throw new e("ellipsoid is required.");
            var s = o.origin, l = o.direction, c = a.geodeticSurfaceNormal(s);
            if (n.dot(l, c) >= 0)return s;
            var d, f, h = "undefined" != typeof this.rayEllipsoid(o, a), p = a.transformPositionToScaledSpace(l), m = p.normalize(), y = p.mostOrthogonalAxis(), v = y.cross(m).normalize(), g = m.cross(v).normalize(), _ = new r(m.x, v.x, g.x, m.y, v.y, g.y, m.z, v.z, g.z), w = _.transpose(), C = r.fromScale(a.getRadii()), x = r.fromScale(a.getOneOverRadii()), S = new r(0, l.z, -l.y, -l.z, 0, l.x, l.y, -l.x, 0), b = w.multiply(x).multiply(S), T = b.multiply(C).multiply(_), E = b.multiplyByVector(s), A = u(T, E.negate(), 0, 0, 1), M = A.length;
            if (M > 0) {
                for (var D = n.ZERO, I = Number.NEGATIVE_INFINITY, P = 0; M > P; ++P) {
                    d = C.multiplyByVector(_.multiplyByVector(A[P]));
                    var O = d.subtract(s).normalize(), R = O.dot(l);
                    R > I && (I = R, D = d)
                }
                var z = a.cartesianToCartographic(D);
                return I = t.clamp(I, 0, 1), f = D.subtract(s).magnitude() * Math.sqrt(1 - I * I), f = h ? -f : f, a.cartographicToCartesian(new i(z.longitude, z.latitude, f))
            }
            return void 0
        };
        var c = new n;
        return l.lineSegmentPlane = function (i, r, o, a) {
            if ("undefined" == typeof i)throw new e("endPoint0 is required.");
            if ("undefined" == typeof r)throw new e("endPoint1 is required.");
            if ("undefined" == typeof o)throw new e("plane is required.");
            var s = n.subtract(r, i, c), u = o.normal, l = n.dot(u, s);
            if (Math.abs(l) < t.EPSILON6)return void 0;
            var d = n.dot(u, i), f = -(o.distance + d) / l;
            return 0 > f || f > 1 ? void 0 : ("undefined" == typeof a && (a = new n), n.multiplyByScalar(s, f, a), n.add(i, a, a), a)
        }, l.trianglePlaneIntersection = function (t, i, r, o) {
            if ("undefined" == typeof t || "undefined" == typeof i || "undefined" == typeof r || "undefined" == typeof o)throw new e("p0, p1, p2, and plane are required.");
            var a = o.normal, s = o.distance, u = n.dot(a, t) + s < 0, c = n.dot(a, i) + s < 0, d = n.dot(a, r) + s < 0, f = 0;
            f += u ? 1 : 0, f += c ? 1 : 0, f += d ? 1 : 0;
            var h, p;
            if ((1 === f || 2 === f) && (h = new n, p = new n), 1 === f) {
                if (u)return l.lineSegmentPlane(t, i, o, h), l.lineSegmentPlane(t, r, o, p), {positions: [t, i, r, h, p], indices: [0, 3, 4, 1, 2, 4, 1, 4, 3]};
                if (c)return l.lineSegmentPlane(i, r, o, h), l.lineSegmentPlane(i, t, o, p), {positions: [t, i, r, h, p], indices: [1, 3, 4, 2, 0, 4, 2, 4, 3]};
                if (d)return l.lineSegmentPlane(r, t, o, h), l.lineSegmentPlane(r, i, o, p), {positions: [t, i, r, h, p], indices: [2, 3, 4, 0, 1, 4, 0, 4, 3]}
            } else if (2 === f) {
                if (!u)return l.lineSegmentPlane(i, t, o, h), l.lineSegmentPlane(r, t, o, p), {positions: [t, i, r, h, p], indices: [1, 2, 4, 1, 4, 3, 0, 3, 4]};
                if (!c)return l.lineSegmentPlane(r, i, o, h), l.lineSegmentPlane(t, i, o, p), {positions: [t, i, r, h, p], indices: [2, 0, 4, 2, 4, 3, 1, 3, 4]};
                if (!d)return l.lineSegmentPlane(t, r, o, h), l.lineSegmentPlane(i, r, o, p), {positions: [t, i, r, h, p], indices: [0, 1, 4, 0, 4, 3, 2, 3, 4]}
            }
            return void 0
        }, l
    }), n("Core/Plane", ["./Cartesian3", "./DeveloperError"], function (e, t) {
        "use strict";
        var n = function (n, i) {
            if ("undefined" == typeof n)throw new t("normal is required.");
            if ("undefined" == typeof i)throw new t("distance is required.");
            this.normal = e.clone(n), this.distance = i
        };
        return n.fromPointNormal = function (i, r, o) {
            if ("undefined" == typeof i)throw new t("point is required.");
            if ("undefined" == typeof r)throw new t("normal is required.");
            var a = -e.dot(r, i);
            return"undefined" == typeof o ? new n(r, a) : (e.clone(r, o.normal), o.distance = a, o)
        }, n.getPointDistance = function (n, i) {
            if ("undefined" == typeof n)throw new t("plane is required.");
            if ("undefined" == typeof i)throw new t("point is required.");
            return e.dot(n.normal, i) + n.distance
        }, n.prototype.getPointDistance = function (e) {
            return n.getPointDistance(this, e)
        }, n
    }), n("Core/Tipsify", ["./DeveloperError", "./defaultValue"], function (e, t) {
        "use strict";
        var n = {};
        return n.calculateACMR = function (n) {
            n = t(n, t.EMPTY_OBJECT);
            var i = n.indices, r = n.maximumIndex, o = t(n.cacheSize, 24);
            if ("undefined" == typeof i)throw new e("indices is required.");
            var a = i.length;
            if (3 > a || 0 !== a % 3)throw new e("indices length must be a multiple of three.");
            if (0 >= r)throw new e("maximumIndex must be greater than zero.");
            if (3 > o)throw new e("cacheSize must be greater than two.");
            if ("undefined" == typeof r) {
                r = 0;
                for (var s = 0, u = i[s]; a > s;)u > r && (r = u), ++s, u = i[s]
            }
            for (var l = [], c = 0; r + 1 > c; c++)l[c] = 0;
            for (var d = o + 1, f = 0; a > f; ++f)d - l[i[f]] > o && (l[i[f]] = d, ++d);
            return(d - o + 1) / (a / 3)
        }, n.tipsify = function (n) {
            function i(e, t, n, i) {
                for (; t.length >= 1;) {
                    var r = t[t.length - 1];
                    if (t.splice(t.length - 1, 1), e[r].numLiveTriangles > 0)return r
                }
                for (; i > o;) {
                    if (e[o].numLiveTriangles > 0)return++o, o - 1;
                    ++o
                }
                return-1
            }

            function r(e, t, n, r, o, a, s) {
                for (var u, l = -1, c = -1, d = 0; d < n.length;) {
                    var f = n[d];
                    r[f].numLiveTriangles && (u = 0, o - r[f].timeStamp + 2 * r[f].numLiveTriangles <= t && (u = o - r[f].timeStamp), (u > c || -1 === c) && (c = u, l = f)), ++d
                }
                return-1 === l ? i(r, a, e, s) : l
            }

            n = t(n, t.EMPTY_OBJECT);
            var o, a = n.indices, s = n.maximumIndex, u = t(n.cacheSize, 24);
            if ("undefined" == typeof a)throw new e("indices is required.");
            var l = a.length;
            if (3 > l || 0 !== l % 3)throw new e("indices length must be a multiple of three.");
            if (0 >= s)throw new e("maximumIndex must be greater than zero.");
            if (3 > u)throw new e("cacheSize must be greater than two.");
            var c = 0, d = 0, f = a[d], h = l;
            if ("undefined" != typeof s)c = s + 1; else {
                for (; h > d;)f > c && (c = f), ++d, f = a[d];
                if (-1 === c)return 0;
                ++c
            }
            for (var p = [], m = 0; c > m; m++)p[m] = {numLiveTriangles: 0, timeStamp: 0, vertexTriangles: []};
            d = 0;
            for (var y = 0; h > d;)p[a[d]].vertexTriangles.push(y), ++p[a[d]].numLiveTriangles, p[a[d + 1]].vertexTriangles.push(y), ++p[a[d + 1]].numLiveTriangles, p[a[d + 2]].vertexTriangles.push(y), ++p[a[d + 2]].numLiveTriangles, ++y, d += 3;
            var v = 0, g = u + 1;
            o = 1;
            var _, w, C = [], x = [], S = 0, b = [], T = l / 3, E = [];
            for (m = 0; T > m; m++)E[m] = !1;
            for (var A, M; -1 !== v;) {
                C = [], w = p[v], M = w.vertexTriangles.length;
                for (var D = 0; M > D; ++D)if (y = w.vertexTriangles[D], !E[y]) {
                    E[y] = !0, d = y + y + y;
                    for (var I = 0; 3 > I; ++I)A = a[d], C.push(A), x.push(A), b[S] = A, ++S, _ = p[A], --_.numLiveTriangles, g - _.timeStamp > u && (_.timeStamp = g, ++g), ++d
                }
                v = r(a, u, C, p, g, x, c)
            }
            return b
        }, n
    }), n("Core/GeometryPipeline", ["./barycentricCoordinates", "./defaultValue", "./DeveloperError", "./Cartesian2", "./Cartesian3", "./Cartesian4", "./Cartographic", "./EncodedCartesian3", "./Intersect", "./IntersectionTests", "./Math", "./Matrix3", "./Matrix4", "./Plane", "./GeographicProjection", "./ComponentDatatype", "./IndexDatatype", "./PrimitiveType", "./Tipsify", "./BoundingSphere", "./Geometry", "./GeometryAttribute"], function (e, t, n, i, r, o, a, s, u, l, c, d, f, h, p, m, y, v, g, _, w, C) {
        "use strict";
        function x(e, t, n, i, r) {
            e[t++] = n, e[t++] = i, e[t++] = i, e[t++] = r, e[t++] = r, e[t] = n
        }

        function S(e) {
            for (var t = e.length, n = 6 * (t / 3), i = y.createTypedArray(t, n), r = 0, o = 0; t > o; o += 3, r += 6)x(i, r, e[o], e[o + 1], e[o + 2]);
            return i
        }

        function b(e) {
            var t = e.length;
            if (t >= 3) {
                var n = 6 * (t - 2), i = y.createTypedArray(t, n);
                x(i, 0, e[0], e[1], e[2]);
                for (var r = 6, o = 3; t > o; ++o, r += 6)x(i, r, e[o - 1], e[o], e[o - 2]);
                return i
            }
            return new Uint16Array
        }

        function T(e) {
            if (e.length > 0) {
                for (var t = e.length - 1, n = 6 * (t - 1), i = y.createTypedArray(t, n), r = e[0], o = 0, a = 1; t > a; ++a, o += 6)x(i, o, r, e[a], e[a + 1]);
                return i
            }
            return new Uint16Array
        }

        function E(e) {
            var t = {};
            for (var n in e)if (e.hasOwnProperty(n) && "undefined" != typeof e[n] && "undefined" != typeof e[n].values) {
                var i = e[n];
                t[n] = new C({componentDatatype: i.componentDatatype, componentsPerAttribute: i.componentsPerAttribute, normalize: i.normalize, values: []})
            }
            return t
        }

        function A(e, t, n) {
            for (var i in t)if (t.hasOwnProperty(i) && "undefined" != typeof t[i] && "undefined" != typeof t[i].values)for (var r = t[i], o = 0; o < r.componentsPerAttribute; ++o)e[i].values.push(r.values[n * r.componentsPerAttribute + o])
        }

        function M(e, t) {
            if ("undefined" != typeof t)for (var n = t.values, i = n.length, o = 0; i > o; o += 3)r.fromArray(n, o, X), f.multiplyByPoint(e, X, X), n[o] = X.x, n[o + 1] = X.y, n[o + 2] = X.z
        }

        function D(e, t) {
            if ("undefined" != typeof t)for (var n = t.values, i = n.length, o = 0; i > o; o += 3)r.fromArray(n, o, X), d.multiplyByVector(e, X, X), n[o] = X.x, n[o + 1] = X.y, n[o + 2] = X.z
        }

        function I(e) {
            var t, n = e.length, i = {}, r = e[0].geometry.attributes;
            for (t in r)if (r.hasOwnProperty(t) && "undefined" != typeof r[t] && "undefined" != typeof r[t].values) {
                for (var o = r[t], a = o.values.length, s = !0, u = 1; n > u; ++u) {
                    var l = e[u].geometry.attributes[t];
                    if ("undefined" == typeof l || o.componentDatatype !== l.componentDatatype || o.componentsPerAttribute !== l.componentsPerAttribute || o.normalize !== l.normalize) {
                        s = !1;
                        break
                    }
                    a += l.values.length
                }
                s && (i[t] = new C({componentDatatype: o.componentDatatype, componentsPerAttribute: o.componentsPerAttribute, normalize: o.normalize, values: o.componentDatatype.createTypedArray(a)}))
            }
            return i
        }

        function P(e) {
            if ("undefined" != typeof e.indices)return e;
            var t = w.computeNumberOfVertices(e);
            if (3 > t)throw new n("The number of vertices must be at least three.");
            if (0 !== t % 3)throw new n("The number of vertices must be a multiple of three.");
            for (var i = y.createTypedArray(t, t), r = 0; t > r; ++r)i[r] = r;
            return e.indices = i, e
        }

        function O(e) {
            var t = w.computeNumberOfVertices(e);
            if (3 > t)throw new n("The number of vertices must be at least three.");
            var i = y.createTypedArray(t, 3 * (t - 2));
            i[0] = 1, i[1] = 0, i[2] = 2;
            for (var r = 3, o = 3; t > o; ++o)i[r++] = o - 1, i[r++] = 0, i[r++] = o;
            return e.indices = i, e.primitiveType = v.TRIANGLES, e
        }

        function R(e) {
            var t = w.computeNumberOfVertices(e);
            if (3 > t)throw new n("The number of vertices must be at least 3.");
            var i = y.createTypedArray(t, 3 * (t - 2));
            i[0] = 0, i[1] = 1, i[2] = 2, t > 3 && (i[3] = 0, i[4] = 2, i[5] = 3);
            for (var r = 6, o = 3; t - 1 > o; o += 2)i[r++] = o, i[r++] = o - 1, i[r++] = o + 1, t > o + 2 && (i[r++] = o, i[r++] = o + 1, i[r++] = o + 2);
            return e.indices = i, e.primitiveType = v.TRIANGLES, e
        }

        function z(e) {
            if ("undefined" != typeof e.indices)return e;
            var t = w.computeNumberOfVertices(e);
            if (2 > t)throw new n("The number of vertices must be at least two.");
            if (0 !== t % 2)throw new n("The number of vertices must be a multiple of 2.");
            for (var i = y.createTypedArray(t, t), r = 0; t > r; ++r)i[r] = r;
            return e.indices = i, e
        }

        function L(e) {
            var t = w.computeNumberOfVertices(e);
            if (2 > t)throw new n("The number of vertices must be at least two.");
            var i = y.createTypedArray(t, 2 * (t - 1));
            i[0] = 0, i[1] = 1;
            for (var r = 2, o = 2; t > o; ++o)i[r++] = o - 1, i[r++] = o;
            return e.indices = i, e.primitiveType = v.LINES, e
        }

        function N(e) {
            var t = w.computeNumberOfVertices(e);
            if (2 > t)throw new n("The number of vertices must be at least two.");
            var i = y.createTypedArray(t, 2 * t);
            i[0] = 0, i[1] = 1;
            for (var r = 2, o = 2; t > o; ++o)i[r++] = o - 1, i[r++] = o;
            return i[r++] = t - 1, i[r] = 0, e.indices = i, e.primitiveType = v.LINES, e
        }

        function F(e) {
            switch (e.primitiveType) {
                case v.TRIANGLE_FAN:
                    return O(e);
                case v.TRIANGLE_STRIP:
                    return R(e);
                case v.TRIANGLES:
                    return P(e);
                case v.LINE_STRIP:
                    return L(e);
                case v.LINE_LOOP:
                    return N(e);
                case v.LINES:
                    return z(e)
            }
            return e
        }

        function V(e, t) {
            Math.abs(e.y) < c.EPSILON11 && (e.y = t ? -c.EPSILON11 : c.EPSILON11)
        }

        function B(e, t, n, i) {
            e.add(t.subtract(e, rt).multiplyByScalar(e.y / (e.y - t.y), rt), n), r.clone(n, i), V(n, !0), V(i, !1)
        }

        function k(e, t, n) {
            if (e.x >= 0 || t.x >= 0 || n.x >= 0)return void 0;
            var i = e.y < 0, r = t.y < 0, o = n.y < 0;
            V(e, i), V(t, r), V(n, o);
            var a = 0;
            a += i ? 1 : 0, a += r ? 1 : 0, a += o ? 1 : 0;
            var s = lt.indices;
            1 === a ? (s[1] = 3, s[2] = 4, s[5] = 6, s[7] = 6, s[8] = 5, i ? (B(e, t, ot, st), B(e, n, at, ut), s[0] = 0, s[3] = 1, s[4] = 2, s[6] = 1) : r ? (B(t, e, ot, st), B(t, n, at, ut), s[0] = 1, s[3] = 2, s[4] = 0, s[6] = 2) : o && (B(n, e, ot, st), B(n, t, at, ut), s[0] = 2, s[3] = 0, s[4] = 1, s[6] = 0)) : 2 === a && (s[2] = 4, s[4] = 4, s[5] = 3, s[7] = 5, s[8] = 6, i ? r ? o || (B(n, e, ot, st), B(n, t, at, ut), s[0] = 0, s[1] = 1, s[3] = 0, s[6] = 2) : (B(t, n, ot, st), B(t, e, at, ut), s[0] = 2, s[1] = 0, s[3] = 2, s[6] = 1) : (B(e, t, ot, st), B(e, n, at, ut), s[0] = 1, s[1] = 2, s[3] = 1, s[6] = 0));
            var u = lt.positions;
            return u[0] = e, u[1] = t, u[2] = n, lt.length = 3, (1 === a || 2 === a) && (u[3] = ot, u[4] = at, u[5] = st, u[6] = ut, lt.length = 7), lt
        }

        function U(t, n, o, a, s, u, l, c) {
            if ("undefined" != typeof s || "undefined" != typeof u || "undefined" != typeof l || "undefined" != typeof c) {
                var d, f, h, p, m, y, v, g, _, w, C, x, S, b, T, E, A, M, D = a.positions, I = D[0], P = D[1], O = D[2];
                "undefined" != typeof s && (d = r.fromArray(s, 3 * t), f = r.fromArray(s, 3 * n), h = r.fromArray(s, 3 * o)), "undefined" != typeof u && (p = r.fromArray(u, 3 * t), m = r.fromArray(u, 3 * n), y = r.fromArray(u, 3 * o)), "undefined" != typeof l && (v = r.fromArray(l, 3 * t), g = r.fromArray(l, 3 * n), _ = r.fromArray(l, 3 * o)), "undefined" != typeof c && (w = i.fromArray(c, 2 * t), C = i.fromArray(c, 2 * n), x = i.fromArray(c, 2 * o));
                for (var R = 3; R < D.length; ++R) {
                    var z = D[R], L = e(z, I, P, O);
                    if ("undefined" != typeof s) {
                        S = r.multiplyByScalar(d, L.x, S), b = r.multiplyByScalar(f, L.y, b), T = r.multiplyByScalar(h, L.z, T);
                        var N = r.add(S, b);
                        r.add(N, T, N), r.normalize(N, N), s.push(N.x, N.y, N.z)
                    }
                    if ("undefined" != typeof u) {
                        S = r.multiplyByScalar(p, L.x, S), b = r.multiplyByScalar(m, L.y, b), T = r.multiplyByScalar(y, L.z, T);
                        var F = r.add(S, b);
                        r.add(F, T, F), r.normalize(F, F), u.push(F.x, F.y, F.z)
                    }
                    if ("undefined" != typeof l) {
                        S = r.multiplyByScalar(v, L.x, S), b = r.multiplyByScalar(g, L.y, b), T = r.multiplyByScalar(_, L.z, T);
                        var V = r.add(S, b);
                        r.add(V, T, V), r.normalize(V, V), l.push(V.x, V.y, V.z)
                    }
                    if ("undefined" != typeof c) {
                        E = i.multiplyByScalar(w, L.x, E), A = i.multiplyByScalar(C, L.y, A), M = i.multiplyByScalar(x, L.z, M);
                        var B = i.add(E, A);
                        i.add(B, M, B), c.push(B.x, B.y)
                    }
                }
            }
        }

        function q(e) {
            for (var t = e.attributes, n = t.position.values, i = "undefined" != typeof t.normal ? t.normal.values : void 0, o = "undefined" != typeof t.binormal ? t.binormal.values : void 0, a = "undefined" != typeof t.tangent ? t.tangent.values : void 0, s = "undefined" != typeof t.st ? t.st.values : void 0, u = e.indices, l = Array.prototype.slice.call(n, 0), c = "undefined" != typeof i ? Array.prototype.slice.call(i, 0) : void 0, d = "undefined" != typeof o ? Array.prototype.slice.call(o, 0) : void 0, f = "undefined" != typeof a ? Array.prototype.slice.call(a, 0) : void 0, h = "undefined" != typeof s ? Array.prototype.slice.call(s, 0) : void 0, p = [], m = u.length, v = 0; m > v; v += 3) {
                var g = u[v], _ = u[v + 1], C = u[v + 2], x = r.fromArray(n, 3 * g), S = r.fromArray(n, 3 * _), b = r.fromArray(n, 3 * C), T = k(x, S, b);
                if ("undefined" != typeof T)if (l[3 * g + 1] = T.positions[0].y, l[3 * _ + 1] = T.positions[1].y, l[3 * C + 1] = T.positions[2].y, T.length > 3) {
                    for (var E = l.length / 3, A = 0; A < T.indices.length; ++A) {
                        var M = T.indices[A];
                        3 > M ? p.push(u[v + M]) : p.push(M - 3 + E)
                    }
                    for (var D = 3; D < T.positions.length; ++D) {
                        var I = T.positions[D];
                        l.push(I.x, I.y, I.z)
                    }
                    U(g, _, C, T, c, d, f, h)
                } else p.push(g, _, C); else p.push(g, _, C)
            }
            e.attributes.position.values = new Float64Array(l), "undefined" != typeof c && (t.normal.values = t.normal.componentDatatype.createTypedArray(c)), "undefined" != typeof d && (t.binormal.values = t.binormal.componentDatatype.createTypedArray(d)), "undefined" != typeof f && (t.tangent.values = t.tangent.componentDatatype.createTypedArray(f)), "undefined" != typeof h && (t.st.values = t.st.componentDatatype.createTypedArray(h));
            var P = w.computeNumberOfVertices(e);
            e.indices = y.createTypedArray(P, p)
        }

        function W(e) {
            for (var t = e.attributes, n = t.position.values, i = e.indices, o = Array.prototype.slice.call(n, 0), a = [], s = h.fromPointNormal(r.ZERO, r.UNIT_Y), u = i.length, d = 0; u > d; d += 2) {
                var f = i[d], p = i[d + 1], m = r.fromArray(n, 3 * f), v = r.fromArray(n, 3 * p);
                if (Math.abs(m.y) < c.EPSILON6 && (m.y = m.y < 0 ? -c.EPSILON6 : c.EPSILON6, o[3 * f + 1] = m.y), Math.abs(v.y) < c.EPSILON6 && (v.y = v.y < 0 ? -c.EPSILON6 : c.EPSILON6, o[3 * p + 1] = v.y), a.push(f), m.x < 0 || v.x < 0) {
                    var g = l.lineSegmentPlane(m, v, s);
                    if ("undefined" != typeof g) {
                        var _ = r.multiplyByScalar(r.UNIT_Y, 5 * c.EPSILON9);
                        m.y < 0 && r.negate(_, _);
                        var C = o.length / 3;
                        a.push(C, C + 1);
                        var x = r.add(g, _);
                        o.push(x.x, x.y, x.z), r.negate(_, _), r.add(g, _, x), o.push(x.x, x.y, x.z)
                    }
                }
                a.push(p)
            }
            e.attributes.position.values = new Float64Array(o);
            var S = w.computeNumberOfVertices(e);
            e.indices = y.createTypedArray(S, a)
        }

        var H = {};
        H.toWireframe = function (e) {
            if ("undefined" == typeof e)throw new n("geometry is required.");
            var t = e.indices;
            if ("undefined" != typeof t) {
                switch (e.primitiveType) {
                    case v.TRIANGLES:
                        e.indices = S(t);
                        break;
                    case v.TRIANGLE_STRIP:
                        e.indices = b(t);
                        break;
                    case v.TRIANGLE_FAN:
                        e.indices = T(t);
                        break;
                    default:
                        throw new n("geometry.primitiveType must be TRIANGLES, TRIANGLE_STRIP, or TRIANGLE_FAN.")
                }
                e.primitiveType = v.LINES
            }
            return e
        }, H.createLineSegmentsForVectors = function (e, i, r) {
            if ("undefined" == typeof e)throw new n("geometry is required.");
            if ("undefined" == typeof e.attributes.position)throw new n("geometry.attributes.position is required.");
            if (i = t(i, "normal"), "undefined" == typeof e.attributes[i])throw new n("geometry.attributes must have an attribute with the same name as the attributeName parameter, " + i + ".");
            r = t(r, 1e4);
            for (var o = e.attributes.position.values, a = e.attributes[i].values, s = o.length, u = new Float64Array(2 * s), l = 0, c = 0; s > c; c += 3)u[l++] = o[c], u[l++] = o[c + 1], u[l++] = o[c + 2], u[l++] = o[c] + a[c] * r, u[l++] = o[c + 1] + a[c + 1] * r, u[l++] = o[c + 2] + a[c + 2] * r;
            var d, f = e.boundingSphere;
            return"undefined" != typeof f && (d = new _(f.center, f.radius + r)), new w({attributes: {position: new C({componentDatatype: m.DOUBLE, componentsPerAttribute: 3, values: u})}, primitiveType: v.LINES, boundingSphere: d})
        }, H.createAttributeIndices = function (e) {
            if ("undefined" == typeof e)throw new n("geometry is required.");
            var t, i = ["position", "positionHigh", "positionLow", "position3DHigh", "position3DLow", "position2DHigh", "position2DLow", "pickColor", "normal", "st", "binormal", "tangent"], r = e.attributes, o = {}, a = 0, s = i.length;
            for (t = 0; s > t; ++t) {
                var u = i[t];
                "undefined" != typeof r[u] && (o[u] = a++)
            }
            for (var l in r)r.hasOwnProperty(l) && "undefined" == typeof o[l] && (o[l] = a++);
            return o
        }, H.reorderForPreVertexCache = function (e) {
            if ("undefined" == typeof e)throw new n("geometry is required.");
            var t = w.computeNumberOfVertices(e), i = e.indices;
            if ("undefined" != typeof i) {
                for (var r = new Int32Array(t), o = 0; t > o; o++)r[o] = -1;
                for (var a, s = i, u = s.length, l = y.createTypedArray(t, u), c = 0, d = 0, f = 0; u > c;)a = r[s[c]], -1 !== a ? l[d] = a : (a = s[c], r[a] = f, l[d] = f, ++f), ++c, ++d;
                e.indices = l;
                var h = e.attributes;
                for (var p in h)if (h.hasOwnProperty(p) && "undefined" != typeof h[p] && "undefined" != typeof h[p].values) {
                    for (var m = h[p], v = m.values, g = 0, _ = m.componentsPerAttribute, C = m.componentDatatype.createTypedArray(v.length); t > g;) {
                        var x = r[g];
                        for (o = 0; _ > o; o++)C[_ * x + o] = v[_ * g + o];
                        ++g
                    }
                    m.values = C
                }
            }
            return e
        }, H.reorderForPostVertexCache = function (e, t) {
            if ("undefined" == typeof e)throw new n("geometry is required.");
            var i = e.indices;
            if (e.primitiveType === v.TRIANGLES && "undefined" != typeof i) {
                for (var r = i.length, o = 0, a = 0; r > a; a++)i[a] > o && (o = i[a]);
                e.indices = g.tipsify({indices: i, maximumIndex: o, cacheSize: t})
            }
            return e
        }, H.fitToUnsignedShortIndices = function (e) {
            if ("undefined" == typeof e)throw new n("geometry is required.");
            if ("undefined" != typeof e.indices && e.primitiveType !== v.TRIANGLES && e.primitiveType !== v.LINES && e.primitiveType !== v.POINTS)throw new n("geometry.primitiveType must equal to PrimitiveType.TRIANGLES, PrimitiveType.LINES, or PrimitiveType.POINTS.");
            var t = [], i = w.computeNumberOfVertices(e);
            if ("undefined" != typeof e.indices && i > c.SIXTY_FOUR_KILOBYTES) {
                var r, o = [], a = [], s = 0, u = E(e.attributes), l = e.indices, d = l.length;
                e.primitiveType === v.TRIANGLES ? r = 3 : e.primitiveType === v.LINES ? r = 2 : e.primitiveType === v.POINTS && (r = 1);
                for (var f = 0; d > f; f += r) {
                    for (var h = 0; r > h; ++h) {
                        var p = l[f + h], m = o[p];
                        "undefined" == typeof m && (m = s++, o[p] = m, A(u, e.attributes, p)), a.push(m)
                    }
                    s + r > c.SIXTY_FOUR_KILOBYTES && (t.push(new w({attributes: u, indices: a, primitiveType: e.primitiveType, boundingSphere: e.boundingSphere})), o = [], a = [], s = 0, u = E(e.attributes))
                }
                0 !== a.length && t.push(new w({attributes: u, indices: a, primitiveType: e.primitiveType, boundingSphere: e.boundingSphere}))
            } else t.push(e);
            return t
        };
        var G = new r, j = new a;
        H.projectTo2D = function (e, t) {
            if ("undefined" == typeof e)throw new n("geometry is required.");
            if ("undefined" != typeof e.attributes.position) {
                t = "undefined" != typeof t ? t : new p;
                for (var i = t.getEllipsoid(), o = e.attributes.position.values, a = new Float64Array(o.length), s = 0, u = 0; u < o.length; u += 3) {
                    var l = r.fromArray(o, u, G), c = i.cartesianToCartographic(l, j), d = t.project(c, G);
                    a[s++] = d.x, a[s++] = d.y, a[s++] = d.z
                }
                e.attributes.position3D = e.attributes.position, e.attributes.position2D = new C({componentDatatype: m.DOUBLE, componentsPerAttribute: 3, values: a}), delete e.attributes.position
            }
            return e
        };
        var Y = {high: 0, low: 0};
        H.encodeAttribute = function (e, t, i, r) {
            if ("undefined" == typeof e)throw new n("geometry is required.");
            if ("undefined" == typeof t)throw new n("attributeName is required.");
            if ("undefined" == typeof i)throw new n("attributeHighName is required.");
            if ("undefined" == typeof r)throw new n("attributeLowName is required.");
            var o = e.attributes[t];
            if ("undefined" == typeof o)throw new n("geometry must have attribute matching the attributeName argument: " + t + ".");
            if (o.componentDatatype !== m.DOUBLE)throw new n("The attribute componentDatatype must be ComponentDatatype.DOUBLE.");
            for (var a = o.values, u = a.length, l = new Float32Array(u), c = new Float32Array(u), d = 0; u > d; ++d)s.encode(a[d], Y), l[d] = Y.high, c[d] = Y.low;
            var f = o.componentsPerAttribute;
            return e.attributes[i] = new C({componentDatatype: m.FLOAT, componentsPerAttribute: f, values: l}), e.attributes[r] = new C({componentDatatype: m.FLOAT, componentsPerAttribute: f, values: c}), delete e.attributes[t], e
        };
        var X = new r, Z = new f, K = new d;
        H.transformToWorldCoordinates = function (e) {
            if ("undefined" == typeof e)throw new n("instance is required.");
            var t = e.modelMatrix;
            if (t.equals(f.IDENTITY))return e;
            var i = e.geometry.attributes;
            M(t, i.position), ("undefined" != typeof i.normal || "undefined" != typeof i.binormal || "undefined" != typeof i.tangent) && (f.inverse(t, Z), f.transpose(Z, Z), f.getRotation(Z, K), D(K, i.normal), D(K, i.binormal), D(K, i.tangent));
            var o = e.geometry.boundingSphere;
            return"undefined" != typeof o && (f.multiplyByPoint(t, o.center, o.center), o.center = r.fromCartesian4(o.center)), e.modelMatrix = f.IDENTITY.clone(), e
        }, H.combine = function (e) {
            if ("undefined" == typeof e || e.length < 1)throw new n("instances is required and must have length greater than zero.");
            var t, i, r, o, a = e.length, s = e[0].modelMatrix, u = "undefined" != typeof e[0].geometry.indices, l = e[0].geometry.primitiveType;
            for (i = 1; a > i; ++i) {
                if (!f.equals(e[i].modelMatrix, s))throw new n("All instances must have the same modelMatrix.");
                if ("undefined" != typeof e[i].geometry.indices !== u)throw new n("All instance geometries must have an indices or not have one.");
                if (e[i].geometry.primitiveType !== l)throw new n("All instance geometries must have the same primitiveType.")
            }
            var c, d, h, p = I(e);
            for (t in p)if (p.hasOwnProperty(t))for (c = p[t].values, o = 0, i = 0; a > i; ++i)for (d = e[i].geometry.attributes[t].values, h = d.length, r = 0; h > r; ++r)c[o++] = d[r];
            var m;
            if (u) {
                var g = 0;
                for (i = 0; a > i; ++i)g += e[i].geometry.indices.length;
                var C = w.computeNumberOfVertices(new w({attributes: p, primitiveType: v.POINTS})), x = y.createTypedArray(C, g), S = 0, b = 0;
                for (i = 0; a > i; ++i) {
                    var T = e[i].geometry.indices, E = T.length;
                    for (o = 0; E > o; ++o)x[S++] = b + T[o];
                    b += w.computeNumberOfVertices(e[i].geometry)
                }
                m = x
            }
            var A;
            for (i = 0; a > i; ++i) {
                var M = e[i].geometry.boundingSphere;
                if ("undefined" == typeof M) {
                    A = void 0;
                    break
                }
                "undefined" == typeof A ? A = M.clone() : _.union(A, M, A)
            }
            return new w({attributes: p, indices: m, primitiveType: l, boundingSphere: A})
        };
        var J = new r, Q = new r, $ = new r, et = new r;
        H.computeNormal = function (e) {
            if ("undefined" == typeof e)throw new n("geometry is required.");
            var t = e.attributes, i = e.indices;
            if ("undefined" == typeof t.position || "undefined" == typeof t.position.values)throw new n("geometry.attributes.position.values is required.");
            if ("undefined" == typeof i)throw new n("geometry.indices is required.");
            if (i.length < 2 || 0 !== i.length % 3)throw new n("geometry.indices length must be greater than 0 and be a multiple of 3.");
            if (e.primitiveType !== v.TRIANGLES)throw new n("geometry.primitiveType must be PrimitiveType.TRIANGLES.");
            for (var o = e.attributes.position.values, a = e.attributes.position.values.length / 3, s = i.length, u = new Array(a), l = new Array(s / 3), c = new Array(s), d = 0; a > d; d++)u[d] = {indexOffset: 0, count: 0, currentCount: 0};
            var f = 0;
            for (d = 0; s > d; d += 3) {
                var h = i[d], p = i[d + 1], y = i[d + 2], g = 3 * h, _ = 3 * p, w = 3 * y;
                Q.x = o[g], Q.y = o[g + 1], Q.z = o[g + 2], $.x = o[_], $.y = o[_ + 1], $.z = o[_ + 2], et.x = o[w], et.y = o[w + 1], et.z = o[w + 2], u[h].count++, u[p].count++, u[y].count++, $.subtract(Q, $), et.subtract(Q, et), l[f] = $.cross(et), f++
            }
            var x = 0;
            for (d = 0; a > d; d++)u[d].indexOffset += x, x += u[d].count;
            f = 0;
            var S;
            for (d = 0; s > d; d += 3) {
                S = u[i[d]];
                var b = S.indexOffset + S.currentCount;
                c[b] = f, S.currentCount++, S = u[i[d + 1]], b = S.indexOffset + S.currentCount, c[b] = f, S.currentCount++, S = u[i[d + 2]], b = S.indexOffset + S.currentCount, c[b] = f, S.currentCount++, f++
            }
            var T = new Float32Array(3 * a);
            for (d = 0; a > d; d++) {
                var E = 3 * d;
                if (S = u[d], S.count > 0) {
                    for (r.ZERO.clone(J), f = 0; f < S.count; f++)J.add(l[c[S.indexOffset + f]], J);
                    J.normalize(J), T[E] = J.x, T[E + 1] = J.y, T[E + 2] = J.z
                } else T[E] = 0, T[E + 1] = 0, T[E + 2] = 1
            }
            return e.attributes.normal = new C({componentDatatype: m.FLOAT, componentsPerAttribute: 3, values: T}), e
        };
        var tt = new r, nt = new r, it = new r;
        H.computeBinormalAndTangent = function (e) {
            if ("undefined" == typeof e)throw new n("geometry is required.");
            var t = e.attributes, i = e.indices;
            if ("undefined" == typeof t.position || "undefined" == typeof t.position.values)throw new n("geometry.attributes.position.values is required.");
            if ("undefined" == typeof t.normal || "undefined" == typeof t.normal.values)throw new n("geometry.attributes.normal.values is required.");
            if ("undefined" == typeof t.st || "undefined" == typeof t.st.values)throw new n("geometry.attributes.st.values is required.");
            if ("undefined" == typeof i)throw new n("geometry.indices is required.");
            if (i.length < 2 || 0 !== i.length % 3)throw new n("geometry.indices length must be greater than 0 and be a multiple of 3.");
            if (e.primitiveType !== v.TRIANGLES)throw new n("geometry.primitiveType must be PrimitiveType.TRIANGLES.");
            for (var o = e.attributes.position.values, a = e.attributes.normal.values, s = e.attributes.st.values, u = e.attributes.position.values.length / 3, l = i.length, c = new Array(3 * u), d = 0; d < c.length; d++)c[d] = 0;
            var f, h, p;
            for (d = 0; l > d; d += 3) {
                var y = i[d], g = i[d + 1], _ = i[d + 2];
                f = 3 * y, h = 3 * g, p = 3 * _;
                var w = 2 * y, x = 2 * g, S = 2 * _, b = o[f], T = o[f + 1], E = o[f + 2], A = s[w], M = s[w + 1], D = s[x + 1] - M, I = s[S + 1] - M, P = 1 / ((s[x] - A) * I - (s[S] - A) * D), O = (I * (o[h] - b) - D * (o[p] - b)) * P, R = (I * (o[h + 1] - T) - D * (o[p + 1] - T)) * P, z = (I * (o[h + 2] - E) - D * (o[p + 2] - E)) * P;
                c[f] += O, c[f + 1] += R, c[f + 2] += z, c[h] += O, c[h + 1] += R, c[h + 2] += z, c[p] += O, c[p + 1] += R, c[p + 2] += z
            }
            var L = new Float32Array(3 * u), N = new Float32Array(3 * u);
            for (d = 0; u > d; d++) {
                f = 3 * d, h = f + 1, p = f + 2;
                var F = r.fromArray(a, f, tt), V = r.fromArray(c, f, it), B = F.dot(V);
                F.multiplyByScalar(B, nt), V.subtract(nt, V).normalize(V), N[f] = V.x, N[h] = V.y, N[p] = V.z, F.cross(V, V).normalize(V), L[f] = V.x, L[h] = V.y, L[p] = V.z
            }
            return e.attributes.tangent = new C({componentDatatype: m.FLOAT, componentsPerAttribute: 3, values: N}), e.attributes.binormal = new C({componentDatatype: m.FLOAT, componentsPerAttribute: 3, values: L}), e
        };
        var rt = new r, ot = new r, at = new r, st = new r, ut = new r, lt = {positions: new Array(7), indices: new Array(9)};
        return H.wrapLongitude = function (e) {
            if ("undefined" == typeof e)throw new n("geometry is required.");
            var t = e.boundingSphere;
            if ("undefined" != typeof t) {
                var i = t.center.x - t.radius;
                if (i > 0 || _.intersect(t, o.UNIT_Y) !== u.INTERSECTING)return e
            }
            return F(e), e.primitiveType === v.TRIANGLES ? q(e) : e.primitiveType === v.LINES && W(e), e
        }, H
    }), n("Core/GeometryInstanceAttribute", ["./defaultValue", "./DeveloperError"], function (e, t) {
        "use strict";
        var n = function (n) {
            if (n = e(n, e.EMPTY_OBJECT), "undefined" == typeof n.componentDatatype)throw new t("options.componentDatatype is required.");
            if ("undefined" == typeof n.componentsPerAttribute)throw new t("options.componentsPerAttribute is required.");
            if (n.componentsPerAttribute < 1 || n.componentsPerAttribute > 4)throw new t("options.componentsPerAttribute must be between 1 and 4.");
            if ("undefined" == typeof n.value)throw new t("options.value is required.");
            this.componentDatatype = n.componentDatatype, this.componentsPerAttribute = n.componentsPerAttribute, this.normalize = e(n.normalize, !1), this.value = n.value
        };
        return n
    }), n("Core/GeometryInstance", ["./defaultValue", "./DeveloperError", "./Matrix4", "./Geometry", "./GeometryInstanceAttribute"], function (e, t, n) {
        "use strict";
        var i = function (i) {
            if (i = e(i, e.EMPTY_OBJECT), "undefined" == typeof i.geometry)throw new t("options.geometry is required.");
            this.geometry = i.geometry, this.modelMatrix = n.clone(e(i.modelMatrix, n.IDENTITY)), this.id = i.id, this.attributes = e(i.attributes, {})
        };
        return i
    }), n("Core/Matrix2", ["./Cartesian2", "./defaultValue", "./DeveloperError", "./freezeObject"], function (e, t, n, i) {
        "use strict";
        var r = function (e, n, i, r) {
            this[0] = t(e, 0), this[1] = t(i, 0), this[2] = t(n, 0), this[3] = t(r, 0)
        };
        return r.clone = function (e, t) {
            return"undefined" == typeof e ? void 0 : "undefined" == typeof t ? new r(e[0], e[2], e[1], e[3]) : (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t)
        }, r.fromColumnMajorArray = function (e, t) {
            if ("undefined" == typeof e)throw new n("values parameter is required");
            return r.clone(e, t)
        }, r.fromRowMajorArray = function (e, t) {
            if ("undefined" == typeof e)throw new n("values is required.");
            return"undefined" == typeof t ? new r(e[0], e[1], e[2], e[3]) : (t[0] = e[0], t[1] = e[2], t[2] = e[1], t[3] = e[3], t)
        }, r.fromScale = function (e, t) {
            if ("undefined" == typeof e)throw new n("scale is required.");
            return"undefined" == typeof t ? new r(e.x, 0, 0, e.y) : (t[0] = e.x, t[1] = 0, t[2] = 0, t[3] = e.y, t)
        }, r.fromUniformScale = function (e, t) {
            if ("number" != typeof e)throw new n("scale is required.");
            return"undefined" == typeof t ? new r(e, 0, 0, e) : (t[0] = e, t[1] = 0, t[2] = 0, t[3] = e, t)
        }, r.fromRotation = function (e, t) {
            if ("undefined" == typeof e)throw new n("angle is required.");
            var i = Math.cos(e), o = Math.sin(e);
            return"undefined" == typeof t ? new r(i, -o, o, i) : (t[0] = i, t[1] = o, t[2] = -o, t[3] = i, t)
        }, r.toArray = function (e, t) {
            if ("undefined" == typeof e)throw new n("matrix is required");
            return"undefined" == typeof t ? [e[0], e[1], e[2], e[3]] : (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t)
        }, r.getElementIndex = function (e, t) {
            if ("number" != typeof t || 0 > t || t > 1)throw new n("row is required and must be 0 or 1.");
            if ("number" != typeof e || 0 > e || e > 1)throw new n("column is required and must be 0 or 1.");
            return 2 * e + t
        }, r.getColumn = function (t, i, r) {
            if ("undefined" == typeof t)throw new n("matrix is required.");
            if ("number" != typeof i || 0 > i || i > 1)throw new n("index is required and must be 0 or 1.");
            var o = 2 * i, a = t[o], s = t[o + 1];
            return"undefined" == typeof r ? new e(a, s) : (r.x = a, r.y = s, r)
        }, r.setColumn = function (e, t, i, o) {
            if ("undefined" == typeof e)throw new n("matrix is required");
            if ("undefined" == typeof i)throw new n("cartesian is required");
            if ("number" != typeof t || 0 > t || t > 1)throw new n("index is required and must be 0 or 1.");
            o = r.clone(e, o);
            var a = 2 * t;
            return o[a] = i.x, o[a + 1] = i.y, o
        }, r.getRow = function (t, i, r) {
            if ("undefined" == typeof t)throw new n("matrix is required.");
            if ("number" != typeof i || 0 > i || i > 1)throw new n("index is required and must be 0 or 1.");
            var o = t[i], a = t[i + 2];
            return"undefined" == typeof r ? new e(o, a) : (r.x = o, r.y = a, r)
        }, r.setRow = function (e, t, i, o) {
            if ("undefined" == typeof e)throw new n("matrix is required");
            if ("undefined" == typeof i)throw new n("cartesian is required");
            if ("number" != typeof t || 0 > t || t > 1)throw new n("index is required and must be 0 or 1.");
            return o = r.clone(e, o), o[t] = i.x, o[t + 2] = i.y, o
        }, r.multiply = function (e, t, i) {
            if ("undefined" == typeof e)throw new n("left is required");
            if ("undefined" == typeof t)throw new n("right is required");
            var o = e[0] * t[0] + e[2] * t[1], a = e[0] * t[2] + e[2] * t[3], s = e[1] * t[0] + e[3] * t[1], u = e[1] * t[2] + e[3] * t[3];
            return"undefined" == typeof i ? new r(o, a, s, u) : (i[0] = o, i[1] = s, i[2] = a, i[3] = u, i)
        }, r.multiplyByVector = function (t, i, r) {
            if ("undefined" == typeof t)throw new n("matrix is required");
            if ("undefined" == typeof i)throw new n("cartesian is required");
            var o = t[0] * i.x + t[2] * i.y, a = t[1] * i.x + t[3] * i.y;
            return"undefined" == typeof r ? new e(o, a) : (r.x = o, r.y = a, r)
        }, r.multiplyByScalar = function (e, t, i) {
            if ("undefined" == typeof e)throw new n("matrix is required");
            if ("number" != typeof t)throw new n("scalar is required and must be a number");
            return"undefined" == typeof i ? new r(e[0] * t, e[2] * t, e[1] * t, e[3] * t) : (i[0] = e[0] * t, i[1] = e[1] * t, i[2] = e[2] * t, i[3] = e[3] * t, i)
        }, r.negate = function (e, t) {
            if ("undefined" == typeof e)throw new n("matrix is required");
            return"undefined" == typeof t ? new r(-e[0], -e[2], -e[1], -e[3]) : (t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = -e[3], t)
        }, r.transpose = function (e, t) {
            if ("undefined" == typeof e)throw new n("matrix is required");
            var i = e[0], o = e[2], a = e[1], s = e[3];
            return"undefined" == typeof t ? new r(i, a, o, s) : (t[0] = i, t[1] = o, t[2] = a, t[3] = s, t)
        }, r.equals = function (e, t) {
            return e === t || "undefined" != typeof e && "undefined" != typeof t && e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3]
        }, r.equalsEpsilon = function (e, t, i) {
            if ("number" != typeof i)throw new n("epsilon is required and must be a number");
            return e === t || "undefined" != typeof e && "undefined" != typeof t && Math.abs(e[0] - t[0]) <= i && Math.abs(e[1] - t[1]) <= i && Math.abs(e[2] - t[2]) <= i && Math.abs(e[3] - t[3]) <= i
        }, r.IDENTITY = i(new r(1, 0, 0, 1)), r.COLUMN0ROW0 = 0, r.COLUMN0ROW1 = 1, r.COLUMN1ROW0 = 2, r.COLUMN1ROW1 = 3, r.prototype.clone = function (e) {
            return r.clone(this, e)
        }, r.prototype.toArray = function (e) {
            return r.toArray(this, e)
        }, r.prototype.getColumn = function (e, t) {
            return r.getColumn(this, e, t)
        }, r.prototype.setColumn = function (e, t, n) {
            return r.setColumn(this, e, t, n)
        }, r.prototype.getRow = function (e, t) {
            return r.getRow(this, e, t)
        }, r.prototype.setRow = function (e, t, n) {
            return r.setRow(this, e, t, n)
        }, r.prototype.multiply = function (e, t) {
            return r.multiply(this, e, t)
        }, r.prototype.multiplyByVector = function (e, t) {
            return r.multiplyByVector(this, e, t)
        }, r.prototype.multiplyByScalar = function (e, t) {
            return r.multiplyByScalar(this, e, t)
        }, r.prototype.negate = function (e) {
            return r.negate(this, e)
        }, r.prototype.transpose = function (e) {
            return r.transpose(this, e)
        }, r.prototype.equals = function (e) {
            return r.equals(this, e)
        }, r.prototype.equalsEpsilon = function (e, t) {
            return r.equalsEpsilon(this, e, t)
        }, r.prototype.toString = function () {
            return"(" + this[0] + ", " + this[2] + ")\n" + "(" + this[1] + ", " + this[3] + ")"
        }, r
    }), n("Core/Quaternion", ["./Cartesian3", "./defaultValue", "./DeveloperError", "./freezeObject", "./Math", "./Matrix3"], function (e, t, n, i, r, o) {
        "use strict";
        var a, s = function (e, n, i, r) {
            this.x = t(e, 0), this.y = t(n, 0), this.z = t(i, 0), this.w = t(r, 0)
        };
        s.fromAxisAngle = function (t, i, r) {
            if ("undefined" == typeof t)throw new n("axis is required.");
            if ("number" != typeof i)throw new n("angle is required and must be a number.");
            var o = i / 2, u = Math.sin(o);
            a = e.normalize(t, a);
            var l = a.x * u, c = a.y * u, d = a.z * u, f = Math.cos(o);
            return"undefined" == typeof r ? new s(l, c, d, f) : (r.x = l, r.y = c, r.z = d, r.w = f, r)
        };
        var u = [1, 2, 0], l = new Array(3);
        s.fromRotationMatrix = function (e, t) {
            if ("undefined" == typeof e)throw new n("matrix is required.");
            var i, r, a, c, d, f = e[o.COLUMN0ROW0], h = e[o.COLUMN1ROW1], p = e[o.COLUMN2ROW2], m = f + h + p;
            if (m > 0)i = Math.sqrt(m + 1), d = .5 * i, i = .5 / i, r = (e[o.COLUMN2ROW1] - e[o.COLUMN1ROW2]) * i, a = (e[o.COLUMN0ROW2] - e[o.COLUMN2ROW0]) * i, c = (e[o.COLUMN1ROW0] - e[o.COLUMN0ROW1]) * i; else {
                var y = u, v = 0;
                h > f && (v = 1), p > f && p > h && (v = 2);
                var g = y[v], _ = y[g];
                i = Math.sqrt(e[o.getElementIndex(v, v)] - e[o.getElementIndex(g, g)] - e[o.getElementIndex(_, _)] + 1);
                var w = l;
                w[v] = .5 * i, i = .5 / i, d = (e[o.getElementIndex(_, g)] - e[o.getElementIndex(g, _)]) * i, w[g] = (e[o.getElementIndex(g, v)] + e[o.getElementIndex(v, g)]) * i, w[_] = (e[o.getElementIndex(_, v)] + e[o.getElementIndex(v, _)]) * i, r = w[0], a = w[1], c = w[2]
            }
            return"undefined" == typeof t ? new s(r, a, c, d) : (t.x = r, t.y = a, t.z = c, t.w = d, t)
        }, s.clone = function (e, t) {
            return"undefined" == typeof e ? void 0 : "undefined" == typeof t ? new s(e.x, e.y, e.z, e.w) : (t.x = e.x, t.y = e.y, t.z = e.z, t.w = e.w, t)
        }, s.conjugate = function (e, t) {
            if ("undefined" == typeof e)throw new n("quaternion is required");
            return"undefined" == typeof t ? new s(-e.x, -e.y, -e.z, e.w) : (t.x = -e.x, t.y = -e.y, t.z = -e.z, t.w = e.w, t)
        }, s.magnitudeSquared = function (e) {
            if ("undefined" == typeof e)throw new n("quaternion is required");
            return e.x * e.x + e.y * e.y + e.z * e.z + e.w * e.w
        }, s.magnitude = function (e) {
            if ("undefined" == typeof e)throw new n("quaternion is required");
            return Math.sqrt(s.magnitudeSquared(e))
        }, s.normalize = function (e, t) {
            var n = 1 / s.magnitude(e), i = e.x * n, r = e.y * n, o = e.z * n, a = e.w * n;
            return"undefined" == typeof t ? new s(i, r, o, a) : (t.x = i, t.y = r, t.z = o, t.w = a, t)
        }, s.inverse = function (e, t) {
            var n = s.magnitudeSquared(e);
            return t = s.conjugate(e, t), s.multiplyByScalar(t, 1 / n, t)
        }, s.add = function (e, t, i) {
            if ("undefined" == typeof e)throw new n("left is required");
            if ("undefined" == typeof t)throw new n("right is required");
            return"undefined" == typeof i ? new s(e.x + t.x, e.y + t.y, e.z + t.z, e.w + t.w) : (i.x = e.x + t.x, i.y = e.y + t.y, i.z = e.z + t.z, i.w = e.w + t.w, i)
        }, s.subtract = function (e, t, i) {
            if ("undefined" == typeof e)throw new n("left is required");
            if ("undefined" == typeof t)throw new n("right is required");
            return"undefined" == typeof i ? new s(e.x - t.x, e.y - t.y, e.z - t.z, e.w - t.w) : (i.x = e.x - t.x, i.y = e.y - t.y, i.z = e.z - t.z, i.w = e.w - t.w, i)
        }, s.negate = function (e, t) {
            if ("undefined" == typeof e)throw new n("quaternion is required");
            return"undefined" == typeof t ? new s(-e.x, -e.y, -e.z, -e.w) : (t.x = -e.x, t.y = -e.y, t.z = -e.z, t.w = -e.w, t)
        }, s.dot = function (e, t) {
            if ("undefined" == typeof e)throw new n("left is required");
            if ("undefined" == typeof t)throw new n("right is required");
            return e.x * t.x + e.y * t.y + e.z * t.z + e.w * t.w
        }, s.multiply = function (e, t, i) {
            if ("undefined" == typeof e)throw new n("left is required");
            if ("undefined" == typeof t)throw new n("right is required");
            var r = e.x, o = e.y, a = e.z, u = e.w, l = t.x, c = t.y, d = t.z, f = t.w, h = u * l + r * f + o * d - a * c, p = u * c - r * d + o * f + a * l, m = u * d + r * c - o * l + a * f, y = u * f - r * l - o * c - a * d;
            return"undefined" == typeof i ? new s(h, p, m, y) : (i.x = h, i.y = p, i.z = m, i.w = y, i)
        }, s.multiplyByScalar = function (e, t, i) {
            if ("undefined" == typeof e)throw new n("quaternion is required");
            if ("number" != typeof t)throw new n("scalar is required and must be a number.");
            return"undefined" == typeof i ? new s(e.x * t, e.y * t, e.z * t, e.w * t) : (i.x = e.x * t, i.y = e.y * t, i.z = e.z * t, i.w = e.w * t, i)
        }, s.divideByScalar = function (e, t, i) {
            if ("undefined" == typeof e)throw new n("quaternion is required");
            if ("number" != typeof t)throw new n("scalar is required and must be a number.");
            return"undefined" == typeof i ? new s(e.x / t, e.y / t, e.z / t, e.w / t) : (i.x = e.x / t, i.y = e.y / t, i.z = e.z / t, i.w = e.w / t, i)
        }, s.getAxis = function (t, i) {
            if ("undefined" == typeof t)throw new n("quaternion is required");
            var o = t.w;
            if (Math.abs(o - 1) < r.EPSILON6)return"undefined" == typeof i ? new e : (i.x = i.y = i.z = 0, i);
            var a = 1 / Math.sqrt(1 - o * o);
            return"undefined" == typeof i ? new e(t.x * a, t.y * a, t.z * a) : (i.x = t.x * a, i.y = t.y * a, i.z = t.z * a, i)
        }, s.getAngle = function (e) {
            if ("undefined" == typeof e)throw new n("quaternion is required");
            return Math.abs(e.w - 1) < r.EPSILON6 ? 0 : 2 * Math.acos(e.w)
        };
        var c;
        s.lerp = function (e, t, i, r) {
            if ("undefined" == typeof e)throw new n("start is required.");
            if ("undefined" == typeof t)throw new n("end is required.");
            if ("number" != typeof i)throw new n("t is required and must be a number.");
            return c = s.multiplyByScalar(t, i, c), r = s.multiplyByScalar(e, 1 - i, r), s.add(c, r, r)
        };
        var d, f, h;
        return s.slerp = function (e, t, i, o) {
            if ("undefined" == typeof e)throw new n("start is required.");
            if ("undefined" == typeof t)throw new n("end is required.");
            if ("number" != typeof i)throw new n("t is required and must be a number.");
            var a = s.dot(e, t), u = t;
            if (0 > a && (a = -a, u = d = s.negate(t, d)), 1 - a < r.EPSILON6)return s.lerp(e, u, i);
            var l = Math.acos(a);
            return f = s.multiplyByScalar(e, Math.sin((1 - i) * l), f), h = s.multiplyByScalar(u, Math.sin(i * l), h), o = s.add(f, h, o), s.multiplyByScalar(o, 1 / Math.sin(l), o)
        }, s.equals = function (e, t) {
            return e === t || "undefined" != typeof e && "undefined" != typeof t && e.x === t.x && e.y === t.y && e.z === t.z && e.w === t.w
        }, s.equalsEpsilon = function (e, t, i) {
            if ("number" != typeof i)throw new n("epsilon is required and must be a number.");
            return e === t || "undefined" != typeof e && "undefined" != typeof t && Math.abs(e.x - t.x) <= i && Math.abs(e.y - t.y) <= i && Math.abs(e.z - t.z) <= i && Math.abs(e.w - t.w) <= i
        }, s.ZERO = i(new s(0, 0, 0, 0)), s.IDENTITY = i(new s(0, 0, 0, 1)), s.prototype.clone = function (e) {
            return s.clone(this, e)
        }, s.prototype.conjugate = function (e) {
            return s.conjugate(this, e)
        }, s.prototype.magnitudeSquared = function () {
            return s.magnitudeSquared(this)
        }, s.prototype.magnitude = function () {
            return s.magnitude(this)
        }, s.prototype.normalize = function (e) {
            return s.normalize(this, e)
        }, s.prototype.inverse = function (e) {
            return s.inverse(this, e)
        }, s.prototype.add = function (e, t) {
            return s.add(this, e, t)
        }, s.prototype.subtract = function (e, t) {
            return s.subtract(this, e, t)
        }, s.prototype.negate = function (e) {
            return s.negate(this, e)
        }, s.prototype.dot = function (e) {
            return s.dot(this, e)
        }, s.prototype.multiply = function (e, t) {
            return s.multiply(this, e, t)
        }, s.prototype.multiplyByScalar = function (e, t) {
            return s.multiplyByScalar(this, e, t)
        }, s.prototype.divideByScalar = function (e, t) {
            return s.divideByScalar(this, e, t)
        }, s.prototype.getAxis = function (e) {
            return s.getAxis(this, e)
        }, s.prototype.getAngle = function () {
            return s.getAngle(this)
        }, s.prototype.lerp = function (e, t, n) {
            return s.lerp(this, e, t, n)
        }, s.prototype.slerp = function (e, t, n) {
            return s.slerp(this, e, t, n)
        }, s.prototype.equals = function (e) {
            return s.equals(this, e)
        }, s.prototype.equalsEpsilon = function (e, t) {
            return s.equalsEpsilon(this, e, t)
        }, s.prototype.toString = function () {
            return"(" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + ")"
        }, s
    }), n("Core/EllipseGeometry", ["./defaultValue", "./BoundingSphere", "./Cartesian2", "./Cartesian3", "./Cartographic", "./ComponentDatatype", "./IndexDatatype", "./DeveloperError", "./Ellipsoid", "./GeographicProjection", "./Geometry", "./GeometryPipeline", "./GeometryInstance", "./GeometryAttribute", "./GeometryAttributes", "./Math", "./Matrix2", "./Matrix3", "./PrimitiveType", "./Quaternion", "./VertexFormat"], function (e, t, n, i, r, o, a, s, u, l, c, d, f, h, p, m, y, v, g, _, w) {
        "use strict";
        function C(e, t, n, r, o, a, s, u, l, c) {
            var d = e + t;
            i.multiplyByScalar(r, Math.cos(d), D), i.multiplyByScalar(n, Math.sin(d), I), i.add(D, I, D);
            var f = Math.cos(e);
            f *= f;
            var h = Math.sin(e);
            h *= h;
            var p = a / Math.sqrt(s * f + o * h), m = p / u;
            return _.fromAxisAngle(D, m, P), v.fromQuaternion(P, O), v.multiplyByVector(O, l, c), i.normalize(c, c), i.multiplyByScalar(c, u, c), c
        }

        function x(e, t, n) {
            var r = t.vertexFormat, a = t.center, s = t.semiMajorAxis, u = t.ellipsoid, c = t.height, d = t.extrudedHeight, f = t.stRotation, m = n ? 2 * (e.length / 3) : e.length / 3, y = new Float64Array(3 * m), g = r.st ? new Float32Array(2 * m) : void 0, w = r.normal ? new Float32Array(3 * m) : void 0, C = r.tangent ? new Float32Array(3 * m) : void 0, x = r.binormal ? new Float32Array(3 * m) : void 0, S = 0, b = k, T = U, E = q, A = new l(u), M = A.project(u.cartesianToCartographic(a, j), Y), D = u.scaleToGeodeticSurface(a, R);
            u.geodeticSurfaceNormal(D, D);
            for (var I = _.fromAxisAngle(D, f, B), P = v.fromQuaternion(I, V), O = e.length, W = n ? O : 0, H = 2 * (W / 3), G = 0; O > G; G += 3) {
                var X, Z = G + 1, K = G + 2, J = i.fromArray(e, G, R);
                if (r.st) {
                    var Q = v.multiplyByVector(P, J, z), $ = A.project(u.cartesianToCartographic(Q, j), L);
                    $ = i.subtract($, M, $), F.x = ($.x + s) / (2 * s), F.y = ($.y + s) / (2 * s), n && (g[S + H] = F.x, g[S + 1 + H] = F.y), g[S++] = F.x, g[S++] = F.y
                }
                J = u.scaleToGeodeticSurface(J, J), X = J.clone(z), b = u.geodeticSurfaceNormal(J, b);
                var et = i.multiplyByScalar(b, c, N);
                J = i.add(J, et, J), n && (et = i.multiplyByScalar(b, d, et), X = i.add(X, et, X)), r.position && (n && (y[G + W] = X.x, y[Z + W] = X.y, y[K + W] = X.z), y[G] = J.x, y[Z] = J.y, y[K] = J.z), (r.normal || r.tangent || r.binormal) && ((r.tangent || r.binormal) && (T = i.cross(i.UNIT_Z, b, T), v.multiplyByVector(P, T, T)), r.normal && (w[G] = b.x, w[G + 1] = b.y, w[G + 2] = b.z, n && (w[G + W] = -b.x, w[Z + W] = -b.y, w[K + W] = -b.z)), r.tangent && (C[G] = T.x, C[G + 1] = T.y, C[G + 2] = T.z, n && (C[G + W] = -T.x, C[Z + W] = -T.y, C[K + W] = -T.z)), r.binormal && (E = i.cross(b, T, E), x[G] = E.x, x[Z] = E.y, x[K] = E.z, n && (x[G + W] = E.x, x[Z + W] = E.y, x[K + W] = E.z)))
            }
            var tt = new p;
            return r.position && (tt.position = new h({componentDatatype: o.DOUBLE, componentsPerAttribute: 3, values: y})), r.st && (tt.st = new h({componentDatatype: o.FLOAT, componentsPerAttribute: 2, values: g})), r.normal && (tt.normal = new h({componentDatatype: o.FLOAT, componentsPerAttribute: 3, values: w})), r.tangent && (tt.tangent = new h({componentDatatype: o.FLOAT, componentsPerAttribute: 3, values: C})), r.binormal && (tt.binormal = new h({componentDatatype: o.FLOAT, componentsPerAttribute: 3, values: x})), tt
        }

        function S(e, t) {
            var n = e.semiMinorAxis, r = e.semiMajorAxis, o = e.rotation, a = e.center, s = e.granularity, u = 2.31, l = n * n, c = r * r, d = r * n, f = a.magnitude(), h = i.normalize(a, W), p = i.cross(i.UNIT_Z, a, H);
            p = i.normalize(p, p);
            var y, v, g = i.cross(h, p, G), _ = 1 + Math.ceil(m.PI_OVER_TWO / s), w = u / (_ - 1), x = 2 * _ * (_ + 1), S = new Array(3 * x), b = 0, T = R, E = z;
            t && (y = [], v = []);
            var A, M, D, I, P, O = m.PI_OVER_TWO;
            for (A = 0; _ > A && O > 0; ++A) {
                for (T = C(O, o, g, p, l, d, c, f, h, T), E = C(Math.PI - O, o, g, p, l, d, c, f, h, E), S[b++] = T.x, S[b++] = T.y, S[b++] = T.z, D = 2 * A + 2, M = 1; D - 1 > M; ++M)I = M / (D - 1), P = i.lerp(T, E, I, L), S[b++] = P.x, S[b++] = P.y, S[b++] = P.z;
                S[b++] = E.x, S[b++] = E.y, S[b++] = E.z, t && (v.unshift(T.x, T.y, T.z), 0 !== A && y.push(E.x, E.y, E.z)), O = m.PI_OVER_TWO - (A + 1) * w
            }
            for (_ = A, A = _; A > 0; --A) {
                for (O = m.PI_OVER_TWO - (A - 1) * w, T = C(-O, o, g, p, l, d, c, f, h, T), E = C(O + Math.PI, o, g, p, l, d, c, f, h, E), S[b++] = T.x, S[b++] = T.y, S[b++] = T.z, D = 2 * (A - 1) + 2, M = 1; D - 1 > M; ++M)I = M / (D - 1), P = i.lerp(T, E, I, L), S[b++] = P.x, S[b++] = P.y, S[b++] = P.z;
                S[b++] = E.x, S[b++] = E.y, S[b++] = E.z, t && (v.unshift(T.x, T.y, T.z), 1 !== A && y.push(E.x, E.y, E.z))
            }
            S.length !== b && (x = b / 3, S.length = b);
            var N = {positions: S, numPts: _};
            return t && (N.outerPositions = v.concat(y)), N
        }

        function b(e) {
            var t, n, i, r, o, a = new Array(2 * e * (e + 1)), s = 0;
            for (r = 1; e > r; ++r) {
                for (i = r * (r + 1), t = (r - 1) * r, a[s++] = i++, a[s++] = t, a[s++] = i, n = 2 * r, o = 0; n - 1 > o; ++o)a[s++] = i, a[s++] = t++, a[s++] = t, a[s++] = i++, a[s++] = t, a[s++] = i;
                a[s++] = i++, a[s++] = t, a[s++] = i
            }
            for (n = 2 * e, ++i, ++t, r = 0; n - 1 > r; ++r)a[s++] = i, a[s++] = t++, a[s++] = t, a[s++] = i++, a[s++] = t, a[s++] = i;
            for (++t, ++i, r = e - 1; r > 0; --r) {
                for (a[s++] = t++, a[s++] = t, a[s++] = i, n = 2 * r, o = 0; n - 1 > o; ++o)a[s++] = i, a[s++] = t++, a[s++] = t, a[s++] = i++, a[s++] = t, a[s++] = i;
                a[s++] = t++, a[s++] = t++, a[s++] = i++
            }
            return a
        }

        function T(e) {
            var n = e.center;
            X = i.multiplyByScalar(e.ellipsoid.geodeticSurfaceNormal(n, X), e.height, X), X = i.add(n, X, X);
            var r = new t(X, e.semiMajorAxis), o = S(e), s = o.positions, u = o.numPts, l = x(s, e, !1), c = b(u);
            return c = a.createTypedArray(s.length / 3, c), {boundingSphere: r, attributes: l, indices: c}
        }

        function E(e, t) {
            var n = t.vertexFormat, r = t.center, a = t.semiMajorAxis, s = t.ellipsoid, u = t.height, c = t.extrudedHeight, d = t.stRotation, f = 2 * (e.length / 3), m = new Float64Array(3 * f), y = n.st ? new Float32Array(2 * f) : void 0, g = n.normal ? new Float32Array(3 * f) : void 0, w = n.tangent ? new Float32Array(3 * f) : void 0, C = n.binormal ? new Float32Array(3 * f) : void 0, x = 0, S = k, b = U, T = q, E = new l(s), A = E.project(s.cartesianToCartographic(r, j), Y), M = s.scaleToGeodeticSurface(r, R);
            s.geodeticSurfaceNormal(M, M);
            for (var D = _.fromAxisAngle(M, d, B), I = v.fromQuaternion(D, V), P = e.length, O = 2 * (P / 3), W = 0; P > W; W += 3) {
                var H, G = W + 1, X = W + 2, Z = i.fromArray(e, W, R);
                if (n.st) {
                    var K = v.multiplyByVector(I, Z, z), J = E.project(s.cartesianToCartographic(K, j), L);
                    J = i.subtract(J, A, J), F.x = (J.x + a) / (2 * a), F.y = (J.y + a) / (2 * a), y[x + O] = F.x, y[x + 1 + O] = F.y, y[x++] = F.x, y[x++] = F.y
                }
                Z = s.scaleToGeodeticSurface(Z, Z), H = Z.clone(z), S = s.geodeticSurfaceNormal(Z, S);
                var Q = i.multiplyByScalar(S, u, N);
                if (Z = i.add(Z, Q, Z), Q = i.multiplyByScalar(S, c, Q), H = i.add(H, Q, H), n.position && (m[W + P] = H.x, m[G + P] = H.y, m[X + P] = H.z, m[W] = Z.x, m[G] = Z.y, m[X] = Z.z), n.normal || n.tangent || n.binormal) {
                    T = S.clone(T);
                    var $ = i.fromArray(e, (W + 3) % P, N);
                    $ = $.subtract(Z, $);
                    var et = H.subtract(Z, L);
                    S = et.cross($, S).normalize(S), n.normal && (g[W] = S.x, g[G] = S.y, g[X] = S.z, g[W + P] = S.x, g[G + P] = S.y, g[X + P] = S.z), n.tangent && (b = i.cross(T, S, b).normalize(b), w[W] = b.x, w[G] = b.y, w[X] = b.z, w[W + P] = b.x, w[W + 1 + P] = b.y, w[W + 2 + P] = b.z), n.binormal && (C[W] = T.x, C[G] = T.y, C[X] = T.z, C[W + P] = T.x, C[G + P] = T.y, C[X + P] = T.z)
                }
            }
            var tt = new p;
            return n.position && (tt.position = new h({componentDatatype: o.DOUBLE, componentsPerAttribute: 3, values: m})), n.st && (tt.st = new h({componentDatatype: o.FLOAT, componentsPerAttribute: 2, values: y})), n.normal && (tt.normal = new h({componentDatatype: o.FLOAT, componentsPerAttribute: 3, values: g})), n.tangent && (tt.tangent = new h({componentDatatype: o.FLOAT, componentsPerAttribute: 3, values: w})), n.binormal && (tt.binormal = new h({componentDatatype: o.FLOAT, componentsPerAttribute: 3, values: C})), tt
        }

        function A(e) {
            for (var t, n, i, r, o = e.length / 3, s = a.createTypedArray(o, 6 * o), u = 0, l = 0; o - 1 > l; l++)t = l, i = l + o, n = t + 1, r = n + o, s[u++] = t, s[u++] = i, s[u++] = n, s[u++] = n, s[u++] = i, s[u++] = r;
            return t = o - 1, i = l + o, n = 0, r = n + o, s[u++] = t, s[u++] = i, s[u++] = n, s[u++] = n, s[u++] = i, s[u++] = r, s
        }

        function M(e) {
            var n = e.center, r = e.ellipsoid, o = e.semiMajorAxis, s = i.multiplyByScalar(r.geodeticSurfaceNormal(n, R), e.height, R);
            Z.center = i.add(n, s, Z.center), Z.radius = o, s = i.multiplyByScalar(r.geodeticSurfaceNormal(n, s), e.extrudedHeight, s), K.center = i.add(n, s, K.center), K.radius = o;
            var u = S(e, !0), l = u.positions, h = u.numPts, p = u.outerPositions, m = t.union(Z, K), y = x(l, e, !0), v = b(h), _ = v.length;
            v.length = 2 * _;
            for (var w = l.length / 3, C = 0; _ > C; C += 3)v[C + _] = v[C + 2] + w, v[C + 1 + _] = v[C + 1] + w, v[C + 2 + _] = v[C] + w;
            var T = a.createTypedArray(2 * w / 3, v), M = new c({attributes: y, indices: T, primitiveType: g.TRIANGLES}), D = E(p, e);
            v = A(p);
            var I = a.createTypedArray(2 * p.length / 3, v), P = new c({attributes: D, indices: I, primitiveType: g.TRIANGLES}), O = d.combine([new f({geometry: M}), new f({geometry: P})]);
            return{boundingSphere: m, attributes: O.attributes, indices: O.indices}
        }

        var D = new i, I = new i, P = new _, O = new v, R = new i, z = new i, L = new i, N = new i, F = new n, V = new v, B = new _, k = new i, U = new i, q = new i, W = new i, H = new i, G = new i, j = new r, Y = new i, X = new i, Z = new t, K = new t, J = function (t) {
            t = e(t, e.EMPTY_OBJECT);
            var n = t.center, i = t.semiMajorAxis, r = t.semiMinorAxis;
            if ("undefined" == typeof n)throw new s("center is required.");
            if ("undefined" == typeof i)throw new s("semiMajorAxis is required.");
            if ("undefined" == typeof r)throw new s("semiMinorAxis is required.");
            if (0 >= i || 0 >= r)throw new s("Semi-major and semi-minor axes must be greater than zero.");
            if (r > i)throw new s("semiMajorAxis must be larger than the semiMajorAxis.");
            var o = {center: n, semiMajorAxis: i, semiMinorAxis: r, ellipsoid: e(t.ellipsoid, u.WGS84), rotation: e(t.rotation, 0), stRotation: e(t.stRotation, 0), height: e(t.height, 0), granularity: e(t.granularity, .02), vertexFormat: e(t.vertexFormat, w.DEFAULT), extrudedHeight: t.extrudedHeight};
            if (o.granularity <= 0)throw new s("granularity must be greater than zero.");
            var a, l = "undefined" != typeof o.extrudedHeight && !m.equalsEpsilon(o.height, o.extrudedHeight, 1);
            if (l) {
                var c = o.extrudedHeight, d = o.height;
                o.extrudedHeight = Math.min(c, d), o.height = Math.max(c, d), a = M(o)
            } else a = T(o);
            this.attributes = a.attributes, this.indices = a.indices, this.primitiveType = g.TRIANGLES, this.boundingSphere = a.boundingSphere
        };
        return J
    }), n("Core/CircleGeometry", ["./clone", "./defaultValue", "./DeveloperError", "./EllipseGeometry"], function (e, t, n, i) {
        "use strict";
        var r = function (e) {
            e = t(e, t.EMPTY_OBJECT);
            var r = e.radius;
            if ("undefined" == typeof r)throw new n("radius is required.");
            if (0 >= r)throw new n("radius must be greater than zero.");
            var o = {center: e.center, semiMajorAxis: r, semiMinorAxis: r, ellipsoid: e.ellipsoid, height: e.height, extrudedHeight: e.extrudedHeight, granularity: e.granularity, vertexFormat: e.vertexFormat, stRotation: e.stRotation}, a = new i(o);
            this.attributes = a.attributes, this.indices = a.indices, this.primitiveType = a.primitiveType, this.boundingSphere = a.boundingSphere
        };
        return r
    }), n("Core/binarySearch", ["./DeveloperError"], function (e) {
        "use strict";
        var t = function (t, n, i) {
            if ("undefined" == typeof t)throw new e("array is required.");
            if ("undefined" == typeof n)throw new e("itemToFind is required.");
            if ("undefined" == typeof i)throw new e("comparator is required.");
            for (var r, o, a = 0, s = t.length - 1; s >= a;)if (r = ~~((a + s) / 2), o = i(t[r], n), 0 > o)a = r + 1; else {
                if (!(o > 0))return r;
                s = r - 1
            }
            return~(s + 1)
        };
        return t
    }), n("Core/TimeConstants", [], function () {
        "use strict";
        var e = {SECONDS_PER_MILLISECOND: .001, SECONDS_PER_MINUTE: 60, MINUTES_PER_HOUR: 60, HOURS_PER_DAY: 24, SECONDS_PER_HOUR: 3600, MINUTES_PER_DAY: 1440, SECONDS_PER_DAY: 86400, DAYS_PER_JULIAN_CENTURY: 36525, PICOSECOND: 1e-9, MODIFIED_JULIAN_DATE_DIFFERENCE: 2400000.5};
        return e
    }), n("Core/LeapSecond", ["./DeveloperError"], function (e) {
        "use strict";
        var t = function (t, n) {
            if ("undefined" == typeof t)throw new e("date is required.");
            if (null === n || isNaN(n))throw new e("offset is required and must be a number.");
            this.julianDate = t, this.offset = n
        };
        return t.setLeapSeconds = function (n) {
            if (!Array.isArray(n))throw new e("leapSeconds is required and must be an array.");
            t._leapSeconds = n, t._leapSeconds.sort(t.compareLeapSecondDate)
        }, t.getLeapSeconds = function () {
            return t._leapSeconds
        }, t.prototype.equals = function (e) {
            return this.julianDate.equals(e.julianDate) && this.offset === e.offset
        }, t.compareLeapSecondDate = function (e, t) {
            return e.julianDate.compareTo(t.julianDate)
        }, t._leapSeconds = [], t
    }), n("Core/TimeStandard", [], function () {
        "use strict";
        var e = {UTC: 0, TAI: 1};
        return e
    }), n("Core/isLeapYear", ["./DeveloperError"], function (e) {
        "use strict";
        function t(t) {
            if (null === t || isNaN(t))throw new e("year is required and must be a number.");
            return 0 === t % 4 && 0 !== t % 100 || 0 === t % 400
        }

        return t
    }), n("ThirdParty/sprintf", [], function () {
        function e() {
            var e = /%%|%(\d+\$)?([-+\'#0 ]*)(\*\d+\$|\*|\d+)?(\.(\*\d+\$|\*|\d+))?([scboxXuideEfFgG])/g, t = arguments, n = 0, i = t[n++], r = function (e, t, n, i) {
                n || (n = " ");
                var r = e.length >= t ? "" : Array(1 + t - e.length >>> 0).join(n);
                return i ? e + r : r + e
            }, o = function (e, t, n, i, o, a) {
                var s = i - e.length;
                return s > 0 && (e = n || !o ? r(e, i, a, n) : e.slice(0, t.length) + r("", s, "0", !0) + e.slice(t.length)), e
            }, a = function (e, t, n, i, a, s, u) {
                var l = e >>> 0;
                return n = n && l && {2: "0b", 8: "0", 16: "0x"}[t] || "", e = n + r(l.toString(t), s || 0, "0", !1), o(e, n, i, a, u)
            }, s = function (e, t, n, i, r, a) {
                return null != i && (e = e.slice(0, i)), o(e, "", t, n, r, a)
            }, u = function (e, i, u, l, c, d, f) {
                var h, p, m, y, v;
                if ("%%" == e)return"%";
                for (var g = !1, _ = "", w = !1, C = !1, x = " ", S = u.length, b = 0; u && S > b; b++)switch (u.charAt(b)) {
                    case" ":
                        _ = " ";
                        break;
                    case"+":
                        _ = "+";
                        break;
                    case"-":
                        g = !0;
                        break;
                    case"'":
                        x = u.charAt(b + 1);
                        break;
                    case"0":
                        w = !0;
                        break;
                    case"#":
                        C = !0
                }
                if (l = l ? "*" == l ? +t[n++] : "*" == l.charAt(0) ? +t[l.slice(1, -1)] : +l : 0, 0 > l && (l = -l, g = !0), !isFinite(l))throw new Error("sprintf: (minimum-)width must be finite");
                switch (d = d ? "*" == d ? +t[n++] : "*" == d.charAt(0) ? +t[d.slice(1, -1)] : +d : "fFeE".indexOf(f) > -1 ? 6 : "d" == f ? 0 : void 0, v = i ? t[i.slice(0, -1)] : t[n++], f) {
                    case"s":
                        return s(String(v), g, l, d, w, x);
                    case"c":
                        return s(String.fromCharCode(+v), g, l, d, w);
                    case"b":
                        return a(v, 2, C, g, l, d, w);
                    case"o":
                        return a(v, 8, C, g, l, d, w);
                    case"x":
                        return a(v, 16, C, g, l, d, w);
                    case"X":
                        return a(v, 16, C, g, l, d, w).toUpperCase();
                    case"u":
                        return a(v, 10, C, g, l, d, w);
                    case"i":
                    case"d":
                        return h = +v || 0, h = Math.round(h - h % 1), p = 0 > h ? "-" : _, v = p + r(String(Math.abs(h)), d, "0", !1), o(v, p, g, l, w);
                    case"e":
                    case"E":
                    case"f":
                    case"F":
                    case"g":
                    case"G":
                        return h = +v, p = 0 > h ? "-" : _, m = ["toExponential", "toFixed", "toPrecision"]["efg".indexOf(f.toLowerCase())], y = ["toString", "toUpperCase"]["eEfFgG".indexOf(f) % 2], v = p + Math.abs(h)[m](d), o(v, p, g, l, w)[y]();
                    default:
                        return e
                }
            };
            return i.replace(e, u)
        }

        return e
    }), n("Core/JulianDate", ["./DeveloperError", "./binarySearch", "./TimeConstants", "./LeapSecond", "./TimeStandard", "./isLeapYear", "../ThirdParty/sprintf"], function (e, t, n, i, r, o, a) {
        "use strict";
        function s(e) {
            m.julianDate = e;
            var n = i.getLeapSeconds(), r = t(n, m, i.compareLeapSecondDate);
            0 > r && (r = ~r), r >= n.length && (r = n.length - 1);
            var o = n[r].offset;
            if (r > 0) {
                var a = e.getSecondsDifference(n[r].julianDate);
                a > o && (r--, o = n[r].offset)
            }
            e.addSeconds(o, e)
        }

        function u(e, n) {
            m.julianDate = e;
            var r = i.getLeapSeconds(), o = t(r, m, i.compareLeapSecondDate);
            if (0 > o && (o = ~o), 0 === o)return e.addSeconds(-r[0].offset, n);
            if (o >= r.length)return e.addSeconds(-r[o - 1].offset, n);
            var a = e.getSecondsDifference(r[o].julianDate);
            return 0 === a ? e.addSeconds(-r[o].offset, n) : 1 >= a ? void 0 : e.addSeconds(-r[--o].offset, n)
        }

        function l(e, t, i) {
            var o = 0 | t / n.SECONDS_PER_DAY;
            return e += o, t -= n.SECONDS_PER_DAY * o, 0 > t && (e--, t += n.SECONDS_PER_DAY), "undefined" == typeof i ? new E(e, t, r.TAI) : (i._julianDayNumber = e, i._secondsOfDay = t, i)
        }

        function c(e, t, i, r, o, a, s) {
            var u = 0 | (t - 14) / 12, l = e + 4800 + u, c = (0 | 1461 * l / 4) + (0 | 367 * (t - 2 - 12 * u) / 12) - (0 | 3 * ((l + 100) / 100) / 4) + i - 32075;
            r -= 12, 0 > r && (r += 24);
            var d = a + (r * n.SECONDS_PER_HOUR + o * n.SECONDS_PER_MINUTE + s * n.SECONDS_PER_MILLISECOND);
            return d >= 43200 && (c -= 1), [c, d]
        }

        function d(e) {
            return c(e.getUTCFullYear(), e.getUTCMonth() + 1, e.getUTCDate(), e.getUTCHours(), e.getUTCMinutes(), e.getUTCSeconds(), e.getUTCMilliseconds())
        }

        var f = function (e, t, n, i, r, o, a, s) {
            this.year = e, this.month = t, this.day = n, this.hour = i, this.minute = r, this.second = o, this.millisecond = a, this.isLeapSecond = s
        }, h = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], p = 29, m = {julianDate: void 0}, y = /^(\d{4})$/, v = /^(\d{4})-(\d{2})$/, g = /^(\d{4})-?(\d{3})$/, _ = /^(\d{4})-?W(\d{2})-?(\d{1})?$/, w = /^(\d{4})-?(\d{2})-?(\d{2})$/, C = /([Z+\-])?(\d{2})?:?(\d{2})?$/, x = /^(\d{2})(\.\d+)?/.source + C.source, S = /^(\d{2}):?(\d{2})(\.\d+)?/.source + C.source, b = /^(\d{2}):?(\d{2}):?(\d{2})(\.\d+)?/.source + C.source, T = "Valid ISO 8601 date string required.", E = function (t, i, o) {
            this._julianDayNumber = void 0, this._secondsOfDay = void 0;
            var a, u;
            if ("undefined" != typeof t || "undefined" != typeof i || "undefined" != typeof o) {
                if ("undefined" == typeof o)o = r.UTC; else if (o !== r.UTC && o !== r.TAI)throw new e("timeStandard is not a known TimeStandard.");
                if (null === t || isNaN(t))throw new e("julianDayNumber is required.");
                if (null === i || isNaN(i))throw new e("julianSecondsOfDay is required.");
                a = 0 | t, u = i + (t - a) * n.SECONDS_PER_DAY
            } else {
                var c = new Date, f = d(c);
                a = f[0], u = f[1], o = r.UTC
            }
            l(a, u, this), o === r.UTC && s(this)
        };
        E.clone = function (e, t) {
            return"undefined" == typeof e ? void 0 : "undefined" == typeof t ? new E(e._julianDayNumber, e._secondsOfDay, r.TAI) : (t._julianDayNumber = e._julianDayNumber, t._secondsOfDay = e._secondsOfDay, t)
        }, E.fromDate = function (t, n) {
            if ("undefined" == typeof t || null === t || isNaN(t.getTime()))throw new e("date must be a valid JavaScript Date.");
            var i = d(t);
            return new E(i[0], i[1], n)
        }, E.fromIso8601 = function (t) {
            if ("string" != typeof t)throw new e(T);
            t = t.replace(",", ".");
            var n, i, a, s = t.split("T"), u = 1, l = 1, d = 0, f = 0, m = 0, C = 0, A = s[0], M = s[1];
            if ("undefined" == typeof A)throw new e(T);
            var D;
            if (s = A.match(w), null !== s) {
                if (D = A.split("-").length - 1, D > 0 && 2 !== D)throw new e(T);
                n = +s[1], u = +s[2], l = +s[3]
            } else if (s = A.match(v), null !== s)n = +s[1], u = +s[2]; else if (s = A.match(y), null !== s)n = +s[1]; else {
                var I;
                if (s = A.match(g), null !== s) {
                    if (n = +s[1], I = +s[2], a = o(n), 1 > I || a && I > 366 || !a && I > 365)throw new e(T)
                } else {
                    if (s = A.match(_), null === s)throw new e(T);
                    n = +s[1];
                    var P = +s[2], O = +s[3] || 0;
                    if (D = A.split("-").length - 1, D > 0 && ("undefined" == typeof s[3] && 1 !== D || "undefined" != typeof s[3] && 2 !== D))throw new e(T);
                    var R = new Date(Date.UTC(n, 0, 4));
                    I = 7 * P + O - R.getUTCDay() - 3
                }
                i = new Date(Date.UTC(n, 0, 1)), i.setUTCDate(I), u = i.getUTCMonth() + 1, l = i.getUTCDate()
            }
            if (a = o(n), 1 > u || u > 12 || 1 > l || (2 !== u || !a) && l > h[u - 1] || a && 2 === u && l > p)throw new e(T);
            var z;
            if ("undefined" != typeof M) {
                if (s = M.match(b), null !== s) {
                    if (D = M.split(":").length - 1, D > 0 && 2 !== D && 3 !== D)throw new e(T);
                    d = +s[1], f = +s[2], m = +s[3], C = 1e3 * +(s[4] || 0), z = 5
                } else if (s = M.match(S), null !== s) {
                    if (D = M.split(":").length - 1, D > 0 && 1 !== D)throw new e(T);
                    d = +s[1], f = +s[2], m = 60 * +(s[3] || 0), z = 4
                } else {
                    if (s = M.match(x), null === s)throw new e(T);
                    d = +s[1], f = 60 * +(s[2] || 0), z = 3
                }
                if (f >= 60 || m >= 61 || d > 24 || 24 === d && (f > 0 || m > 0 || C > 0))throw new e(T);
                var L = s[z], N = +s[z + 1], F = +(s[z + 2] || 0);
                switch (L) {
                    case"+":
                        d -= N, f -= F;
                        break;
                    case"-":
                        d += N, f += F;
                        break;
                    case"Z":
                        break;
                    default:
                        f += new Date(Date.UTC(n, u - 1, l, d, f)).getTimezoneOffset()
                }
            } else f += new Date(Date.UTC(n, u - 1, l)).getTimezoneOffset();
            var V = 60 === m;
            for (V && m--; f >= 60;)f -= 60, d++;
            for (; d >= 24;)d -= 24, l++;
            for (i = a && 2 === u ? p : h[u - 1]; l > i;)l -= i, u++, u > 12 && (u -= 12, n++), i = a && 2 === u ? p : h[u - 1];
            for (; 0 > f;)f += 60, d--;
            for (; 0 > d;)d += 24, l--;
            for (; 1 > l;)u--, 1 > u && (u += 12, n--), i = a && 2 === u ? p : h[u - 1], l += i;
            var B = c(n, u, l, d, f, m, C), k = new E(B[0], B[1], r.UTC);
            return V && k.addSeconds(1, k), k
        }, E.fromTotalDays = function (t, n) {
            if (null === t || isNaN(t))throw new e("totalDays is required.");
            return new E(t, 0, n)
        }, E.compare = function (e, t) {
            var n = e._julianDayNumber - t._julianDayNumber;
            return 0 !== n ? n : e._secondsOfDay - t._secondsOfDay
        }, E.equals = function (e, t) {
            return e === t || "undefined" != typeof e && "undefined" != typeof t && e._julianDayNumber === t._julianDayNumber && e._secondsOfDay === t._secondsOfDay
        }, E.prototype.clone = function (e) {
            return E.clone(this, e)
        }, E.prototype.getTotalDays = function () {
            return this._julianDayNumber + this._secondsOfDay / n.SECONDS_PER_DAY
        }, E.prototype.getJulianDayNumber = function () {
            return this._julianDayNumber
        }, E.prototype.getJulianTimeFraction = function () {
            return this._secondsOfDay / n.SECONDS_PER_DAY
        }, E.prototype.getSecondsOfDay = function () {
            return this._secondsOfDay
        };
        var A = new E(0, 0, r.TAI);
        return E.prototype.toGregorianDate = function () {
            var e = !1, t = u(this, A);
            "undefined" == typeof t && (this.addSeconds(-1, A), t = u(A, A), e = !0);
            var i = t._julianDayNumber, r = t._secondsOfDay;
            r >= 43200 && (i += 1);
            var o = 0 | i + 68569, a = 0 | 4 * o / 146097;
            o = 0 | o - (0 | (146097 * a + 3) / 4);
            var s = 0 | 4e3 * (o + 1) / 1461001;
            o = 0 | o - (0 | 1461 * s / 4) + 31;
            var l = 0 | 80 * o / 2447, c = 0 | o - (0 | 2447 * l / 80);
            o = 0 | l / 11;
            var d = 0 | l + 2 - 12 * o, h = 0 | 100 * (a - 49) + s + o, p = 0 | r / n.SECONDS_PER_HOUR, m = r - p * n.SECONDS_PER_HOUR, y = 0 | m / n.SECONDS_PER_MINUTE;
            m -= y * n.SECONDS_PER_MINUTE;
            var v = 0 | m, g = (m - v) / n.SECONDS_PER_MILLISECOND;
            return p += 12, p > 23 && (p -= 24), e && (v += 1), new f(h, d, c, p, y, v, g, e)
        }, E.prototype.toDate = function () {
            var e = this.toGregorianDate(), t = e.second;
            return e.isLeapSecond && (t -= 1), new Date(Date.UTC(e.year, e.month - 1, e.day, e.hour, e.minute, t, e.millisecond))
        }, E.prototype.toIso8601 = function (e) {
            var t, n = this.toGregorianDate();
            return"undefined" == typeof e && 0 !== n.millisecond ? (t = (.01 * n.millisecond).toString().replace(".", ""), a("%04d-%02d-%02dT%02d:%02d:%02d.%sZ", n.year, n.month, n.day, n.hour, n.minute, n.second, t)) : "undefined" == typeof e || 0 === e ? a("%04d-%02d-%02dT%02d:%02d:%02dZ", n.year, n.month, n.day, n.hour, n.minute, n.second) : (t = (.01 * n.millisecond).toFixed(e).replace(".", "").slice(0, e), a("%04d-%02d-%02dT%02d:%02d:%02d.%sZ", n.year, n.month, n.day, n.hour, n.minute, n.second, t))
        }, E.prototype.getSecondsDifference = function (e) {
            var t = this, i = e, r = (i._julianDayNumber - t._julianDayNumber) * n.SECONDS_PER_DAY;
            return r + (i._secondsOfDay - t._secondsOfDay)
        }, E.prototype.getMinutesDifference = function (e) {
            return this.getSecondsDifference(e) / n.SECONDS_PER_MINUTE
        }, E.prototype.getDaysDifference = function (e) {
            var t = this, i = e, r = i._julianDayNumber - t._julianDayNumber, o = (i._secondsOfDay - t._secondsOfDay) / n.SECONDS_PER_DAY;
            return r + o
        }, E.prototype.getTaiMinusUtc = function () {
            m.julianDate = this;
            var e = i.getLeapSeconds(), n = t(e, m, i.compareLeapSecondDate);
            return 0 > n && (n = ~n, --n, 0 > n && (n = 0)), e[n].offset
        }, E.prototype.addSeconds = function (t, n) {
            if (null === t || isNaN(t))throw new e("seconds is required and must be a number.");
            return l(this._julianDayNumber, this._secondsOfDay + t, n)
        }, E.prototype.addMinutes = function (t) {
            if (null === t || isNaN(t))throw new e("duration is required and must be a number.");
            var i = this._secondsOfDay + t * n.SECONDS_PER_MINUTE;
            return new E(this._julianDayNumber, i, r.TAI)
        }, E.prototype.addHours = function (t) {
            if (null === t || isNaN(t))throw new e("duration is required and must be a number.");
            var i = this._secondsOfDay + t * n.SECONDS_PER_HOUR;
            return new E(this._julianDayNumber, i, r.TAI)
        }, E.prototype.addDays = function (t) {
            if (null === t || isNaN(t))throw new e("duration is required and must be a number.");
            var n = this._julianDayNumber + t;
            return new E(n, this._secondsOfDay, r.TAI)
        }, E.prototype.lessThan = function (e) {
            return E.compare(this, e) < 0
        }, E.prototype.lessThanOrEquals = function (e) {
            return E.compare(this, e) <= 0
        }, E.prototype.greaterThan = function (e) {
            return E.compare(this, e) > 0
        }, E.prototype.greaterThanOrEquals = function (e) {
            return E.compare(this, e) >= 0
        }, E.prototype.compareTo = function (e) {
            return E.compare(this, e)
        }, E.prototype.equals = function (e) {
            return E.equals(this, e)
        }, E.prototype.equalsEpsilon = function (t, n) {
            if (null === n || isNaN(n))throw new e("epsilon is required and must be number.");
            return Math.abs(this.getSecondsDifference(t)) <= n
        }, 0 === i._leapSeconds.length && (i._leapSeconds = [new i(new E(2441317, 43210, r.TAI), 10), new i(new E(2441499, 43211, r.TAI), 11), new i(new E(2441683, 43212, r.TAI), 12), new i(new E(2442048, 43213, r.TAI), 13), new i(new E(2442413, 43214, r.TAI), 14), new i(new E(2442778, 43215, r.TAI), 15), new i(new E(2443144, 43216, r.TAI), 16), new i(new E(2443509, 43217, r.TAI), 17), new i(new E(2443874, 43218, r.TAI), 18), new i(new E(2444239, 43219, r.TAI), 19), new i(new E(2444786, 43220, r.TAI), 20), new i(new E(2445151, 43221, r.TAI), 21), new i(new E(2445516, 43222, r.TAI), 22), new i(new E(2446247, 43223, r.TAI), 23), new i(new E(2447161, 43224, r.TAI), 24), new i(new E(2447892, 43225, r.TAI), 25), new i(new E(2448257, 43226, r.TAI), 26), new i(new E(2448804, 43227, r.TAI), 27), new i(new E(2449169, 43228, r.TAI), 28), new i(new E(2449534, 43229, r.TAI), 29), new i(new E(2450083, 43230, r.TAI), 30), new i(new E(2450630, 43231, r.TAI), 31), new i(new E(2451179, 43232, r.TAI), 32), new i(new E(2453736, 43233, r.TAI), 33), new i(new E(2454832, 43234, r.TAI), 34), new i(new E(2456109, 43235, r.TAI), 35)]), E
    }), n("Core/ClockStep", ["./Enumeration"], function (e) {
        "use strict";
        var t = {TICK_DEPENDENT: new e(0, "TICK_DEPENDENT"), SYSTEM_CLOCK_MULTIPLIER: new e(1, "SYSTEM_CLOCK_MULTIPLIER"), SYSTEM_CLOCK: new e(2, "SYSTEM_CLOCK")};
        return t
    }), n("Core/ClockRange", ["./Enumeration"], function (e) {
        "use strict";
        var t = {UNBOUNDED: new e(0, "UNBOUNDED"), CLAMPED: new e(1, "CLAMPED"), LOOP_STOP: new e(2, "LOOP_STOP")};
        return t
    }), n("Core/Event", ["./DeveloperError"], function (e) {
        "use strict";
        var t = function () {
            this._listeners = [], this._scopes = []
        };
        return t.prototype.getNumberOfListeners = function () {
            return this._listeners.length
        }, t.prototype.addEventListener = function (t, n) {
            if ("function" != typeof t)throw new e("listener is required and must be a function.");
            this._listeners.push(t), this._scopes.push(n);
            var i = this;
            return function () {
                i.removeEventListener(t, n)
            }
        }, t.prototype.removeEventListener = function (t, n) {
            if ("function" != typeof t)throw new e("listener is required and must be a function.");
            for (var i = this._listeners, r = this._scopes, o = -1, a = 0; a < i.length; a++)if (i[a] === t && r[a] === n) {
                o = a;
                break
            }
            if (-1 === o)throw new e("listener is not subscribed.");
            i.splice(o, 1), this._scopes.splice(o, 1)
        }, t.prototype.raiseEvent = function () {
            for (var e = this._listeners, t = this._scopes, n = e.length - 1; n > -1; n--)e[n].apply(t[n], arguments)
        }, t
    }), n("Core/Clock", ["./DeveloperError", "./JulianDate", "./ClockStep", "./ClockRange", "./Event", "./defaultValue"], function (e, t, n, i, r, o) {
        "use strict";
        var a = function (a) {
            a = o(a, o.EMPTY_OBJECT);
            var s = a.startTime, u = "undefined" == typeof s, l = a.stopTime, c = "undefined" == typeof l, d = a.currentTime, f = "undefined" == typeof d;
            if (u && c && f ? (d = new t, s = d.clone(), l = d.addDays(1)) : u && c ? (s = d.clone(), l = d.addDays(1)) : u && f ? (s = l.addDays(-1), d = s.clone()) : f && c ? (d = s.clone(), l = s.addDays(1)) : f ? d = s.clone() : c ? l = d.addDays(1) : u && (s = d.clone()), s.greaterThan(l))throw new e("startTime must come before stopTime.");
            this.startTime = s, this.stopTime = l, this.currentTime = d, this.multiplier = o(a.multiplier, 1), this.clockStep = o(a.clockStep, n.SYSTEM_CLOCK_MULTIPLIER), this.clockRange = o(a.clockRange, i.UNBOUNDED), this.shouldAnimate = o(a.shouldAnimate, !0), this.onTick = new r, this._lastSystemTime = Date.now()
        };
        return a.prototype.tick = function () {
            var e = Date.now(), r = this.currentTime, o = this.startTime, a = this.stopTime, s = this.multiplier;
            if (this.shouldAnimate)if (this.clockStep === n.SYSTEM_CLOCK)r = new t; else {
                if (this.clockStep === n.TICK_DEPENDENT)r = r.addSeconds(s); else {
                    var u = e - this._lastSystemTime;
                    r = r.addSeconds(s * (u / 1e3))
                }
                if (this.clockRange === i.CLAMPED)r.lessThan(o) ? r = o : r.greaterThan(a) && (r = a); else if (this.clockRange === i.LOOP_STOP)for (r.lessThan(o) && (r = o.clone()); r.greaterThan(a);)r = o.addSeconds(a.getSecondsDifference(r))
            }
            return this.currentTime = r, this._lastSystemTime = e, this.onTick.raiseEvent(this), r
        }, a
    }), n("Core/Color", ["./defaultValue", "./freezeObject", "./DeveloperError"], function (e, t, n) {
        "use strict";
        function i(e, t, n) {
            return 0 > n && (n += 1), n > 1 && (n -= 1), 1 > 6 * n ? e + 6 * (t - e) * n : 1 > 2 * n ? t : 2 > 3 * n ? e + 6 * (t - e) * (2 / 3 - n) : e
        }

        var r = function (t, n, i, r) {
            this.red = e(t, 1), this.green = e(n, 1), this.blue = e(i, 1), this.alpha = e(r, 1)
        };
        r.fromBytes = function (t, n, i, o) {
            return t = r.byteToFloat(e(t, 255)), n = r.byteToFloat(e(n, 255)), i = r.byteToFloat(e(i, 255)), o = r.byteToFloat(e(o, 255)), new r(t, n, i, o)
        };
        var o, a, s;
        "undefined" != typeof ArrayBuffer && (o = new ArrayBuffer(4), a = new Uint32Array(o), s = new Uint8Array(o)), r.fromRgba = function (e) {
            return a[0] = e, r.fromBytes(s[0], s[1], s[2], s[3])
        }, r.fromHsl = function (t, n, o, a) {
            t = e(t, 0) % 1, n = e(n, 0), o = e(o, 0), a = e(a, 1);
            var s = o, u = o, l = o;
            if (0 !== n) {
                var c;
                c = .5 > o ? o * (1 + n) : o + n - o * n;
                var d = 2 * o - c;
                s = i(d, c, t + 1 / 3), u = i(d, c, t), l = i(d, c, t - 1 / 3)
            }
            return new r(s, u, l, a)
        };
        var u = /^#([0-9a-f])([0-9a-f])([0-9a-f])$/i, l = /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i, c = /^rgba?\(\s*([0-9.]+%?)\s*,\s*([0-9.]+%?)\s*,\s*([0-9.]+%?)(?:\s*,\s*([0-9.]+))?\s*\)$/i, d = /^hsla?\(\s*([0-9.]+)\s*,\s*([0-9.]+%)\s*,\s*([0-9.]+%)(?:\s*,\s*([0-9.]+))?\s*\)$/i;
        return r.fromCssColorString = function (t) {
            if ("undefined" == typeof t)throw new n("color is required");
            var i = r[t.toUpperCase()];
            if ("undefined" != typeof i)return i.clone();
            var o = u.exec(t);
            return null !== o ? new r(parseInt(o[1], 16) / 15, parseInt(o[2], 16) / 15, parseInt(o[3], 16) / 15) : (o = l.exec(t), null !== o ? new r(parseInt(o[1], 16) / 255, parseInt(o[2], 16) / 255, parseInt(o[3], 16) / 255) : (o = c.exec(t), null !== o ? new r(parseFloat(o[1]) / ("%" === o[1].substr(-1) ? 100 : 255), parseFloat(o[2]) / ("%" === o[2].substr(-1) ? 100 : 255), parseFloat(o[3]) / ("%" === o[3].substr(-1) ? 100 : 255), parseFloat(e(o[4], "1.0"))) : (o = d.exec(t), null !== o ? r.fromHsl(parseFloat(o[1]) / 360, parseFloat(o[2]) / 100, parseFloat(o[3]) / 100, parseFloat(e(o[4], "1.0"))) : void 0)))
        }, r.byteToFloat = function (e) {
            return e / 255
        }, r.floatToByte = function (e) {
            return 1 === e ? 255 : 0 | 256 * e
        }, r.clone = function (e, t) {
            return"undefined" == typeof e ? void 0 : "undefined" == typeof t ? new r(e.red, e.green, e.blue, e.alpha) : (t.red = e.red, t.green = e.green, t.blue = e.blue, t.alpha = e.alpha, t)
        }, r.equals = function (e, t) {
            return e === t || "undefined" != typeof e && "undefined" != typeof t && e.red === t.red && e.green === t.green && e.blue === t.blue && e.alpha === t.alpha
        }, r.prototype.clone = function (e) {
            return r.clone(this, e)
        }, r.prototype.equals = function (e) {
            return r.equals(this, e)
        }, r.prototype.equalsEpsilon = function (e, t) {
            return this === e || "undefined" != typeof e && Math.abs(this.red - e.red) <= t && Math.abs(this.green - e.green) <= t && Math.abs(this.blue - e.blue) <= t && Math.abs(this.alpha - e.alpha) <= t
        }, r.prototype.toString = function () {
            return"(" + this.red + ", " + this.green + ", " + this.blue + ", " + this.alpha + ")"
        }, r.prototype.toCssColorString = function () {
            var e = r.floatToByte(this.red), t = r.floatToByte(this.green), n = r.floatToByte(this.blue);
            return 1 === this.alpha ? "rgb(" + e + "," + t + "," + n + ")" : "rgba(" + e + "," + t + "," + n + "," + this.alpha + ")"
        }, r.prototype.toBytes = function () {
            var e = r.floatToByte(this.red), t = r.floatToByte(this.green), n = r.floatToByte(this.blue), i = r.floatToByte(this.alpha);
            return[e, t, n, i]
        }, r.prototype.toRgba = function () {
            return s[0] = r.floatToByte(this.red), s[1] = r.floatToByte(this.green), s[2] = r.floatToByte(this.blue), s[3] = r.floatToByte(this.alpha), a[0]
        }, r.ALICEBLUE = t(r.fromCssColorString("#F0F8FF")), r.ANTIQUEWHITE = t(r.fromCssColorString("#FAEBD7")), r.AQUA = t(r.fromCssColorString("#00FFFF")), r.AQUAMARINE = t(r.fromCssColorString("#7FFFD4")), r.AZURE = t(r.fromCssColorString("#F0FFFF")), r.BEIGE = t(r.fromCssColorString("#F5F5DC")), r.BISQUE = t(r.fromCssColorString("#FFE4C4")), r.BLACK = t(r.fromCssColorString("#000000")), r.BLANCHEDALMOND = t(r.fromCssColorString("#FFEBCD")), r.BLUE = t(r.fromCssColorString("#0000FF")), r.BLUEVIOLET = t(r.fromCssColorString("#8A2BE2")), r.BROWN = t(r.fromCssColorString("#A52A2A")), r.BURLYWOOD = t(r.fromCssColorString("#DEB887")), r.CADETBLUE = t(r.fromCssColorString("#5F9EA0")), r.CHARTREUSE = t(r.fromCssColorString("#7FFF00")), r.CHOCOLATE = t(r.fromCssColorString("#D2691E")), r.CORAL = t(r.fromCssColorString("#FF7F50")), r.CORNFLOWERBLUE = t(r.fromCssColorString("#6495ED")), r.CORNSILK = t(r.fromCssColorString("#FFF8DC")), r.CRIMSON = t(r.fromCssColorString("#DC143C")), r.CYAN = t(r.fromCssColorString("#00FFFF")), r.DARKBLUE = t(r.fromCssColorString("#00008B")), r.DARKCYAN = t(r.fromCssColorString("#008B8B")), r.DARKGOLDENROD = t(r.fromCssColorString("#B8860B")), r.DARKGRAY = t(r.fromCssColorString("#A9A9A9")), r.DARKGREEN = t(r.fromCssColorString("#006400")), r.DARKGREY = r.DARKGRAY, r.DARKKHAKI = t(r.fromCssColorString("#BDB76B")), r.DARKMAGENTA = t(r.fromCssColorString("#8B008B")), r.DARKOLIVEGREEN = t(r.fromCssColorString("#556B2F")), r.DARKORANGE = t(r.fromCssColorString("#FF8C00")), r.DARKORCHID = t(r.fromCssColorString("#9932CC")), r.DARKRED = t(r.fromCssColorString("#8B0000")), r.DARKSALMON = t(r.fromCssColorString("#E9967A")), r.DARKSEAGREEN = t(r.fromCssColorString("#8FBC8F")), r.DARKSLATEBLUE = t(r.fromCssColorString("#483D8B")), r.DARKSLATEGRAY = t(r.fromCssColorString("#2F4F4F")), r.DARKSLATEGREY = r.DARKSLATEGRAY, r.DARKTURQUOISE = t(r.fromCssColorString("#00CED1")), r.DARKVIOLET = t(r.fromCssColorString("#9400D3")), r.DEEPPINK = t(r.fromCssColorString("#FF1493")), r.DEEPSKYBLUE = t(r.fromCssColorString("#00BFFF")), r.DIMGRAY = t(r.fromCssColorString("#696969")), r.DIMGREY = r.DIMGRAY, r.DODGERBLUE = t(r.fromCssColorString("#1E90FF")), r.FIREBRICK = t(r.fromCssColorString("#B22222")), r.FLORALWHITE = t(r.fromCssColorString("#FFFAF0")), r.FORESTGREEN = t(r.fromCssColorString("#228B22")), r.FUSCHIA = t(r.fromCssColorString("#FF00FF")), r.GAINSBORO = t(r.fromCssColorString("#DCDCDC")), r.GHOSTWHITE = t(r.fromCssColorString("#F8F8FF")), r.GOLD = t(r.fromCssColorString("#FFD700")), r.GOLDENROD = t(r.fromCssColorString("#DAA520")), r.GRAY = t(r.fromCssColorString("#808080")), r.GREEN = t(r.fromCssColorString("#008000")), r.GREENYELLOW = t(r.fromCssColorString("#ADFF2F")), r.GREY = r.GRAY, r.HONEYDEW = t(r.fromCssColorString("#F0FFF0")), r.HOTPINK = t(r.fromCssColorString("#FF69B4")), r.INDIANRED = t(r.fromCssColorString("#CD5C5C")), r.INDIGO = t(r.fromCssColorString("#4B0082")), r.IVORY = t(r.fromCssColorString("#FFFFF0")), r.KHAKI = t(r.fromCssColorString("#F0E68C")), r.LAVENDER = t(r.fromCssColorString("#E6E6FA")), r.LAVENDAR_BLUSH = t(r.fromCssColorString("#FFF0F5")), r.LAWNGREEN = t(r.fromCssColorString("#7CFC00")), r.LEMONCHIFFON = t(r.fromCssColorString("#FFFACD")), r.LIGHTBLUE = t(r.fromCssColorString("#ADD8E6")), r.LIGHTCORAL = t(r.fromCssColorString("#F08080")), r.LIGHTCYAN = t(r.fromCssColorString("#E0FFFF")), r.LIGHTGOLDENRODYELLOW = t(r.fromCssColorString("#FAFAD2")), r.LIGHTGRAY = t(r.fromCssColorString("#D3D3D3")), r.LIGHTGREEN = t(r.fromCssColorString("#90EE90")), r.LIGHTGREY = r.LIGHTGRAY, r.LIGHTPINK = t(r.fromCssColorString("#FFB6C1")), r.LIGHTSEAGREEN = t(r.fromCssColorString("#20B2AA")), r.LIGHTSKYBLUE = t(r.fromCssColorString("#87CEFA")), r.LIGHTSLATEGRAY = t(r.fromCssColorString("#778899")), r.LIGHTSLATEGREY = r.LIGHTSLATEGRAY, r.LIGHTSTEELBLUE = t(r.fromCssColorString("#B0C4DE")), r.LIGHTYELLOW = t(r.fromCssColorString("#FFFFE0")), r.LIME = t(r.fromCssColorString("#00FF00")), r.LIMEGREEN = t(r.fromCssColorString("#32CD32")), r.LINEN = t(r.fromCssColorString("#FAF0E6")), r.MAGENTA = t(r.fromCssColorString("#FF00FF")), r.MAROON = t(r.fromCssColorString("#800000")), r.MEDIUMAQUAMARINE = t(r.fromCssColorString("#66CDAA")), r.MEDIUMBLUE = t(r.fromCssColorString("#0000CD")), r.MEDIUMORCHID = t(r.fromCssColorString("#BA55D3")), r.MEDIUMPURPLE = t(r.fromCssColorString("#9370DB")), r.MEDIUMSEAGREEN = t(r.fromCssColorString("#3CB371")), r.MEDIUMSLATEBLUE = t(r.fromCssColorString("#7B68EE")), r.MEDIUMSPRINGGREEN = t(r.fromCssColorString("#00FA9A")), r.MEDIUMTURQUOISE = t(r.fromCssColorString("#48D1CC")), r.MEDIUMVIOLETRED = t(r.fromCssColorString("#C71585")), r.MIDNIGHTBLUE = t(r.fromCssColorString("#191970")), r.MINTCREAM = t(r.fromCssColorString("#F5FFFA")), r.MISTYROSE = t(r.fromCssColorString("#FFE4E1")), r.MOCCASIN = t(r.fromCssColorString("#FFE4B5")), r.NAVAJOWHITE = t(r.fromCssColorString("#FFDEAD")), r.NAVY = t(r.fromCssColorString("#000080")), r.OLDLACE = t(r.fromCssColorString("#FDF5E6")), r.OLIVE = t(r.fromCssColorString("#808000")), r.OLIVEDRAB = t(r.fromCssColorString("#6B8E23")), r.ORANGE = t(r.fromCssColorString("#FFA500")), r.ORANGERED = t(r.fromCssColorString("#FF4500")), r.ORCHID = t(r.fromCssColorString("#DA70D6")), r.PALEGOLDENROD = t(r.fromCssColorString("#EEE8AA")), r.PALEGREEN = t(r.fromCssColorString("#98FB98")), r.PALETURQUOISE = t(r.fromCssColorString("#AFEEEE")), r.PALEVIOLETRED = t(r.fromCssColorString("#DB7093")), r.PAPAYAWHIP = t(r.fromCssColorString("#FFEFD5")), r.PEACHPUFF = t(r.fromCssColorString("#FFDAB9")), r.PERU = t(r.fromCssColorString("#CD853F")), r.PINK = t(r.fromCssColorString("#FFC0CB")), r.PLUM = t(r.fromCssColorString("#DDA0DD")), r.POWDERBLUE = t(r.fromCssColorString("#B0E0E6")), r.PURPLE = t(r.fromCssColorString("#800080")), r.RED = t(r.fromCssColorString("#FF0000")), r.ROSYBROWN = t(r.fromCssColorString("#BC8F8F")), r.ROYALBLUE = t(r.fromCssColorString("#4169E1")), r.SADDLEBROWN = t(r.fromCssColorString("#8B4513")), r.SALMON = t(r.fromCssColorString("#FA8072")), r.SANDYBROWN = t(r.fromCssColorString("#F4A460")), r.SEAGREEN = t(r.fromCssColorString("#2E8B57")), r.SEASHELL = t(r.fromCssColorString("#FFF5EE")), r.SIENNA = t(r.fromCssColorString("#A0522D")), r.SILVER = t(r.fromCssColorString("#C0C0C0")), r.SKYBLUE = t(r.fromCssColorString("#87CEEB")), r.SLATEBLUE = t(r.fromCssColorString("#6A5ACD")), r.SLATEGRAY = t(r.fromCssColorString("#708090")), r.SLATEGREY = r.SLATEGRAY, r.SNOW = t(r.fromCssColorString("#FFFAFA")), r.SPRINGGREEN = t(r.fromCssColorString("#00FF7F")), r.STEELBLUE = t(r.fromCssColorString("#4682B4")), r.TAN = t(r.fromCssColorString("#D2B48C")), r.TEAL = t(r.fromCssColorString("#008080")), r.THISTLE = t(r.fromCssColorString("#D8BFD8")), r.TOMATO = t(r.fromCssColorString("#FF6347")), r.TURQUOISE = t(r.fromCssColorString("#40E0D0")), r.VIOLET = t(r.fromCssColorString("#EE82EE")), r.WHEAT = t(r.fromCssColorString("#F5DEB3")), r.WHITE = t(r.fromCssColorString("#FFFFFF")), r.WHITESMOKE = t(r.fromCssColorString("#F5F5F5")), r.YELLOW = t(r.fromCssColorString("#FFFF00")), r.YELLOWGREEN = t(r.fromCssColorString("#9ACD32")), r
    }), n("Core/ColorGeometryInstanceAttribute", ["./defaultValue", "./Color", "./ComponentDatatype", "./DeveloperError"], function (e, t, n, i) {
        "use strict";
        var r = function (i, r, o, a) {
            i = e(i, 1), r = e(r, 1), o = e(o, 1), a = e(a, 1), this.componentDatatype = n.UNSIGNED_BYTE, this.componentsPerAttribute = 4, this.normalize = !0, this.value = new Uint8Array([t.floatToByte(i), t.floatToByte(r), t.floatToByte(o), t.floatToByte(a)])
        };
        return r.fromColor = function (e) {
            if ("undefined" == typeof e)throw new i("color is required.");
            return new r(e.red, e.green, e.blue, e.alpha)
        }, r.toValue = function (e) {
            if ("undefined" == typeof e)throw new i("color is required.");
            return new Uint8Array(e.toBytes())
        }, r
    }), n("Core/CylinderGeometry", ["./defaultValue", "./DeveloperError", "./Cartesian2", "./Cartesian3", "./Math", "./ComponentDatatype", "./IndexDatatype", "./PrimitiveType", "./BoundingSphere", "./GeometryAttribute", "./GeometryAttributes", "./VertexFormat"], function (e, t, n, i, r, o, a, s, u, l, c, d) {
        "use strict";
        var f = new n, h = new i, p = new i, m = new i, y = new i, v = function (n) {
            n = e(n, e.EMPTY_OBJECT);
            var v = n.length;
            if ("undefined" == typeof v || 0 >= v)throw new t("options.length must be greater than 0");
            var g = n.topRadius;
            if ("undefined" == typeof g || 0 > g)throw new t("options.topRadius must be greater than 0");
            var _ = n.bottomRadius;
            if ("undefined" == typeof _ || 0 > _)throw new t("options.bottomRadius must be greater than 0");
            if (0 === _ && 0 === g)throw new t("bottomRadius and topRadius cannot both equal 0");
            var w = e(n.vertexFormat, d.DEFAULT), C = e(n.slices, 100);
            if (3 > C)throw new t("options.slices must be greater that 3");
            var x, S = C + C, b = C + S, T = .5 * v, E = -T, A = S + S, M = new Array(S), D = new Array(C), I = new Array(C), P = w.st ? new Float32Array(2 * A) : void 0, O = w.normal ? new Float32Array(3 * A) : void 0, R = w.tangent ? new Float32Array(3 * A) : void 0, z = w.binormal ? new Float32Array(3 * A) : void 0, L = w.normal || w.tangent || w.binormal, N = w.tangent || w.binormal, F = 0, V = 0, B = 0, k = 0, U = 0, q = 0, W = h;
            W.z = 0;
            var H = m, G = p;
            for (x = 0; C > x; x++) {
                var j = x / C * r.TWO_PI, Y = Math.cos(j), X = Math.sin(j), Z = Y * _, K = X * _, J = Y * g, Q = X * g;
                D[V++] = Z, D[V++] = K, D[V++] = E, I[B++] = J, I[B++] = Q, I[B++] = T, M[F++] = Z, M[F++] = K, M[F++] = E, M[F++] = J, M[F++] = Q, M[F++] = T, L && (W.x = Y, W.y = X, N && (H = i.cross(i.UNIT_Z, W, H).normalize(H)), w.normal && (O[k++] = Y, O[k++] = X, O[k++] = 0, O[k++] = Y, O[k++] = X, O[k++] = 0), w.tangent && (R[U++] = H.x, R[U++] = H.y, R[U++] = H.z, R[U++] = H.x, R[U++] = H.y, R[U++] = H.z), w.binormal && (G = i.cross(W, H, G).normalize(G), z[q++] = G.x, z[q++] = G.y, z[q++] = G.z, z[q++] = G.x, z[q++] = G.y, z[q++] = G.z))
            }
            if (M = M.concat(D).concat(I), L) {
                for (x = 0; C > x; x++)w.normal && (O[k++] = 0, O[k++] = 0, O[k++] = -1), w.tangent && (R[U++] = 1, R[U++] = 0, R[U++] = 0), w.binormal && (z[q++] = 0, z[q++] = -1, z[q++] = 0);
                for (x = 0; C > x; x++)w.normal && (O[k++] = 0, O[k++] = 0, O[k++] = 1), w.tangent && (R[U++] = 1, R[U++] = 0, R[U++] = 0), w.binormal && (z[q++] = 0, z[q++] = 1, z[q++] = 0)
            }
            var $ = 18 * C - 24, et = a.createTypedArray(A, $);
            F = 0;
            var tt = 0;
            for (x = 0; C - 1 > x; x++)et[F++] = tt, et[F++] = tt + 2, et[F++] = tt + 3, et[F++] = tt, et[F++] = tt + 3, et[F++] = tt + 1, tt += 2;
            for (et[F++] = S - 2, et[F++] = 0, et[F++] = 1, et[F++] = S - 2, et[F++] = 1, et[F++] = S - 1, x = 1; C - 1 > x; x++)et[F++] = S + x + 1, et[F++] = S + x, et[F++] = S;
            for (x = 1; C - 1 > x; x++)et[F++] = b, et[F++] = b + x, et[F++] = b + x + 1;
            var nt = 0;
            if (w.st) {
                var it = Math.max(g, _);
                for (x = 0; A > x; x++) {
                    var rt = i.fromArray(M, 3 * x, y);
                    P[nt++] = (rt.x + it) / (2 * it), P[nt++] = (rt.y + it) / (2 * it)
                }
            }
            var ot = new c;
            w.position && (ot.position = new l({componentDatatype: o.DOUBLE, componentsPerAttribute: 3, values: new Float64Array(M)})), w.normal && (ot.normal = new l({componentDatatype: o.FLOAT, componentsPerAttribute: 3, values: O})), w.tangent && (ot.tangent = new l({componentDatatype: o.FLOAT, componentsPerAttribute: 3, values: R})), w.binormal && (ot.binormal = new l({componentDatatype: o.FLOAT, componentsPerAttribute: 3, values: z})), w.st && (ot.st = new l({componentDatatype: o.FLOAT, componentsPerAttribute: 2, values: P})), f.x = .5 * v, f.y = Math.max(_, g);
            var at = new u(i.ZERO, f.magnitude());
            this.attributes = ot, this.indices = et, this.primitiveType = s.TRIANGLES, this.boundingSphere = at
        };
        return v
    }), n("Core/DefaultProxy", [], function () {
        "use strict";
        var e = function (e) {
            this.proxy = e
        };
        return e.prototype.getURL = function (e) {
            return this.proxy + "?" + encodeURIComponent(e)
        }, e
    }), n("Core/RequestErrorEvent", [], function () {
        "use strict";
        var e = function (e, t) {
            this.statusCode = e, this.response = t
        };
        return e
    }), function (e) {
        "use strict";
        e("ThirdParty/when", [], function () {
            function e(e, n, i, r) {
                return t(e).then(n, i, r)
            }

            function t(e) {
                var t, n;
                return e instanceof i ? t = e : s(e) ? (n = a(), e.then(function (e) {
                    n.resolve(e)
                }, function (e) {
                    n.reject(e)
                }, function (e) {
                    n.progress(e)
                }), t = n.promise) : t = r(e), t
            }

            function n(t) {
                return e(t, o)
            }

            function i(e) {
                this.then = e
            }

            function r(e) {
                var n = new i(function (n) {
                    try {
                        return t(n ? n(e) : e)
                    } catch (i) {
                        return o(i)
                    }
                });
                return n
            }

            function o(e) {
                var n = new i(function (n, i) {
                    try {
                        return i ? t(i(e)) : o(e)
                    } catch (r) {
                        return o(r)
                    }
                });
                return n
            }

            function a() {
                function e(e, t, n) {
                    return f(e, t, n)
                }

                function n(e) {
                    return p(e)
                }

                function r(e) {
                    return p(o(e))
                }

                function s(e) {
                    return h(e)
                }

                var u, l, c, d, f, h, p;
                return l = new i(e), u = {then: e, resolve: n, reject: r, progress: s, promise: l, resolver: {resolve: n, reject: r, progress: s}}, c = [], d = [], f = function (e, t, n) {
                    var i, r;
                    return i = a(), r = "function" == typeof n ? function (e) {
                        try {
                            i.progress(n(e))
                        } catch (t) {
                            i.progress(t)
                        }
                    } : function (e) {
                        i.progress(e)
                    }, c.push(function (n) {
                        n.then(e, t).then(i.resolve, i.reject, r)
                    }), d.push(r), i.promise
                }, h = function (e) {
                    return m(d, e), e
                }, p = function (e) {
                    return e = t(e), f = e.then, p = t, h = v, m(c, e), d = c = C, e
                }, u
            }

            function s(e) {
                return e && "function" == typeof e.then
            }

            function u(t, n, i, r, o) {
                return y(2, arguments), e(t, function (t) {
                    function s(e) {
                        m(e)
                    }

                    function u(e) {
                        p(e)
                    }

                    var l, c, d, f, h, p, m, y, g, _;
                    if (g = t.length >>> 0, l = Math.max(0, Math.min(n, g)), d = [], c = g - l + 1, f = [], h = a(), l)for (y = h.progress, m = function (e) {
                        f.push(e), --c || (p = m = v, h.reject(f))
                    }, p = function (e) {
                        d.push(e), --l || (p = m = v, h.resolve(d))
                    }, _ = 0; g > _; ++_)_ in t && e(t[_], u, s, y); else h.resolve(d);
                    return h.then(i, r, o)
                })
            }

            function l(e, t, n, i) {
                function r(e) {
                    return t ? t(e[0]) : e[0]
                }

                return u(e, 1, r, n, i)
            }

            function c(e, t, n, i) {
                return y(1, arguments), f(e, g).then(t, n, i)
            }

            function d() {
                return f(arguments, g)
            }

            function f(t, n) {
                return e(t, function (t) {
                    var i, r, o, s, u, l;
                    if (o = r = t.length >>> 0, i = [], l = a(), o)for (s = function (t, r) {
                        e(t, n).then(function (e) {
                            i[r] = e, --o || l.resolve(i)
                        }, l.reject)
                    }, u = 0; r > u; u++)u in t ? s(t[u], u) : --o; else l.resolve(i);
                    return l.promise
                })
            }

            function h(t, n) {
                var i = w.call(arguments, 1);
                return e(t, function (t) {
                    var r;
                    return r = t.length, i[0] = function (t, i, o) {
                        return e(t, function (t) {
                            return e(i, function (e) {
                                return n(t, e, o, r)
                            })
                        })
                    }, _.apply(t, i)
                })
            }

            function p(t, n, i) {
                var r = arguments.length > 2;
                return e(t, function (e) {
                    return e = r ? i : e, n.resolve(e), e
                }, function (e) {
                    return n.reject(e), o(e)
                }, n.progress)
            }

            function m(e, t) {
                for (var n, i = 0; n = e[i++];)n(t)
            }

            function y(e, t) {
                for (var n, i = t.length; i > e;)if (n = t[--i], null != n && "function" != typeof n)throw new Error("arg " + i + " must be a function")
            }

            function v() {
            }

            function g(e) {
                return e
            }

            var _, w, C;
            return e.defer = a, e.resolve = t, e.reject = n, e.join = d, e.all = c, e.map = f, e.reduce = h, e.any = l, e.some = u, e.chain = p, e.isPromise = s, i.prototype = {always: function (e, t) {
                return this.then(e, e, t)
            }, otherwise: function (e) {
                return this.then(C, e)
            }, yield: function (e) {
                return this.then(function () {
                    return e
                })
            }, spread: function (e) {
                return this.then(function (t) {
                    return c(t, function (t) {
                        return e.apply(C, t)
                    })
                })
            }}, w = [].slice, _ = [].reduce || function (e) {
                var t, n, i, r, o;
                if (o = 0, t = Object(this), r = t.length >>> 0, n = arguments, n.length <= 1)for (; ;) {
                    if (o in t) {
                        i = t[o++];
                        break
                    }
                    if (++o >= r)throw new TypeError
                } else i = n[1];
                for (; r > o; ++o)o in t && (i = e(i, t[o], o, t));
                return i
            }, e
        })
    }("function" == typeof n && n.amd ? n : function (e) {
        "object" == typeof exports ? module.exports = e() : this.when = e()
    }), n("Core/loadWithXhr", ["./DeveloperError", "./RequestErrorEvent", "../ThirdParty/when"], function (e, t, n) {
        "use strict";
        var i = function (t, r, o) {
            if ("undefined" == typeof t)throw new e("url is required.");
            return n(t, function (e) {
                var t = n.defer();
                return i.load(e, r, o, t), t.promise
            })
        };
        return i.load = function (e, n, i, r) {
            var o = new XMLHttpRequest;
            if (o.open("GET", e, !0), "undefined" != typeof i)for (var a in i)i.hasOwnProperty(a) && o.setRequestHeader(a, i[a]);
            "undefined" != typeof n && (o.responseType = n), o.onload = function () {
                200 === o.status ? r.resolve(o.response) : r.reject(new t(o.status, o.response))
            }, o.onerror = function () {
                r.reject(new t)
            }, o.send()
        }, i.defaultLoad = i.load, i
    }), n("Core/loadText", ["./loadWithXhr"], function (e) {
        "use strict";
        var t = function (t, n) {
            return e(t, void 0, n)
        };
        return t
    }), n("Core/loadJson", ["./clone", "./defaultValue", "./loadText", "./DeveloperError"], function (e, t, n, i) {
        "use strict";
        var r = function (r, o) {
            if ("undefined" == typeof r)throw new i("url is required.");
            return o = e(t(o, t.EMPTY_OBJECT)), o.Accept = "application/json", n(r, o).then(function (e) {
                return JSON.parse(e)
            })
        };
        return r
    }), n("Core/EarthOrientationParametersSample", [], function () {
        "use strict";
        var e = function (e, t, n, i, r) {
            this.xPoleWander = e, this.yPoleWander = t, this.xPoleOffset = n, this.yPoleOffset = i, this.ut1MinusUtc = r
        };
        return e
    }), n("Core/EarthOrientationParameters", ["./binarySearch", "./defaultValue", "./freezeObject", "./loadJson", "./EarthOrientationParametersSample", "./JulianDate", "./LeapSecond", "./RuntimeError", "./TimeConstants", "./TimeStandard", "../ThirdParty/when"], function (e, t, n, i, r, o, a, s, u, l, c) {
        "use strict";
        function d(e, t) {
            return o.compare(e.julianDate, t)
        }

        function f(t, n) {
            if ("undefined" == typeof n.columnNames)return t._dataError = "Error in loaded EOP data: The columnNames property is required.", void 0;
            if ("undefined" == typeof n.samples)return t._dataError = "Error in loaded EOP data: The samples property is required.", void 0;
            var i = n.columnNames.indexOf("modifiedJulianDateUtc"), r = n.columnNames.indexOf("xPoleWanderRadians"), s = n.columnNames.indexOf("yPoleWanderRadians"), c = n.columnNames.indexOf("ut1MinusUtcSeconds"), f = n.columnNames.indexOf("xCelestialPoleOffsetRadians"), h = n.columnNames.indexOf("yCelestialPoleOffsetRadians"), p = n.columnNames.indexOf("taiMinusUtcSeconds");
            if (0 > i || 0 > r || 0 > s || 0 > c || 0 > f || 0 > h || 0 > p)return t._dataError = "Error in loaded EOP data: The columnNames property must include modifiedJulianDateUtc, xPoleWanderRadians, yPoleWanderRadians, ut1MinusUtcSeconds, xCelestialPoleOffsetRadians, yCelestialPoleOffsetRadians, and taiMinusUtcSeconds columns", void 0;
            var m = t._samples = n.samples, y = t._dates = [];
            t._dateColumn = i, t._xPoleWanderRadiansColumn = r, t._yPoleWanderRadiansColumn = s, t._ut1MinusUtcSecondsColumn = c, t._xCelestialPoleOffsetRadiansColumn = f, t._yCelestialPoleOffsetRadiansColumn = h, t._taiMinusUtcSecondsColumn = p, t._columnCount = n.columnNames.length, t._lastIndex = void 0;
            for (var v, g = t._addNewLeapSeconds, _ = 0, w = m.length; w > _; _ += t._columnCount) {
                var C = m[_ + i], x = m[_ + p], S = C + u.MODIFIED_JULIAN_DATE_DIFFERENCE, b = new o(S, x, l.TAI);
                if (y.push(b), g) {
                    if (x !== v && "undefined" != typeof v) {
                        var T = a.getLeapSeconds(), E = e(T, b, d);
                        if (0 > E) {
                            var A = new a(b, x);
                            T.splice(~E, 0, A)
                        }
                    }
                    v = x
                }
            }
        }

        function h(e, t, n, i, r) {
            var o = n * i;
            r.xPoleWander = t[o + e._xPoleWanderRadiansColumn], r.yPoleWander = t[o + e._yPoleWanderRadiansColumn], r.xPoleOffset = t[o + e._xCelestialPoleOffsetRadiansColumn], r.yPoleOffset = t[o + e._yCelestialPoleOffsetRadiansColumn], r.ut1MinusUtc = t[o + e._ut1MinusUtcSecondsColumn]
        }

        function p(e, t, n) {
            return t + e * (n - t)
        }

        function m(e, t, n, i, r, o, a) {
            var s = e._columnCount;
            if (o > t.length - 1)return a.xPoleWander = 0, a.yPoleWander = 0, a.xPoleOffset = 0, a.yPoleOffset = 0, a.ut1MinusUtc = 0, a;
            var u = t[r], l = t[o];
            if (u.equals(l) || i.equals(u))return h(e, n, r, s, a), a;
            if (i.equals(l))return h(e, n, o, s, a), a;
            var c = u.getSecondsDifference(i) / u.getSecondsDifference(l), d = r * s, f = o * s, m = n[d + e._ut1MinusUtcSecondsColumn], y = n[f + e._ut1MinusUtcSecondsColumn], v = y - m;
            if (v > .5 || -.5 > v) {
                var g = n[d + e._taiMinusUtcSecondsColumn], _ = n[f + e._taiMinusUtcSecondsColumn];
                g !== _ && (l.equals(i) ? m = y : y -= _ - g)
            }
            return a.xPoleWander = p(c, n[d + e._xPoleWanderRadiansColumn], n[f + e._xPoleWanderRadiansColumn]), a.yPoleWander = p(c, n[d + e._yPoleWanderRadiansColumn], n[f + e._yPoleWanderRadiansColumn]), a.xPoleOffset = p(c, n[d + e._xCelestialPoleOffsetRadiansColumn], n[f + e._xCelestialPoleOffsetRadiansColumn]), a.yPoleOffset = p(c, n[d + e._yCelestialPoleOffsetRadiansColumn], n[f + e._yCelestialPoleOffsetRadiansColumn]), a.ut1MinusUtc = p(c, m, y), a
        }

        var y = function (e) {
            if (e = t(e, t.EMPTY_OBJECT), this._dates = void 0, this._samples = void 0, this._dateColumn = -1, this._xPoleWanderRadiansColumn = -1, this._yPoleWanderRadiansColumn = -1, this._ut1MinusUtcSecondsColumn = -1, this._xCelestialPoleOffsetRadiansColumn = -1, this._yCelestialPoleOffsetRadiansColumn = -1, this._taiMinusUtcSecondsColumn = -1, this._columnCount = 0, this._lastIndex = -1, this._downloadPromise = void 0, this._dataError = void 0, this._addNewLeapSeconds = t(e.addNewLeapSeconds, !0), "undefined" != typeof e.data)f(this, e.data); else if ("undefined" != typeof e.url) {
                var n = this;
                this._downloadPromise = c(i(e.url), function (e) {
                    f(n, e)
                }, function () {
                    n._dataError = "An error occurred while retrieving the EOP data from the URL " + e.url + "."
                })
            } else f(this, {columnNames: ["dateIso8601", "modifiedJulianDateUtc", "xPoleWanderRadians", "yPoleWanderRadians", "ut1MinusUtcSeconds", "lengthOfDayCorrectionSeconds", "xCelestialPoleOffsetRadians", "yCelestialPoleOffsetRadians", "taiMinusUtcSeconds"], samples: []})
        };
        return y.NONE = n({getPromiseToLoad: function () {
            return c()
        }, compute: function (e, t) {
            return"undefined" == typeof t ? t = new r(0, 0, 0, 0, 0) : (t.xPoleWander = 0, t.yPoleWander = 0, t.xPoleOffset = 0, t.yPoleOffset = 0, t.ut1MinusUtc = 0), t
        }}), y.prototype.getPromiseToLoad = function () {
            return c(this._downloadPromise)
        }, y.prototype.compute = function (t, n) {
            if ("undefined" == typeof this._samples) {
                if ("undefined" != typeof this._dataError)throw new s(this._dataError);
                return void 0
            }
            if ("undefined" == typeof n && (n = new r(0, 0, 0, 0, 0)), 0 === this._samples.length)return n.xPoleWander = 0, n.yPoleWander = 0, n.xPoleOffset = 0, n.yPoleOffset = 0, n.ut1MinusUtc = 0, n;
            var i = this._dates, a = this._lastIndex, u = 0, l = 0;
            if ("undefined" != typeof a) {
                var c = i[a], d = i[a + 1], f = c.lessThanOrEquals(t), h = "undefined" == typeof d, p = h || d.greaterThanOrEquals(t);
                if (f && p)return u = a, !h && d.equals(t) && ++u, l = u + 1, m(this, i, this._samples, t, u, l, n), n
            }
            var y = e(i, t, o.compare, this._dateColumn);
            return y >= 0 ? (y < i.length - 1 && i[y + 1].equals(t) && ++y, u = y, l = y) : (l = ~y, u = l - 1, 0 > u && (u = 0)), this._lastIndex = u, m(this, i, this._samples, t, u, l, n), n
        }, y
    }), n("Core/EllipsoidGeometry", ["./defaultValue", "./DeveloperError", "./Cartesian3", "./Math", "./Ellipsoid", "./ComponentDatatype", "./IndexDatatype", "./PrimitiveType", "./BoundingSphere", "./GeometryAttribute", "./GeometryAttributes", "./VertexFormat"], function (e, t, n, i, r, o, a, s, u, l, c, d) {
        "use strict";
        function f(e, t, i, r) {
            var o = new Array(2 + i - 1);
            o[0] = e;
            for (var a = r[e], s = n.subtract(r[t], r[e], p), u = 1; i > u; ++u) {
                var l = u / i, c = n.multiplyByScalar(s, l);
                n.add(a, c, c), o[u] = r.length, r.push(c)
            }
            return o[2 + (i - 1) - 1] = t, o
        }

        function h(e, t, i, r, o, a, s) {
            for (var u = a[t[0]], l = n.subtract(a[t[t.length - 1]], u, m), c = n.subtract(a[r[0]], u, y), d = [], f = [], h = t, p = f, _ = 1; o >= _; ++_) {
                if (_ !== o) {
                    1 !== _ && (d = f.slice(0), h = d), f[0] = e[_], f[o] = i[_];
                    for (var w = _ / o, C = n.multiplyByScalar(c, w, g), x = 1; o > x; ++x) {
                        var S = x / o, b = n.multiplyByScalar(l, S, v), T = n.add(u, b);
                        n.add(T, C, T), f[x] = a.length, a.push(T)
                    }
                } else 1 !== _ && (h = f), p = r;
                for (var E = 0; o > E; ++E)s.push(h[E]), s.push(h[E + 1]), s.push(p[E + 1]), s.push(h[E]), s.push(p[E + 1]), s.push(p[E])
            }
        }

        var p = new n, m = new n, y = new n, v = new n, g = new n, _ = new n, w = new n, C = new n, x = new n, S = new n(1, 1, 1), b = function (p) {
            p = e(p, e.EMPTY_OBJECT);
            var m = e(p.radii, S), y = r.fromCartesian3(m), v = e(p.numberOfPartitions, 32), g = e(p.vertexFormat, d.DEFAULT);
            if (0 >= v)throw new t("options.numberOfPartitions must be greater than zero.");
            var b = [], T = [];
            b.push(new n(-1, 0, -1)), b.push(new n(0, -1, -1)), b.push(new n(1, 0, -1)), b.push(new n(0, 1, -1)), b.push(new n(-1, 0, 1)), b.push(new n(0, -1, 1)), b.push(new n(1, 0, 1)), b.push(new n(0, 1, 1));
            var E = f(0, 1, v, b), A = f(1, 2, v, b), M = f(2, 3, v, b), D = f(3, 0, v, b), I = f(4, 5, v, b), P = f(5, 6, v, b), O = f(6, 7, v, b), R = f(7, 4, v, b), z = f(0, 4, v, b), L = f(1, 5, v, b), N = f(2, 6, v, b), F = f(3, 7, v, b);
            h(z, E, L, I, v, b, T), h(L, A, N, P, v, b, T), h(N, M, F, O, v, b, T), h(F, D, z, R, v, b, T), h(R.slice(0).reverse(), I, P, O.slice(0).reverse(), v, b, T), h(A, E.slice(0).reverse(), D.slice(0).reverse(), M, v, b, T);
            var V, B, k = new c, U = b.length;
            if (g.position) {
                var q = new Float64Array(3 * U);
                for (V = B = 0; U > V; ++V) {
                    var W = b[V];
                    n.normalize(W, W), n.multiplyComponents(W, m, W), q[B++] = W.x, q[B++] = W.y, q[B++] = W.z
                }
                k.position = new l({componentDatatype: o.DOUBLE, componentsPerAttribute: 3, values: q})
            }
            if (g.st) {
                var H = new Float32Array(2 * U), G = y.getOneOverRadii();
                for (V = B = 0; U > V; ++V)n.multiplyComponents(b[V], G, _), n.normalize(_, _), H[B++] = Math.atan2(_.y, _.x) * i.ONE_OVER_TWO_PI + .5, H[B++] = Math.asin(_.z) * i.ONE_OVER_PI + .5;
                k.st = new l({componentDatatype: o.FLOAT, componentsPerAttribute: 2, values: H})
            }
            if (g.normal || g.tangent || g.binormal) {
                var j = g.normal ? new Float32Array(3 * U) : void 0, Y = g.tangent ? new Float32Array(3 * U) : void 0, X = g.binormal ? new Float32Array(3 * U) : void 0;
                for (V = B = 0; U > V; ++V, B += 3)y.geodeticSurfaceNormal(b[V], w), n.cross(n.UNIT_Z, w, C).normalize(C), n.cross(w, C, x).normalize(x), g.normal && (j[B] = w.x, j[B + 1] = w.y, j[B + 2] = w.z), g.tangent && (Y[B] = C.x, Y[B + 1] = C.y, Y[B + 2] = C.z), g.binormal && (X[B] = x.x, X[B + 1] = x.y, X[B + 2] = x.z);
                g.normal && (k.normal = new l({componentDatatype: o.FLOAT, componentsPerAttribute: 3, values: j})), g.tangent && (k.tangent = new l({componentDatatype: o.FLOAT, componentsPerAttribute: 3, values: Y})), g.binormal && (k.binormal = new l({componentDatatype: o.FLOAT, componentsPerAttribute: 3, values: X}))
            }
            this.attributes = k, this.indices = a.createTypedArray(U, T), this.primitiveType = s.TRIANGLES, this.boundingSphere = u.fromEllipsoid(y)
        };
        return b
    }), n("Core/buildModuleUrl", ["require", "./DeveloperError"], function (e, t) {
        "use strict";
        function n() {
            if ("undefined" != typeof o)return o;
            if ("undefined" != typeof CESIUM_BASE_URL)o = CESIUM_BASE_URL; else for (var e = /(.*?)Cesium\w*\.js(?:\W|$)/i, n = document.getElementsByTagName("script"), i = 0, r = n.length; r > i; ++i) {
                var a = n[i].getAttribute("src"), s = e.exec(a);
                if (null !== s) {
                    o = s[1];
                    break
                }
            }
            if ("undefined" == typeof o)throw new t("Unable to determine Cesium base URL automatically, try defining a global variable called CESIUM_BASE_URL.");
            return/\/$/.test(o) || (o += "/"), o
        }

        function i(t) {
            return e.toUrl("../" + t)
        }

        function r(e) {
            return n() + e
        }

        var o, a, s, u = function (t) {
            "undefined" == typeof a && (a = "undefined" != typeof e.toUrl ? i : r), "undefined" == typeof s && (s = document.createElement("a"));
            var n = a(t);
            return s.href = n, s.href = s.href, s.href
        };
        return u
    }), n("Core/Iau2006XysSample", [], function () {
        "use strict";
        var e = function (e, t, n) {
            this.x = e, this.y = t, this.s = n
        };
        return e
    }), n("Core/Iau2006XysData", ["./buildModuleUrl", "./defaultValue", "./Iau2006XysSample", "./JulianDate", "./loadJson", "./TimeStandard", "../ThirdParty/when"], function (e, t, n, i, r, o, a) {
        "use strict";
        function s(e, t, n) {
            var i = c;
            return i._julianDayNumber = t, i._secondsOfDay = n, e._sampleZeroDateTT.getDaysDifference(i)
        }

        function u(t, n) {
            if (t._chunkDownloadsInProgress[n])return t._chunkDownloadsInProgress[n];
            var i = a.defer();
            t._chunkDownloadsInProgress[n] = i;
            var o, s = t._xysFileUrlTemplate;
            return o = "undefined" != typeof s ? s.replace("{0}", n) : e("Assets/IAU2006_XYS/IAU2006_XYS_" + n + ".json"), a(r(o), function (e) {
                t._chunkDownloadsInProgress[n] = !1;
                for (var r = t._samples, o = e.samples, a = 3 * n * t._samplesPerXysFile, s = 0, u = o.length; u > s; ++s)r[a + s] = o[s];
                i.resolve()
            }), i.promise
        }

        var l = function (e) {
            e = t(e, t.EMPTY_OBJECT), this._xysFileUrlTemplate = e.xysFileUrlTemplate, this._interpolationOrder = t(e.interpolationOrder, 9), this._sampleZeroJulianEphemerisDate = t(e.sampleZeroJulianEphemerisDate, 2442396.5), this._sampleZeroDateTT = new i(this._sampleZeroJulianEphemerisDate, 0, o.TAI), this._stepSizeDays = t(e.stepSizeDays, 1), this._samplesPerXysFile = t(e.samplesPerXysFile, 1e3), this._totalSamples = t(e.totalSamples, 27426), this._samples = new Array(3 * this._totalSamples), this._chunkDownloadsInProgress = [];
            for (var n = this._interpolationOrder, r = this._denominators = new Array(n + 1), a = this._xTable = new Array(n + 1), s = Math.pow(this._stepSizeDays, n), u = 0; n >= u; ++u) {
                r[u] = s, a[u] = u * this._stepSizeDays;
                for (var l = 0; n >= l; ++l)l !== u && (r[u] *= u - l);
                r[u] = 1 / r[u]
            }
            this._work = new Array(n + 1), this._coef = new Array(n + 1)
        }, c = new i(0, 0, o.TAI);
        return l.prototype.preload = function (e, t, n, i) {
            var r = s(this, e, t), o = s(this, n, i), l = 0 | r / this._stepSizeDays - this._interpolationOrder / 2;
            0 > l && (l = 0);
            var c = o / this._stepSizeDays - this._interpolationOrder / 2 | 0 + this._interpolationOrder;
            c >= this._totalSamples && (c = this._totalSamples - 1);
            for (var d = 0 | l / this._samplesPerXysFile, f = 0 | c / this._samplesPerXysFile, h = [], p = d; f >= p; ++p)h.push(u(this, p));
            return a.all(h)
        }, l.prototype.computeXysRadians = function (e, t, i) {
            var r = s(this, e, t);
            if (0 > r)return void 0;
            var o = 0 | r / this._stepSizeDays;
            if (o >= this._totalSamples)return void 0;
            var a = this._interpolationOrder, l = o - (0 | a / 2);
            0 > l && (l = 0);
            var c = l + a;
            c >= this._totalSamples && (c = this._totalSamples - 1, l = c - a, 0 > l && (l = 0));
            var d = !1, f = this._samples;
            if ("undefined" == typeof f[3 * l] && (u(this, 0 | l / this._samplesPerXysFile), d = !0), "undefined" == typeof f[3 * c] && (u(this, 0 | c / this._samplesPerXysFile), d = !0), d)return void 0;
            "undefined" == typeof i ? i = new n(0, 0, 0) : (i.x = 0, i.y = 0, i.s = 0);
            var h, p, m = r - l * this._stepSizeDays, y = this._work, v = this._denominators, g = this._coef, _ = this._xTable;
            for (h = 0; a >= h; ++h)y[h] = m - _[h];
            for (h = 0; a >= h; ++h) {
                for (g[h] = 1, p = 0; a >= p; ++p)p !== h && (g[h] *= y[p]);
                g[h] *= v[h];
                var w = 3 * (l + h);
                i.x += g[h] * f[w++], i.y += g[h] * f[w++], i.s += g[h] * f[w]
            }
            return i
        }, l
    }), n("Core/Transforms", ["./defaultValue", "./DeveloperError", "./Iau2006XysData", "./Iau2006XysSample", "./Math", "./Matrix3", "./Matrix4", "./Cartesian2", "./Cartesian3", "./Cartesian4", "./TimeConstants", "./Ellipsoid", "./EarthOrientationParameters", "./EarthOrientationParametersSample", "../ThirdParty/when"], function (e, t, n, i, r, o, a, s, u, l, c, d, f, h, p) {
        "use strict";
        var m = {}, y = new u, v = new u, g = new u;
        m.eastNorthUpToFixedFrame = function (n, i, o) {
            if ("undefined" == typeof n)throw new t("origin is required.");
            if (r.equalsEpsilon(n.x, 0, r.EPSILON14) && r.equalsEpsilon(n.y, 0, r.EPSILON14)) {
                var s = r.sign(n.z);
                return"undefined" == typeof o ? new a(0, -s, 0, n.x, 1, 0, 0, n.y, 0, 0, s, n.z, 0, 0, 0, 1) : (o[0] = 0, o[1] = 1, o[2] = 0, o[3] = 0, o[4] = -s, o[5] = 0, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = s, o[11] = 0, o[12] = n.x, o[13] = n.y, o[14] = n.z, o[15] = 1, o)
            }
            var l = y, c = v, f = g;
            return i = e(i, d.WGS84), i.geodeticSurfaceNormal(n, l), c.x = -n.y, c.y = n.x, c.z = 0, u.normalize(c, c), l.cross(c, f), "undefined" == typeof o ? new a(c.x, f.x, l.x, n.x, c.y, f.y, l.y, n.y, c.z, f.z, l.z, n.z, 0, 0, 0, 1) : (o[0] = c.x, o[1] = c.y, o[2] = c.z, o[3] = 0, o[4] = f.x, o[5] = f.y, o[6] = f.z, o[7] = 0, o[8] = l.x, o[9] = l.y, o[10] = l.z, o[11] = 0, o[12] = n.x, o[13] = n.y, o[14] = n.z, o[15] = 1, o)
        };
        var _ = new u, w = new u, C = new u;
        m.northEastDownToFixedFrame = function (n, i, o) {
            if ("undefined" == typeof n)throw new t("origin is required.");
            if (r.equalsEpsilon(n.x, 0, r.EPSILON14) && r.equalsEpsilon(n.y, 0, r.EPSILON14)) {
                var s = r.sign(n.z);
                return"undefined" == typeof o ? new a(-s, 0, 0, n.x, 0, 1, 0, n.y, 0, 0, -s, n.z, 0, 0, 0, 1) : (o[0] = -s, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = 1, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = -s, o[11] = 0, o[12] = n.x, o[13] = n.y, o[14] = n.z, o[15] = 1, o)
            }
            var l = _, c = w, f = C;
            return i = e(i, d.WGS84), i.geodeticSurfaceNormal(n, l), c.x = -n.y, c.y = n.x, c.z = 0, u.normalize(c, c), l.cross(c, f), "undefined" == typeof o ? new a(f.x, c.x, -l.x, n.x, f.y, c.y, -l.y, n.y, f.z, c.z, -l.z, n.z, 0, 0, 0, 1) : (o[0] = f.x, o[1] = f.y, o[2] = f.z, o[3] = 0, o[4] = c.x, o[5] = c.y, o[6] = c.z, o[7] = 0, o[8] = -l.x, o[9] = -l.y, o[10] = -l.z, o[11] = 0, o[12] = n.x, o[13] = n.y, o[14] = n.z, o[15] = 1, o)
        };
        var x = 24110.54841, S = 8640184.812866, b = .093104, T = -62e-7, E = 1.1772758384668e-19, A = 72921158553e-15, M = r.TWO_PI / 86400;
        m.computeTemeToPseudoFixedMatrix = function (e, n) {
            if ("undefined" == typeof e)throw new t("date is required.");
            var i, a = e.addSeconds(-e.getTaiMinusUtc()), s = a.getJulianDayNumber(), u = a.getSecondsOfDay(), l = s - 2451545;
            i = u >= 43200 ? (l + .5) / c.DAYS_PER_JULIAN_CENTURY : (l - .5) / c.DAYS_PER_JULIAN_CENTURY;
            var d = x + i * (S + i * (b + i * T)), f = d * M % r.TWO_PI, h = A + E * (s - 2451545.5), p = (u + .5 * c.SECONDS_PER_DAY) % c.SECONDS_PER_DAY, m = f + h * p, y = Math.cos(m), v = Math.sin(m);
            return"undefined" == typeof n ? new o(y, v, 0, -v, y, 0, 0, 0, 1) : (n[0] = y, n[1] = -v, n[2] = 0, n[3] = v, n[4] = y, n[5] = 0, n[6] = 0, n[7] = 0, n[8] = 1, n)
        }, m.iau2006XysData = new n, m.earthOrientationParameters = f.NONE;
        var D = 32.184, I = 2451545;
        m.preloadIcrfFixed = function (e) {
            var t = e.start.getJulianDayNumber(), n = e.start.getSecondsOfDay() + D, i = e.stop.getJulianDayNumber(), r = e.stop.getSecondsOfDay() + D, o = m.iau2006XysData.preload(t, n, i, r), a = m.earthOrientationParameters.getPromiseToLoad();
            return p.all([o, a])
        }, m.computeIcrfToFixedMatrix = function (e, n) {
            if ("undefined" == typeof e)throw new t("date is required.");
            var i = m.computeFixedToIcrfMatrix(e, n);
            return"undefined" == typeof i ? void 0 : i.transpose(n)
        };
        var P = new i(0, 0, 0), O = new h(0, 0, 0, 0, 0, 0), R = new o, z = new o;
        m.computeFixedToIcrfMatrix = function (e, n) {
            if ("undefined" == typeof e)throw new t("date is required.");
            var i = m.earthOrientationParameters.compute(e, O);
            if ("undefined" == typeof i)return void 0;
            var a = e.getJulianDayNumber(), s = e.getSecondsOfDay() + D, u = m.iau2006XysData.computeXysRadians(a, s, P);
            if ("undefined" == typeof u)return void 0;
            var l = u.x + i.xPoleOffset, d = u.y + i.yPoleOffset, f = 1 / (1 + Math.sqrt(1 - l * l - d * d)), h = R;
            h[0] = 1 - f * l * l, h[3] = -f * l * d, h[6] = l, h[1] = -f * l * d, h[4] = 1 - f * d * d, h[7] = d, h[2] = -l, h[5] = -d, h[8] = 1 - f * (l * l + d * d);
            var p = o.fromRotationZ(-u.s, z), y = h.multiply(p, R), v = e.getJulianDayNumber(), g = e.getSecondsOfDay() - e.getTaiMinusUtc() + i.ut1MinusUtc, _ = v - 2451545, w = g / c.SECONDS_PER_DAY, C = .779057273264 + w + .00273781191135448 * (_ + w);
            C = C % 1 * r.TWO_PI;
            var x = o.fromRotationZ(C, z), S = y.multiply(x, R), b = Math.cos(i.xPoleWander), T = Math.cos(i.yPoleWander), E = Math.sin(i.xPoleWander), A = Math.sin(i.yPoleWander), M = a - I + s / c.SECONDS_PER_DAY;
            M /= 36525;
            var L = -47e-6 * M * r.RADIANS_PER_DEGREE / 3600, N = Math.cos(L), F = Math.sin(L), V = z;
            return V[0] = b * N, V[1] = b * F, V[2] = E, V[3] = -T * F + A * E * N, V[4] = T * N + A * E * F, V[5] = -A * b, V[6] = -A * F - T * E * N, V[7] = A * N - T * E * F, V[8] = T * b, S.multiply(V, n)
        };
        var L = new l;
        return m.pointToWindowCoordinates = function (e, n, i, r) {
            if ("undefined" == typeof e)throw new t("modelViewProjectionMatrix is required.");
            if ("undefined" == typeof n)throw new t("viewportTransformation is required.");
            if ("undefined" == typeof i)throw new t("point is required.");
            var o = L;
            return a.multiplyByPoint(e, i, o), l.multiplyByScalar(o, 1 / o.w, o), a.multiplyByVector(n, o, o), s.fromCartesian4(o, r)
        }, m
    }), n("Core/Ray", ["./DeveloperError", "./defaultValue", "./Cartesian3"], function (e, t, n) {
        "use strict";
        var i = function (e, i) {
            i = n.clone(t(i, n.ZERO)), i.equals(n.ZERO) || n.normalize(i, i), this.origin = n.clone(t(e, n.ZERO)), this.direction = i
        };
        return i.prototype.getPoint = function (t, i) {
            if ("number" != typeof t)throw new e("t is a required number");
            return i = n.multiplyByScalar(this.direction, t, i), n.add(this.origin, i, i)
        }, i
    }), n("Core/EllipsoidTangentPlane", ["./defaultValue", "./DeveloperError", "./Transforms", "./AxisAlignedBoundingBox", "./IntersectionTests", "./Cartesian2", "./Cartesian3", "./Ellipsoid", "./Ray", "./Plane"], function (e, t, n, i, r, o, a, s, u, l) {
        "use strict";
        var c = function (i, r) {
            if ("undefined" == typeof i)throw new t("origin is required.");
            if (r = e(r, s.WGS84), i = r.scaleToGeodeticSurface(i), "undefined" == typeof i)throw new t("origin must not be at the center of the ellipsoid.");
            var o = n.eastNorthUpToFixedFrame(i, r);
            this._ellipsoid = r, this._origin = a.clone(i), this._xAxis = a.fromCartesian4(o.getColumn(0)), this._yAxis = a.fromCartesian4(o.getColumn(1));
            var u = a.fromCartesian4(o.getColumn(2)), c = -a.dot(i, i);
            this._plane = new l(u, c)
        }, d = new i;
        c.fromPoints = function (e, n) {
            if ("undefined" == typeof e)throw new t("cartesians is required.");
            var r = i.fromPoints(e, d);
            return new c(r.center, n)
        }, c.prototype.getEllipsoid = function () {
            return this._ellipsoid
        }, c.prototype.getOrigin = function () {
            return this._origin
        };
        var f = new u, h = new a;
        c.prototype.projectPointOntoPlane = function (e, n) {
            if ("undefined" == typeof e)throw new t("cartesian is required.");
            var i = f;
            i.origin = e, a.normalize(e, i.direction);
            var s = r.rayPlane(i, this._plane, h);
            if ("undefined" != typeof s) {
                var u = s.subtract(this._origin, s), l = this._xAxis.dot(u), c = this._yAxis.dot(u);
                return"undefined" == typeof n ? new o(l, c) : (n.x = l, n.y = c, n)
            }
            return void 0
        }, c.prototype.projectPointsOntoPlane = function (e, n) {
            if ("undefined" == typeof e)throw new t("cartesians is required.");
            "undefined" == typeof n && (n = []);
            for (var i = 0, r = e.length, o = 0; r > o; o++) {
                var a = this.projectPointOntoPlane(e[o], n[i]);
                "undefined" != typeof a && (n[i] = a, i++)
            }
            return n.length = i, n
        };
        var p = new a;
        return c.prototype.projectPointsOntoEllipsoid = function (e, n) {
            if ("undefined" == typeof e)throw new t("cartesians is required.");
            var i = e.length;
            "undefined" == typeof n ? n = new Array(i) : n.length = i;
            for (var r = this._ellipsoid, o = this._origin, s = this._xAxis, u = this._yAxis, l = p, c = 0; i > c; ++c) {
                var d = e[c];
                s.multiplyByScalar(d.x, l);
                var f = n[c] = a.add(o, l, n[c]);
                u.multiplyByScalar(d.y, l), a.add(f, l, f), r.scaleToGeocentricSurface(f, f)
            }
            return n
        }, c
    }), n("Core/EllipsoidalOccluder", ["./defaultValue", "./DeveloperError", "./Cartesian3", "./BoundingSphere"], function (e, t, n, i) {
        "use strict";
        function r(e, t, n) {
            var i = e.transformPositionToScaledSpace(t, d), r = i.magnitudeSquared(), o = Math.sqrt(r), a = i.divideByScalar(o, f);
            r = Math.max(1, r), o = Math.max(1, o);
            var s = a.dot(n), u = a.cross(n).magnitude(), l = 1 / o, c = Math.sqrt(r - 1) * l;
            return 1 / (s * l - u * c)
        }

        function o(e, t, n) {
            return 0 >= t || t === 1 / 0 || t !== t ? void 0 : e.multiplyByScalar(t, n)
        }

        function a(e, t) {
            return e.transformPositionToScaledSpace(t, h), h.normalize(h)
        }

        var s = function (e, i) {
            if ("undefined" == typeof e)throw new t("ellipsoid is required.");
            this._ellipsoid = e, this._cameraPosition = new n, this._cameraPositionInScaledSpace = new n, this._distanceToLimbInScaledSpaceSquared = 0, "undefined" != typeof i && this.setCameraPosition(i)
        };
        s.prototype.getEllipsoid = function () {
            return this._ellipsoid
        }, s.prototype.setCameraPosition = function (e) {
            var t = this._ellipsoid, i = t.transformPositionToScaledSpace(e, this._cameraPositionInScaledSpace), r = n.magnitudeSquared(i) - 1;
            n.clone(e, this._cameraPosition), this._cameraPositionInScaledSpace = i, this._distanceToLimbInScaledSpaceSquared = r
        }, s.prototype.getCameraPosition = function () {
            return this._cameraPosition
        };
        var u = new n;
        s.prototype.isPointVisible = function (e) {
            var t = this._ellipsoid, n = t.transformPositionToScaledSpace(e, u);
            return this.isScaledSpacePointVisible(n)
        }, s.prototype.isScaledSpacePointVisible = function (e) {
            var t = this._cameraPositionInScaledSpace, i = this._distanceToLimbInScaledSpaceSquared, r = n.subtract(e, t, u), o = -r.dot(t), a = o > i && o * o / r.magnitudeSquared() > i;
            return!a
        }, s.prototype.computeHorizonCullingPoint = function (e, n, i) {
            if ("undefined" == typeof e)throw new t("directionToPoint is required");
            if ("undefined" == typeof n)throw new t("positions is required");
            for (var s = this._ellipsoid, u = a(s, e), l = 0, c = 0, d = n.length; d > c; ++c) {
                var f = n[c], h = r(s, f, u);
                l = Math.max(l, h)
            }
            return o(u, l, i)
        };
        var l = new n;
        s.prototype.computeHorizonCullingPointFromVertices = function (i, s, u, c, d) {
            if ("undefined" == typeof i)throw new t("directionToPoint is required");
            if ("undefined" == typeof s)throw new t("vertices is required");
            if ("undefined" == typeof u)throw new t("stride is required");
            c = e(c, n.ZERO);
            for (var f = this._ellipsoid, h = a(f, i), p = 0, m = 0, y = s.length; y > m; m += u) {
                l.x = s[m] + c.x, l.y = s[m + 1] + c.y, l.z = s[m + 2] + c.z;
                var v = r(f, l, h);
                p = Math.max(p, v)
            }
            return o(h, p, d)
        };
        var c = [];
        s.prototype.computeHorizonCullingPointFromExtent = function (e, n, r) {
            if ("undefined" == typeof e)throw new t("extent is required.");
            var o = e.subsample(n, 0, c), a = i.fromPoints(o);
            return a.center.magnitude() < .1 * n.getMinimumRadius() ? void 0 : this.computeHorizonCullingPoint(a.center, o, r)
        };
        var d = new n, f = new n, h = new n;
        return s
    }), n("Core/EventHelper", ["./DeveloperError"], function (e) {
        "use strict";
        var t = function () {
            this._removalFunctions = []
        };
        return t.prototype.add = function (t, n, i) {
            if ("undefined" == typeof t)throw new e("event is required");
            this._removalFunctions.push(t.addEventListener(n, i))
        }, t.prototype.removeAll = function () {
            for (var e = this._removalFunctions, t = 0, n = e.length; n > t; ++t)e[t]();
            e.length = 0
        }, t
    }), n("Core/Extent", ["./freezeObject", "./defaultValue", "./Ellipsoid", "./Cartographic", "./DeveloperError", "./Math"], function (e, t, n, i, r, o) {
        "use strict";
        var a = function (e, n, i, r) {
            this.west = t(e, 0), this.south = t(n, 0), this.east = t(i, 0), this.north = t(r, 0)
        };
        a.fromDegrees = function (e, n, i, r, s) {
            return e = o.toRadians(t(e, 0)), n = o.toRadians(t(n, 0)), i = o.toRadians(t(i, 0)), r = o.toRadians(t(r, 0)), "undefined" == typeof s ? new a(e, n, i, r) : (s.west = e, s.south = n, s.east = i, s.north = r, s)
        }, a.fromCartographicArray = function (e, t) {
            if ("undefined" == typeof e)throw new r("cartographics is required.");
            for (var n = Number.MAX_VALUE, i = -Number.MAX_VALUE, o = Number.MAX_VALUE, s = -Number.MAX_VALUE, u = 0, l = e.length; l > u; u++) {
                var c = e[u];
                n = Math.min(n, c.longitude), i = Math.max(i, c.longitude), o = Math.min(o, c.latitude), s = Math.max(s, c.latitude)
            }
            return"undefined" == typeof t ? new a(n, o, i, s) : (t.west = n, t.south = o, t.east = i, t.north = s, t)
        }, a.clone = function (e, t) {
            return"undefined" == typeof e ? void 0 : "undefined" == typeof t ? new a(e.west, e.south, e.east, e.north) : (t.west = e.west, t.south = e.south, t.east = e.east, t.north = e.north, t)
        }, a.prototype.clone = function (e) {
            return a.clone(this, e)
        }, a.prototype.equals = function (e) {
            return a.equals(this, e)
        }, a.equals = function (e, t) {
            return e === t || "undefined" != typeof e && "undefined" != typeof t && e.west === t.west && e.south === t.south && e.east === t.east && e.north === t.north
        }, a.prototype.equalsEpsilon = function (e, t) {
            if ("number" != typeof t)throw new r("epsilon is required and must be a number.");
            return"undefined" != typeof e && Math.abs(this.west - e.west) <= t && Math.abs(this.south - e.south) <= t && Math.abs(this.east - e.east) <= t && Math.abs(this.north - e.north) <= t
        }, a.prototype.validate = function () {
            var e = this.north;
            if ("number" != typeof e)throw new r("north is required to be a number.");
            if (e < -o.PI_OVER_TWO || e > o.PI_OVER_TWO)throw new r("north must be in the interval [-Pi/2, Pi/2].");
            var t = this.south;
            if ("number" != typeof t)throw new r("south is required to be a number.");
            if (t < -o.PI_OVER_TWO || t > o.PI_OVER_TWO)throw new r("south must be in the interval [-Pi/2, Pi/2].");
            var n = this.west;
            if ("number" != typeof n)throw new r("west is required to be a number.");
            if (n < -Math.PI || n > Math.PI)throw new r("west must be in the interval [-Pi, Pi].");
            var i = this.east;
            if ("number" != typeof i)throw new r("east is required to be a number.");
            if (i < -Math.PI || i > Math.PI)throw new r("east must be in the interval [-Pi, Pi].")
        }, a.prototype.getSouthwest = function (e) {
            return"undefined" == typeof e ? new i(this.west, this.south) : (e.longitude = this.west, e.latitude = this.south, e.height = 0, e)
        }, a.prototype.getNorthwest = function (e) {
            return"undefined" == typeof e ? new i(this.west, this.north) : (e.longitude = this.west, e.latitude = this.north, e.height = 0, e)
        }, a.prototype.getNortheast = function (e) {
            return"undefined" == typeof e ? new i(this.east, this.north) : (e.longitude = this.east, e.latitude = this.north, e.height = 0, e)
        }, a.prototype.getSoutheast = function (e) {
            return"undefined" == typeof e ? new i(this.east, this.south) : (e.longitude = this.east, e.latitude = this.south, e.height = 0, e)
        }, a.prototype.getCenter = function (e) {
            return"undefined" == typeof e ? new i(.5 * (this.west + this.east), .5 * (this.south + this.north)) : (e.longitude = .5 * (this.west + this.east), e.latitude = .5 * (this.south + this.north), e.height = 0, e)
        }, a.prototype.intersectWith = function (e, t) {
            if ("undefined" == typeof e)throw new r("otherExtent is required.");
            var n = Math.max(this.west, e.west), i = Math.max(this.south, e.south), o = Math.min(this.east, e.east), s = Math.min(this.north, e.north);
            return"undefined" == typeof t ? new a(n, i, o, s) : (t.west = n, t.south = i, t.east = o, t.north = s, t)
        }, a.prototype.contains = function (e) {
            if ("undefined" == typeof e)throw new r("cartographic is required.");
            return e.longitude >= this.west && e.longitude <= this.east && e.latitude >= this.south && e.latitude <= this.north
        }, a.prototype.isEmpty = function () {
            return this.west >= this.east || this.south >= this.north
        };
        var s = new i;
        return a.prototype.subsample = function (e, i, r) {
            e = t(e, n.WGS84), i = t(i, 0), "undefined" == typeof r && (r = []);
            var a = 0, u = this.north, l = this.south, c = this.east, d = this.west, f = s;
            f.height = i, f.longitude = d, f.latitude = u, r[a] = e.cartographicToCartesian(f, r[a]), a++, f.longitude = c, r[a] = e.cartographicToCartesian(f, r[a]), a++, f.latitude = l, r[a] = e.cartographicToCartesian(f, r[a]), a++, f.longitude = d, r[a] = e.cartographicToCartesian(f, r[a]), a++, f.latitude = 0 > u ? u : l > 0 ? l : 0;
            for (var h = 1; 8 > h; ++h) {
                var p = -Math.PI + h * o.PI_OVER_TWO;
                p > d && c > p && (f.longitude = p, r[a] = e.cartographicToCartesian(f, r[a]), a++)
            }
            return 0 === f.latitude && (f.longitude = d, r[a] = e.cartographicToCartesian(f, r[a]), a++, f.longitude = c, r[a] = e.cartographicToCartesian(f, r[a]), a++), r.length = a, r
        }, a.MAX_VALUE = e(new a(-Math.PI, -o.PI_OVER_TWO, Math.PI, o.PI_OVER_TWO)), a
    }), n("Core/ExtentGeometry", ["./clone", "./defaultValue", "./BoundingSphere", "./Cartesian2", "./Cartesian3", "./Cartographic", "./ComponentDatatype", "./IndexDatatype", "./DeveloperError", "./Ellipsoid", "./Extent", "./Geometry", "./GeometryInstance", "./GeometryPipeline", "./GeographicProjection", "./GeometryAttribute", "./GeometryAttributes", "./Math", "./Matrix2", "./Matrix3", "./PrimitiveType", "./Quaternion", "./VertexFormat"], function (e, t, n, i, r, o, a, s, u, l, c, d, f, h, p, m, y, v, g, _, w, C, x) {
        "use strict";
        function S(e, t) {
            return e < -v.PI_OVER_TWO || e > v.PI_OVER_TWO ? !1 : t > v.PI || t < -v.PI ? !1 : !0
        }

        function b(e, t, n, i, r) {
            var o = e.radiiSquared;
            O = L.latitude - e.granYCos * t + n * e.granXSin;
            var a = et(O), s = tt(O), u = o.z * s;
            R = L.longitude + t * e.granYSin + n * e.granXCos;
            var l = a * et(R), c = a * tt(R), d = o.x * l, f = o.y * c, h = nt(d * l + f * c + u * s), p = d / h, m = f / h, y = u / h;
            "undefined" != typeof i && (W.x = p + l * i, W.y = m + c * i, W.z = y + s * i), "undefined" != typeof r && (Y.x = p + l * r, Y.y = m + c * r, Y.z = y + s * r)
        }

        function T(e, t) {
            var n = new d({attributes: new y, primitiveType: w.TRIANGLES});
            return e.position && (n.attributes.position = new m({componentDatatype: a.DOUBLE, componentsPerAttribute: 3, values: t.positions})), e.normal && (n.attributes.normal = new m({componentDatatype: a.FLOAT, componentsPerAttribute: 3, values: t.normals})), e.tangent && (n.attributes.tangent = new m({componentDatatype: a.FLOAT, componentsPerAttribute: 3, values: t.tangents})), e.binormal && (n.attributes.binormal = new m({componentDatatype: a.FLOAT, componentsPerAttribute: 3, values: t.binormals})), n
        }

        function E(e, t, n, i, o) {
            var a = e.length, s = t.normal ? new Float32Array(a) : void 0, u = t.tangent ? new Float32Array(a) : void 0, l = t.binormal ? new Float32Array(a) : void 0, c = 0, d = i ? a / 2 : 0;
            a = i && o ? a / 2 : a;
            for (var f = 0; a > f; f += 3) {
                var h = r.fromArray(e, f, W), p = c + 1, m = c + 2;
                (t.normal || t.tangent || t.binormal) && (H = n.geodeticSurfaceNormal(h, H), (t.tangent || t.binormal) && (r.cross(r.UNIT_Z, H, G), _.multiplyByVector(U, G, G), r.normalize(G, G), t.binormal && r.cross(H, G, j).normalize(j)), i && (t.normal && (s[c] = H.x, s[p] = H.y, s[m] = H.z), t.tangent && (u[c] = G.x, u[p] = G.y, u[m] = G.z), t.binormal && (l[c] = j.x, l[p] = j.y, l[m] = j.z)), o && (t.normal && (s[c + d] = -H.x, s[p + d] = -H.y, s[m + d] = -H.z), t.tangent && (u[c + d] = -G.x, u[p + d] = -G.y, u[m + d] = -G.z), t.binormal && (l[c + d] = j.x, l[p + d] = j.y, l[m + d] = j.z))), c += 3
            }
            return T(t, {positions: e, normals: s, tangents: u, binormals: l})
        }

        function A(e, t, n) {
            for (var i = e.length, o = t.normal ? new Float32Array(i) : void 0, a = t.tangent ? new Float32Array(i) : void 0, s = t.binormal ? new Float32Array(i) : void 0, u = 0, l = !0, c = i / 2, d = 0; c > d; d += 3) {
                var f = r.fromArray(e, d, W), h = u + 1, p = u + 2;
                if (t.normal || t.tangent || t.binormal) {
                    var m = r.fromArray(e, d + 3, K);
                    if (l) {
                        var y = r.fromArray(e, d + c, J);
                        m = m.subtract(f, m), y = y.subtract(f, y), H = y.cross(m, H).normalize(H), l = !1
                    }
                    m.equalsEpsilon(f, v.EPSILON10) && (l = !0), (t.tangent || t.binormal) && (j = n.geodeticSurfaceNormal(f, j), t.tangent && (G = r.cross(j, H, G).normalize(G))), t.normal && (o[u] = H.x, o[h] = H.y, o[p] = H.z, o[u + c] = H.x, o[h + c] = H.y, o[p + c] = H.z), t.tangent && (a[u] = G.x, a[h] = G.y, a[p] = G.z, a[u + c] = G.x, a[h + c] = G.y, a[p + c] = G.z), t.binormal && (s[u] = j.x, s[h] = j.y, s[p] = j.z, s[u + c] = j.x, s[h + c] = j.y, s[p + c] = j.z)
                }
                u += 3
            }
            return T(t, {positions: e, normals: o, tangents: a, binormals: s})
        }

        function M(e, t, n, i, r) {
            return Q.x = (R - V.west) * i.lonScalar - .5, Q.y = (O - V.south) * i.latScalar - .5, g.multiplyByVector(B, Q, Q), Q.x += .5, Q.y += .5, "undefined" != typeof r && (n[t + r] = Q.x, n[t + 1 + r] = Q.y), n[t++] = Q.x, n[t++] = Q.y, t
        }

        function D(e, t, n) {
            return e[t + n] = Y.x, e[t++] = W.x, e[t + n] = Y.y, e[t++] = W.y, e[t + n] = Y.z, e[t++] = W.z, e
        }

        function I(e, t, i) {
            for (var r = i.ellipsoid, o = i.size, u = i.height, l = i.width, c = i.surfaceHeight, d = 0, f = t.position ? new Float64Array(3 * o) : void 0, h = t.st ? new Float32Array(2 * o) : void 0, p = 0, y = 0; u > y; ++y)for (var v = 0; l > v; ++v)b(i, y, v, c), f[p++] = W.x, f[p++] = W.y, f[p++] = W.z, t.st && (Q.x = (R - V.west) * i.lonScalar - .5, Q.y = (O - V.south) * i.latScalar - .5, g.multiplyByVector(B, Q, Q), Q.x += .5, Q.y += .5, h[d++] = Q.x, h[d++] = Q.y);
            for (var _ = E(f, t, r, !0, !1), w = 6 * (l - 1) * (u - 1), C = s.createTypedArray(o, w), x = 0, S = 0, T = 0; u - 1 > T; ++T) {
                for (var A = 0; l - 1 > A; ++A) {
                    var M = x, D = M + l, I = D + 1, P = M + 1;
                    C[S++] = M, C[S++] = D, C[S++] = P, C[S++] = P, C[S++] = D, C[S++] = I, ++x
                }
                ++x
            }
            return _.indices = C, t.st && (_.attributes.st = new m({componentDatatype: a.FLOAT, componentsPerAttribute: 2, values: h})), {boundingSphere: n.fromExtent3D(e.extent, r, c), geometry: _}
        }

        function P(e, i, o) {
            var u = o.surfaceHeight, l = o.height, c = o.width, d = o.size, p = o.ellipsoid, y = e.extrudedOptions;
            if ("number" != typeof y.height)return I(e, i, o);
            var g = Math.min(y.height, u), _ = Math.max(y.height, u);
            if (v.equalsEpsilon(g, _, .1))return I(e, i, o);
            var w, C = t(y.closeTop, !0), x = t(y.closeBottom, !0), S = 2 * c + 2 * l - 4, T = 2 * (S + 4), P = new Float64Array(3 * T), O = i.st ? new Float32Array(2 * T) : void 0, R = 0, z = 0, L = 0, N = 3 * (T / 2);
            for (w = 0; l > w; w++)b(o, w, R, _, g), P = D(P, z, N), z += 3, i.st && (L = M(i, L, O, o, T));
            for (w = l - 1, R = 0; c > R; R++)b(o, w, R, _, g), P = D(P, z, N), z += 3, i.st && (L = M(i, L, O, o, T));
            for (R = c - 1, w = l - 1; w >= 0; w--)b(o, w, R, _, g), P = D(P, z, N), z += 3, i.st && (L = M(i, L, O, o, T));
            for (w = 0, R = c - 1; R >= 0; R--)b(o, w, R, _, g), P = D(P, z, N), z += 3, i.st && (L = M(i, L, O, o, T));
            var F = A(P, i, p);
            i.st && (F.attributes.st = new m({componentDatatype: a.FLOAT, componentsPerAttribute: 2, values: O}));
            var V, B, k, U, q, H = s.createTypedArray(T, 6 * S), G = P.length / 6, j = 0;
            for (q = 0; G - 1 > q; q++) {
                V = q, U = V + 1;
                var Q = r.fromArray(P, 3 * V, K), $ = r.fromArray(P, 3 * U, J);
                Q.equalsEpsilon($, v.EPSILON10) || (B = V + G, k = B + 1, H[j++] = V, H[j++] = B, H[j++] = U, H[j++] = U, H[j++] = B, H[j++] = k)
            }
            if (F.indices = H, x || C) {
                var et, tt, nt = 0, it = 0;
                C && (nt += d, it += 6 * (c - 1) * (l - 1), et = _), x && (nt += d, it += 6 * (c - 1) * (l - 1), tt = g);
                var rt = new Float64Array(3 * nt), ot = i.st ? new Float32Array(2 * nt) : void 0, at = s.createTypedArray(nt, it);
                for (z = 0, L = 0, N = x && C ? 3 * d : 0, w = 0; l > w; ++w)for (R = 0; c > R; ++R)b(o, w, R, et, tt), x && (rt[z + N] = Y.x, rt[z + 1 + N] = Y.y, rt[z + 2 + N] = Y.z), C && (rt[z] = W.x, rt[z + 1] = W.y, rt[z + 2] = W.z), i.st && (L = M(i, L, ot, o, 2 * d)), z += 3;
                var st = E(rt, i, p, C, x);
                i.st && (st.attributes.st = new m({componentDatatype: a.FLOAT, componentsPerAttribute: 2, values: ot}));
                var ut = 0;
                for (j = 0, N /= 3, q = 0; l - 1 > q; ++q) {
                    for (var lt = 0; c - 1 > lt; ++lt)V = j, B = V + c, k = B + 1, U = V + 1, x && (at[ut++] = U + N, at[ut++] = B + N, at[ut++] = V + N, at[ut++] = k + N, at[ut++] = B + N, at[ut++] = U + N), C && (at[ut++] = V, at[ut++] = B, at[ut++] = U, at[ut++] = U, at[ut++] = B, at[ut++] = k), ++j;
                    ++j
                }
                st.indices = at, F = h.combine([new f({geometry: st}), new f({geometry: F})])
            }
            var ct = n.fromExtent3D(e.extent, p, _, Z), dt = n.fromExtent3D(e.extent, p, g, X), ft = n.union(ct, dt);
            return{boundingSphere: ft, geometry: F}
        }

        var O, R, z = new r, L = new o, N = new o, F = new r, V = new c, B = new g, k = new g, U = new _, q = new p, W = new r, H = new r, G = new r, j = new r, Y = new r, X = new n, Z = new n, K = new r, J = new r, Q = new i, $ = new C, et = Math.cos, tt = Math.sin, nt = Math.sqrt, it = function (e) {
            e = t(e, t.EMPTY_OBJECT);
            var n = e.extent;
            if ("undefined" == typeof n)throw new u("extent is required.");
            n.validate();
            var i = t(e.granularity, v.RADIANS_PER_DEGREE), o = Math.ceil((n.east - n.west) / i) + 1, a = Math.ceil((n.north - n.south) / i) + 1, s = (n.east - n.west) / (o - 1), d = (n.north - n.south) / (a - 1), f = t(e.ellipsoid, l.WGS84), h = f.getRadiiSquared(), p = t(e.height, 0), m = e.rotation, w = e.stRotation;
            c.clone(n, V), n.getNorthwest(L), n.getCenter(N);
            var b = d, T = s, E = 0, A = 0;
            if ("undefined" != typeof m) {
                var M = et(m);
                b *= M, T *= M;
                var D = tt(m);
                E = d * D, A = s * D, q.project(L, z), q.project(N, F), z.subtract(F, z), g.fromRotation(m, k), k.multiplyByVector(z, z), z.add(F, z), q.unproject(z, L);
                var O = L.latitude, R = O + (o - 1) * A, W = O - b * (a - 1), H = O - b * (a - 1) + (o - 1) * A, G = Math.max(O, R, W, H), j = Math.min(O, R, W, H), Y = L.longitude, X = Y + (o - 1) * T, Z = Y + (a - 1) * E, J = Y + (a - 1) * E + (o - 1) * T, Q = Math.max(Y, X, Z, J), nt = Math.min(Y, X, Z, J);
                if (!(S(G, nt) && S(G, Q) && S(j, nt) && S(j, Q)))throw new u("Rotated extent is invalid.");
                V.north = G, V.south = j, V.east = Q, V.west = nt
            }
            var it = 1 / (V.east - V.west), rt = 1 / (V.north - V.south), ot = t(e.vertexFormat, x.DEFAULT), at = o * a;
            if ("undefined" != typeof w) {
                g.fromRotation(-w, B);
                var st = f.cartographicToCartesian(N, K);
                r.normalize(st, st), C.fromAxisAngle(st, -w, $), _.fromQuaternion($, U)
            } else g.clone(g.IDENTITY, B), _.clone(_.IDENTITY, U);
            var ut, lt = {granYCos: b, granYSin: E, granXCos: T, granXSin: A, radiiSquared: h, ellipsoid: f, lonScalar: it, latScalar: rt, extent: n, width: o, height: a, surfaceHeight: p, size: at};
            ut = "undefined" != typeof e.extrudedOptions ? P(e, ot, lt) : I(e, ot, lt);
            var ct = ut.geometry;
            this.attributes = new y(ct.attributes), this.indices = ct.indices, this.boundingSphere = ut.boundingSphere, this.primitiveType = ct.primitiveType
        };
        return it
    }), n("Core/FAR", [], function () {
        "use strict";
        var e = 5906376272e3;
        return e
    }), n("Core/Fullscreen", [], function () {
        "use strict";
        var e, t = {requestFullscreen: void 0, exitFullscreen: void 0, fullscreenEnabled: void 0, fullscreenElement: void 0, fullscreenchange: void 0, fullscreenerror: void 0}, n = {};
        return n.supportsFullscreen = function () {
            if ("undefined" != typeof e)return e;
            e = !1;
            var n = document.body;
            if ("function" == typeof n.requestFullscreen)return t.requestFullscreen = "requestFullscreen", t.exitFullscreen = "exitFullscreen", t.fullscreenEnabled = "fullscreenEnabled", t.fullscreenElement = "fullscreenElement", t.fullscreenchange = "fullscreenchange", t.fullscreenerror = "fullscreenerror", e = !0;
            for (var i, r = ["webkit", "moz", "o", "ms", "khtml"], o = 0, a = r.length; a > o; ++o) {
                var s = r[o];
                i = s + "RequestFullscreen", "function" == typeof n[i] ? (t.requestFullscreen = i, e = !0) : (i = s + "RequestFullScreen", "function" == typeof n[i] && (t.requestFullscreen = i, e = !0)), i = s + "ExitFullscreen", "function" == typeof document[i] ? t.exitFullscreen = i : (i = s + "CancelFullScreen", "function" == typeof document[i] && (t.exitFullscreen = i)), i = s + "FullscreenEnabled", "undefined" != typeof document[i] ? t.fullscreenEnabled = i : (i = s + "FullScreenEnabled", "undefined" != typeof document[i] && (t.fullscreenEnabled = i)), i = s + "FullscreenElement", "undefined" != typeof document[i] ? t.fullscreenElement = i : (i = s + "FullScreenElement", "undefined" != typeof document[i] && (t.fullscreenElement = i)), i = s + "fullscreenchange", "undefined" != typeof document["on" + i] && (t.fullscreenchange = i), i = s + "fullscreenerror", "undefined" != typeof document["on" + i] && (t.fullscreenerror = i)
            }
            return e
        }, n.requestFullscreen = function (e) {
            n.supportsFullscreen() && e[t.requestFullscreen]()
        }, n.exitFullscreen = function () {
            n.supportsFullscreen() && document[t.exitFullscreen]()
        }, n.isFullscreenEnabled = function () {
            return n.supportsFullscreen() ? document[t.fullscreenEnabled] : void 0
        }, n.getFullscreenElement = function () {
            return n.supportsFullscreen() ? document[t.fullscreenElement] : void 0
        }, n.isFullscreen = function () {
            return n.supportsFullscreen() ? null !== n.getFullscreenElement() : void 0
        }, n.getFullscreenChangeEventName = function () {
            return n.supportsFullscreen() ? t.fullscreenchange : void 0
        }, n.getFullscreenErrorEventName = function () {
            return n.supportsFullscreen() ? t.fullscreenerror : void 0
        }, n
    }), n("Core/FeatureDetection", ["./Fullscreen"], function (e) {
        "use strict";
        function t(e) {
            for (var t = e.split("."), n = 0, i = t.length; i > n; ++n)t[n] = parseInt(t[n], 10)
        }

        function n() {
            if ("undefined" == typeof c) {
                var e = / Chrome\/([\.0-9]+)/.exec(navigator.userAgent);
                null === e ? c = !1 : (c = !0, d = t(e[1]))
            }
            return c
        }

        function i() {
            return n() && d
        }

        function r() {
            if ("undefined" == typeof f)if (n() || !/ Safari\/[\.0-9]+/.test(navigator.userAgent))f = !1; else {
                var e = / Version\/([\.0-9]+)/.exec(navigator.userAgent);
                null === e ? f = !1 : (f = !0, h = t(e[1]))
            }
            return f
        }

        function o() {
            return r() && h
        }

        function a() {
            if ("undefined" == typeof p) {
                var e = / AppleWebKit\/([\.0-9]+)(\+?)/.exec(navigator.userAgent);
                null === e ? p = !1 : (p = !0, m = t(e[1]), m.isNightly = !!e[2])
            }
            return p
        }

        function s() {
            return a() && m
        }

        function u() {
            if ("undefined" == typeof y) {
                var e = / MSIE ([\.0-9]+)/.exec(navigator.userAgent);
                null === e ? y = !1 : (y = !0, v = t(e[1]))
            }
            return y
        }

        function l() {
            return u() && v
        }

        var c, d, f, h, p, m, y, v, g, _ = {isChrome: n, chromeVersion: i, isSafari: r, safariVersion: o, isWebkit: a, webkitVersion: s, isInternetExplorer: u, internetExplorerVersion: l};
        return _.supportsCrossOriginImagery = function () {
            return"undefined" == typeof g && (g = r() && s()[0] < 536 ? !1 : "withCredentials"in new XMLHttpRequest), g
        }, _.supportsFullscreen = function () {
            return e.supportsFullscreen()
        }, _
    }), n("Core/HeightmapTessellator", ["./defaultValue", "./freezeObject", "./DeveloperError", "./Cartesian3", "./Ellipsoid", "./Math"], function (e, t, n, i, r, o) {
        "use strict";
        var a = {};
        return a.DEFAULT_STRUCTURE = t({heightScale: 1, heightOffset: 0, elementsPerHeight: 1, stride: 1, elementMultiplier: 256, isBigEndian: !1}), a.computeVertices = function (t) {
            if ("undefined" == typeof t || "undefined" == typeof t.heightmap)throw new n("description.heightmap is required.");
            if ("undefined" == typeof t.width || "undefined" == typeof t.height)throw new n("description.width and description.height are required.");
            if ("undefined" == typeof t.vertices)throw new n("description.vertices is required.");
            if ("undefined" == typeof t.nativeExtent)throw new n("description.nativeExtent is required.");
            if ("undefined" == typeof t.skirtHeight)throw new n("description.skirtHeight is required.");
            var s, u, l, c, d = Math.cos, f = Math.sin, h = Math.sqrt, p = Math.atan, m = Math.exp, y = o.PI_OVER_TWO, v = o.toRadians, g = t.vertices, _ = t.heightmap, w = t.width, C = t.height, x = t.skirtHeight, S = e(t.isGeographic, !0), b = e(t.ellipsoid, r.WGS84), T = 1 / b.getMaximumRadius(), E = t.nativeExtent, A = t.extent;
            "undefined" == typeof A ? S ? (s = v(E.west), u = v(E.south), l = v(E.east), c = v(E.north)) : (s = E.west * T, u = y - 2 * p(m(-E.south * T)), l = E.east * T, c = y - 2 * p(m(-E.north * T))) : (s = A.west, u = A.south, l = A.east, c = A.north);
            var M = e(t.relativeToCenter, i.ZERO), D = e(t.structure, a.DEFAULT_STRUCTURE), I = e(D.heightScale, a.DEFAULT_STRUCTURE.heightScale), P = e(D.heightOffset, a.DEFAULT_STRUCTURE.heightOffset), O = e(D.elementsPerHeight, a.DEFAULT_STRUCTURE.elementsPerHeight), R = e(D.stride, a.DEFAULT_STRUCTURE.stride), z = e(D.elementMultiplier, a.DEFAULT_STRUCTURE.elementMultiplier), L = e(D.isBigEndian, a.DEFAULT_STRUCTURE.isBigEndian), N = (E.east - E.west) / (w - 1), F = (E.north - E.south) / (C - 1), V = b.getRadiiSquared(), B = V.x, k = V.y, U = V.z, q = 0, W = 65536, H = -65536, G = 0, j = C, Y = 0, X = w;
            x > 0 && (--G, ++j, --Y, ++X);
            for (var Z = G; j > Z; ++Z) {
                var K = Z;
                0 > K && (K = 0), K >= C && (K = C - 1);
                var J = E.north - F * K;
                J = S ? v(J) : y - 2 * p(m(-J * T));
                for (var Q = d(J), $ = f(J), et = U * $, tt = (J - u) / (c - u), nt = Y; X > nt; ++nt) {
                    var it = nt;
                    0 > it && (it = 0), it >= w && (it = w - 1);
                    var rt = E.west + N * it;
                    S ? rt = v(rt) : rt *= T;
                    var ot, at = K * w * R + it * R;
                    if (1 === O)ot = _[at]; else {
                        ot = 0;
                        var st;
                        if (L)for (st = 0; O > st; ++st)ot = ot * z + _[at + st]; else for (st = O - 1; st >= 0; --st)ot = ot * z + _[at + st]
                    }
                    ot = ot * I + P, H = Math.max(H, ot), W = Math.min(W, ot), (nt !== it || Z !== K) && (ot -= x);
                    var ut = Q * d(rt), lt = Q * f(rt), ct = B * ut, dt = k * lt, ft = h(ct * ut + dt * lt + et * $), ht = 1 / ft, pt = ct * ht, mt = dt * ht, yt = et * ht;
                    g[q++] = pt + ut * ot - M.x, g[q++] = mt + lt * ot - M.y, g[q++] = yt + $ * ot - M.z, g[q++] = ot;
                    var vt = (rt - s) / (l - s);
                    g[q++] = vt, g[q++] = tt
                }
            }
            return{maximumHeight: H, minimumHeight: W}
        }, a
    }), n("Core/HermitePolynomialApproximation", ["./Math"], function (e) {
        "use strict";
        function t(e, n, i, r, o, a) {
            var s, u, l, c = 0;
            if (r > 0) {
                for (u = 0; o > u; u++) {
                    for (s = !1, l = 0; l < a.length && !s; l++)u === a[l] && (s = !0);
                    s || (a.push(u), c += t(e, n, i, r - 1, o, a), a.splice(a.length - 1, 1))
                }
                return c
            }
            for (c = 1, u = 0; o > u; u++) {
                for (s = !1, l = 0; l < a.length && !s; l++)u === a[l] && (s = !0);
                s || (c *= e - i[n[u]])
            }
            return c
        }

        var n = e.factorial, i = {type: "Hermite"};
        return i.getRequiredDataPoints = function (e) {
            return Math.max(e + 1, 2)
        }, i.interpolateOrderZero = function (e, i, r, o, a) {
            "undefined" == typeof a && (a = new Array(o));
            var s, u, l, c, d, f, h = i.length, p = new Array(o);
            for (s = 0; o > s; s++) {
                a[s] = 0;
                var m = new Array(h);
                for (p[s] = m, u = 0; h > u; u++)m[u] = []
            }
            var y = h, v = new Array(y);
            for (s = 0; y > s; s++)v[s] = s;
            var g = h - 1;
            for (c = 0; o > c; c++) {
                for (u = 0; y > u; u++)f = v[u] * o + c, p[c][0].push(r[f]);
                for (s = 1; y > s; s++) {
                    var _ = !1;
                    for (u = 0; y - s > u; u++) {
                        var w, C = i[v[u]], x = i[v[u + s]];
                        0 >= x - C ? (f = v[u] * o + o * s + c, w = r[f], p[c][s].push(w / n(s))) : (w = p[c][s - 1][u + 1] - p[c][s - 1][u], p[c][s].push(w / (x - C))), _ = _ || 0 !== w
                    }
                    _ || (g = s - 1)
                }
            }
            for (l = 0, d = 0; d >= l; l++)for (s = l; g >= s; s++) {
                var S = t(e, v, i, l, s, []);
                for (c = 0; o > c; c++) {
                    var b = p[c][s][0];
                    a[c + l * o] += b * S
                }
            }
            return a
        }, i
    }), n("Core/TimeInterval", ["./DeveloperError", "./freezeObject", "./JulianDate", "./TimeStandard"], function (e, t, n, i) {
        "use strict";
        var r = function (t, i, r, o, a) {
            if ("undefined" == typeof t)throw new e("start must be specified.");
            if ("undefined" == typeof i)throw new e("stop must be specified.");
            "undefined" == typeof r && (r = !0), "undefined" == typeof o && (o = !0);
            var s = n.compare(i, t);
            this.start = t, this.stop = i, this.data = a, this.isStartIncluded = r, this.isStopIncluded = o, this.isEmpty = 0 > s || 0 === s && (!r || !o)
        };
        return r.fromIso8601 = function (e, t, i, o) {
            var a = e.split("/"), s = n.fromIso8601(a[0]), u = n.fromIso8601(a[1]);
            return new r(s, u, t, i, o)
        }, r.equals = function (e, t) {
            return e === t || "undefined" != typeof e && "undefined" != typeof t && (e.isEmpty && t.isEmpty || e.isStartIncluded === t.isStartIncluded && e.isStopIncluded === t.isStopIncluded && e.start.equals(t.start) && e.stop.equals(t.stop))
        }, r.equalsEpsilon = function (t, n, i) {
            if ("number" != typeof i)throw new e("epsilon is required and must be a number.");
            return t === n || "undefined" != typeof t && "undefined" != typeof n && (t.isEmpty && n.isEmpty || t.isStartIncluded === n.isStartIncluded && t.isStopIncluded === n.isStopIncluded && t.start.equalsEpsilon(n.start, i) && t.stop.equalsEpsilon(n.stop, i))
        }, r.prototype.clone = function () {
            return new r(this.start, this.stop, this.isStartIncluded, this.isStopIncluded, this.data)
        }, r.EMPTY = t(new r(new n(0, 0, i.TAI), new n(0, 0, i.TAI), !1, !1)), r.prototype.intersect = function (e, t) {
            if ("undefined" == typeof e)return r.EMPTY;
            var n, i, o, a = e.start, s = e.stop, u = e.isStartIncluded, l = e.isStopIncluded, c = this.start, d = this.stop, f = this.isStartIncluded, h = this.isStopIncluded;
            return a.greaterThanOrEquals(c) && d.greaterThanOrEquals(a) ? (i = !a.equals(c) && u || f && u, o = h && l, n = "undefined" != typeof t ? t(this.data, e.data) : this.data, d.greaterThanOrEquals(s) ? (o = o || !s.equals(d) && l, new r(a, s, i, o, n)) : (o = o || h, new r(a, d, i, o, n))) : a.lessThanOrEquals(c) && c.lessThanOrEquals(s) ? (i = a.equals(c) === !1 && f || f && u, o = h && l, n = "undefined" != typeof t ? t(this.data, e.data) : this.data, d.greaterThanOrEquals(s) ? (o = o || s.equals(d) === !1 && l, new r(c, s, i, o, n)) : (o = o || h, new r(c, d, i, o, n))) : r.EMPTY
        }, r.prototype.contains = function (e) {
            if (this.isEmpty)return!1;
            var t = n.compare(this.start, e);
            if (0 === t)return this.isStartIncluded;
            var i = n.compare(e, this.stop);
            return 0 === i ? this.isStopIncluded : 0 > t && 0 > i
        }, r.prototype.equals = function (e) {
            return r.equals(this, e)
        }, r.prototype.equalsEpsilon = function (e, t) {
            return r.equalsEpsilon(this, e, t)
        }, r
    }), n("Core/Iso8601", ["./freezeObject", "./JulianDate", "./TimeInterval"], function (e, t, n) {
        "use strict";
        var i = e(t.fromIso8601("0000-01-01T00:00:00Z")), r = e(t.fromIso8601("9999-12-31T24:00:00Z")), o = e(new n(i, r, !0, !0)), a = {MINIMUM_VALUE: i, MAXIMUM_VALUE: r, MAXIMUM_INTERVAL: o};
        return a
    }), n("Core/KeyboardEventModifier", ["./Enumeration"], function (e) {
        "use strict";
        var t = {SHIFT: new e(0, "SHIFT"), CTRL: new e(1, "CTRL"), ALT: new e(2, "ALT")};
        return t
    }), n("Core/LagrangePolynomialApproximation", [], function () {
        "use strict";
        var e = {type: "Lagrange"};
        return e.getRequiredDataPoints = function (e) {
            return Math.max(e + 1, 2)
        }, e.interpolateOrderZero = function (e, t, n, i, r) {
            "undefined" == typeof r && (r = new Array(i));
            var o, a, s = t.length;
            for (o = 0; i > o; o++)r[o] = 0;
            for (o = 0; s > o; o++) {
                var u = 1;
                for (a = 0; s > a; a++)if (a !== o) {
                    var l = t[o] - t[a];
                    u *= (e - t[a]) / l
                }
                for (a = 0; i > a; a++)r[a] += u * n[o * i + a]
            }
            return r
        }, e
    }), n("Core/LinearApproximation", ["./DeveloperError"], function (e) {
        "use strict";
        var t = {type: "Linear"};
        return t.getRequiredDataPoints = function (t) {
            if (1 !== t)throw new e("Linear interpolation can only generate a first degree polynomial.");
            return 2
        }, t.interpolateOrderZero = function (t, n, i, r, o) {
            if (2 !== n.length)throw new e("The xTable provided to the linear interpolator must have exactly two elements.");
            if (0 >= r)throw new e("There must be at least 1 dependent variable for each independent variable.");
            "undefined" == typeof o && (o = new Array(r));
            var a, s, u, l = n[0], c = n[1];
            if (l === c)throw new e("Divide by zero error: xTable[0] and xTable[1] are equal");
            for (a = 0; r > a; a++)s = i[a], u = i[a + r], o[a] = ((u - s) * t + c * s - l * u) / (c - l);
            return o
        }, t
    }), n("Core/Visibility", ["./Enumeration"], function (e) {
        "use strict";
        var t = {NONE: new e(-1, "NONE"), PARTIAL: new e(0, "PARTIAL"), FULL: new e(1, "FULL")};
        return t
    }), n("Core/Occluder", ["./defaultValue", "./DeveloperError", "./Math", "./Cartesian3", "./Visibility", "./Ellipsoid", "./BoundingSphere"], function (e, t, n, i, r, o, a) {
        "use strict";
        var s = function (e, n) {
            if (!e)throw new t("occluderBoundingSphere is required.");
            if (!n)throw new t("camera position is required.");
            this._occluderPosition = e.center.clone(), this._occluderRadius = e.radius, this._horizonDistance = 0, this._horizonPlaneNormal = void 0, this._horizonPlanePosition = void 0, this._cameraPosition = void 0, this.setCameraPosition(n)
        };
        s.prototype.getPosition = function () {
            return this._occluderPosition
        }, s.prototype.getRadius = function () {
            return this._occluderRadius
        }, s.prototype.setCameraPosition = function (e) {
            e = i.clone(e);
            var t, n, r, o = this._occluderPosition.subtract(e), a = o.magnitudeSquared(), s = this._occluderRadius * this._occluderRadius;
            if (a > s) {
                t = Math.sqrt(a - s), a = 1 / Math.sqrt(a), n = o.multiplyByScalar(a);
                var u = t * t * a;
                r = e.add(n.multiplyByScalar(u))
            } else t = Number.MAX_VALUE;
            this._horizonDistance = t, this._horizonPlaneNormal = n, this._horizonPlanePosition = r, this._cameraPosition = e
        };
        var u = new i;
        s.prototype.isPointVisible = function (e) {
            if (this._horizonDistance !== Number.MAX_VALUE) {
                var t = i.subtract(e, this._occluderPosition, u), n = this._occluderRadius;
                if (n = t.magnitudeSquared() - n * n, n > 0)return n = Math.sqrt(n) + this._horizonDistance, t = i.subtract(e, this._cameraPosition, t), n * n > t.magnitudeSquared()
            }
            return!1
        }, s.prototype.isBoundingSphereVisible = function (e) {
            var t = e.center.clone(), n = e.radius;
            if (this._horizonDistance !== Number.MAX_VALUE) {
                var r = i.subtract(t, this._occluderPosition, u), o = this._occluderRadius - n;
                if (o = r.magnitudeSquared() - o * o, n < this._occluderRadius)return o > 0 ? (o = Math.sqrt(o) + this._horizonDistance, r = i.subtract(t, this._cameraPosition, r), o * o + n * n > r.magnitudeSquared()) : !1;
                if (o > 0) {
                    r = t.subtract(this._cameraPosition);
                    var a = r.magnitudeSquared(), s = this._occluderRadius * this._occluderRadius, l = n * n;
                    return(this._horizonDistance * this._horizonDistance + s) * l > a * s ? !0 : (o = Math.sqrt(o) + this._horizonDistance, o * o + l > a)
                }
                return!0
            }
            return!1
        }, s.prototype.getVisibility = function (e) {
            var t = e.center.clone(), n = e.radius;
            if (n > this._occluderRadius)return r.FULL;
            if (this._horizonDistance !== Number.MAX_VALUE) {
                var i = t.subtract(this._occluderPosition), o = this._occluderRadius - n, a = i.magnitudeSquared();
                if (o = a - o * o, o > 0) {
                    o = Math.sqrt(o) + this._horizonDistance, i = t.subtract(this._cameraPosition);
                    var s = i.magnitudeSquared();
                    return s > o * o + n * n ? r.NONE : (o = this._occluderRadius + n, o = a - o * o, o > 0 ? (o = Math.sqrt(o) + this._horizonDistance, o * o + n * n > s ? r.FULL : r.PARTIAL) : (i = t.subtract(this._horizonPlanePosition), i.dot(this._horizonPlaneNormal) > -n ? r.PARTIAL : r.FULL))
                }
            }
            return r.NONE
        }, s.getOccludeePoint = function (e, n, r) {
            if (!e)throw new t("occluderBoundingSphere is required.");
            if (!r)throw new t("positions is required.");
            if (0 === r.length)throw new t("positions must contain at least one element");
            var o = i.clone(n), a = e.center.clone(), u = e.radius, l = r.length;
            if (a.equals(n))throw new t("occludeePosition must be different than occluderBoundingSphere.center");
            var c = o.subtract(a).normalize(), d = -c.dot(a), f = s._anyRotationVector(a, c, d), h = s._horizonToPlaneNormalDotProduct(e, c, d, f, r[0]);
            if (!h)return void 0;
            for (var p, m = 1; l > m; ++m) {
                if (p = s._horizonToPlaneNormalDotProduct(e, c, d, f, r[m]), !p)return void 0;
                h > p && (h = p)
            }
            if (.0017453283658983088 > h)return void 0;
            var y = u / h;
            return a.add(c.multiplyByScalar(y))
        };
        var l = [];
        return s.computeOccludeePointFromExtent = function (n, r) {
            if ("undefined" == typeof n)throw new t("extent is required.");
            r = e(r, o.WGS84);
            var u = n.subsample(r, 0, l), c = a.fromPoints(u), d = i.ZERO;
            return d.equals(c.center) ? void 0 : s.getOccludeePoint(new a(d, r.getMinimumRadius()), c.center, u)
        }, s._anyRotationVector = function (e, t, n) {
            var r = t.clone().abs(), o = r.x > r.y ? 0 : 1;
            (0 === o && r.z > r.x || 1 === o && r.z > r.y) && (o = 2);
            var a = new i;
            0 === o ? (r.x = e.x, r.y = e.y + 1, r.z = e.z + 1, a = i.UNIT_X) : 1 === o ? (r.x = e.x + 1, r.y = e.y, r.z = e.z + 1, a = i.UNIT_Y) : (r.x = e.x + 1, r.y = e.y + 1, r.z = e.z, a = i.UNIT_Z);
            var s = (t.dot(r) + n) / -t.dot(a);
            return r.add(a.multiplyByScalar(s)).subtract(e).normalize()
        }, s._rotationVector = function (e, t, i, r, o) {
            var a = r.subtract(e);
            if (a = a.normalize(), t.dot(a) < .9999999847691291) {
                var s = t.cross(a), u = s.magnitude();
                if (u > n.EPSILON13)return s.normalize()
            }
            return o
        }, s._horizonToPlaneNormalDotProduct = function (e, t, n, r, o) {
            var a = i.clone(o), s = e.center.clone(), u = e.radius, l = s.subtract(a), c = l.magnitudeSquared(), d = u * u;
            if (d > c)return!1;
            var f = c - d, h = Math.sqrt(f), p = Math.sqrt(c), m = 1 / p, y = h * m, v = y * h;
            l = l.normalize();
            var g = a.add(l.multiplyByScalar(v)), _ = Math.sqrt(f - v * v), w = this._rotationVector(s, t, n, a, r), C = new i(w.x * w.x * l.x + (w.x * w.y - w.z) * l.y + (w.x * w.z + w.y) * l.z, (w.x * w.y + w.z) * l.x + w.y * w.y * l.y + (w.y * w.z - w.x) * l.z, (w.x * w.z - w.y) * l.x + (w.y * w.z + w.x) * l.y + w.z * w.z * l.z);
            C = C.normalize();
            var x = C.multiplyByScalar(_);
            w = g.add(x).subtract(s).normalize();
            var S = t.dot(w);
            w = g.subtract(x).subtract(s).normalize();
            var b = t.dot(w);
            return b > S ? S : b
        }, s
    }), n("Core/OrientationInterpolator", ["./DeveloperError"], function (e) {
        "use strict";
        function t(e, t) {
            var n = e._lastTimeIndex || 0;
            if (t >= e._points[n].time) {
                if (n + 1 < e._points.length && t < e._points[n + 1].time)return n;
                if (n + 2 < e._points.length && t < e._points[n + 2].time)return e._lastTimeIndex = n + 1, e._lastTimeIndex
            } else if (n - 1 >= 0 && t >= e._points[n - 1].time)return e._lastTimeIndex = n - 1, e._lastTimeIndex;
            for (n = 0; n < e._points.length - 1 && !(t >= e._points[n].time && t < e._points[n + 1].time); ++n);
            return n === e._points.length - 1 && (n = e._points.length - 2), e._lastTimeIndex = n, e._lastTimeIndex
        }

        var n = function (t) {
            if ("undefined" == typeof t || !(t instanceof Array) || t.length < 2)throw new e("controlPoints is required. It must be an array with at least a length of 3.");
            this._points = t, this._lastTimeIndex = 0
        };
        return n.prototype.getControlPoints = function () {
            return this._points
        }, n.prototype.evaluate = function (n) {
            if ("undefined" == typeof n)throw new e("time is required.");
            if (n < this._points[0].time || n > this._points[this._points.length - 1].time)throw new e("time is out of range.");
            var i = t(this, n), r = (n - this._points[i].time) / (this._points[i + 1].time - this._points[i].time);
            return this._points[i].orientation.slerp(this._points[i + 1].orientation, r)
        }, n
    }), n("Core/pointInsideTriangle", ["./barycentricCoordinates", "./Cartesian3", "./DeveloperError"], function (e, t) {
        "use strict";
        var n = new t, i = function (t, i, r, o) {
            return e(t, i, r, o, n), n.x > 0 && n.y > 0 && n.z > 0
        };
        return i
    }), n("Core/Queue", [], function () {
        "use strict";
        var e = function () {
            this._array = [], this._offset = 0, this.length = 0
        };
        return e.prototype.enqueue = function (e) {
            this._array.push(e), this.length++
        }, e.prototype.dequeue = function () {
            if (0 === this.length)return void 0;
            var e = this._array, t = this._offset, n = e[t];
            return e[t] = void 0, t++, t > 10 && 2 * t > e.length && (this._array = e.slice(t), t = 0), this._offset = t, this.length--, n
        }, e.prototype.contains = function (e) {
            return-1 !== this._array.indexOf(e)
        }, e.prototype.clear = function () {
            this._array.length = this._offset = this.length = 0
        }, e.prototype.sort = function (e) {
            this._offset > 0 && (this._array = this._array.slice(this._offset), this._offset = 0), this._array.sort(e)
        }, e
    }), n("Core/WindingOrder", ["./Enumeration"], function (e) {
        "use strict";
        var t = {CLOCKWISE: new e(2304, "CLOCKWISE"), COUNTER_CLOCKWISE: new e(2305, "COUNTER_CLOCKWISE"), validate: function (e) {
            return e === t.CLOCKWISE || e === t.COUNTER_CLOCKWISE
        }};
        return t
    }), n("Core/PolygonPipeline", ["./DeveloperError", "./Math", "./Cartesian2", "./Cartesian3", "./Geometry", "./GeometryAttribute", "./Ellipsoid", "./EllipsoidTangentPlane", "./defaultValue", "./pointInsideTriangle", "./ComponentDatatype", "./PrimitiveType", "./Queue", "./WindingOrder"], function (e, t, n, i, r, o, a, s, u, l, c, d, f, h) {
        "use strict";
        function p() {
            this.head = void 0, this.tail = void 0, this.length = 0
        }

        function m(e, t, n) {
            var i = t.subtract(e), r = n.subtract(t);
            return i.x * r.y - i.y * r.x >= 0
        }

        function y(e) {
            for (var t = e[0].x, n = 0, i = 0; i < e.length; i++)e[i].x > t && (t = e[i].x, n = i);
            return n
        }

        function v(e) {
            for (var t = e[0][0].x, n = 0, i = 0; i < e.length; i++) {
                var r = e[i][y(e[i])].x;
                r > t && (t = r, n = i)
            }
            return n
        }

        function g(e) {
            for (var t = [], n = 0; n < e.length; n++) {
                var i = e[(n - 1 + e.length) % e.length], r = e[n], o = e[(n + 1) % e.length];
                m(i, r, o) || t.push(r)
            }
            return t
        }

        function _(e, t) {
            for (var n = 0; n < e.length; n++)if (t.equals(e[n]))return n;
            return-1
        }

        function w(e, t, r) {
            r = u(r, []);
            var o = Number.MAX_VALUE, a = y(t), s = new n(t[a].x, e.y);
            r.push(a), r.push((a + 1) % t.length);
            for (var l = t[0].x, c = l, d = 1; d < t.length; ++d)t[d].x < l ? l = t[d].x : t[d].x > c && (c = t[d].x);
            c += c - l;
            var f = new i(c, e.y, 0);
            for (d = 0; d < t.length; d++) {
                var h = t[d], p = t[(d + 1) % t.length];
                if ((h.x >= e.x || p.x >= e.x) && (h.y >= e.y && p.y <= e.y || h.y <= e.y && p.y >= e.y)) {
                    var m = (p.y - h.y) * (f.x - e.x) - (p.x - h.x) * (f.y - e.y);
                    if (0 !== m) {
                        m = 1 / m;
                        var v = ((p.x - h.x) * (e.y - h.y) - (p.y - h.y) * (e.x - h.x)) * m, g = ((f.x - e.x) * (e.y - h.y) - (f.y - e.y) * (e.x - h.x)) * m;
                        if (v >= 0 && 1 >= v && g >= 0 && 1 >= g) {
                            var _ = new n(e.x + v * (f.x - e.x), e.y + v * (f.y - e.y)), w = _.subtract(e);
                            m = w.magnitudeSquared(), o > m && (s = _, o = m, r[0] = d, r[1] = (d + 1) % t.length)
                        }
                    }
                }
            }
            return s
        }

        function C(e, t) {
            var i = v(t), r = t[i], o = y(r), a = r[o], s = [], u = w(a, e, s), c = _(e, u);
            if (-1 !== c)return c;
            var d = e[s[0]].subtract(a).magnitudeSquared(), f = e[s[1]].subtract(a).magnitudeSquared(), h = f > d ? e[s[0]] : e[s[1]], p = g(e), m = p.indexOf(h);
            -1 !== m && p.splice(m, 1);
            for (var C = [], x = 0; x < p.length; x++) {
                var S = p[x];
                l(S, a, u, h) && C.push(S)
            }
            var b = Number.MAX_VALUE;
            if (C.length > 0) {
                var T = new n(1, 0, 0);
                for (x = 0; x < C.length; x++) {
                    var E = C[x].subtract(a), A = T.magnitude() * E.magnitude();
                    if (0 !== A) {
                        var M = Math.abs(Math.acos(T.dot(E) / A));
                        b > M && (b = M, h = C[x])
                    }
                }
            }
            return e.indexOf(h)
        }

        function x(e, t, n) {
            for (var i = T.computeWindingOrder2D(e), r = 0; r < t.length; r++) {
                var o = t[r];
                o[0].equals(o[o.length - 1]) || o.push(o[0]);
                var a = T.computeWindingOrder2D(o);
                a === i && o.reverse()
            }
            var u = s.fromPoints(e, n), l = u.projectPointsOntoPlane(e), c = [];
            for (r = 0; r < t.length; r++)c.push(u.projectPointsOntoPlane(t[r]));
            var d = C(l, c), f = v(c), h = y(c[f]), p = t[f], m = [];
            for (r = 0; r < e.length; r++)m.push(e[r]);
            var g, _ = [];
            if (0 !== h)for (g = 0; g <= p.length; g++) {
                var w = (g + h) % p.length;
                0 !== w && _.push(p[w])
            } else for (g = 0; g < p.length; g++)_.push(p[(g + h) % p.length]);
            var x = m.lastIndexOf(e[d]);
            _.push(e[x]);
            var S = m.slice(0, x + 1), b = m.slice(x + 1);
            return m = S.concat(_, b), t.splice(f, 1), m
        }

        p.prototype.add = function (e) {
            if ("undefined" != typeof e) {
                var t = {item: e, previous: this.tail, next: void 0};
                "undefined" != typeof this.tail ? (this.tail.next = t, this.tail = t) : (this.head = t, this.tail = t), ++this.length
            }
        }, p.prototype.remove = function (e) {
            "undefined" != typeof e && ("undefined" != typeof e.previous && "undefined" != typeof e.next ? (e.previous.next = e.next, e.next.previous = e.previous) : "undefined" != typeof e.previous ? (e.previous.next = void 0, this.tail = e.previous) : "undefined" != typeof e.next ? (e.next.previous = void 0, this.head = e.next) : (this.head = void 0, this.tail = void 0), --this.length)
        };
        var S = new i, b = new i, T = {removeDuplicates: function (t) {
            if ("undefined" == typeof t)throw new e("positions is required.");
            var n = t.length;
            if (3 > n)throw new e("At least three positions are required.");
            for (var i = [], r = n - 1, o = 0; n > o; r = o++) {
                var a = t[r], s = t[o];
                a.equals(s) || i.push(s)
            }
            return i
        }, computeArea2D: function (t) {
            if ("undefined" == typeof t)throw new e("positions is required.");
            var n = t.length;
            if (3 > n)throw new e("At least three positions are required.");
            for (var i = 0, r = n - 1, o = 0; n > o; r = o++) {
                var a = t[r], s = t[o];
                i += a.x * s.y - s.x * a.y
            }
            return.5 * i
        }, computeWindingOrder2D: function (e) {
            var t = T.computeArea2D(e);
            return t >= 0 ? h.COUNTER_CLOCKWISE : h.CLOCKWISE
        }, earClip2D: function (t) {
            if ("undefined" == typeof t)throw new e("positions is required.");
            var n = t.length;
            if (3 > n)throw new e("At least three positions are required.");
            for (var i = new p, r = 0; n > r; ++r)i.add({position: t[r], index: r});
            for (var o = [], a = i.head, s = a.next, u = s.next, c = n * n; i.length > 3;) {
                var d = a.item.position, f = s.item.position, h = u.item.position;
                if (m(d, f, h)) {
                    for (var y = !0, v = u.next ? u.next : i.head; v !== a; v = v.next ? v.next : i.head)if (l(v.item.position, d, f, h)) {
                        y = !1;
                        break
                    }
                    if (y) {
                        o.push(a.item.index), o.push(s.item.index), o.push(u.item.index), i.remove(s), s = u, u = u.next ? u.next : i.head;
                        continue
                    }
                }
                if (a = a.next ? a.next : i.head, s = s.next ? s.next : i.head, u = u.next ? u.next : i.head, 0 === --c)break
            }
            var g = i.head, _ = g.next, w = _.next;
            return o.push(g.item.index), o.push(_.item.index), o.push(w.item.index), o
        }, computeSubdivision: function (n, i, a) {
            if ("undefined" == typeof n)throw new e("positions is required.");
            if ("undefined" == typeof i)throw new e("indices is required.");
            if (i.length < 3)throw new e("At least three indices are required.");
            if (0 !== i.length % 3)throw new e("The number of indices must be divisable by three.");
            if (a = u(a, t.RADIANS_PER_DEGREE), 0 >= a)throw new e("granularity must be greater than zero.");
            for (var s = new f, l = i.length, h = 0; l > h; h += 3)s.enqueue({i0: i[h], i1: i[h + 1], i2: i[h + 2]});
            for (var p, m = n.slice(0), y = [], v = {}; s.length > 0;) {
                var g, _ = s.dequeue(), w = m[_.i0], C = m[_.i1], x = m[_.i2], S = w.angleBetween(C), b = C.angleBetween(x), T = x.angleBetween(w), E = Math.max(S, Math.max(b, T));
                E > a ? S === E ? (g = Math.min(_.i0, _.i1).toString() + " " + Math.max(_.i0, _.i1).toString(), p = v[g], p || (m.push(w.add(C).multiplyByScalar(.5)), p = m.length - 1, v[g] = p), s.enqueue({i0: _.i0, i1: p, i2: _.i2}), s.enqueue({i0: p, i1: _.i1, i2: _.i2})) : b === E ? (g = Math.min(_.i1, _.i2).toString() + " " + Math.max(_.i1, _.i2).toString(), p = v[g], p || (m.push(C.add(x).multiplyByScalar(.5)), p = m.length - 1, v[g] = p), s.enqueue({i0: _.i1, i1: p, i2: _.i0}), s.enqueue({i0: p, i1: _.i2, i2: _.i0})) : T === E && (g = Math.min(_.i2, _.i0).toString() + " " + Math.max(_.i2, _.i0).toString(), p = v[g], p || (m.push(x.add(w).multiplyByScalar(.5)), p = m.length - 1, v[g] = p), s.enqueue({i0: _.i2, i1: p, i2: _.i1}), s.enqueue({i0: p, i1: _.i0, i2: _.i1})) : (y.push(_.i0), y.push(_.i1), y.push(_.i2))
            }
            var A = m.length, M = new Array(3 * A), D = 0;
            for (p = 0; A > p; p++) {
                var I = m[p];
                M[D++] = I.x, M[D++] = I.y, M[D++] = I.z
            }
            return new r({attributes: {position: new o({componentDatatype: c.DOUBLE, componentsPerAttribute: 3, values: M})}, indices: y, primitiveType: d.TRIANGLES})
        }, scaleToGeodeticHeight: function (e, t, n) {
            n = u(n, a.WGS84);
            var r = S, o = b;
            if (t = u(t, 0), "undefined" != typeof e && "undefined" != typeof e.attributes && "undefined" != typeof e.attributes.position)for (var s = e.attributes.position.values, l = s.length, c = 0; l > c; c += 3)o.x = s[c], o.y = s[c + 1], o.z = s[c + 2], n.scaleToGeodeticSurface(o, o), n.geodeticSurfaceNormal(o, r), i.multiplyByScalar(r, t, r), i.add(o, r, o), s[c] = o.x, s[c + 1] = o.y, s[c + 2] = o.z;
            return e
        }, eliminateHoles: function (t, n, r) {
            if ("undefined" == typeof t)throw new e("outerRing is required.");
            if (0 === t.length)throw new e("outerRing must not be empty.");
            if ("undefined" == typeof n)throw new e("innerRings is required.");
            r = u(r, a.WGS84);
            for (var o = [], s = 0; s < n.length; s++) {
                for (var l = [], c = 0; c < n[s].length; c++)l.push(i.clone(n[s][c]));
                o.push(l)
            }
            for (var d = t; o.length > 0;)d = x(d, o, r);
            return d
        }};
        return T
    }), n("Core/PolygonGeometry", ["./defaultValue", "./BoundingRectangle", "./BoundingSphere", "./Cartesian2", "./Cartesian3", "./Cartesian4", "./ComponentDatatype", "./DeveloperError", "./Ellipsoid", "./EllipsoidTangentPlane", "./Geometry", "./GeometryAttribute", "./GeometryAttributes", "./GeometryInstance", "./GeometryPipeline", "./IndexDatatype", "./Intersect", "./Math", "./Matrix3", "./PolygonPipeline", "./PrimitiveType", "./Quaternion", "./Queue", "./VertexFormat", "./WindingOrder"], function (e, t, n, i, r, o, a, s, u, l, c, d, f, h, p, m, y, v, g, _, w, C, x, S, b) {
        "use strict";
        function T(e, t, n, i) {
            for (var o = C.fromAxisAngle(e._plane.normal, n, L), a = g.fromQuaternion(o, N), s = Number.POSITIVE_INFINITY, u = Number.NEGATIVE_INFINITY, l = Number.POSITIVE_INFINITY, c = Number.NEGATIVE_INFINITY, d = t.length, f = 0; d > f; ++f) {
                var h = r.clone(t[f], z);
                g.multiplyByVector(a, h, h);
                var p = e.projectPointOntoPlane(h, R);
                "undefined" != typeof p && (s = Math.min(s, p.x), u = Math.max(u, p.x), l = Math.min(l, p.y), c = Math.max(c, p.y))
            }
            return i.x = s, i.y = l, i.width = u - s, i.height = c - l, i
        }

        function E(e, t, n) {
            var i = _.removeDuplicates(t);
            if (i.length < 3)throw new s("Duplicate positions result in not enough positions to form a polygon.");
            var r = l.fromPoints(i, e), o = r.projectPointsOntoPlane(i, F), a = _.computeWindingOrder2D(o);
            a === b.CLOCKWISE && (o.reverse(), i.reverse());
            var u = _.earClip2D(o);
            return new h({geometry: _.computeSubdivision(i, u, n)})
        }

        function A(e, t, n, o, s, u, c) {
            if (e.st || e.normal || e.tangent || e.binormal) {
                var f = _.removeDuplicates(n), h = l.fromPoints(f, o), p = T(h, n, s, V), m = j;
                m.x = p.x, m.y = p.y;
                var y = t.attributes.position.values, w = y.length, x = e.st ? new Float32Array(2 * (w / 3)) : void 0, S = e.normal ? new Float32Array(w) : void 0, b = e.tangent ? new Float32Array(w) : void 0, E = e.binormal ? new Float32Array(w) : void 0, A = 0, M = 0, D = k, I = U, P = q, O = !0, R = C.fromAxisAngle(h._plane.normal, s, Z), z = g.fromQuaternion(R, K), L = w / 2, N = w / 3;
                u && (w /= 2);
                for (var F = 0; w > F; F += 3) {
                    var W = r.fromArray(y, F, X);
                    if (e.st) {
                        var J = g.multiplyByVector(z, W, B), Q = h.projectPointOntoPlane(J, Y);
                        i.subtract(Q, m, Q), u && (x[A + N] = Q.x / p.width, x[A + 1 + N] = Q.y / p.height), x[A] = Q.x / p.width, x[A + 1] = Q.y / p.height, A += 2
                    }
                    if (e.normal || e.tangent || e.binormal) {
                        var $ = M + 1, et = M + 2;
                        c ? (w > F + 3 && (H = r.fromArray(y, F + 3, H), O && (G = r.fromArray(y, F + w, G), H.subtract(W, H), G.subtract(W, G), D = r.cross(G, H, D).normalize(D), O = !1), H.equalsEpsilon(W, v.EPSILON10) && (O = !0)), (e.tangent || e.binormal) && (P = o.geodeticSurfaceNormal(W, P), e.tangent && (I = r.cross(P, D, I).normalize(I)))) : (D = o.geodeticSurfaceNormal(W, D), (e.tangent || e.binormal) && (I = r.cross(r.UNIT_Z, D, I), I = g.multiplyByVector(z, I, I).normalize(I), e.binormal && (P = r.cross(D, I, P).normalize(P)))), e.normal && (u && !c ? (S[M + L] = -D.x, S[$ + L] = -D.y, S[et + L] = -D.z) : (S[M + L] = D.x, S[$ + L] = D.y, S[et + L] = D.z), S[M] = D.x, S[$] = D.y, S[et] = D.z), e.tangent && (u && !c ? (b[M + L] = -I.x, b[$ + L] = -I.y, b[et + L] = -I.z) : (b[M + L] = I.x, b[$ + L] = I.y, b[et + L] = I.z), b[M] = I.x, b[$] = I.y, b[et] = I.z), e.binormal && (u && (E[M + L] = P.x, E[$ + L] = P.y, E[et + L] = P.z), E[M] = P.x, E[$] = P.y, E[et] = P.z), M += 3
                    }
                }
                e.st && (t.attributes.st = new d({componentDatatype: a.FLOAT, componentsPerAttribute: 2, values: x})), e.normal && (t.attributes.normal = new d({componentDatatype: a.FLOAT, componentsPerAttribute: 3, values: S})), e.tangent && (t.attributes.tangent = new d({componentDatatype: a.FLOAT, componentsPerAttribute: 3, values: b})), e.binormal && (t.attributes.binormal = new d({componentDatatype: a.FLOAT, componentsPerAttribute: 3, values: E}))
            }
            return t
        }

        function M(t, n, i, o) {
            o = e(o, u.WGS84);
            var a = J, s = Q, l = $;
            if ("undefined" != typeof t && "undefined" != typeof t.attributes && "undefined" != typeof t.attributes.position)for (var c = t.attributes.position.values, d = c.length / 2, f = 0; d > f; f += 3)r.fromArray(c, f, l), o.scaleToGeodeticSurface(l, l), o.geodeticSurfaceNormal(l, a), r.multiplyByScalar(a, n, s), r.add(l, s, s), c[f] = s.x, c[f + 1] = s.y, c[f + 2] = s.z, r.multiplyByScalar(a, i, s), r.add(l, s, s), c[f + d] = s.x, c[f + 1 + d] = s.y, c[f + 2 + d] = s.z;
            return t
        }

        function D(e, t, n, i) {
            return et = t.subtract(e, et), et = et.multiplyByScalar(n / i, et), et = e.add(et, et), [et.x, et.y, et.z]
        }

        function I(e, t, n) {
            var i = r.distance(e, t), o = r.angleBetween(e, t), a = o / n, s = Math.ceil(Math.log(a) / Math.log(2));
            1 > s && (s = 0);
            var u = Math.pow(2, s), l = i / u, c = new Array(3 * u), d = 0;
            c[d++] = e.x, c[d++] = e.y, c[d++] = e.z;
            for (var f = 1; u > f; f++) {
                var h = D(e, t, f * l, i);
                c[d++] = h[0], c[d++] = h[1], c[d++] = h[2]
            }
            return c[d++] = t.x, c[d++] = t.y, c[d++] = t.z, c
        }

        function P(e, t) {
            var n, i, o, s, u, l, h, p = [], y = e.length;
            for (h = 0; y > h; h++)n = I(e[h], e[(h + 1) % y], t), p = p.concat(n);
            p = p.concat(p), y = p.length;
            var g = m.createTypedArray(y / 3, y - 6 * e.length);
            for (i = 0, y /= 6, h = 0; y > h; h++)o = h, s = o + 1, H = r.fromArray(p, 3 * o, H), G = r.fromArray(p, 3 * s, G), r.equalsEpsilon(H, G, v.EPSILON6) || (u = o + y, l = u + 1, g[i++] = o, g[i++] = u, g[i++] = s, g[i++] = s, g[i++] = u, g[i++] = l);
            return new c({attributes: new f({position: new d({componentDatatype: a.DOUBLE, componentsPerAttribute: 3, values: p})}), indices: g, primitiveType: w.TRIANGLES})
        }

        function O(e, t, n, i) {
            var r = E(e, t, n).geometry, o = r.attributes.position.values, s = r.indices, u = o.concat(o), l = u.length / 3, p = m.createTypedArray(l, 2 * s.length);
            p.set(s);
            var y, v = s.length, g = l / 2;
            for (y = 0; v > y; y += 3) {
                var w = p[y] + g, C = p[y + 1] + g, x = p[y + 2] + g;
                p[y + v] = x, p[y + 1 + v] = C, p[y + 2 + v] = w
            }
            var S = new c({attributes: new f({position: new d({componentDatatype: a.DOUBLE, componentsPerAttribute: 3, values: u})}), indices: p, primitiveType: r.primitiveType}), T = {topAndBottom: new h({geometry: S})};
            T.walls = [];
            var A = i.outerRing, M = _.computeWindingOrder2D(A);
            M === b.CLOCKWISE && (A = A.reverse());
            var D = P(A, n);
            T.walls.push(new h({geometry: D}));
            var I = i.holes;
            for (y = 0; y < I.length; y++) {
                var O = I[y];
                M = _.computeWindingOrder2D(O), M !== b.CLOCKWISE && (O = O.reverse()), D = P(O, n), T.walls.push(new h({geometry: D}))
            }
            return T
        }

        var R = new i, z = new r, L = new C, N = new g, F = [], V = new t, B = new r, k = new r, U = new r, q = new r, W = new n, H = new r, G = new r, j = new i, Y = new i, X = new r, Z = new C, K = new g, J = new r, Q = new r, $ = new r, et = new r, tt = function (t) {
            t = e(t, e.EMPTY_OBJECT);
            var i = e(t.vertexFormat, S.DEFAULT), o = e(t.ellipsoid, u.WGS84), a = e(t.granularity, v.RADIANS_PER_DEGREE), l = e(t.stRotation, 0), c = e(t.height, 0), d = e(t.extrudedHeight, void 0), f = "undefined" != typeof d && !v.equalsEpsilon(c, d, v.EPSILON6);
            if (f) {
                var h = d;
                d = Math.min(h, c), c = Math.max(h, c)
            }
            var y = t.polygonHierarchy;
            if ("undefined" == typeof y)throw new s("options.polygonHierarchy is required.");
            var g, w, C, b, T = [], D = new x;
            D.enqueue(y), y = [];
            for (var I; 0 !== D.length;) {
                var P = D.dequeue(), R = P.positions;
                if (R.length < 3)throw new s("At least three positions are required.");
                var z = P.holes ? P.holes.length : 0;
                if (0 === z)y.push({outerRing: R, holes: []}), T.push(P.positions); else {
                    var L = [];
                    for (I = 0; z > I; I++) {
                        var N = P.holes[I];
                        L.push(N.positions);
                        var F = 0;
                        "undefined" != typeof N.holes && (F = N.holes.length);
                        for (var V = 0; F > V; V++)D.enqueue(N.holes[V])
                    }
                    y.push({outerRing: R, holes: L});
                    var U = _.eliminateHoles(R, L);
                    T.push(U)
                }
            }
            b = T[0], g = n.fromPoints(b);
            var q, H = [];
            if (f) {
                for (I = 0; I < T.length; I++)if (q = O(o, T[I], a, y[I]), "undefined" != typeof q) {
                    C = q.topAndBottom, C.geometry = M(C.geometry, c, d, o), C.geometry = A(i, C.geometry, b, o, l, !0, !1), H.push(C), w = q.walls;
                    for (var G = 0; G < w.length; G++) {
                        var j = w[G];
                        j.geometry = M(j.geometry, c, d, o), j.geometry = A(i, j.geometry, b, o, l, !0, !0), H.push(j)
                    }
                }
            } else for (I = 0; I < T.length; I++)q = E(o, T[I], a), "undefined" != typeof q && (q.geometry = _.scaleToGeodeticHeight(q.geometry, c, o), q.geometry = A(i, q.geometry, b, o, l, !1, !1), H.push(q));
            q = p.combine(H);
            var Y = g.center;
            k = o.geodeticSurfaceNormal(Y, k), B = r.multiplyByScalar(k, c, B), Y = r.add(Y, B, Y), f && (W = g.clone(W), Y = W.center, B = r.multiplyByScalar(k, d, B), Y = r.add(Y, B, Y), g = n.union(g, W, g)), q.attributes.position.values = new Float64Array(q.attributes.position.values), q.indices = m.createTypedArray(q.attributes.position.values.length / 3, q.indices);
            var X = q.attributes;
            i.position || delete X.position, this.attributes = X, this.indices = q.indices, this.primitiveType = q.primitiveType, this.boundingSphere = g
        };
        return tt.fromPositions = function (t) {
            if (t = e(t, e.EMPTY_OBJECT), "undefined" == typeof t.positions)throw new s("options.positions is required.");
            var n = {polygonHierarchy: {positions: t.positions}, height: t.height, extrudedHeight: t.extrudedHeight, vertexFormat: t.vertexFormat, stRotation: t.stRotation, ellipsoid: t.ellipsoid, granularity: t.granularity};
            return new tt(n)
        }, tt
    }), n("Core/PolylinePipeline", ["./defaultValue", "./DeveloperError", "./Cartesian3", "./Cartesian4", "./IntersectionTests", "./Matrix4", "./Plane"], function (e, t, n, i, r, o, a) {
        "use strict";
        var s = {}, u = new o, l = new i, c = new i, d = new a(n.ZERO, 0), f = new i, h = new a(n.ZERO, 0), p = new n, m = new n;
        return s.wrapLongitude = function (t, s) {
            var y = [], v = [];
            if ("undefined" != typeof t && t.length > 0) {
                s = e(s, o.IDENTITY);
                var g = o.inverseTransformation(s, u), _ = o.multiplyByPoint(g, n.ZERO, l), w = o.multiplyByVector(g, i.UNIT_Y, c), C = a.fromPointNormal(_, w, d), x = o.multiplyByVector(g, i.UNIT_X, f), S = a.fromPointNormal(_, x, h), b = 1;
                y.push(n.clone(t[0]));
                for (var T = y[0], E = t.length, A = 1; E > A; ++A) {
                    var M = t[A];
                    if (a.getPointDistance(S, T) < 0 || a.getPointDistance(S, M) < 0) {
                        var D = r.lineSegmentPlane(T, M, C, p);
                        if ("undefined" != typeof D) {
                            var I = n.multiplyByScalar(w, 5e-9, m);
                            a.getPointDistance(C, T) < 0 && n.negate(I, I), y.push(n.add(D, I)), v.push(b + 1), n.negate(I, I), y.push(n.add(D, I)), b = 1
                        }
                    }
                    y.push(n.clone(t[A])), b++, T = M
                }
                v.push(b)
            }
            return{positions: y, lengths: v}
        }, s.removeDuplicates = function (e) {
            if ("undefined" == typeof e)throw new t("positions is required.");
            var n = e.length;
            if (2 > n)return e.slice(0);
            var i = [];
            i.push(e[0]);
            for (var r = 1; n > r; ++r) {
                var o = e[r - 1], a = e[r];
                o.equals(a) || i.push(a)
            }
            return i
        }, s
    }), n("Core/ReferenceFrame", ["./Enumeration"], function (e) {
        "use strict";
        var t = {FIXED: new e(0, "FIXED"), INERTIAL: new e(1, "INERTIAL")};
        return t
    }), n("Core/destroyObject", ["./defaultValue", "./DeveloperError"], function (e, t) {
        "use strict";
        function n() {
            return!0
        }

        var i = function (i, r) {
            function o() {
                throw new t(r)
            }

            r = e(r, "This object was destroyed, i.e., destroy() was called.");
            for (var a in i)"function" == typeof i[a] && (i[a] = o);
            return i.isDestroyed = n, void 0
        };
        return i
    }), n("Core/ScreenSpaceEventType", ["./Enumeration"], function (e) {
        "use strict";
        var t = {LEFT_DOWN: new e(0, "LEFT_DOWN"), LEFT_UP: new e(1, "LEFT_UP"), LEFT_CLICK: new e(2, "LEFT_CLICK"), LEFT_DOUBLE_CLICK: new e(3, "LEFT_DOUBLE_CLICK"), RIGHT_DOWN: new e(5, "RIGHT_DOWN"), RIGHT_UP: new e(6, "RIGHT_UP"), RIGHT_CLICK: new e(7, "RIGHT_CLICK"), RIGHT_DOUBLE_CLICK: new e(8, "RIGHT_DOUBLE_CLICK"), MIDDLE_DOWN: new e(10, "MIDDLE_DOWN"), MIDDLE_UP: new e(11, "MIDDLE_UP"), MIDDLE_CLICK: new e(12, "MIDDLE_CLICK"), MIDDLE_DOUBLE_CLICK: new e(13, "MIDDLE_DOUBLE_CLICK"), MOUSE_MOVE: new e(15, "MOUSE_MOVE"), WHEEL: new e(16, "WHEEL"), PINCH_START: new e(17, "PINCH_START"), PINCH_END: new e(18, "PINCH_END"), PINCH_MOVE: new e(19, "PINCH_MOVE")};
        return t
    }), n("Core/ScreenSpaceEventHandler", ["./DeveloperError", "./destroyObject", "./Cartesian2", "./ScreenSpaceEventType", "./KeyboardEventModifier", "./defaultValue"], function (e, t, n, i, r, o) {
        "use strict";
        function a(e, t) {
            if (e._element === document)return{x: t.clientX, y: t.clientY};
            var n = e._element.getBoundingClientRect();
            return{x: t.clientX - n.left, y: t.clientY - n.top}
        }

        function s(e) {
            return e.shiftKey ? r.SHIFT : e.ctrlKey ? r.CTRL : e.altKey ? r.ALT : void 0
        }

        function u(e, t) {
            var r = a(e, t);
            if (e._lastMouseX = r.x, e._lastMouseY = r.y, e._totalPixels = 0, !e._seenAnyTouchEvents) {
                var o, u = s(t);
                0 === t.button ? (e._leftMouseButtonDown = !0, o = e.getInputAction(i.LEFT_DOWN, u)) : 1 === t.button ? (e._middleMouseButtonDown = !0, o = e.getInputAction(i.MIDDLE_DOWN, u)) : 2 === t.button && (e._rightMouseButtonDown = !0, o = e.getInputAction(i.RIGHT_DOWN, u)), "undefined" != typeof o && o({position: new n(r.x, r.y)}), t.preventDefault()
            }
        }

        function l(e, t) {
            var r, o, u = s(t);
            if (!e._seenAnyTouchEvents) {
                0 === t.button ? (e._leftMouseButtonDown = !1, r = e.getInputAction(i.LEFT_UP, u), o = e.getInputAction(i.LEFT_CLICK, u)) : 1 === t.button ? (e._middleMouseButtonDown = !1, r = e.getInputAction(i.MIDDLE_UP, u), o = e.getInputAction(i.MIDDLE_CLICK, u)) : 2 === t.button && (e._rightMouseButtonDown = !1, r = e.getInputAction(i.RIGHT_UP, u), o = e.getInputAction(i.RIGHT_CLICK, u));
                var l = a(e, t), c = e._lastMouseX - l.x, d = e._lastMouseY - l.y;
                e._totalPixels += Math.sqrt(c * c + d * d), "undefined" != typeof r && r({position: new n(l.x, l.y)}), "undefined" != typeof o && e._totalPixels < e._clickPixelTolerance && o({position: new n(l.x, l.y)})
            }
        }

        function c(e, t) {
            var r = a(e, t);
            if (!e._seenAnyTouchEvents) {
                var o = e._lastMouseX - r.x, u = e._lastMouseY - r.y;
                e._totalPixels += Math.sqrt(o * o + u * u);
                var l = {startPosition: new n(e._lastMouseX, e._lastMouseY), endPosition: new n(r.x, r.y), motion: new n}, c = s(t), d = e.getInputAction(i.MOUSE_MOVE, c);
                "undefined" != typeof d && d(l), e._lastMouseX = l.endPosition.x, e._lastMouseY = l.endPosition.y, (e._leftMouseButtonDown || e._middleMouseButtonDown || e._rightMouseButtonDown) && t.preventDefault()
            }
        }

        function d(e, t) {
            var r, o, u = t.touches.length;
            e._seenAnyTouchEvents = !0;
            var l, c = s(t);
            r = a(e, t.touches[0]), 1 === u ? (e._lastMouseX = r.x, e._lastMouseY = r.y, e._totalPixels = 0, e._leftMouseButtonDown = !0, l = e.getInputAction(i.LEFT_DOWN, c), "undefined" != typeof l && l({position: new n(r.x, r.y)}), t.preventDefault()) : e._leftMouseButtonDown && (e._leftMouseButtonDown = !1, l = e.getInputAction(i.LEFT_UP, c), "undefined" != typeof l && l({position: new n(r.x, r.y)})), 2 === u ? (e._isPinching = !0, o = a(e, t.touches[1]), e._touchID1 = t.touches[0].identifier, e._touchID2 = t.touches[1].identifier, e._lastMouseX = r.x, e._lastMouseY = r.y, e._lastTouch2X = o.x, e._lastTouch2Y = o.y, l = e.getInputAction(i.PINCH_START, c), "undefined" != typeof l && l({position1: new n(r.x, r.y), position2: new n(o.x, o.y)})) : e._isPinching && (e._isPinching = !1, l = e.getInputAction(i.PINCH_END, c), "undefined" != typeof l && l())
        }

        function f(e, t) {
            var r, o, u = t.touches.length, l = t.changedTouches.length, c = s(t);
            if (e._leftMouseButtonDown && (e._leftMouseButtonDown = !1, r = e.getInputAction(i.LEFT_UP, c), o = e.getInputAction(i.LEFT_CLICK, c), l > 0)) {
                var f = a(e, t.changedTouches[0]), h = e._lastMouseX - f.x, p = e._lastMouseY - f.y;
                e._totalPixels += Math.sqrt(h * h + p * p), "undefined" != typeof r && r({position: new n(f.x, f.y)}), "undefined" != typeof o && e._totalPixels < e._clickPixelTolerance && o({position: new n(f.x, f.y)})
            }
            e._isPinching && (e._isPinching = !1, r = e.getInputAction(i.PINCH_END, c), r && r()), (1 === u || 2 === u) && d(e, t)
        }

        function h(e, t) {
            var r, o, u, l, c = s(t);
            if (e._leftMouseButtonDown && 1 === t.touches.length) {
                r = a(e, t.touches[0]);
                var d = e._lastMouseX - r.x, f = e._lastMouseY - r.y;
                e._totalPixels += Math.sqrt(d * d + f * f), l = {startPosition: new n(e._lastMouseX, e._lastMouseY), endPosition: new n(r.x, r.y), motion: new n}, u = e.getInputAction(i.MOUSE_MOVE, c), "undefined" != typeof u && u(l), e._lastMouseX = l.endPosition.x, e._lastMouseY = l.endPosition.y, (e._leftMouseButtonDown || e._middleMouseButtonDown || e._rightMouseButtonDown) && t.preventDefault()
            }
            if (e._isPinching && 2 === t.touches.length) {
                if (t.touches[0].identifier === e._touchID2 ? (r = a(e, t.touches[1]), o = a(e, t.touches[0])) : (r = a(e, t.touches[0]), o = a(e, t.touches[1])), u = e.getInputAction(i.PINCH_MOVE, c), "undefined" != typeof u) {
                    var h = o.x - r.x, p = o.y - r.y, m = .25 * Math.sqrt(h * h + p * p), y = e._lastTouch2X - e._lastMouseX, v = e._lastTouch2Y - e._lastMouseY, g = .25 * Math.sqrt(y * y + v * v), _ = .125 * (o.y + r.y), w = .125 * (e._lastTouch2Y + e._lastMouseY), C = Math.atan2(p, h), x = Math.atan2(v, y);
                    l = {distance: {startPosition: new n(0, g), endPosition: new n(0, m), motion: new n}, angleAndHeight: {startPosition: new n(x, w), endPosition: new n(C, _), motion: new n}}, u(l)
                }
                e._lastMouseX = r.x, e._lastMouseY = r.y, e._lastTouch2X = o.x, e._lastTouch2Y = o.y
            }
        }

        function p(e, t) {
            var n = t.detail ? -120 * t.detail : t.wheelDelta, r = s(t), o = i.WHEEL, a = e.getInputAction(o, r);
            "undefined" != typeof a && (t.preventDefault(), a(n))
        }

        function m(e, t) {
            var r, o = s(t), u = a(e, t);
            0 === t.button ? r = e.getInputAction(i.LEFT_DOUBLE_CLICK, o) : 1 === t.button ? r = e.getInputAction(i.MIDDLE_DOUBLE_CLICK, o) : 2 === t.button && (r = e.getInputAction(i.RIGHT_DOUBLE_CLICK, o)), "undefined" != typeof r && r({position: new n(u.x, u.y)})
        }

        function y(e) {
            var t = e, n = !0;
            e._callbacks = [], "undefined" != typeof e._element.disableRootEvents && (n = !1), e._callbacks.push({name: "mousedown", onDoc: !1, action: function (e) {
                u(t, e)
            }}), e._callbacks.push({name: "mouseup", onDoc: n, action: function (e) {
                l(t, e)
            }}), e._callbacks.push({name: "mousemove", onDoc: n, action: function (e) {
                c(t, e)
            }}), e._callbacks.push({name: "dblclick", onDoc: !1, action: function (e) {
                m(t, e)
            }}), e._callbacks.push({name: "touchstart", onDoc: !1, action: function (e) {
                d(t, e)
            }}), e._callbacks.push({name: "touchend", onDoc: n, action: function (e) {
                f(t, e)
            }}), e._callbacks.push({name: "touchmove", onDoc: n, action: function (e) {
                h(t, e)
            }}), e._callbacks.push({name: "mousewheel", onDoc: !1, action: function (e) {
                p(t, e)
            }}), e._callbacks.push({name: "DOMMouseScroll", onDoc: !1, action: function (e) {
                p(t, e)
            }});
            for (var i = 0; i < e._callbacks.length; i++) {
                var r = e._callbacks[i];
                r.onDoc ? document.addEventListener(r.name, r.action, !1) : e._element.addEventListener(r.name, r.action, !1)
            }
        }

        var v = function (e) {
            this._mouseEvents = {};
            for (var t in i)i.hasOwnProperty(t) && (this._mouseEvents[t] = void 0);
            this._modifiedMouseEvents = {};
            for (var n in r)if (r.hasOwnProperty(n)) {
                this._modifiedMouseEvents[n] = {};
                for (t in i)i.hasOwnProperty(t) && (this._modifiedMouseEvents[n][t] = void 0)
            }
            this._leftMouseButtonDown = !1, this._middleMouseButtonDown = !1, this._rightMouseButtonDown = !1, this._isPinching = !1, this._seenAnyTouchEvents = !1, this._lastMouseX = 0, this._lastMouseY = 0, this._lastTouch2X = 0, this._lastTouch2Y = 0, this._totalPixels = 0, this._touchID1 = 0, this._touchID2 = 0, this._clickPixelTolerance = 5, this._element = o(e, document), y(this)
        };
        return v.prototype.setInputAction = function (t, n, i) {
            if ("undefined" == typeof t)throw new e("action is required.");
            if ("undefined" == typeof n)throw new e("type is required.");
            var r;
            r = "undefined" != typeof i && "undefined" != typeof i.name ? this._modifiedMouseEvents[i.name] : this._mouseEvents, "undefined" != typeof n && "undefined" != typeof n.name && "undefined" != typeof r && (r[n.name] = t)
        }, v.prototype.getInputAction = function (t, n) {
            if ("undefined" == typeof t)throw new e("type is required.");
            var i;
            return i = "undefined" != typeof n && "undefined" != typeof n.name ? this._modifiedMouseEvents[n.name] : this._mouseEvents, "undefined" != typeof t && "undefined" != typeof t.name && "undefined" != typeof i ? i[t.name] : void 0
        }, v.prototype.removeInputAction = function (t, n) {
            if ("undefined" == typeof t)throw new e("type is required.");
            var i;
            i = "undefined" != typeof n && "undefined" != typeof n.name ? this._modifiedMouseEvents[n.name] : this._mouseEvents, "undefined" != typeof t && "undefined" != typeof t.name && "undefined" != typeof i && "undefined" != typeof i[t.name] && delete i[t.name]
        }, v.prototype._unregister = function () {
            for (var e = 0; e < this._callbacks.length; e++) {
                var t = this._callbacks[e];
                t.onDoc ? document.removeEventListener(t.name, t.action, !1) : this._element.removeEventListener(t.name, t.action, !1)
            }
        }, v.prototype.isDestroyed = function () {
            return!1
        }, v.prototype.destroy = function () {
            return this._unregister(), t(this)
        }, v
    }), n("Core/Shapes", ["./defaultValue", "./DeveloperError", "./Math", "./Cartesian3", "./Quaternion", "./Matrix3"], function (e, t, n, i, r, o) {
        "use strict";
        function a(e, t, n, i, a, s, u, l, c, d, f, h, p, m, y, v, g, _) {
            for (var w, C, x, S, b, T, E, A, M = 0; _ > M; M++, p += y, ++g) {
                C = y > 0 ? h[p] + m : m - h[p], S = C + f, b = -Math.cos(S), E = c.multiplyByScalar(b), b = Math.sin(S), A = d.multiplyByScalar(b), E = E.add(A), b = Math.cos(C), b *= b, T = Math.sin(C), T *= T, x = a / Math.sqrt(i * b + n * T), w = x / t, b = Math.sin(w / 2);
                var D = new r(E.x * b, E.y * b, E.z * b, Math.cos(w / 2)).normalize(), I = o.fromQuaternion(D), P = I.multiplyByVector(l), O = P.normalize();
                P = O.multiplyByScalar(u), v[g] = P
            }
        }

        var s = {computeCircleBoundary: function (i, r, o, a) {
            if ("undefined" == typeof i || "undefined" == typeof r || "undefined" == typeof o)throw new t("ellipsoid, center, and radius are required.");
            if (0 >= o)throw new t("radius must be greater than zero.");
            if (a = e(a, n.RADIANS_PER_DEGREE), 0 >= a)throw new t("granularity must be greater than zero.");
            return this.computeEllipseBoundary(i, r, o, o, 0, a)
        }, computeEllipseBoundary: function (r, o, s, u, l, c) {
            if ("undefined" == typeof r || "undefined" == typeof o || "undefined" == typeof s || "undefined" == typeof u)throw new t("ellipsoid, center, semiMajorAxis, and semiMinorAxis are required.");
            if (0 >= s || 0 >= u)throw new t("Semi-major and semi-minor axes must be greater than zero.");
            if (l = l || 0, c = e(c, n.RADIANS_PER_DEGREE), 0 >= c)throw new t("granularity must be greater than zero.");
            if (u > s) {
                var d = s;
                s = u, u = d
            }
            for (var f = 2.31, h = s * s, p = u * u, m = s * u, y = 1 - p / h, v = Math.sqrt(y), g = i.clone(o), _ = g.magnitude(), w = new i(0, 0, 1), C = 1 / _, x = g.multiplyByScalar(C), S = w.cross(g).normalize(), b = x.cross(S), T = 1 + Math.ceil(n.PI_OVER_TWO / c), E = f / (T - 1), A = [], M = 0, D = 0, I = 0; T > I; I++, D += E, ++M)if (A[M] = D - v * Math.sin(D), A[M] >= n.PI_OVER_TWO) {
                A[M] = n.PI_OVER_TWO, T = I + 1;
                break
            }
            var P = [];
            return a(r, g.magnitude(), h, p, m, v, _, x, S, b, l, A, 0, 0, 1, P, 0, T - 1), a(r, g.magnitude(), h, p, m, v, _, x, S, b, l, A, T - 1, Math.PI, -1, P, T - 1, T - 1), a(r, g.magnitude(), h, p, m, v, _, x, S, b, l, A, 0, Math.PI, 1, P, 2 * T - 2, T - 1), a(r, g.magnitude(), h, p, m, v, _, x, S, b, l, A, T - 1, n.TWO_PI, -1, P, 3 * T - 3, T), P.push(P[0].clone()), P
        }};
        return s
    }), n("Core/ShowGeometryInstanceAttribute", ["./defaultValue", "./ComponentDatatype", "./DeveloperError"], function (e, t, n) {
        "use strict";
        var i = function (n) {
            n = e(n, !0), this.componentDatatype = t.UNSIGNED_BYTE, this.componentsPerAttribute = 1, this.normalize = !0, this.value = i.toValue(n)
        };
        return i.toValue = function (e) {
            if ("undefined" == typeof e)throw new n("show is required.");
            return new Uint8Array([e])
        }, i
    }), n("Core/Simon1994PlanetaryPositions", ["./Cartesian3", "./DeveloperError", "./JulianDate", "./Math", "./Matrix3", "./TimeConstants", "./TimeStandard"], function (e, t, n, i, r, o, a) {
        "use strict";
        function s(e) {
            var t = 6.239996 + .0172019696544 * e;
            return.001657 * Math.sin(t + .01671 * Math.sin(t))
        }

        function u(e, t) {
            t = e.addSeconds(_, t);
            var n = t.getTotalDays() - w;
            return t = t.addSeconds(s(n), t)
        }

        function l(n, r, o, a, s, u, l, f) {
            if (0 > o && (o = -o, s += i.PI), 0 > o || o > i.PI)throw new t("The inclination is out of range. Inclination must be greater than or equal to zero and less than or equal to Pi radians.");
            var h = n * (1 - r), m = a - s, y = s, v = d(u - a, r), g = c(r, 0);
            if ("Hyperbolic" === g && Math.abs(i.NegativePiToPi(v)) >= Math.acos(-1 / r))throw new t("The true anomaly of the hyperbolic orbit lies outside of the bounds of the hyperbola.");
            p(m, o, y, M);
            var _ = h * (1 + r), w = Math.cos(v), C = Math.sin(v), x = 1 + r * w;
            if (x <= i.Epsilon10)throw new t("elements cannot be converted to cartesian");
            var S = _ / x;
            return"undefined" == typeof f ? f = new e(S * w, S * C, 0) : (f.x = S * w, f.y = S * C, f.z = 0), M.multiplyByVector(f, f)
        }

        function c(e, n) {
            if (0 > e)throw new t("eccentricity cannot be negative.");
            return n >= e ? "Circular" : 1 - n > e ? "Elliptical" : 1 + n >= e ? "Parabolic" : "Hyperbolic"
        }

        function d(e, n) {
            if (0 > n || n >= 1)throw new t("eccentricity out of range.");
            var i = f(e, n);
            return h(i, n)
        }

        function f(e, n) {
            if (0 > n || n >= 1)throw new t("eccentricity out of range.");
            var r = Math.floor(e / i.TWO_PI);
            e -= r * i.TWO_PI;
            var o, a = e + n * Math.sin(e) / (1 - Math.sin(e + n) + Math.sin(e)), s = Number.MAX_VALUE;
            for (o = 0; D > o && Math.abs(s - a) > I; ++o) {
                s = a;
                var u = s - n * Math.sin(s) - e, l = 1 - n * Math.cos(s);
                a = s - u / l
            }
            if (o >= D)throw new t("Kepler equation did not converge");
            return s = a + r * i.TWO_PI
        }

        function h(e, n) {
            if (0 > n || n >= 1)throw new t("eccentricity out of range.");
            var r = Math.floor(e / i.TWO_PI);
            e -= r * i.TWO_PI;
            var o = Math.cos(e) - n, a = Math.sin(e) * Math.sqrt(1 - n * n), s = Math.atan2(a, o);
            return s = i.zeroToTwoPi(s), 0 > e && (s -= i.TWO_PI), s += r * i.TWO_PI
        }

        function p(e, n, o, a) {
            if (0 > n || n > i.PI)throw new t("inclination out of range");
            var s = Math.cos(e), u = Math.sin(e), l = Math.cos(n), c = Math.sin(n), d = Math.cos(o), f = Math.sin(o);
            return"undefined" == typeof a ? a = new r(d * s - f * u * l, -d * u - f * s * l, f * c, f * s + d * u * l, -f * u + d * s * l, -d * c, u * c, s * c, l) : (a[0] = d * s - f * u * l, a[1] = f * s + d * u * l, a[2] = u * c, a[3] = -d * u - f * s * l, a[4] = -f * u + d * s * l, a[5] = s * c, a[6] = f * c, a[7] = -d * c, a[8] = l), a
        }

        function m(e, t) {
            u(e, Mt);
            var n = Mt.getJulianDayNumber() - C.getJulianDayNumber() + (Mt.getSecondsOfDay() - C.getSecondsOfDay()) / o.SECONDS_PER_DAY, i = n / (10 * o.DAYS_PER_JULIAN_CENTURY), r = .3595362 * i, a = P + q * Math.cos(z * r) + K * Math.sin(z * r) + W * Math.cos(L * r) + J * Math.sin(L * r) + H * Math.cos(N * r) + Q * Math.sin(N * r) + G * Math.cos(F * r) + $ * Math.sin(F * r) + j * Math.cos(V * r) + et * Math.sin(V * r) + Y * Math.cos(B * r) + tt * Math.sin(B * r) + X * Math.cos(k * r) + nt * Math.sin(k * r) + Z * Math.cos(U * r) + it * Math.sin(U * r), s = O + R * i + ft * Math.cos(rt * r) + wt * Math.sin(rt * r) + ht * Math.cos(ot * r) + Ct * Math.sin(ot * r) + pt * Math.cos(at * r) + xt * Math.sin(at * r) + mt * Math.cos(st * r) + St * Math.sin(st * r) + yt * Math.cos(ut * r) + bt * Math.sin(ut * r) + vt * Math.cos(lt * r) + Tt * Math.sin(lt * r) + gt * Math.cos(ct * r) + Et * Math.sin(ct * r) + _t * Math.cos(dt * r) + At * Math.sin(dt * r), c = .0167086342 - .0004203654 * i, d = 102.93734808 * T + 11612.3529 * E * i, f = 469.97289 * E * i, h = 174.87317577 * T - 8679.27034 * E * i;
            return l(a, c, f, d, h, s, S, t)
        }

        function y(e, t) {
            u(e, Mt);
            var n = Mt.getJulianDayNumber() - C.getJulianDayNumber() + (Mt.getSecondsOfDay() - C.getSecondsOfDay()) / o.SECONDS_PER_DAY, i = n / o.DAYS_PER_JULIAN_CENTURY, r = i * i, a = r * i, s = a * i, c = 383397.7725 + .004 * i, d = .055545526 - 1.6e-8 * i, f = 5.15668983 * T, h = -8e-5 * i + .02966 * r - 42e-6 * a - 1.3e-7 * s, p = 83.35324312 * T, m = 14643420.2669 * i - 38.2702 * r - .045047 * a + 21301e-8 * s, y = 125.04455501 * T, v = -6967919.3631 * i + 6.3602 * r + .007625 * a - 3586e-8 * s, g = 218.31664563 * T, _ = 1732559343.4847 * i - 6.391 * r + .006588 * a - 3169e-8 * s, w = 297.85019547 * T + E * (1602961601.209 * i - 6.3706 * r + .006593 * a - 3169e-8 * s), S = 93.27209062 * T + E * (1739527262.8478 * i - 12.7512 * r - .001037 * a + 417e-8 * s), A = 134.96340251 * T + E * (1717915923.2178 * i + 31.8792 * r + .051635 * a - 2447e-7 * s), M = 357.52910918 * T + E * (129596581.0481 * i - .5532 * r + 136e-6 * a - 1149e-8 * s), D = 310.17137918 * T - E * (6967051.436 * i + 6.2068 * r + .007618 * a - 3219e-8 * s), I = 2 * w, P = 4 * w, O = 6 * w, R = 2 * A, z = 3 * A, L = 4 * A, N = 2 * S;
            c += 3400.4 * Math.cos(I) - 635.6 * Math.cos(I - A) - 235.6 * Math.cos(A) + 218.1 * Math.cos(I - M) + 181 * Math.cos(I + A), d += .014216 * Math.cos(I - A) + .008551 * Math.cos(I - R) - .001383 * Math.cos(A) + .001356 * Math.cos(I + A) - .001147 * Math.cos(P - z) - 914e-6 * Math.cos(P - R) + 869e-6 * Math.cos(I - M - A) - 627e-6 * Math.cos(I) - 394e-6 * Math.cos(P - L) + 282e-6 * Math.cos(I - M - R) - 279e-6 * Math.cos(w - A) - 236e-6 * Math.cos(R) + 231e-6 * Math.cos(P) + 229e-6 * Math.cos(O - L) - 201e-6 * Math.cos(R - N), h += 486.26 * Math.cos(I - N) - 40.13 * Math.cos(I) + 37.51 * Math.cos(N) + 25.73 * Math.cos(R - N) + 19.97 * Math.cos(I - M - N), m += -55609 * Math.sin(I - A) - 34711 * Math.sin(I - R) - 9792 * Math.sin(A) + 9385 * Math.sin(P - z) + 7505 * Math.sin(P - R) + 5318 * Math.sin(I + A) + 3484 * Math.sin(P - L) - 3417 * Math.sin(I - M - A) - 2530 * Math.sin(O - L) - 2376 * Math.sin(I) - 2075 * Math.sin(I - z) - 1883 * Math.sin(R) - 1736 * Math.sin(O - 5 * A) + 1626 * Math.sin(M) - 1370 * Math.sin(O - z), v += -5392 * Math.sin(I - N) - 540 * Math.sin(M) - 441 * Math.sin(I) + 423 * Math.sin(N) - 288 * Math.sin(R - N), _ += -3332.9 * Math.sin(I) + 1197.4 * Math.sin(I - A) - 662.5 * Math.sin(M) + 396.3 * Math.sin(A) - 218 * Math.sin(I - M);
            var F = 2 * D, V = 3 * D;
            h += 46.997 * Math.cos(D) * i - .614 * Math.cos(I - N + D) * i + .614 * Math.cos(I - N - D) * i - .0297 * Math.cos(F) * r - .0335 * Math.cos(D) * r + .0012 * Math.cos(I - N + F) * r - 16e-5 * Math.cos(D) * a + 4e-5 * Math.cos(V) * a + 4e-5 * Math.cos(F) * a;
            var B = 2.116 * Math.sin(D) * i - .111 * Math.sin(I - N - D) * i - .0015 * Math.sin(D) * r;
            m += B, _ += B, v += -520.77 * Math.sin(D) * i + 13.66 * Math.sin(I - N + D) * i + 1.12 * Math.sin(I - D) * i - 1.06 * Math.sin(N - D) * i + .66 * Math.sin(F) * r + .371 * Math.sin(D) * r - .035 * Math.sin(I - N + F) * r - .015 * Math.sin(I - N + D) * r + .0014 * Math.sin(D) * a - .0011 * Math.sin(V) * a - 9e-4 * Math.sin(F) * a, c *= b;
            var k = f + h * E, U = p + m * E, q = g + _ * E, W = y + v * E;
            return l(c, d, k, U, W, q, x, t)
        }

        function v(e, t) {
            var n = y(e);
            return t = n.multiplyByScalar(It, t)
        }

        var g = {}, _ = 32.184, w = 2451545, C = n.fromTotalDays(2451545, a.TAI), x = 398600435e6, S = 328900.56 * 1.012300034 * x, b = 1e3, T = i.RADIANS_PER_DEGREE, E = i.RADIANS_PER_ARCSECOND, A = 14959787e4, M = new r, D = 50, I = i.EPSILON8, P = 1.0000010178 * A, O = 100.46645683 * T, R = 1295977422.83429 * E, z = 16002, L = 21863, N = 32004, F = 10931, V = 14529, B = 16368, k = 15318, U = 32794, q = 64e-7 * A, W = -152 * 1e-7 * A, H = 62e-7 * A, G = -8e-7 * A, j = 32e-7 * A, Y = -41 * 1e-7 * A, X = 19e-7 * A, Z = -11 * 1e-7 * A, K = -150 * 1e-7 * A, J = -46 * 1e-7 * A, Q = 68 * 1e-7 * A, $ = 54e-7 * A, et = 14e-7 * A, tt = 24e-7 * A, nt = -28 * 1e-7 * A, it = 22e-7 * A, rt = 10, ot = 16002, at = 21863, st = 10931, ut = 1473, lt = 32004, ct = 4387, dt = 73, ft = -325 * 1e-7, ht = -322 * 1e-7, pt = -79 * 1e-7, mt = 232 * 1e-7, yt = -52 * 1e-7, vt = 97e-7, gt = 55e-7, _t = -41 * 1e-7, wt = -105 * 1e-7, Ct = -137 * 1e-7, xt = 258e-7, St = 35e-7, bt = -116 * 1e-7, Tt = -88 * 1e-7, Et = -112 * 1e-7, At = -80 * 1e-7, Mt = new n, Dt = .012300034, It = -1 * (Dt / (Dt + 1)), Pt = new r(1.0000000000000002, 5.619723173785822e-16, 4.690511510146299e-19, -5.154129427414611e-16, .9174820620691819, -.39777715593191376, -2.23970096136568e-16, .39777715593191376, .9174820620691819), Ot = new e;
        return g.ComputeSunPositionInEarthInertialFrame = function (e, t) {
            return"undefined" == typeof e && (e = new n), Ot = m(e, Ot), t = Ot.negate(t), v(e, Ot), t.subtract(Ot, t), Pt.multiplyByVector(t, t), t
        }, g.ComputeMoonPositionInEarthInertialFrame = function (e, t) {
            return"undefined" == typeof e && (e = new n), t = y(e, t), Pt.multiplyByVector(t, t), t
        }, g
    }), n("Core/SimplePolylineGeometry", ["./DeveloperError", "./ComponentDatatype", "./IndexDatatype", "./PrimitiveType", "./defaultValue", "./BoundingSphere", "./GeometryAttribute", "./GeometryAttributes"], function (e, t, n, i, r, o, a, s) {
        "use strict";
        var u = function (u) {
            u = r(u, r.EMPTY_OBJECT);
            var l = u.positions;
            if ("undefined" == typeof l || l.length < 2)throw new e("At least two positions are required.");
            var c, d = 0, f = l.length, h = new Float64Array(3 * f);
            for (c = 0; f > c; ++c) {
                var p = l[c];
                h[d++] = p.x, h[d++] = p.y, h[d++] = p.z
            }
            var m = new s;
            m.position = new a({componentDatatype: t.DOUBLE, componentsPerAttribute: 3, values: h});
            var y = 2 * (f - 1), v = n.createTypedArray(f, y);
            for (d = 0, c = 0; f - 1 > c; ++c)v[d++] = c, v[d++] = c + 1;
            this.attributes = m, this.indices = v, this.primitiveType = i.LINES, this.boundingSphere = o.fromPoints(l)
        };
        return u
    }), n("Core/SphereGeometry", ["./defaultValue", "./Cartesian3", "./EllipsoidGeometry"], function (e, t, n) {
        "use strict";
        var i = function (i) {
            var r = e(i.radius, 1), o = new t(r, r, r), a = {radii: o, numberOfPartitions: i.numberOfPartitions, vertexFormat: i.vertexFormat}, s = new n(a);
            this.attributes = s.attributes, this.indices = s.indices, this.primitiveType = s.primitiveType, this.boundingSphere = s.boundingSphere
        };
        return i
    }), n("Core/Spherical", ["./DeveloperError", "./defaultValue"], function (e, t) {
        "use strict";
        var n = function (e, n, i) {
            this.clock = t(e, 0), this.cone = t(n, 0), this.magnitude = t(i, 1)
        };
        return n.fromCartesian3 = function (t, i) {
            if ("undefined" == typeof t)throw new e("cartesian3 is required");
            var r = t.x, o = t.y, a = t.z, s = r * r + o * o;
            return"undefined" == typeof i && (i = new n), i.clock = Math.atan2(o, r), i.cone = Math.atan2(Math.sqrt(s), a), i.magnitude = Math.sqrt(s + a * a), i
        }, n.clone = function (e, t) {
            return"undefined" == typeof e ? void 0 : "undefined" == typeof t ? new n(e.clock, e.cone, e.magnitude) : (t.clock = e.clock, t.cone = e.cone, t.magnitude = e.magnitude, t)
        }, n.normalize = function (t, i) {
            if ("undefined" == typeof t)throw new e("spherical is required");
            return"undefined" == typeof i ? new n(t.clock, t.cone, 1) : (i.clock = t.clock, i.cone = t.cone, i.magnitude = 1, i)
        }, n.equals = function (e, t) {
            return e === t || "undefined" != typeof e && "undefined" != typeof t && e.clock === t.clock && e.cone === t.cone && e.magnitude === t.magnitude
        }, n.equalsEpsilon = function (e, n, i) {
            return i = t(i, 0), e === n || "undefined" != typeof e && "undefined" != typeof n && Math.abs(e.clock - n.clock) <= i && Math.abs(e.cone - n.cone) <= i && Math.abs(e.magnitude - n.magnitude) <= i
        }, n.toString = function (e) {
            return"(" + e.clock + ", " + e.cone + ", " + e.magnitude + ")"
        }, n.prototype.clone = function (e) {
            return n.clone(this, e)
        }, n.prototype.normalize = function (e) {
            return n.normalize(this, e)
        }, n.prototype.equals = function (e) {
            return n.equals(this, e)
        }, n.prototype.equalsEpsilon = function (e, t) {
            return n.equalsEpsilon(this, e, t)
        }, n.prototype.toString = function () {
            return n.toString(this)
        }, n
    }), n("Core/isCrossOriginUrl", [], function () {
        "use strict";
        var e, t = function (t) {
            "undefined" == typeof e && (e = document.createElement("a")), e.href = window.location.href;
            var n = e.host, i = e.protocol;
            return e.href = t, e.href = e.href, i !== e.protocol || n !== e.host
        };
        return t
    }), n("ThirdParty/Uri", [], function () {
        function e(t) {
            if (t instanceof e)this.scheme = t.scheme, this.authority = t.authority, this.path = t.path, this.query = t.query, this.fragment = t.fragment; else if (t) {
                var n = i.exec(t);
                this.scheme = n[1], this.authority = n[2], this.path = n[3], this.query = n[4], this.fragment = n[5]
            }
        }

        function t(e) {
            var t = unescape(e);
            return o.test(t) ? t : e.toUpperCase()
        }

        function n(e, t, n, i) {
            return(t || "") + n.toLowerCase() + (i || "")
        }

        e.prototype.scheme = null, e.prototype.authority = null, e.prototype.path = "", e.prototype.query = null, e.prototype.fragment = null;
        var i = new RegExp("^(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\\?([^#]*))?(?:#(.*))?$");
        e.prototype.getScheme = function () {
            return this.scheme
        }, e.prototype.getAuthority = function () {
            return this.authority
        }, e.prototype.getPath = function () {
            return this.path
        }, e.prototype.getQuery = function () {
            return this.query
        }, e.prototype.getFragment = function () {
            return this.fragment
        }, e.prototype.isAbsolute = function () {
            return!!this.scheme && !this.fragment
        }, e.prototype.isSameDocumentAs = function (e) {
            return e.scheme == this.scheme && e.authority == this.authority && e.path == this.path && e.query == this.query
        }, e.prototype.equals = function (e) {
            return this.isSameDocumentAs(e) && e.fragment == this.fragment
        }, e.prototype.normalize = function () {
            this.removeDotSegments(), this.scheme && (this.scheme = this.scheme.toLowerCase()), this.authority && (this.authority = this.authority.replace(a, n).replace(r, t)), this.path && (this.path = this.path.replace(r, t)), this.query && (this.query = this.query.replace(r, t)), this.fragment && (this.fragment = this.fragment.replace(r, t))
        };
        var r = /%[0-9a-z]{2}/gi, o = /[a-zA-Z0-9\-\._~]/, a = /(.*@)?([^@:]*)(:.*)?/;
        e.prototype.resolve = function (t) {
            var n = new e;
            return this.scheme ? (n.scheme = this.scheme, n.authority = this.authority, n.path = this.path, n.query = this.query) : (n.scheme = t.scheme, this.authority ? (n.authority = this.authority, n.path = this.path, n.query = this.query) : (n.authority = t.authority, "" == this.path ? (n.path = t.path, n.query = this.query || t.query) : ("/" == this.path.charAt(0) ? (n.path = this.path, n.removeDotSegments()) : (n.path = t.authority && "" == t.path ? "/" + this.path : t.path.substring(0, t.path.lastIndexOf("/") + 1) + this.path, n.removeDotSegments()), n.query = this.query))), n.fragment = this.fragment, n
        }, e.prototype.removeDotSegments = function () {
            var e, t = this.path.split("/"), n = [], i = "" == t[0];
            for (i && t.shift(), "" == t[0] ? t.shift() : null; t.length;)e = t.shift(), ".." == e ? n.pop() : "." != e && n.push(e);
            ("." == e || ".." == e) && n.push(""), i && n.unshift(""), this.path = n.join("/")
        }, e.resolve = function (t, n) {
            var i = s[t] || (s[t] = new e(t)), r = s[n] || (s[n] = new e(n));
            return i.resolve(r).toString()
        };
        var s = {};
        return e.prototype.toString = function () {
            var e = "";
            return this.scheme && (e += this.scheme + ":"), this.authority && (e += "//" + this.authority), e += this.path, this.query && (e += "?" + this.query), this.fragment && (e += "#" + this.fragment), e
        }, e
    }), n("Core/TaskProcessor", ["require", "./buildModuleUrl", "./defaultValue", "./isCrossOriginUrl", "../ThirdParty/when", "../ThirdParty/Uri"], function (e, t, n, i, r, o) {
        "use strict";
        function a(e, t) {
            --e._activeTasks;
            var n = t.data, i = n.id, r = n.result, o = e._deferreds, a = o[i];
            a.resolve(r), delete o[i]
        }

        function s() {
            if ("undefined" != typeof l)return l;
            if (l = t("Workers/cesiumWorkerBootstrapper.js"), i(l)) {
                var e, n = 'importScripts("' + l + '");';
                try {
                    e = new Blob([n], {type: "application/javascript"})
                } catch (r) {
                    var o = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder, a = new o;
                    a.append(n), e = a.getBlob("application/javascript")
                }
                var s = window.URL || window.webkitURL;
                l = s.createObjectURL(e)
            }
            return l
        }

        function u(i) {
            var r = s(), u = new Worker(r);
            u.postMessage = n(u.webkitPostMessage, u.postMessage);
            var l = {loaderConfig: {}, workerModule: "Workers/" + i._workerName};
            if ("undefined" != typeof e.toUrl) {
                var c = new o("..").resolve(new o(t("Workers/cesiumWorkerBootstrapper.js"))).toString();
                l.loaderConfig.baseUrl = c
            } else l.loaderConfig.paths = {Workers: t("Workers")};
            u.postMessage(l), u.onmessage = function (e) {
                a(i, e)
            }, i._worker = u
        }

        var l, c = function (e, t) {
            this._workerName = e, this._maximumActiveTasks = n(t, 5), this._activeTasks = 0, this._deferreds = {}, this._nextID = 0
        };
        return c.prototype.scheduleTask = function (e, t) {
            if ("undefined" == typeof this._worker && u(this), this._activeTasks >= this._maximumActiveTasks)return void 0;
            ++this._activeTasks;
            var n = this._nextID++, i = r.defer();
            return this._deferreds[n] = i, this._worker.postMessage({id: n, parameters: e}, t), i.promise
        }, c
    }), n("Core/TimeIntervalCollection", ["./DeveloperError", "./binarySearch", "./TimeInterval", "./JulianDate"], function (e, t, n, i) {
        "use strict";
        function r(e, t) {
            return i.compare(e.start, t.start)
        }

        function o(e, t, n, i) {
            for (var r = 0, o = 0, s = new a, u = e._intervals, l = t._intervals; r < u.length && o < l.length;) {
                var c = u[r], d = l[o];
                if (c.stop.lessThan(d.start))++r; else if (d.stop.lessThan(c.start))++o; else {
                    if ("undefined" != typeof i || "undefined" != typeof n && n(c, d) || "undefined" == typeof n && d.data === c.data) {
                        var f = c.intersect(d, i);
                        f.isEmpty || s.addInterval(f, n)
                    }
                    c.stop.lessThan(d.stop) || c.stop.equals(d.stop) && !c.isStopIncluded && d.isStopIncluded ? ++r : ++o
                }
            }
            return s
        }

        var a = function () {
            this._intervals = []
        };
        return a.prototype.get = function (t) {
            if (isNaN(t))throw new e("index must be a number.");
            return this._intervals[t]
        }, a.prototype.getStart = function () {
            var e = this._intervals;
            return 0 === e.length ? void 0 : e[0].start
        }, a.prototype.getStop = function () {
            var e = this._intervals, t = e.length;
            return 0 === t ? void 0 : e[t - 1].stop
        }, a.prototype.getLength = function () {
            return this._intervals.length
        }, a.prototype.clear = function () {
            this._intervals = []
        }, a.prototype.isEmpty = function () {
            return 0 === this._intervals.length
        }, a.prototype.findIntervalContainingDate = function (e) {
            var t = this.indexOf(e);
            return t >= 0 ? this._intervals[t] : void 0
        }, a.prototype.contains = function (e) {
            return this.indexOf(e) >= 0
        }, a.prototype.indexOf = function (i) {
            if ("undefined" == typeof i)throw new e("date required");
            var o = this._intervals, a = t(o, new n(i, i, !0, !0), r);
            return a >= 0 ? o[a].isStartIncluded ? a : a > 0 && o[a - 1].stop.equals(i) && o[a - 1].isStopIncluded ? a - 1 : ~a : (a = ~a, a > 0 && a - 1 < o.length && o[a - 1].contains(i) ? a - 1 : ~a)
        }, a.prototype.findInterval = function (e, t, n, i) {
            for (var r, o = this._intervals, a = 0, s = o.length; s > a; a++)if (r = o[a], !("undefined" != typeof e && !r.start.equals(e) || "undefined" != typeof t && !r.stop.equals(t) || "undefined" != typeof n && r.isStartIncluded !== n || "undefined" != typeof i && r.isStopIncluded !== i))return o[a];
            return void 0
        }, a.prototype.addInterval = function (o, a) {
            if ("undefined" == typeof o)throw new e("interval is required");
            if (!o.isEmpty) {
                var s, u, l = this._intervals;
                if (0 === l.length || o.start.greaterThan(l[l.length - 1].stop))return l.push(o), void 0;
                for (u = t(l, o, r), 0 > u ? u = ~u : u > 0 && o.isStartIncluded && l[u - 1].isStartIncluded && l[u - 1].start.equals(o.start) ? --u : u < l.length && !o.isStartIncluded && l[u].isStartIncluded && l[u].start.equals(o.start) && ++u, u > 0 && (s = i.compare(l[u - 1].stop, o.start), (s > 0 || 0 === s && (l[u - 1].isStopIncluded || o.isStartIncluded)) && (("undefined" != typeof a ? a(l[u - 1].data, o.data) : l[u - 1].data === o.data) ? (o = o.stop.greaterThan(l[u - 1].stop) ? new n(l[u - 1].start, o.stop, l[u - 1].isStartIncluded, o.isStopIncluded, o.data) : new n(l[u - 1].start, l[u - 1].stop, l[u - 1].isStartIncluded, l[u - 1].isStopIncluded || o.stop.equals(l[u - 1].stop) && o.isStopIncluded, o.data), l.splice(u - 1, 1), --u) : (s = i.compare(l[u - 1].stop, o.stop), s > 0 || 0 === s && l[u - 1].isStopIncluded && !o.isStopIncluded ? l.splice(u - 1, 1, new n(l[u - 1].start, o.start, l[u - 1].isStartIncluded, !o.isStartIncluded, l[u - 1].data), new n(o.stop, l[u - 1].stop, !o.isStopIncluded, l[u - 1].isStopIncluded, l[u - 1].data)) : l[u - 1] = new n(l[u - 1].start, o.start, l[u - 1].isStartIncluded, !o.isStartIncluded, l[u - 1].data)))); u < l.length && (s = i.compare(o.stop, l[u].start), s > 0 || 0 === s && (o.isStopIncluded || l[u].isStartIncluded));)if ("undefined" != typeof a ? a(l[u].data, o.data) : l[u].data === o.data)o = new n(o.start, l[u].stop.greaterThan(o.stop) ? l[u].stop : o.stop, o.isStartIncluded, l[u].stop.greaterThan(o.stop) ? l[u].isStopIncluded : o.isStopIncluded, o.data), l.splice(u, 1); else {
                    if (l[u] = new n(o.stop, l[u].stop, !o.isStopIncluded, l[u].isStopIncluded, l[u].data), !l[u].isEmpty)break;
                    l.splice(u, 1)
                }
                l.splice(u, 0, o)
            }
        }, a.prototype.removeInterval = function (i) {
            if ("undefined" == typeof i)throw new e("interval is required");
            if (i.isEmpty)return!1;
            var o = !1, a = this._intervals, s = t(a, i, r);
            0 > s && (s = ~s);
            var u = i.start, l = i.stop, c = i.isStartIncluded, d = i.isStopIncluded;
            if (s > 0) {
                var f = a[s - 1], h = f.stop;
                (h.greaterThan(u) || h.equals(u) && f.isStopIncluded && c) && (o = !0, (h.greaterThan(l) || f.isStopIncluded && !d && h.equals(l)) && a.splice(s, 0, new n(l, h, !d, f.isStopIncluded, f.data)), a[s - 1] = new n(f.start, u, f.isStartIncluded, !c, f.data))
            }
            var p = a[s];
            for (s < a.length && !c && p.isStartIncluded && u.equals(p.start) && (o = !0, a.splice(s, 0, new n(p.start, p.start, !0, !0, p.data)), ++s, p = a[s]); s < a.length && l.greaterThan(p.stop);)o = !0, a.splice(s, 1);
            return s < a.length && l.equals(p.stop) && (o = !0, !d && p.isStopIncluded ? s + 1 < a.length && a[s + 1].start.equals(l) && p.data === a[s + 1].data ? (a.splice(s, 1), a[s] = p = new n(p.start, p.stop, !0, p.isStopIncluded, p.data)) : a[s] = p = new n(l, l, !0, !0, p.data) : a.splice(s, 1)), s < a.length && (l.greaterThan(p.start) || l.equals(p.start) && d && p.isStartIncluded) && (o = !0, a[s] = new n(l, p.stop, !d, p.isStopIncluded, p.data)), o
        }, a.prototype.intersect = function (t, n, i) {
            if ("undefined" == typeof t)throw new e("timeIntervalCollection is required.");
            return o(this, t, n, i)
        }, a.prototype.intersectInterval = function (t, n, i) {
            if ("undefined" == typeof t)throw new e("interval is required.");
            var r = new a;
            return r.addInterval(t), o(this, r, n, i)
        }, a
    }), n("Core/WallGeometry", ["./defaultValue", "./BoundingSphere", "./Cartesian3", "./Cartographic", "./ComponentDatatype", "./IndexDatatype", "./DeveloperError", "./Ellipsoid", "./EllipsoidTangentPlane", "./GeometryAttribute", "./GeometryAttributes", "./Math", "./PolylinePipeline", "./PolygonPipeline", "./PrimitiveType", "./VertexFormat", "./WindingOrder"], function (e, t, n, i, r, o, a, s, u, l, c, d, f, h, p, m, y) {
        "use strict";
        function v(e, t, i, r, o, a) {
            var s = e.length;
            r.push(e[0]), "undefined" != typeof t && o.push(t[0]), "undefined" != typeof i && a.push(i[0]);
            for (var u = 1; s > u; ++u) {
                var l = e[u - 1], c = e[u];
                n.equals(l, c) || (r.push(c), "undefined" != typeof t && o.push(t[u]), "undefined" != typeof i && a.push(i[u]))
            }
        }

        var g = new i, _ = new n, w = new n, C = new n, x = new n, S = new n, b = new n, T = function (i) {
            i = e(i, e.EMPTY_OBJECT);
            var f = i.positions, T = i.maximumHeights, E = i.minimumHeights, A = e(i.ellipsoid, s.WGS84), M = e(i.vertexFormat, m.DEFAULT);
            if ("undefined" == typeof f)throw new a("positions is required.");
            if ("undefined" != typeof T && T.length !== f.length)throw new a("positions and maximumHeights must have the same length.");
            if ("undefined" != typeof E && E.length !== f.length)throw new a("positions and minimumHeights must have the same length.");
            var D = [], I = "undefined" != typeof T ? [] : void 0, P = "undefined" != typeof E ? [] : void 0;
            if (v(f, T, E, D, I, P), f = D, T = I, E = P, f.length >= 3) {
                var O = u.fromPoints(f, A), R = O.projectPointsOntoPlane(f);
                h.computeWindingOrder2D(R) === y.CLOCKWISE && (f.reverse(), "undefined" != typeof T && T.reverse(), "undefined" != typeof E && E.reverse())
            }
            var z, L = f.length, N = 3 * 2 * 2 * (L - 1), F = M.position ? new Float64Array(N) : void 0, V = M.normal ? new Float32Array(N) : void 0, B = M.tangent ? new Float32Array(N) : void 0, k = M.binormal ? new Float32Array(N) : void 0, U = M.st ? new Float32Array(2 * (N / 3)) : void 0, q = 0, W = 0, H = 0, G = 0, j = 0, Y = b, X = S, Z = x, K = !0;
            for (z = 0; L - 1 > z; ++z)for (var J = 0; 2 > J; ++J) {
                var Q = z + J, $ = f[Q], et = A.cartesianToCartographic($, g);
                "undefined" != typeof T && (et.height = T[Q]);
                var tt = A.cartographicToCartesian(et, _);
                et.height = 0, "undefined" != typeof E ? et.height += E[Q] : et.height = 0;
                var nt = A.cartographicToCartesian(et, w);
                if (M.position && (F[q++] = nt.x, F[q++] = nt.y, F[q++] = nt.z, F[q++] = tt.x, F[q++] = tt.y, F[q++] = tt.z), M.normal || M.tangent || M.binormal) {
                    var it;
                    L > Q + 1 && (it = n.clone(f[Q + 1], C)), K && (it = it.subtract(tt, it), nt = nt.subtract(tt, nt), Y = n.cross(nt, it, Y).normalize(Y), M.tangent && (X = it.normalize(X)), M.binormal && (Z = n.cross(Y, X, Z).normalize(Z)), K = !1), 1 === J && (K = !0), M.normal && (V[W++] = Y.x, V[W++] = Y.y, V[W++] = Y.z, V[W++] = Y.x, V[W++] = Y.y, V[W++] = Y.z), M.tangent && (B[H++] = X.x, B[H++] = X.y, B[H++] = X.z, B[H++] = X.x, B[H++] = X.y, B[H++] = X.z), M.binormal && (k[G++] = Z.x, k[G++] = Z.y, k[G++] = Z.z, k[G++] = Z.x, k[G++] = Z.y, k[G++] = Z.z)
                }
                if (M.st) {
                    var rt = Q / (L - 1);
                    U[j++] = rt, U[j++] = 0, U[j++] = rt, U[j++] = 1
                }
            }
            var ot = new c;
            M.position && (ot.position = new l({componentDatatype: r.DOUBLE, componentsPerAttribute: 3, values: F})), M.normal && (ot.normal = new l({componentDatatype: r.FLOAT, componentsPerAttribute: 3, values: V})), M.tangent && (ot.tangent = new l({componentDatatype: r.FLOAT, componentsPerAttribute: 3, values: B})), M.binormal && (ot.binormal = new l({componentDatatype: r.FLOAT, componentsPerAttribute: 3, values: k})), M.st && (ot.st = new l({componentDatatype: r.FLOAT, componentsPerAttribute: 2, values: U}));
            var at = N / 3;
            N -= 6;
            var st = o.createTypedArray(at, N), ut = 0;
            for (z = 0; at - 2 > z; z += 2) {
                var lt = z, ct = z + 2, dt = n.fromArray(F, 3 * lt, _), ft = n.fromArray(F, 3 * ct, w);
                if (!n.equalsEpsilon(dt, ft, d.EPSILON6)) {
                    var ht = z + 1, pt = z + 3;
                    st[ut++] = ht, st[ut++] = lt, st[ut++] = pt, st[ut++] = pt, st[ut++] = lt, st[ut++] = ct
                }
            }
            this.attributes = ot, this.indices = st, this.primitiveType = p.TRIANGLES, this.boundingSphere = new t.fromVertices(F)
        };
        return T.fromConstantHeights = function (t) {
            t = e(t, e.EMPTY_OBJECT);
            var n = t.positions;
            if ("undefined" == typeof n)throw new a("options.positions is required.");
            var i, r, o = t.minimumHeight, s = t.maximumHeight;
            if ("undefined" != typeof o || "undefined" != typeof s) {
                var u = n.length;
                i = "undefined" != typeof o ? new Array(u) : void 0, r = "undefined" != typeof s ? new Array(u) : void 0;
                for (var l = 0; u > l; ++l)"undefined" != typeof o && (i[l] = o), "undefined" != typeof s && (r[l] = s)
            }
            var c = {positions: n, maximumHeights: r, minimumHeights: i, ellipsoid: t.ellipsoid, vertexFormat: t.vertexFormat};
            return new T(c)
        }, T
    }), n("Core/WebMercatorProjection", ["./defaultValue", "./Cartesian3", "./Cartographic", "./Math", "./Ellipsoid"], function (e, t, n, i, r) {
        "use strict";
        var o = function (t) {
            this._ellipsoid = e(t, r.WGS84), this._semimajorAxis = this._ellipsoid.getMaximumRadius(), this._oneOverSemimajorAxis = 1 / this._semimajorAxis
        };
        return o.mercatorAngleToGeodeticLatitude = function (e) {
            return i.PI_OVER_TWO - 2 * Math.atan(Math.exp(-e))
        }, o.geodeticLatitudeToMercatorAngle = function (e) {
            e > o.MaximumLatitude ? e = o.MaximumLatitude : e < -o.MaximumLatitude && (e = -o.MaximumLatitude);
            var t = Math.sin(e);
            return.5 * Math.log((1 + t) / (1 - t))
        }, o.MaximumLatitude = o.mercatorAngleToGeodeticLatitude(Math.PI), o.prototype.getEllipsoid = function () {
            return this._ellipsoid
        }, o.prototype.project = function (e, n) {
            var i = this._semimajorAxis, r = e.longitude * i, a = o.geodeticLatitudeToMercatorAngle(e.latitude) * i, s = e.height;
            return"undefined" == typeof n ? new t(r, a, s) : (n.x = r, n.y = a, n.z = s, n)
        }, o.prototype.unproject = function (e, t) {
            var i = this._oneOverSemimajorAxis, r = e.x * i, a = o.mercatorAngleToGeodeticLatitude(e.y * i), s = e.z;
            return"undefined" == typeof t ? new n(r, a, s) : (t.longitude = r, t.latitude = a, t.height = s, t)
        }, o
    }), n("Core/cancelAnimationFrame", [], function () {
        "use strict";
        var e = window.cancelAnimationFrame;
        !function () {
            if ("undefined" == typeof e)for (var t = ["webkit", "moz", "ms", "o"], n = 0, i = t.length; i > n && "undefined" == typeof e;)e = window[t[n] + "CancelAnimationFrame"], "undefined" == typeof e && (e = window[t[n] + "CancelRequestAnimationFrame"]), ++n;
            "undefined" == typeof e && (e = clearTimeout)
        }();
        var t = function (t) {
            e(t)
        };
        return t
    }), n("Core/combine", ["./DeveloperError", "./defaultValue"], function (e, t) {
        "use strict";
        var n = function (e, n, r) {
            n = t(n, !0), r = t(r, !0);
            for (var o = {}, a = 0; a < e.length; a++)i(o, e[a], n, r);
            return o
        }, i = function (t, n, r, o) {
            for (var a in n)if (n.hasOwnProperty(a))if (t.hasOwnProperty(a) && "undefined" != typeof t[a]) {
                if (!o)throw new e("Duplicate member: " + a);
                r && "object" == typeof t[a] && "object" == typeof n[a] && i(t[a], n[a], r, o)
            } else t[a] = n[a]
        };
        return n
    }), n("Core/createGuid", [], function () {
        "use strict";
        var e = function () {
            return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (e) {
                var t = 0 | 16 * Math.random(), n = "x" === e ? t : 8 | 3 & t;
                return n.toString(16)
            })
        };
        return e
    }), n("Core/defineProperties", [], function () {
        "use strict";
        var e = function () {
            try {
                return"x"in Object.defineProperty({}, "x", {})
            } catch (e) {
                return!1
            }
        }(), t = Object.defineProperties;
        return e && "undefined" != typeof t || (t = function (e) {
            return e
        }), t
    }), n("Core/defined", [], function () {
        "use strict";
        var e = function (e) {
            return void 0 !== e
        };
        return e
    }), n("Core/getImagePixels", [], function () {
        "use strict";
        var e = {}, t = function (t, n, i) {
            "undefined" == typeof n && (n = t.width), "undefined" == typeof i && (i = t.height);
            var r = e[n];
            "undefined" == typeof r && (r = {}, e[n] = r);
            var o = r[i];
            if ("undefined" == typeof o) {
                var a = document.createElement("canvas");
                a.width = n, a.height = i, o = a.getContext("2d"), o.globalCompositeOperation = "copy", r[i] = o
            }
            return o.drawImage(t, 0, 0, n, i), o.getImageData(0, 0, n, i).data
        };
        return t
    }), n("Core/jsonp", ["./defaultValue", "./DeveloperError", "../ThirdParty/when"], function (e, t, n) {
        "use strict";
        function i(e, t, n) {
            e.push(encodeURIComponent(t) + "=" + encodeURIComponent(n))
        }

        var r = function (o, a) {
            if ("undefined" == typeof o)throw new t("url is required.");
            a = e(a, e.EMPTY_OBJECT);
            var s, u = n.defer();
            do s = "jsonp" + Math.random().toString().substring(2, 8); while ("undefined" != typeof window[s]);
            window[s] = function (e) {
                u.resolve(e);
                try {
                    delete window[s]
                } catch (t) {
                    window[s] = void 0
                }
            };
            var l = e(a.callbackParameterName, "callback"), c = [];
            i(c, l, s);
            var d = e(a.parameters, e.EMPTY_OBJECT);
            for (var f in d)d.hasOwnProperty(f) && i(c, f, d[f]);
            c.length > 0 && (o += -1 === o.indexOf("?") ? "?" : "&", o += c.join("&"));
            var h = a.proxy;
            return"undefined" != typeof h && (o = h.getURL(o)), r.loadAndExecuteScript(o, s, u), u.promise
        };
        return r.loadAndExecuteScript = function (e, t, n) {
            var i = document.createElement("script");
            i.async = !0, i.src = e;
            var r = document.getElementsByTagName("head")[0];
            i.onload = function () {
                i.onload = void 0, r.removeChild(i)
            }, i.onerror = function (e) {
                n.reject(e)
            }, r.appendChild(i)
        }, r.defaultLoadAndExecuteScript = r.loadAndExecuteScript, r
    }), n("Core/loadArrayBuffer", ["./loadWithXhr"], function (e) {
        "use strict";
        var t = function (t, n) {
            return e(t, "arraybuffer", n)
        };
        return t
    }), n("Core/loadBlob", ["./loadWithXhr"], function (e) {
        "use strict";
        var t = function (t, n) {
            return e(t, "blob", n)
        };
        return t
    }), n("Core/loadImage", ["./defaultValue", "./DeveloperError", "./isCrossOriginUrl", "../ThirdParty/when"], function (e, t, n, i) {
        "use strict";
        var r = /^data:/, o = function (a, s) {
            if ("undefined" == typeof a)throw new t("url is required.");
            return s = e(s, !0), i(a, function (e) {
                var t;
                t = r.test(e) || !s ? !1 : n(e);
                var a = i.defer();
                return o.createImage(e, t, a), a.promise
            })
        };
        return o.createImage = function (e, t, n) {
            var i = new Image;
            i.onload = function () {
                n.resolve(i)
            }, i.onerror = function (e) {
                n.reject(e)
            }, t && (i.crossOrigin = ""), i.src = e
        }, o.defaultCreateImage = o.createImage, o
    }), n("Core/loadImageViaBlob", ["./loadBlob", "./loadImage"], function (e, t) {
        "use strict";
        var n = /^data:/, i = function (i) {
            return n.test(i) ? t(i) : e(i).then(function (e) {
                var n = window.URL.createObjectURL(e);
                return t(n, !1).then(function (t) {
                    return t.blob = e, window.URL.revokeObjectURL(n), t
                }, function (e) {
                    return window.URL.revokeObjectURL(n), e
                })
            })
        }, r = function () {
            try {
                var e = new XMLHttpRequest;
                return e.responseType = "blob", "blob" === e.responseType
            } catch (t) {
                return!1
            }
        }();
        return r ? i : t
    }), n("Core/loadXML", ["./DeveloperError", "./RequestErrorEvent", "../ThirdParty/when"], function (e, t, n) {
        "use strict";
        var i = function (t, r) {
            if ("undefined" == typeof t)throw new e("url is required.");
            return n(t, function (e) {
                var t = n.defer();
                return i.loadXML(e, r, t), t.promise
            })
        };
        return i.loadXML = function (e, n, i) {
            var r = new XMLHttpRequest;
            if (r.overrideMimeType("text/xml"), r.open("GET", e, !0), "undefined" != typeof n)for (var o in n)n.hasOwnProperty(o) && r.setRequestHeader(o, n[o]);
            r.onload = function () {
                200 === r.status ? i.resolve(r.responseXML) : i.reject(new t(r.status, r.response))
            }, r.onerror = function () {
                i.reject(new t)
            }, r.send()
        }, i.defaultLoadXML = i.loadXML, i
    }), n("Core/requestAnimationFrame", [], function () {
        "use strict";
        var e = window.requestAnimationFrame;
        !function () {
            if ("undefined" == typeof e)for (var t = ["webkit", "moz", "ms", "o"], n = 0, i = t.length; i > n && "undefined" == typeof e;)e = window[t[n] + "RequestAnimationFrame"], ++n;
            if ("undefined" == typeof e) {
                var r = 0;
                e = function (e) {
                    var t = Date.now(), n = Math.max(16 - (t - r), 0);
                    return r = t + n, setTimeout(function () {
                        e(r)
                    }, n)
                }
            }
        }();
        var t = function (t) {
            return e(t)
        };
        return t
    }), n("Core/throttleRequestByServer", ["./defaultValue", "../ThirdParty/when"], function (e, t) {
        "use strict";
        function n(e) {
            return"undefined" == typeof r && (r = document.createElement("a")), r.href = e, r.hostname + "%" + r.port
        }

        function i(i, r) {
            var s = n(i), u = e(a[s], 0);
            return u > o ? void 0 : (a[s] = u + 1, t(r(i), function (e) {
                return a[s]--, e
            }, function (e) {
                return a[s]--, t.reject(e)
            }))
        }

        var r, o = 6, a = {};
        return i
    }), n("Core/wrapFunction", ["./DeveloperError"], function (e) {
        "use strict";
        var t = function (t, n, i) {
            if ("function" != typeof n)throw new e("oldFunction is required to be a function.");
            if ("function" != typeof i)throw new e("oldFunction is required to be a function.");
            return function () {
                i.apply(t, arguments), n.apply(t, arguments)
            }
        };
        return t
    }), n("ThirdParty/measureText", [], function () {
        var e = function (e, t) {
            return document.defaultView.getComputedStyle(e, null).getPropertyValue(t)
        }, t = function (t, n, i, r) {
            var o = t.measureText(n), a = e(t.canvas, "font-family"), s = e(t.canvas, "font-size").replace("px", ""), u = !/\S/.test(n);
            o.fontsize = s;
            var l = document.createElement("div");
            l.style.position = "absolute", l.style.opacity = 0, l.style.font = s + "px " + a, l.innerHTML = n + "<br/>" + n, document.body.appendChild(l), o.leading = 1.2 * s;
            var c = e(l, "height");
            if (c = c.replace("px", ""), c >= 2 * s && (o.leading = 0 | c / 2), document.body.removeChild(l), u)o.ascent = 0, o.descent = 0, o.bounds = {minx: 0, maxx: o.width, miny: 0, maxy: 0}, o.height = 0; else {
                var d = document.createElement("canvas"), f = 100;
                d.width = o.width + f, d.height = 3 * s, d.style.opacity = 1, d.style.fontFamily = a, d.style.fontSize = s;
                var h = d.getContext("2d");
                h.font = s + "px " + a;
                var p = d.width, m = d.height, y = m / 2;
                h.fillStyle = "white", h.fillRect(-1, -1, p + 2, m + 2), i && (h.strokeStyle = "black", h.lineWidth = t.lineWidth, h.strokeText(n, f / 2, y)), r && (h.fillStyle = "black", h.fillText(n, f / 2, y));
                for (var v = h.getImageData(0, 0, p, m).data, g = 0, _ = 4 * p, w = v.length; ++g < w && 255 === v[g];);
                var C = 0 | g / _;
                for (g = w - 1; --g > 0 && 255 === v[g];);
                var x = 0 | g / _;
                for (g = 0; w > g && 255 === v[g];)g += _, g >= w && (g = g - w + 4);
                var S = 0 | g % _ / 4, b = 1;
                for (g = w - 3; g >= 0 && 255 === v[g];)g -= _, 0 > g && (g = w - 3 - 4 * b++);
                var T = 0 | g % _ / 4 + 1;
                o.ascent = y - C, o.descent = x - y, o.bounds = {minx: S - f / 2, maxx: T - f / 2, miny: 0, maxy: x - C}, o.height = 1 + (x - C)
            }
            return o
        };
        return t
    }), n("Core/writeTextToCanvas", ["./defaultValue", "./DeveloperError", "./Color", "../ThirdParty/measureText"], function (e, t, n, i) {
        "use strict";
        var r = function (r, o) {
            if ("undefined" == typeof r)throw new t("text is required.");
            if ("" === r)return void 0;
            o = e(o, e.EMPTY_OBJECT);
            var a = e(o.font, "10px sans-serif"), s = document.createElement("canvas");
            s.width = s.height = 1, s.style.font = a;
            var u = s.getContext("2d");
            u.font = a, u.textBaseline = e(o.textBaseline, "bottom"), s.style.visibility = "hidden", document.body.appendChild(s);
            var l = e(o.stroke, !1), c = e(o.fill, !0), d = 2 * e(o.strokeWidth, 1);
            u.lineWidth = d;
            var f = i(u, r, l, c);
            s.dimensions = f, document.body.removeChild(s), s.style.visibility = "";
            var h = f.height - f.ascent;
            s.width = f.width, s.height = f.height;
            var p = s.height - h;
            if (u.font = a, l) {
                var m = e(o.strokeColor, n.BLACK);
                u.strokeStyle = m.toCssColorString(), u.lineWidth = d, u.strokeText(r, 0, p)
            }
            if (c) {
                var y = e(o.fillColor, n.WHITE);
                u.fillStyle = y.toCssColorString(), u.fillText(r, 0, p)
            }
            return s
        };
        return r
    }), n("DynamicScene/DynamicProperty", ["../Core/DeveloperError", "../Core/Iso8601", "../Core/JulianDate", "../Core/TimeInterval", "../Core/TimeIntervalCollection", "../Core/binarySearch", "../Core/HermitePolynomialApproximation", "../Core/LinearApproximation", "../Core/LagrangePolynomialApproximation"], function (e, t, n, i, r, o, a, s, u) {
        "use strict";
        function l() {
            this.interpolationAlgorithm = s, this.numberOfPoints = s.getRequiredDataPoints(1), this.interpolationDegree = 1, this.times = void 0, this.values = void 0, this.isSampled = !1, this.xTable = void 0, this.yTable = void 0
        }

        function c(e, t) {
            return"string" == typeof e ? n.fromIso8601(e) : t.addSeconds(e)
        }

        function d(e, t, n) {
            var i, r = e.length, o = n.length, a = r + o;
            if (e.length = a, r !== t) {
                var s = r - 1;
                for (i = a - 1; i >= t; i--)e[i] = e[s--]
            }
            for (i = 0; o > i; i++)e[t++] = n[i]
        }

        var f = {HERMITE: a, LAGRANGE: u, LINEAR: s}, h = function (t) {
            if ("undefined" == typeof t)throw new e("valueType is required.");
            this.valueType = t, this._intervals = new r, this._cachedTime = void 0, this._cachedInterval = void 0
        };
        h.prototype.processCzmlIntervals = function (e, t, n) {
            if (Array.isArray(e))for (var i = 0, r = e.length; r > i; i++)this._addCzmlInterval(e[i], t, n); else this._addCzmlInterval(e, t, n)
        };
        var p;
        return h.prototype.getValue = function (e, t) {
            var i = this.valueType;
            if ("undefined" != typeof this._staticValue)return i.getValue(this._staticValue, t);
            var r = this._cachedInterval;
            if (n.equals(this._cachedTime, e) || (this._cachedTime = n.clone(e, this._cachedTime), "undefined" != typeof r && r.contains(e) || (r = this._intervals.findIntervalContainingDate(e), this._cachedInterval = r)), "undefined" == typeof r)return void 0;
            var a = r.data, s = a.times, u = a.values;
            if (a.isSampled && s.length >= 0 && u.length > 0) {
                var l = i.doublesPerValue, c = o(s, e, n.compare);
                if (0 > c) {
                    if (a.numberOfPoints < 2)return void 0;
                    c = ~c, c >= s.length && (c = s.length - 1);
                    var d = 0, f = s.length - 1, h = a.numberOfPoints - 1, m = f - d + 1;
                    if (h + 1 > m); else {
                        var y = c - (0 | h / 2) - 1;
                        d > y && (y = d);
                        var v = y + h;
                        v > f && (v = f, y = v - h, d > y && (y = d)), d = y, f = v
                    }
                    var g = f - d + 1, _ = i.doublesPerInterpolationValue, w = a.xTable, C = a.yTable;
                    "undefined" == typeof w && (w = a.xTable = new Array(a.numberOfPoints), C = a.yTable = new Array(a.numberOfPoints * _));
                    for (var x = 0; g > x; ++x)w[x] = s[f].getSecondsDifference(s[d + x]);
                    var S = i.packValuesForInterpolation;
                    if ("undefined" == typeof S)for (var b = 0, T = d * l, E = (f + 1) * l; E > T;)C[b] = u[T], T++, b++; else S(u, C, d, f);
                    var A = s[f].getSecondsDifference(e);
                    p = a.interpolationAlgorithm.interpolateOrderZero(A, w, C, _, p);
                    var M = i.getValueFromInterpolationResult;
                    return"undefined" == typeof M ? i.getValueFromArray(p, 0, t) : M(p, t, u, d, f)
                }
                return i.getValueFromArray(a.values, c * l, t)
            }
            return i.getValue(a.values, t)
        }, h._mergeNewSamples = function (e, t, i, r, a) {
            for (var s, u, l, f, h, p, m, y, v = 0; v < r.length;)if (m = c(r[v], e), l = o(t, m, n.compare), 0 > l) {
                for (l = ~l, h = [], f = l * a, p = [], u = void 0, y = t[l]; v < r.length && (m = c(r[v], e), !("undefined" != typeof u && n.compare(u, m) >= 0 || "undefined" != typeof y && n.compare(m, y) >= 0));) {
                    for (h.push(m), v += 1, s = 0; a > s; s++)p.push(r[v]), v += 1;
                    u = m
                }
                d(i, f, p), d(t, l, h)
            } else {
                for (s = 0; a > s; s++)v++, i[l * a + s] = r[v];
                v++
            }
        }, h.prototype._addCzmlInterval = function (e, n, r) {
            var o = e.interval;
            o = "undefined" == typeof o ? t.MAXIMUM_INTERVAL : i.fromIso8601(o), "undefined" != typeof n && (o = o.intersect(n));
            var a = this.valueType.unwrapInterval(e, r);
            "undefined" != typeof a && this._addCzmlIntervalUnwrapped(o.start, o.stop, a, e.epoch, e.interpolationAlgorithm, e.interpolationDegree)
        }, h.prototype._addCzmlIntervalUnwrapped = function (e, r, o, a, s, u) {
            var c = this._intervals, d = c.findInterval(e, r);
            this._cachedTime = void 0, this._cachedInterval = void 0;
            var p;
            "undefined" == typeof d ? (p = new l, d = new i(e, r, !0, !0, p), c.addInterval(d)) : p = d.data;
            var m = this.valueType;
            if (m.isSampled(o)) {
                var y;
                "undefined" != typeof s && (y = f[s], p.interpolationAlgorithm = y), "undefined" != typeof y && "undefined" != typeof u && (p.interpolationDegree = u, p.xTable = void 0, p.yTable = void 0), p.isSampled || (p.times = [], p.values = [], p.isSampled = !0), "undefined" != typeof a && (a = n.fromIso8601(a)), h._mergeNewSamples(a, p.times, p.values, o, m.doublesPerValue, m), p.numberOfPoints = Math.min(p.interpolationAlgorithm.getRequiredDataPoints(p.interpolationDegree), p.times.length), this._staticValue = void 0
            } else p.times = void 0, p.values = o, p.isSampled = !1, this._staticValue = d.equals(t.MAXIMUM_INTERVAL) ? o : void 0
        }, h
    }), n("DynamicScene/CzmlPosition", ["../Core/Cartesian3", "../Core/Cartographic", "../Core/Math", "../Core/Ellipsoid"], function (e, t, n, i) {
        "use strict";
        var r = 3, o = new e, a = new t, s = {doublesPerValue: r, doublesPerInterpolationValue: r, unwrapInterval: function (e) {
            var t = e.cartesian;
            if ("undefined" != typeof t)return t;
            var r, s, u = o, l = e.cartographicRadians;
            if ("undefined" != typeof l)if (this.isSampled(l))for (s = l.length, t = new Array(s), r = 0; s > r; r += 4)a.longitude = l[r + 1], a.latitude = l[r + 2], a.height = l[r + 3], i.WGS84.cartographicToCartesian(a, u), t[r] = l[r], t[r + 1] = u.x, t[r + 2] = u.y, t[r + 3] = u.z; else a.longitude = l[0], a.latitude = l[1], a.height = l[2], i.WGS84.cartographicToCartesian(a, u), t = [u.x, u.y, u.z]; else {
                var c = e.cartographicDegrees;
                if ("undefined" == typeof c)return void 0;
                if (this.isSampled(c))for (s = c.length, t = new Array(s), r = 0; s > r; r += 4)a.longitude = n.toRadians(c[r + 1]), a.latitude = n.toRadians(c[r + 2]), a.height = c[r + 3], i.WGS84.cartographicToCartesian(a, u), t[r] = c[r], t[r + 1] = u.x, t[r + 2] = u.y, t[r + 3] = u.z; else a.longitude = n.toRadians(c[0]), a.latitude = n.toRadians(c[1]), a.height = c[2], i.WGS84.cartographicToCartesian(a, u), t = [u.x, u.y, u.z]
            }
            return t
        }, isSampled: function (e) {
            return Array.isArray(e) && e.length > r
        }, getValue: function (t, n) {
            return"undefined" == typeof n && (n = new e), n.x = t[0], n.y = t[1], n.z = t[2], n
        }, getValueFromArray: function (t, n, i) {
            return"undefined" == typeof i && (i = new e), i.x = t[n], i.y = t[n + 1], i.z = t[n + 2], i
        }};
        return s
    }), n("DynamicScene/DynamicPositionProperty", ["../Core/DeveloperError", "../Core/Ellipsoid", "../Core/Iso8601", "../Core/JulianDate", "../Core/Matrix3", "../Core/ReferenceFrame", "../Core/TimeInterval", "../Core/TimeIntervalCollection", "../Core/Transforms", "./CzmlPosition", "./DynamicProperty"], function (e, t, n, i, r, o, a, s, u, l, c) {
        "use strict";
        function d(e, t) {
            var n = u.computeIcrfToFixedMatrix(e, f);
            return"undefined" == typeof n && (n = u.computeTemeToPseudoFixedMatrix(e, f)), n.multiplyByVector(t, t)
        }

        var f = new r, h = t.WGS84, p = function () {
            this._dynamicProperties = [], this._propertyIntervals = new s, this._cachedTime = void 0, this._cachedInterval = void 0
        };
        return p.prototype.processCzmlIntervals = function (e, t) {
            if (Array.isArray(e))for (var n = 0, i = e.length; i > n; n++)this._addCzmlInterval(e[n], t); else this._addCzmlInterval(e, t)
        }, p.prototype.getValueCartographic = function (t, n) {
            if ("undefined" == typeof t)throw new e("time is required.");
            var r = this._cachedInterval;
            if (i.equals(this._cachedTime, t) || (this._cachedTime = i.clone(t, this._cachedTime), "undefined" != typeof r && r.contains(t) || (r = this._propertyIntervals.findIntervalContainingDate(t), this._cachedInterval = r)), "undefined" == typeof r)return void 0;
            var a = r.data;
            return n = r.cachedValue = a.getValue(t, r.cachedValue), "undefined" != typeof n && (r.data.referenceFrame === o.INERTIAL && (n = d(t, n)), n = h.cartesianToCartographic(n)), n
        }, p.prototype.getValueCartesian = function (t, n) {
            if ("undefined" == typeof t)throw new e("time is required.");
            var r = this._cachedInterval;
            if (i.equals(this._cachedTime, t) || (this._cachedTime = i.clone(t, this._cachedTime), "undefined" != typeof r && r.contains(t) || (r = this._propertyIntervals.findIntervalContainingDate(t), this._cachedInterval = r)), "undefined" == typeof r)return void 0;
            var a = r.data;
            return n = a.getValue(t, n), r.data.referenceFrame === o.INERTIAL ? d(t, n) : n
        }, p.prototype.getValueRangeCartesian = function (t, n, i, r) {
            if ("undefined" == typeof t)throw new e("start is required");
            if ("undefined" == typeof n)throw new e("stop is required");
            "undefined" == typeof r && (r = []);
            var o = this._propertyIntervals, a = "undefined" != typeof t ? o.indexOf(t) : 0, s = "undefined" != typeof n ? o.indexOf(n) : o.length - 1;
            if (0 > a && (a = ~a), a === o.getLength())return r.length = 0, r;
            if (0 > s) {
                if (s = ~s, s !== o.getLength())return r.length = 0, r;
                s -= 1
            }
            var u, l = 0;
            u = this.getValueCartesian(t, r[l]), "undefined" != typeof u && (r[l++] = u);
            for (var c = "undefined" == typeof i || i.lessThan(t) || i.greaterThan(n), d = a; s + 1 > d; d++) {
                var f, h = o.get(d), p = o.get(d + 1), m = n;
                "undefined" != typeof p && n.greaterThan(p.start) && (m = p.start);
                var y = h.data, v = y._intervals.get(0), g = v.data.times;
                if ("undefined" != typeof g) {
                    var _;
                    for (_ = 0; _ < g.length; _++)f = g[_], !c && f.greaterThanOrEquals(i) && (u = y.getValue(i, r[l]), "undefined" != typeof u && (r[l++] = u), c = !0), f.greaterThan(t) && f.lessThan(m) && (u = y.getValue(f, r[l]), "undefined" != typeof u && (r[l++] = u))
                } else f = h.start, c = c || f.greaterThanOrEquals(i), f.lessThan(m) && (u = y.getValue(f, r[l]), "undefined" != typeof u && (r[l++] = u))
            }
            return u = this.getValueCartesian(n, r[l]), "undefined" != typeof u && (r[l++] = u), r.length = l, r
        }, p.prototype._addCzmlInterval = function (e, t) {
            this._cachedTime = void 0, this._cachedInterval = void 0;
            var i, r, s = e.interval;
            s = "undefined" == typeof s ? n.MAXIMUM_INTERVAL.clone() : a.fromIso8601(s), "undefined" != typeof t && (s = s.intersect(t));
            var u = this._propertyIntervals, d = u.findInterval(s.start, s.stop);
            "undefined" != typeof d ? (i = d.data, "undefined" != typeof i && (r = l.unwrapInterval(e))) : (d = s, u.addInterval(d)), "undefined" == typeof r && (r = l.unwrapInterval(e), "undefined" != typeof r && (i = new c(l), this._dynamicProperties.push(i), d.data = i, i.referenceFrame = o.FIXED)), "undefined" != typeof r && ("undefined" != typeof e.referenceFrame && (d.data.referenceFrame = o[e.referenceFrame]), i._addCzmlIntervalUnwrapped(s.start, s.stop, r, e.epoch, e.interpolationAlgorithm, e.interpolationDegree))
        }, p.prototype._getReferenceFrame = function () {
            var e = this._propertyIntervals;
            return e.getLength() > 0 ? e.get(0).data.referenceFrame : void 0
        }, p.prototype._getValueInReferenceFrame = function (t, n, r) {
            if ("undefined" == typeof t)throw new e("time is required.");
            var a = this._cachedInterval;
            if (i.equals(this._cachedTime, t) || (this._cachedTime = i.clone(t, this._cachedTime), "undefined" != typeof a && a.contains(t) || (a = this._propertyIntervals.findIntervalContainingDate(t), this._cachedInterval = a)), "undefined" == typeof a)return void 0;
            var s = a.data;
            if (r = s.getValue(t, r), a.data.referenceFrame !== n) {
                if (n === o.FIXED)return d(t, r);
                if (n === o.INERTIAL) {
                    var l = u.computeFixedToIcrfMatrix(t, f);
                    return"undefined" == typeof l ? void 0 : l.multiplyByVector(r, r)
                }
            }
            return r
        }, p.prototype._getValueRangeInReferenceFrame = function (t, n, i, r, o, a) {
            if ("undefined" == typeof t)throw new e("start is required");
            if ("undefined" == typeof n)throw new e("stop is required");
            "undefined" == typeof a && (a = []);
            var s = this._propertyIntervals, u = "undefined" != typeof t ? s.indexOf(t) : 0, l = "undefined" != typeof n ? s.indexOf(n) : s.length - 1;
            if (0 > u && (u = ~u), u === s.getLength())return a.length = 0, a;
            if (0 > l) {
                if (l = ~l, l !== s.getLength())return a.length = 0, a;
                l -= 1
            }
            var c, d = 0;
            c = this._getValueInReferenceFrame(t, r, a[d]), "undefined" != typeof c && (a[d++] = c);
            for (var f = "undefined" == typeof i || i.lessThan(t) || i.greaterThan(n), h = u; l + 1 > h; h++) {
                var p, m = s.get(h), y = s.get(h + 1), v = n;
                "undefined" != typeof y && n.greaterThan(y.start) && (v = y.start);
                var g, _, w, C = !1, x = m.data, S = x._intervals.get(0), b = S.data.times;
                if ("undefined" != typeof b) {
                    var T = 0, E = b.length;
                    for (p = b[T]; E > T;) {
                        if (!f && p.greaterThanOrEquals(i) && (c = this._getValueInReferenceFrame(i, r, a[d]), "undefined" != typeof c && (a[d++] = c), f = !0), p.greaterThan(t) && p.lessThan(v) && (c = this._getValueInReferenceFrame(p, r, a[d]), "undefined" != typeof c && (a[d++] = c)), E - 1 > T) {
                            if (!C) {
                                var A = b[T + 1], M = p.getSecondsDifference(A);
                                C = M > o, C && (g = Math.floor(M / o), _ = 0, w = M / Math.max(g, 2), g = Math.max(g - 2, 1))
                            }
                            if (C && g > _) {
                                p = p.addSeconds(w), _++;
                                continue
                            }
                        }
                        C = !1, T++, p = b[T]
                    }
                } else p = m.start, f = f || p.greaterThanOrEquals(i), p.lessThan(v) && (c = this._getValueInReferenceFrame(p, r, a[d]), "undefined" != typeof c && (a[d++] = c))
            }
            return c = this._getValueInReferenceFrame(n, r, a[d]), "undefined" != typeof c && (a[d++] = c), a.length = d, a
        }, p
    }), n("DynamicScene/ReferenceProperty", ["../Core/defaultValue", "../Core/DeveloperError"], function (e, t) {
        "use strict";
        function n(t) {
            var n = t._targetProperty;
            if ("undefined" == typeof n) {
                var i = e(t._dynamicObjectCollection.compositeCollection, t._dynamicObjectCollection), r = i.getObject(t._targetObjectId);
                "undefined" != typeof r && (n = r[t._targetPropertyName], t._targetProperty = n, t._targetObject = r)
            }
            return n
        }

        var i = function (e, n, i) {
            if ("undefined" == typeof e)throw new t("dynamicObjectCollection is required.");
            if ("undefined" == typeof n)throw new t("targetObjectId is required.");
            if ("undefined" == typeof i)throw new t("targetPropertyName is required.");
            this._targetProperty = void 0, this._dynamicObjectCollection = e, this._targetObjectId = n, this._targetObject = void 0, this._targetPropertyName = i
        };
        return i.fromString = function (e, n) {
            if ("undefined" == typeof e)throw new t("dynamicObjectCollection is required.");
            if ("undefined" == typeof n)throw new t("referenceString is required.");
            var r = n.split(".");
            if (2 !== r.length)throw new t("referenceString must contain a single . delineating the target object ID and property name.");
            return new i(e, r[0], r[1])
        }, i.prototype.getValue = function (e, t) {
            var i = n(this);
            return"undefined" != typeof i && this._targetObject.isAvailable(e) ? i.getValue(e, t) : void 0
        }, i.prototype.getValueCartographic = function (e, t) {
            var i = n(this);
            return"undefined" != typeof i && this._targetObject.isAvailable(e) ? i.getValueCartographic(e, t) : void 0
        }, i.prototype.getValueCartesian = function (e, t) {
            var i = n(this);
            return"undefined" != typeof i && this._targetObject.isAvailable(e) ? i.getValueCartesian(e, t) : void 0
        }, i.prototype.getValueSpherical = function (e, t) {
            var i = n(this);
            return"undefined" != typeof i && this._targetObject.isAvailable(e) ? i.getValueSpherical(e, t) : void 0
        }, i
    }), n("DynamicScene/DynamicVertexPositionsProperty", ["../Core/TimeInterval", "../Core/TimeIntervalCollection", "../Core/Cartesian3", "../Core/Cartographic", "../Core/Iso8601", "../Core/Ellipsoid", "./ReferenceProperty"], function (e, t, n, i, r, o, a) {
        "use strict";
        function s(e) {
            var t, r, o, a = [];
            if (o = e.cartesian, "undefined" != typeof o) {
                for (t = 0, r = o.length; r > t; t += 3)a.push(new n(o[t], o[t + 1], o[t + 2]));
                this.cartesian = a
            } else if (o = e.cartographicRadians, "undefined" != typeof o) {
                for (t = 0, r = o.length; r > t; t += 3)a.push(new i(o[t], o[t + 1], o[t + 2]));
                this.cartographic = a
            } else if (o = e.cartographicDegrees, "undefined" != typeof o) {
                for (t = 0, r = o.length; r > t; t += 3)a.push(i.fromDegrees(o[t], o[t + 1], o[t + 2]));
                this.cartographic = a
            }
        }

        var u = o.WGS84;
        s.prototype.getValueCartographic = function () {
            return"undefined" == typeof this.cartographic && (this.cartographic = u.cartesianArrayToCartographicArray(this.cartesian)), this.cartographic
        }, s.prototype.getValueCartesian = function () {
            return"undefined" == typeof this.cartesian && (this.cartesian = u.cartographicArrayToCartesianArray(this.cartographic)), this.cartesian
        };
        var l = function () {
            this._propertyIntervals = new t
        };
        return l.prototype.processCzmlIntervals = function (e, t, n) {
            if (Array.isArray(e))for (var i = 0, r = e.length; r > i; i++)this._addCzmlInterval(e[i], t, n); else this._addCzmlInterval(e, t, n)
        }, l.prototype.getValueCartographic = function (e) {
            var t = this._propertyIntervals.findIntervalContainingDate(e);
            if ("undefined" == typeof t)return void 0;
            var n = t.data;
            if (Array.isArray(n)) {
                for (var i = [], r = 0, o = n.length; o > r; r++) {
                    var a = n[r].getValueCartographic(e);
                    "undefined" != typeof a && i.push(a)
                }
                return i
            }
            return n.getValueCartographic()
        }, l.prototype.getValueCartesian = function (e) {
            var t = this._propertyIntervals.findIntervalContainingDate(e);
            if ("undefined" == typeof t)return void 0;
            var n = t.data;
            if (Array.isArray(n)) {
                for (var i = [], r = 0, o = n.length; o > r; r++) {
                    var a = n[r].getValueCartesian(e);
                    "undefined" != typeof a && i.push(a)
                }
                return i
            }
            return n.getValueCartesian()
        }, l.prototype._addCzmlInterval = function (t, n, i) {
            var o = t.interval;
            o = "undefined" == typeof o ? r.MAXIMUM_INTERVAL.clone() : e.fromIso8601(o), "undefined" != typeof n && (o = o.intersect(n));
            var u = this._propertyIntervals, l = u.findInterval(o.start, o.stop);
            "undefined" == typeof l && (l = o, u.addInterval(l));
            var c = t.references;
            if ("undefined" == typeof c)l.data = new s(t); else {
                for (var d = [], f = 0, h = c.length; h > f; f++)d.push(a.fromString(i, c[f]));
                l.data = d
            }
        }, l
    }), n("DynamicScene/CzmlUnitQuaternion", ["../Core/Quaternion", "../Core/Cartesian3"], function (e, t) {
        "use strict";
        var n = 3, i = 4, r = new t, o = new t, a = new e, s = new e, u = new e, l = {doublesPerValue: i, doublesPerInterpolationValue: n, unwrapInterval: function (e) {
            return e.unitQuaternion
        }, isSampled: function (e) {
            return Array.isArray(e) && e.length > i
        }, packValuesForInterpolation: function (e, t, o, s) {
            l.getValueFromArray(e, s * i, u), u.conjugate(u);
            for (var c = 0, d = s - o + 1; d > c; c++) {
                var f = c * n;
                l.getValueFromArray(e, (o + c) * i, a), a.multiply(u, a), a.w < 0 && a.negate(a), a.getAxis(r);
                var h = a.getAngle();
                t[f] = r.x * h, t[f + 1] = r.y * h, t[f + 2] = r.z * h
            }
        }, getValue: function (t, n) {
            return"undefined" == typeof n && (n = new e), n.x = t[0], n.y = t[1], n.z = t[2], n.w = t[3], n.normalize(n)
        }, getValueFromArray: function (t, n, i) {
            return"undefined" == typeof i && (i = new e), i.x = t[n], i.y = t[n + 1], i.z = t[n + 2], i.w = t[n + 3], i.normalize(i)
        }, getValueFromInterpolationResult: function (t, n, r, u, c) {
            "undefined" == typeof n && (n = new e), o.x = t[0], o.y = t[1], o.z = t[2];
            var d = o.magnitude();
            return l.getValueFromArray(r, c * i, s), 0 === d ? (a.x = a.y = a.z = 0, a.w = 1) : e.fromAxisAngle(o, d, a), n.normalize(a.multiply(s, n), n)
        }};
        return l
    }), n("DynamicScene/CzmlCartesian3", ["../Core/Cartesian3"], function (e) {
        "use strict";
        var t = 3, n = {doublesPerValue: t, doublesPerInterpolationValue: t, unwrapInterval: function (e) {
            return e.cartesian
        }, isSampled: function (e) {
            return Array.isArray(e) && e.length > t
        }, getValue: function (t, n) {
            return"undefined" == typeof n && (n = new e), n.x = t[0], n.y = t[1], n.z = t[2], n
        }, getValueFromArray: function (t, n, i) {
            return"undefined" == typeof i && (i = new e), i.x = t[n], i.y = t[n + 1], i.z = t[n + 2], i
        }};
        return n
    }), n("DynamicScene/DynamicObject", ["../Core/createGuid", "../Core/defaultValue", "../Core/DeveloperError", "../Core/JulianDate", "../Core/TimeInterval", "./DynamicProperty", "./DynamicPositionProperty", "./DynamicVertexPositionsProperty", "./CzmlUnitQuaternion", "./CzmlCartesian3"], function (e, t, n, i, r, o, a, s, u, l) {
        "use strict";
        var c = function (t) {
            this._cachedAvailabilityDate = void 0, this._cachedAvailabilityValue = void 0, "undefined" == typeof t && (t = e()), this.id = t, this.availability = void 0, this.position = void 0, this.orientation = void 0, this.billboard = void 0, this.cone = void 0, this.ellipsoid = void 0, this.ellipse = void 0, this.label = void 0, this.path = void 0, this.point = void 0, this.polygon = void 0, this.polyline = void 0, this.pyramid = void 0, this.vertexPositions = void 0, this.vector = void 0, this.viewFrom = void 0
        };
        return c.prototype.isAvailable = function (e) {
            if ("undefined" == typeof e)throw new n("time is required.");
            var t = this.availability;
            if ("undefined" == typeof t)return!0;
            if (i.equals(this._cachedAvailabilityDate, e))return this._cachedAvailabilityValue;
            var r = t.contains(e);
            return this._cachedAvailabilityDate = i.clone(e, this._cachedAvailabilityDate), this._cachedAvailabilityValue = r, r
        }, c.prototype.merge = function (e) {
            if ("undefined" == typeof e)throw new n("other is required");
            for (var i in e)e.hasOwnProperty(i) && (this[i] = t(this[i], e[i]))
        }, c.processCzmlPacketPosition = function (e, t) {
            var n = t.position;
            if ("undefined" == typeof n)return!1;
            var i = e.position, r = "undefined" == typeof i;
            return r && (e.position = i = new a), i.processCzmlIntervals(n), r
        }, c.processCzmlPacketViewFrom = function (e, t) {
            var n = t.viewFrom;
            if ("undefined" == typeof n)return!1;
            var i = e.viewFrom, r = "undefined" == typeof i;
            return r && (e.viewFrom = i = new o(l)), i.processCzmlIntervals(n), r
        }, c.processCzmlPacketOrientation = function (e, t) {
            var n = t.orientation;
            if ("undefined" == typeof n)return!1;
            var i = e.orientation, r = "undefined" == typeof i;
            return r && (e.orientation = i = new o(u)), i.processCzmlIntervals(n), r
        }, c.processCzmlPacketVertexPositions = function (e, t, n) {
            var i = t.vertexPositions;
            if ("undefined" == typeof i)return!1;
            var r = e.vertexPositions, o = "undefined" == typeof e.vertexPositions;
            return o && (e.vertexPositions = r = new s), r.processCzmlIntervals(i, void 0, n), o
        }, c.processCzmlPacketAvailability = function (e, t) {
            var n = t.availability;
            if ("undefined" == typeof n)return!1;
            var i = !1, o = r.fromIso8601(n);
            return"undefined" != typeof o && (i = e._setAvailability(o)), i
        }, c.mergeProperties = function (e, n) {
            e.position = t(e.position, n.position), e.orientation = t(e.orientation, n.orientation), e.vertexPositions = t(e.vertexPositions, n.vertexPositions), e.viewFrom = t(e.viewFrom, n.viewFrom);
            var i = n.availability;
            "undefined" != typeof i && e._setAvailability(i)
        }, c.undefineProperties = function (e) {
            e.position = void 0, e.orientation = void 0, e.vertexPositions = void 0, e.viewFrom = void 0, e._setAvailability(void 0)
        }, c.prototype._setAvailability = function (e) {
            var t = !r.equals(this.availability, e);
            return this.availability = e, this._cachedAvailabilityDate = void 0, this._cachedAvailabilityValue = void 0, t
        }, c
    }), n("DynamicScene/CzmlBoolean", ["../Core/defaultValue"], function (e) {
        "use strict";
        var t = {unwrapInterval: function (t) {
            return e(t["boolean"], t)
        }, isSampled: function () {
            return!1
        }, getValue: function (e) {
            return e
        }};
        return t
    }), n("DynamicScene/CzmlCartesian2", ["../Core/Cartesian2"], function (e) {
        "use strict";
        var t = 2, n = {doublesPerValue: t, doublesPerInterpolationValue: t, unwrapInterval: function (e) {
            return e.cartesian2
        }, isSampled: function (e) {
            return Array.isArray(e) && e.length > t
        }, getValue: function (t, n) {
            return"undefined" == typeof n && (n = new e), n.x = t[0], n.y = t[1], n
        }, getValueFromArray: function (t, n, i) {
            return"undefined" == typeof i && (i = new e), i.x = t[n], i.y = t[n + 1], i
        }};
        return n
    }), n("DynamicScene/CzmlNumber", ["../Core/defaultValue"], function (e) {
        "use strict";
        var t = 1, n = {doublesPerValue: t, doublesPerInterpolationValue: t, unwrapInterval: function (t) {
            return e(t.number, t)
        }, isSampled: function (e) {
            return Array.isArray(e)
        }, getValue: function (e) {
            return e
        }, getValueFromArray: function (e, t) {
            return e[t]
        }};
        return n
    }), n("DynamicScene/CzmlImage", ["../Core/defaultValue", "../ThirdParty/Uri"], function (e, t) {
        "use strict";
        var n = {unwrapInterval: function (n, i) {
            var r = e(n.image, n);
            if ("undefined" != typeof i) {
                var o = new t(document.location.href);
                i = new t(i), r = new t(r).resolve(i.resolve(o)).toString()
            }
            return r
        }, isSampled: function () {
            return!1
        }, getValue: function (e) {
            return e
        }};
        return n
    }), n("Scene/HorizontalOrigin", ["../Core/Enumeration"], function (e) {
        "use strict";
        var t = {CENTER: new e(0, "CENTER"), LEFT: new e(1, "LEFT"), RIGHT: new e(-1, "RIGHT")};
        return t
    }), n("DynamicScene/CzmlHorizontalOrigin", ["../Core/defaultValue", "../Scene/HorizontalOrigin"], function (e, t) {
        "use strict";
        var n = {unwrapInterval: function (t) {
            return e(t.horizontalOrigin, t)
        }, isSampled: function () {
            return!1
        }, getValue: function (e) {
            return t[e]
        }};
        return n
    }), n("Scene/VerticalOrigin", ["../Core/Enumeration"], function (e) {
        "use strict";
        var t = {CENTER: new e(0, "CENTER"), BOTTOM: new e(1, "BOTTOM"), TOP: new e(-1, "TOP")};
        return t
    }), n("DynamicScene/CzmlVerticalOrigin", ["../Core/defaultValue", "../Scene/VerticalOrigin"], function (e, t) {
        "use strict";
        var n = {unwrapInterval: function (t) {
            return e(t.verticalOrigin, t)
        }, isSampled: function () {
            return!1
        }, getValue: function (e) {
            return t[e]
        }};
        return n
    }), n("DynamicScene/CzmlColor", ["../Core/Color"], function (e) {
        "use strict";
        var t = 4, n = {doublesPerValue: t, doublesPerInterpolationValue: t, unwrapInterval: function (t) {
            var n = t.rgbaf;
            if ("undefined" != typeof n)return n;
            var i = t.rgba;
            if ("undefined" == typeof i)return void 0;
            if (!this.isSampled(i))return[e.byteToFloat(i[0]), e.byteToFloat(i[1]), e.byteToFloat(i[2]), e.byteToFloat(i[3])];
            var r = i.length;
            n = new Array(r);
            for (var o = 0; r > o; o += 5)n[o] = i[o], n[o + 1] = e.byteToFloat(i[o + 1]), n[o + 2] = e.byteToFloat(i[o + 2]), n[o + 3] = e.byteToFloat(i[o + 3]), n[o + 4] = e.byteToFloat(i[o + 4]);
            return n
        }, isSampled: function (e) {
            return Array.isArray(e) && e.length > t
        }, getValue: function (t, n) {
            return"undefined" == typeof n && (n = new e), n.red = t[0], n.green = t[1], n.blue = t[2], n.alpha = t[3], n
        }, getValueFromArray: function (t, n, i) {
            return"undefined" == typeof i && (i = new e), i.red = t[n], i.green = t[n + 1], i.blue = t[n + 2], i.alpha = t[n + 3], i
        }};
        return n
    }), n("DynamicScene/DynamicBillboard", ["../Core/TimeInterval", "../Core/defaultValue", "./CzmlBoolean", "./CzmlCartesian2", "./CzmlCartesian3", "./CzmlNumber", "./CzmlImage", "./CzmlHorizontalOrigin", "./CzmlVerticalOrigin", "./CzmlColor", "./DynamicProperty"], function (e, t, n, i, r, o, a, s, u, l, c) {
        "use strict";
        var d = function () {
            this.image = void 0, this.scale = void 0, this.rotation = void 0, this.alignedAxis = void 0, this.horizontalOrigin = void 0, this.verticalOrigin = void 0, this.color = void 0, this.eyeOffset = void 0, this.pixelOffset = void 0, this.show = void 0
        };
        return d.processCzmlPacket = function (t, f, h, p) {
            var m = f.billboard;
            if ("undefined" == typeof m)return!1;
            var y = !1, v = t.billboard;
            y = "undefined" == typeof v, y && (t.billboard = v = new d);
            var g = m.interval;
            if ("undefined" != typeof g && (g = e.fromIso8601(g)), "undefined" != typeof m.color) {
                var _ = v.color;
                "undefined" == typeof _ && (v.color = _ = new c(l), y = !0), _.processCzmlIntervals(m.color, g)
            }
            if ("undefined" != typeof m.eyeOffset) {
                var w = v.eyeOffset;
                "undefined" == typeof w && (v.eyeOffset = w = new c(r), y = !0), w.processCzmlIntervals(m.eyeOffset, g)
            }
            if ("undefined" != typeof m.horizontalOrigin) {
                var C = v.horizontalOrigin;
                "undefined" == typeof C && (v.horizontalOrigin = C = new c(s), y = !0), C.processCzmlIntervals(m.horizontalOrigin, g)
            }
            if ("undefined" != typeof m.image) {
                var x = v.image;
                "undefined" == typeof x && (v.image = x = new c(a), y = !0), x.processCzmlIntervals(m.image, g, p)
            }
            if ("undefined" != typeof m.pixelOffset) {
                var S = v.pixelOffset;
                "undefined" == typeof S && (v.pixelOffset = S = new c(i), y = !0), S.processCzmlIntervals(m.pixelOffset, g)
            }
            if ("undefined" != typeof m.scale) {
                var b = v.scale;
                "undefined" == typeof b && (v.scale = b = new c(o), y = !0), b.processCzmlIntervals(m.scale, g)
            }
            if ("undefined" != typeof m.rotation) {
                var T = v.rotation;
                "undefined" == typeof T && (v.rotation = T = new c(o), y = !0), T.processCzmlIntervals(m.rotation, g)
            }
            if ("undefined" != typeof m.alignedAxis) {
                var E = v.alignedAxis;
                "undefined" == typeof E && (v.alignedAxis = E = new c(r), y = !0), E.processCzmlIntervals(m.alignedAxis, g)
            }
            if ("undefined" != typeof m.show) {
                var A = v.show;
                "undefined" == typeof A && (v.show = A = new c(n), y = !0), A.processCzmlIntervals(m.show, g)
            }
            if ("undefined" != typeof m.verticalOrigin) {
                var M = v.verticalOrigin;
                "undefined" == typeof M && (v.verticalOrigin = M = new c(u), y = !0), M.processCzmlIntervals(m.verticalOrigin, g)
            }
            return y
        }, d.mergeProperties = function (e, n) {
            var i = n.billboard;
            if ("undefined" != typeof i) {
                var r = e.billboard;
                "undefined" == typeof r && (e.billboard = r = new d), r.color = t(r.color, i.color), r.eyeOffset = t(r.eyeOffset, i.eyeOffset), r.horizontalOrigin = t(r.horizontalOrigin, i.horizontalOrigin), r.image = t(r.image, i.image), r.pixelOffset = t(r.pixelOffset, i.pixelOffset), r.scale = t(r.scale, i.scale), r.rotation = t(r.rotation, i.rotation), r.alignedAxis = t(r.alignedAxis, i.alignedAxis), r.show = t(r.show, i.show), r.verticalOrigin = t(r.verticalOrigin, i.verticalOrigin)
            }
        }, d.undefineProperties = function (e) {
            e.billboard = void 0
        }, d
    }), n("DynamicScene/DynamicClock", ["../Core/TimeInterval", "../Core/Iso8601", "../Core/ClockRange", "../Core/ClockStep", "../Core/JulianDate"], function (e, t, n, i, r) {
        "use strict";
        var o = function () {
            this.startTime = t.MAXIMUM_INTERVAL.start, this.stopTime = t.MAXIMUM_INTERVAL.stop, this.currentTime = t.MAXIMUM_INTERVAL.start, this.clockRange = n.LOOP_STOP, this.clockStep = i.SYSTEM_CLOCK_MULTIPLIER, this.multiplier = 1
        };
        return o.prototype.clone = function (e) {
            return"undefined" == typeof e && (e = new o), e.startTime = this.startTime, e.stopTime = this.stopTime, e.clockRange = this.clockRange, e.clockStep = this.clockStep, e.multiplier = this.multiplier, e.currentTime = this.currentTime, e
        }, o.processCzmlPacket = function (t, a) {
            var s = !1, u = a.clock;
            if ("undefined" != typeof u && "document" === t.id) {
                var l = t.clock;
                if ("undefined" == typeof l && (l = new o, t.clock = l, s = !0), "undefined" != typeof u.interval) {
                    var c = e.fromIso8601(u.interval);
                    "undefined" != typeof c && (l.startTime = c.start, l.stopTime = c.stop)
                }
                "undefined" != typeof u.currentTime && (l.currentTime = r.fromIso8601(u.currentTime)), "undefined" != typeof typeof u.range && (l.clockRange = n[u.range]), "undefined" != typeof u.step && (l.clockStep = i[u.step]), "undefined" != typeof u.multiplier && (l.multiplier = u.multiplier)
            }
            return s
        }, o.mergeProperties = function (e, t) {
            var n = t.clock;
            if ("undefined" != typeof n) {
                var i = e.clock;
                "undefined" == typeof i && (i = new o, e.clock = i), i.startTime = n.startTime, i.stopTime = n.stopTime, i.currentTime = n.currentTime, i.clockRange = n.clockRange, i.clockStep = n.clockStep, i.multiplier = n.multiplier
            }
        }, o.undefineProperties = function (e) {
            e.clock = void 0
        }, o
    }), n("DynamicScene/DynamicEllipse", ["../Core/TimeInterval", "../Core/defaultValue", "../Core/Cartesian3", "../Core/Ellipsoid", "../Core/Shapes", "./CzmlNumber", "./DynamicProperty"], function (e, t, n, i, r, o, a) {
        "use strict";
        var s = function () {
            this.semiMajorAxis = void 0, this.semiMinorAxis = void 0, this.bearing = void 0, this._lastPosition = void 0, this._lastSemiMajorAxis = void 0, this._lastSemiMinorAxis = void 0, this._lastBearing = void 0, this._cachedVertexPositions = void 0
        };
        return s.processCzmlPacket = function (t, n) {
            var i = n.ellipse;
            if ("undefined" == typeof i)return!1;
            var r = !1, u = t.ellipse;
            r = "undefined" == typeof u, r && (t.ellipse = u = new s);
            var l = i.interval;
            if ("undefined" != typeof l && (l = e.fromIso8601(l)), "undefined" != typeof i.bearing) {
                var c = u.bearing;
                "undefined" == typeof c && (u.bearing = c = new a(o), r = !0), c.processCzmlIntervals(i.bearing, l)
            }
            if ("undefined" != typeof i.semiMajorAxis) {
                var d = u.semiMajorAxis;
                "undefined" == typeof d && (u.semiMajorAxis = d = new a(o), r = !0), d.processCzmlIntervals(i.semiMajorAxis, l)
            }
            if ("undefined" != typeof i.semiMinorAxis) {
                var f = u.semiMinorAxis;
                "undefined" == typeof f && (u.semiMinorAxis = f = new a(o), r = !0), f.processCzmlIntervals(i.semiMinorAxis, l)
            }
            return r
        }, s.mergeProperties = function (e, n) {
            var i = n.ellipse;
            if ("undefined" != typeof i) {
                var r = e.ellipse;
                "undefined" == typeof r && (e.ellipse = r = new s), r.bearing = t(r.bearing, i.bearing), r.semiMajorAxis = t(r.semiMajorAxis, i.semiMajorAxis), r.semiMinorAxis = t(r.semiMinorAxis, i.semiMinorAxis)
            }
        }, s.undefineProperties = function (e) {
            e.ellipse = void 0
        }, s.prototype.getValue = function (e, t) {
            var o = this.semiMajorAxis, a = this.semiMinorAxis;
            if ("undefined" == typeof t || "undefined" == typeof o || "undefined" == typeof a)return void 0;
            var s = o.getValue(e), u = a.getValue(e), l = 0, c = this.bearing;
            if ("undefined" != typeof c && (l = c.getValue(e)), "undefined" == typeof s || "undefined" == typeof u || 0 === s || 0 === u)return void 0;
            var d = this._lastPosition, f = this._lastSemiMajorAxis, h = this._lastSemiMinorAxis, p = this._lastBearing;
            return l === p && f === s && h === u && n.equals(d, t) || (this._cachedVertexPositions = r.computeEllipseBoundary(i.WGS84, t, s, u, l), this._lastPosition = n.clone(t, this._lastPosition), this._lastBearing = l, this._lastSemiMajorAxis = s, this._lastSemiMinorAxis = u), this._cachedVertexPositions
        }, s
    }), n("Renderer/MipmapHint", ["../Core/Enumeration"], function (e) {
        "use strict";
        var t = {DONT_CARE: new e(4352, "DONT_CARE"), FASTEST: new e(4353, "FASTEST"), NICEST: new e(4354, "NICEST"), validate: function (e) {
            return e === t.DONT_CARE || e === t.FASTEST || e === t.NICEST
        }};
        return t
    }), n("Renderer/PixelDatatype", ["../Core/Enumeration"], function (e) {
        "use strict";
        var t = {UNSIGNED_BYTE: new e(5121, "UNSIGNED_BYTE"), UNSIGNED_SHORT: new e(5123, "UNSIGNED_SHORT"), UNSIGNED_INT: new e(5125, "UNSIGNED_INT"), FLOAT: new e(5126, "FLOAT"), UNSIGNED_INT_24_8_WEBGL: new e(34042, "UNSIGNED_INT_24_8_WEBGL"), UNSIGNED_SHORT_4_4_4_4: new e(32819, "UNSIGNED_SHORT_4_4_4_4"), UNSIGNED_SHORT_5_5_5_1: new e(32820, "UNSIGNED_SHORT_5_5_5_1"), UNSIGNED_SHORT_5_6_5: new e(33635, "UNSIGNED_SHORT_5_6_5"), validate: function (e) {
            return e === t.UNSIGNED_BYTE || e === t.UNSIGNED_SHORT || e === t.UNSIGNED_INT || e === t.FLOAT || e === t.UNSIGNED_INT_24_8_WEBGL || e === t.UNSIGNED_SHORT_4_4_4_4 || e === t.UNSIGNED_SHORT_5_5_5_1 || e === t.UNSIGNED_SHORT_5_6_5
        }};
        return t
    }), n("Renderer/PixelFormat", ["../Core/Enumeration"], function (e) {
        "use strict";
        var t = {DEPTH_COMPONENT: new e(6402, "DEPTH_COMPONENT"), DEPTH_STENCIL: new e(34041, "DEPTH_STENCIL"), ALPHA: new e(6406, "ALPHA"), RGB: new e(6407, "RGB"), RGBA: new e(6408, "RGBA"), LUMINANCE: new e(6409, "LUMINANCE"), LUMINANCE_ALPHA: new e(6410, "LUMINANCE_ALPHA"), validate: function (e) {
            return e === t.DEPTH_COMPONENT || e === t.DEPTH_STENCIL || e === t.ALPHA || e === t.RGB || e === t.RGBA || e === t.LUMINANCE || e === t.LUMINANCE_ALPHA
        }, isColorFormat: function (e) {
            return e === t.ALPHA || e === t.RGB || e === t.RGBA || e === t.LUMINANCE || e === t.LUMINANCE_ALPHA
        }, isDepthFormat: function (e) {
            return e === t.DEPTH_COMPONENT || e === t.DEPTH_STENCIL
        }};
        return t
    }), n("Renderer/TextureMagnificationFilter", ["../Core/Enumeration"], function (e) {
        "use strict";
        var t = {NEAREST: new e(9728, "NEAREST"), LINEAR: new e(9729, "LINEAR"), validate: function (e) {
            return e === t.NEAREST || e === t.LINEAR
        }};
        return t
    }), n("Renderer/TextureMinificationFilter", ["../Core/Enumeration"], function (e) {
        "use strict";
        var t = {NEAREST: new e(9728, "NEAREST"), LINEAR: new e(9729, "LINEAR"), NEAREST_MIPMAP_NEAREST: new e(9984, "NEAREST_MIPMAP_NEAREST"), LINEAR_MIPMAP_NEAREST: new e(9985, "LINEAR_MIPMAP_NEAREST"), NEAREST_MIPMAP_LINEAR: new e(9986, "NEAREST_MIPMAP_LINEAR"), LINEAR_MIPMAP_LINEAR: new e(9987, "LINEAR_MIPMAP_LINEAR"), validate: function (e) {
            return e === t.NEAREST || e === t.LINEAR || e === t.NEAREST_MIPMAP_NEAREST || e === t.LINEAR_MIPMAP_NEAREST || e === t.NEAREST_MIPMAP_LINEAR || e === t.LINEAR_MIPMAP_LINEAR
        }};
        return t
    }), n("Renderer/TextureWrap", ["../Core/Enumeration"], function (e) {
        "use strict";
        var t = {CLAMP: new e(33071, "CLAMP"), REPEAT: new e(10497, "REPEAT"), MIRRORED_REPEAT: new e(33648, "MIRRORED_REPEAT"), validate: function (e) {
            return e === t.CLAMP || e === t.REPEAT || e === t.MIRRORED_REPEAT
        }};
        return t
    }), n("Renderer/Texture", ["../Core/Cartesian2", "../Core/defaultValue", "../Core/destroyObject", "../Core/DeveloperError", "../Core/Math", "./MipmapHint", "./PixelDatatype", "./PixelFormat", "./TextureMagnificationFilter", "./TextureMinificationFilter", "./TextureWrap"], function (e, t, n, i, r, o, a, s, u, l, c) {
        "use strict";
        var d = function (t, n, i, r, o, a, s, u, l, c) {
            this._gl = t, this._textureFilterAnisotropic = n, this._textureTarget = i, this._texture = r, this._pixelFormat = o, this._pixelDatatype = a, this._width = s, this._height = u, this._dimensions = new e(s, u), this._preMultiplyAlpha = l, this._flipY = c, this._sampler = void 0, this.setSampler()
        };
        return d.prototype.copyFrom = function (e, n, r) {
            if ("undefined" == typeof e)throw new i("source is required.");
            if (s.isDepthFormat(this._pixelFormat))throw new i("Cannot call copyFrom when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.");
            if (n = t(n, 0), r = t(r, 0), 0 > n)throw new i("xOffset must be greater than or equal to zero.");
            if (0 > r)throw new i("yOffset must be greater than or equal to zero.");
            var o = e.width, a = e.height;
            if (n + o > this._width)throw new i("xOffset + source.width must be less than or equal to getWidth().");
            if (r + a > this._height)throw new i("yOffset + source.height must be less than or equal to getHeight().");
            var u = this._gl, l = this._textureTarget;
            u.pixelStorei(u.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._preMultiplyAlpha), u.pixelStorei(u.UNPACK_FLIP_Y_WEBGL, this._flipY), u.activeTexture(u.TEXTURE0), u.bindTexture(l, this._texture), e.arrayBufferView ? u.texSubImage2D(l, 0, n, r, o, a, +this._pixelFormat, +this._pixelDatatype, e.arrayBufferView) : u.texSubImage2D(l, 0, n, r, this._pixelFormat, this._pixelDatatype, e), u.bindTexture(l, null)
        }, d.prototype.copyFromFramebuffer = function (e, n, r, o, u, l) {
            if (s.isDepthFormat(this._pixelFormat))throw new i("Cannot call copyFromFramebuffer when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.");
            if (this._pixelDatatype === a.FLOAT)throw new i("Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT.");
            if (e = t(e, 0), n = t(n, 0), r = t(r, 0), o = t(o, 0), u = t(u, this._width), l = t(l, this._height), 0 > e)throw new i("xOffset must be greater than or equal to zero.");
            if (0 > n)throw new i("yOffset must be greater than or equal to zero.");
            if (0 > r)throw new i("framebufferXOffset must be greater than or equal to zero.");
            if (0 > o)throw new i("framebufferYOffset must be greater than or equal to zero.");
            if (e + u > this._width)throw new i("xOffset + width must be less than or equal to getWidth().");
            if (n + l > this._height)throw new i("yOffset + height must be less than or equal to getHeight().");
            var c = this._gl, d = this._textureTarget;
            c.activeTexture(c.TEXTURE0), c.bindTexture(d, this._texture), c.copyTexSubImage2D(d, 0, e, n, r, o, u, l), c.bindTexture(d, null)
        }, d.prototype.generateMipmap = function (e) {
            if (s.isDepthFormat(this._pixelFormat))throw new i("Cannot call generateMipmap when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.");
            if (this._width > 1 && !r.isPowerOfTwo(this._width))throw new i("width must be a power of two to call generateMipmap().");
            if (this._height > 1 && !r.isPowerOfTwo(this._height))throw new i("height must be a power of two to call generateMipmap().");
            if (e = t(e, o.DONT_CARE), !o.validate(e))throw new i("hint is invalid.");
            var n = this._gl, a = this._textureTarget;
            n.hint(n.GENERATE_MIPMAP_HINT, e), n.activeTexture(n.TEXTURE0), n.bindTexture(a, this._texture), n.generateMipmap(a), n.bindTexture(a, null)
        }, d.prototype.getSampler = function () {
            return this._sampler
        }, d.prototype.setSampler = function (e) {
            if ("undefined" == typeof e) {
                var t = l.LINEAR, n = u.LINEAR;
                this._pixelDatatype === a.FLOAT && (t = l.NEAREST, n = u.NEAREST), e = {wrapS: c.CLAMP, wrapT: c.CLAMP, minificationFilter: t, magnificationFilter: n, maximumAnisotropy: 1}
            }
            if (this._pixelDatatype === a.FLOAT) {
                if (e.minificationFilter !== l.NEAREST && e.minificationFilter !== l.NEAREST_MIPMAP_NEAREST)throw new i("Only NEAREST and NEAREST_MIPMAP_NEAREST minification filters are supported for floating point textures.");
                if (e.magnificationFilter !== u.NEAREST)throw new i("Only the NEAREST magnification filter is supported for floating point textures.")
            }
            var r = this._gl, o = this._textureTarget;
            r.activeTexture(r.TEXTURE0), r.bindTexture(o, this._texture), r.texParameteri(o, r.TEXTURE_MIN_FILTER, e.minificationFilter), r.texParameteri(o, r.TEXTURE_MAG_FILTER, e.magnificationFilter), r.texParameteri(o, r.TEXTURE_WRAP_S, e.wrapS), r.texParameteri(o, r.TEXTURE_WRAP_T, e.wrapT), this._textureFilterAnisotropic && r.texParameteri(o, this._textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, e.maximumAnisotropy), r.bindTexture(o, null), this._sampler = {wrapS: e.wrapS, wrapT: e.wrapT, minificationFilter: e.minificationFilter, magnificationFilter: e.magnificationFilter, maximumAnisotropy: e.maximumAnisotropy}
        }, d.prototype.getPixelFormat = function () {
            return this._pixelFormat
        }, d.prototype.getPixelDatatype = function () {
            return this._pixelDatatype
        }, d.prototype.getDimensions = function () {
            return this._dimensions
        }, d.prototype.getPreMultiplyAlpha = function () {
            return this._preMultiplyAlpha
        }, d.prototype.getFlipY = function () {
            return this._flipY
        }, d.prototype.getWidth = function () {
            return this._width
        }, d.prototype.getHeight = function () {
            return this._height
        }, d.prototype._getTexture = function () {
            return this._texture
        }, d.prototype._getTarget = function () {
            return this._textureTarget
        }, d.prototype.isDestroyed = function () {
            return!1
        }, d.prototype.destroy = function () {
            return this._gl.deleteTexture(this._texture), n(this)
        }, d
    }), n("Renderer/CubeMapFace", ["../Core/defaultValue", "../Core/DeveloperError", "./PixelDatatype"], function (e, t, n) {
        "use strict";
        var i = function (e, t, n, i, r, o, a, s, u) {
            this._gl = e, this._texture = t, this._textureTarget = n, this._targetFace = i, this._pixelFormat = r, this._pixelDatatype = o, this._size = a, this._preMultiplyAlpha = s, this._flipY = u
        };
        return i.prototype.copyFrom = function (n, i, r) {
            if (!n)throw new t("source is required.");
            i = e(i, 0), r = e(r, 0);
            var o = n.width, a = n.height;
            if (0 > i)throw new t("xOffset must be greater than or equal to zero.");
            if (0 > r)throw new t("yOffset must be greater than or equal to zero.");
            if (i + o > this._size)throw new t("xOffset + source.width must be less than or equal to getWidth().");
            if (r + a > this._size)throw new t("yOffset + source.height must be less than or equal to getHeight().");
            var s = this._gl, u = this._textureTarget;
            s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._preMultiplyAlpha), s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, this._flipY), s.activeTexture(s.TEXTURE0), s.bindTexture(u, this._texture), n.arrayBufferView ? s.texSubImage2D(this._targetFace, 0, i, r, o, a, +this._pixelFormat, +this._pixelDatatype, n.arrayBufferView) : s.texSubImage2D(this._targetFace, 0, i, r, +this._pixelFormat, +this._pixelDatatype, n), s.bindTexture(u, null)
        }, i.prototype.copyFromFramebuffer = function (i, r, o, a, s, u) {
            if (i = e(i, 0), r = e(r, 0), o = e(o, 0), a = e(a, 0), s = e(s, this._size), u = e(u, this._size), 0 > i)throw new t("xOffset must be greater than or equal to zero.");
            if (0 > r)throw new t("yOffset must be greater than or equal to zero.");
            if (0 > o)throw new t("framebufferXOffset must be greater than or equal to zero.");
            if (0 > a)throw new t("framebufferYOffset must be greater than or equal to zero.");
            if (i + s > this._size)throw new t("xOffset + source.width must be less than or equal to getWidth().");
            if (r + u > this._size)throw new t("yOffset + source.height must be less than or equal to getHeight().");
            if (this._pixelDatatype === n.FLOAT)throw new t("Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT.");
            var l = this._gl, c = this._textureTarget;
            l.activeTexture(l.TEXTURE0), l.bindTexture(c, this._texture), l.copyTexSubImage2D(this._targetFace, 0, i, r, o, a, s, u), l.bindTexture(c, null)
        }, i.prototype.getPixelFormat = function () {
            return this._pixelFormat
        }, i.prototype.getPixelDatatype = function () {
            return this._pixelDatatype
        }, i.prototype._getTexture = function () {
            return this._texture
        }, i.prototype._getTarget = function () {
            return this._targetFace
        }, i
    }), n("Renderer/CubeMap", ["../Core/DeveloperError", "../Core/destroyObject", "../Core/Math", "./MipmapHint", "./PixelDatatype", "./TextureMagnificationFilter", "./TextureMinificationFilter", "./TextureWrap", "./CubeMapFace"], function (e, t, n, i, r, o, a, s, u) {
        "use strict";
        var l = function (e, t, n, i, r, o, a, s, l) {
            this._gl = e, this._textureFilterAnisotropic = t, this._textureTarget = n, this._texture = i, this._pixelFormat = r, this._pixelDatatype = o, this._size = a, this._preMultiplyAlpha = s, this._flipY = l, this._sampler = void 0, this._positiveX = new u(e, i, n, e.TEXTURE_CUBE_MAP_POSITIVE_X, r, o, a, s, l), this._negativeX = new u(e, i, n, e.TEXTURE_CUBE_MAP_NEGATIVE_X, r, o, a, s, l), this._positiveY = new u(e, i, n, e.TEXTURE_CUBE_MAP_POSITIVE_Y, r, o, a, s, l), this._negativeY = new u(e, i, n, e.TEXTURE_CUBE_MAP_NEGATIVE_Y, r, o, a, s, l), this._positiveZ = new u(e, i, n, e.TEXTURE_CUBE_MAP_POSITIVE_Z, r, o, a, s, l), this._negativeZ = new u(e, i, n, e.TEXTURE_CUBE_MAP_NEGATIVE_Z, r, o, a, s, l), this.setSampler()
        };
        return l.prototype.getPositiveX = function () {
            return this._positiveX
        }, l.prototype.getNegativeX = function () {
            return this._negativeX
        }, l.prototype.getPositiveY = function () {
            return this._positiveY
        }, l.prototype.getNegativeY = function () {
            return this._negativeY
        }, l.prototype.getPositiveZ = function () {
            return this._positiveZ
        }, l.prototype.getNegativeZ = function () {
            return this._negativeZ
        }, l.prototype.generateMipmap = function (t) {
            if (this._size > 1 && !n.isPowerOfTwo(this._size))throw new e("width and height must be a power of two to call generateMipmap().");
            if (t = t || i.DONT_CARE, !i.validate(t))throw new e("hint is invalid.");
            var r = this._gl, o = this._textureTarget;
            r.hint(r.GENERATE_MIPMAP_HINT, t), r.activeTexture(r.TEXTURE0), r.bindTexture(o, this._texture), r.generateMipmap(o), r.bindTexture(o, null)
        }, l.prototype.setSampler = function (t) {
            if ("undefined" == typeof t) {
                var n = a.LINEAR, i = o.LINEAR;
                this._pixelDatatype === r.FLOAT && (n = a.NEAREST, i = o.NEAREST), t = {wrapS: s.CLAMP, wrapT: s.CLAMP, minificationFilter: n, magnificationFilter: i, maximumAnisotropy: 1}
            }
            if (this._pixelDatatype === r.FLOAT) {
                if (t.minificationFilter !== a.NEAREST && t.minificationFilter !== a.NEAREST_MIPMAP_NEAREST)throw new e("Only NEAREST and NEAREST_MIPMAP_NEAREST minification filters are supported for floating point textures.");
                if (t.magnificationFilter !== o.NEAREST)throw new e("Only the NEAREST magnification filter is supported for floating point textures.")
            }
            var u = this._gl, l = this._textureTarget;
            u.activeTexture(u.TEXTURE0), u.bindTexture(l, this._texture), u.texParameteri(l, u.TEXTURE_MIN_FILTER, t.minificationFilter), u.texParameteri(l, u.TEXTURE_MAG_FILTER, t.magnificationFilter), u.texParameteri(l, u.TEXTURE_WRAP_S, t.wrapS), u.texParameteri(l, u.TEXTURE_WRAP_T, t.wrapT), this._textureFilterAnisotropic && u.texParameteri(l, this._textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t.maximumAnisotropy), u.bindTexture(l, null), this._sampler = {wrapS: t.wrapS, wrapT: t.wrapT, minificationFilter: t.minificationFilter, magnificationFilter: t.magnificationFilter, maximumAnisotropy: t.maximumAnisotropy}
        }, l.prototype.getSampler = function () {
            return this._sampler
        }, l.prototype.getPixelFormat = function () {
            return this._pixelFormat
        }, l.prototype.getPixelDatatype = function () {
            return this._pixelDatatype
        }, l.prototype.getWidth = function () {
            return this._size
        }, l.prototype.getHeight = function () {
            return this._size
        }, l.prototype.getPreMultiplyAlpha = function () {
            return this._preMultiplyAlpha
        }, l.prototype.getFlipY = function () {
            return this._flipY
        }, l.prototype._getTexture = function () {
            return this._texture
        }, l.prototype._getTarget = function () {
            return this._textureTarget
        }, l.prototype.isDestroyed = function () {
            return!1
        }, l.prototype.destroy = function () {
            return this._gl.deleteTexture(this._texture), this._positiveX = t(this._positiveX), this._negativeX = t(this._negativeX), this._positiveY = t(this._positiveY), this._negativeY = t(this._negativeY), this._positiveZ = t(this._positiveZ), this._negativeZ = t(this._negativeZ), t(this)
        }, l
    }), n("Shaders/Materials/AsphaltMaterial", [], function () {
        "use strict";
        return"uniform vec4 asphaltColor;\nuniform float bumpSize;\nuniform float roughness;\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nvec4 color = asphaltColor;\nvec2 st = materialInput.st;\nvec2 F = czm_cellular(st / bumpSize);\ncolor.rgb -= (F.x / F.y) * 0.1;\nfloat noise = czm_snoise(st / bumpSize);\nnoise = pow(noise, 5.0) * roughness;\ncolor.rgb += noise;\nmaterial.diffuse = color.rgb;\nmaterial.alpha = color.a;\nreturn material;\n}\n"
    }), n("Shaders/Materials/BlobMaterial", [], function () {
        "use strict";
        return"uniform vec4 lightColor;\nuniform vec4 darkColor;\nuniform float frequency;\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nvec2 F = czm_cellular(materialInput.st * frequency);\nfloat t = 1.0 - F.x * F.x;\nvec4 color = mix(lightColor, darkColor, t);\nmaterial.diffuse = color.rgb;\nmaterial.alpha = color.a;\nreturn material;\n}\n"
    }), n("Shaders/Materials/BrickMaterial", [], function () {
        "use strict";
        return"uniform vec4 brickColor;\nuniform vec4 mortarColor;\nuniform vec2 brickSize;\nuniform vec2 brickPct;\nuniform float brickRoughness;\nuniform float mortarRoughness;\n#define Integral(x, p) ((floor(x) * p) + max(fract(x) - (1.0 - p), 0.0))\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nvec2 st = materialInput.st;\nvec2 position = st / brickSize;\nif(fract(position.y * 0.5) > 0.5) {\nposition.x += 0.5;\n}\nvec2 filterWidth = vec2(0.02);\nvec2 useBrick = (Integral(position + filterWidth, brickPct) -\nIntegral(position, brickPct)) / filterWidth;\nfloat useBrickFinal = useBrick.x * useBrick.y;\nvec4 color = mix(mortarColor, brickColor, useBrickFinal);\nvec2 brickScaled = vec2(st.x / 0.1, st.y / 0.006);\nfloat brickNoise = abs(czm_snoise(brickScaled) * brickRoughness / 5.0);\ncolor.rg += brickNoise * useBrickFinal;\nvec2 mortarScaled = st / 0.005;\nfloat mortarNoise = max(czm_snoise(mortarScaled) * mortarRoughness, 0.0);\ncolor.rgb += mortarNoise * (1.0 - useBrickFinal);\nmaterial.diffuse = color.rgb;\nmaterial.alpha = color.a;\nreturn material;\n}\n"
    }), n("Shaders/Materials/BumpMapMaterial", [], function () {
        "use strict";
        return"uniform sampler2D image;\nuniform float strength;\nuniform vec2 repeat;\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nvec2 st = materialInput.st;\nvec2 centerPixel = fract(repeat * st);\nfloat centerBump = texture2D(image, centerPixel).channel;\nfloat imageWidth = float(imageDimensions.x);\nvec2 rightPixel = fract(repeat * (st + vec2(1.0 / imageWidth, 0.0)));\nfloat rightBump = texture2D(image, rightPixel).channel;\nfloat imageHeight = float(imageDimensions.y);\nvec2 leftPixel = fract(repeat * (st + vec2(0.0, 1.0 / imageHeight)));\nfloat topBump = texture2D(image, leftPixel).channel;\nvec3 normalTangentSpace = normalize(vec3(centerBump - rightBump, centerBump - topBump, clamp(1.0 - strength, 0.1, 1.0)));\nvec3 normalEC = materialInput.tangentToEyeMatrix * normalTangentSpace;\nmaterial.normal = normalEC;\nmaterial.diffuse = vec3(0.01);\nreturn material;\n}\n"
    }), n("Shaders/Materials/CementMaterial", [], function () {
        "use strict";
        return"uniform vec4 cementColor;\nuniform float grainScale;\nuniform float roughness;\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nfloat noise = czm_snoise(materialInput.st / grainScale);\nnoise = pow(noise, 5.0) * roughness;\nvec4 color = cementColor;\ncolor.rgb += noise;\nmaterial.diffuse = color.rgb;\nmaterial.alpha = color.a;\nreturn material;\n}\n"
    }), n("Shaders/Materials/CheckerboardMaterial", [], function () {
        "use strict";
        return"uniform vec4 lightColor;\nuniform vec4 darkColor;\nuniform vec2 repeat;\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nvec2 st = materialInput.st;\nfloat b = mod(floor(repeat.s * st.s) + floor(repeat.t * st.t), 2.0);\nfloat scaledWidth = fract(repeat.s * st.s);\nscaledWidth = abs(scaledWidth - floor(scaledWidth + 0.5));\nfloat scaledHeight = fract(repeat.t * st.t);\nscaledHeight = abs(scaledHeight - floor(scaledHeight + 0.5));\nfloat value = min(scaledWidth, scaledHeight);\nvec4 currentColor = mix(lightColor, darkColor, b);\nvec4 color = czm_antialias(lightColor, darkColor, currentColor, value, 0.03);\nmaterial.diffuse = color.rgb;\nmaterial.alpha = color.a;\nreturn material;\n}\n"
    }), n("Shaders/Materials/DotMaterial", [], function () {
        "use strict";
        return"uniform vec4 lightColor;\nuniform vec4 darkColor;\nuniform vec2 repeat;\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nfloat b = smoothstep(0.3, 0.32, length(fract(repeat * materialInput.st) - 0.5));\nvec4 color = mix(lightColor, darkColor, b);\nmaterial.diffuse = color.rgb;\nmaterial.alpha = color.a;\nreturn material;\n}\n"
    }), n("Shaders/Materials/FacetMaterial", [], function () {
        "use strict";
        return"uniform vec4 lightColor;\nuniform vec4 darkColor;\nuniform float frequency;\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nvec2 F = czm_cellular(materialInput.st * frequency);\nfloat t = 0.1 + (F.y - F.x);\nvec4 color = mix(lightColor, darkColor, t);\nmaterial.diffuse = color.rgb;\nmaterial.alpha = color.a;\nreturn material;\n}\n"
    }), n("Shaders/Materials/FresnelMaterial", [], function () {
        "use strict";
        return"czm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nvec3 normalWC = normalize(czm_inverseViewRotation * material.normal);\nvec3 positionWC = normalize(czm_inverseViewRotation * materialInput.positionToEyeEC);\nfloat cosAngIncidence = max(dot(normalWC, positionWC), 0.0);\nmaterial.diffuse = mix(reflection.diffuse, refraction.diffuse, cosAngIncidence);\nreturn material;\n}\n"
    }), n("Shaders/Materials/GrassMaterial", [], function () {
        "use strict";
        return"uniform vec4 grassColor;\nuniform vec4 dirtColor;\nuniform float patchiness;\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nvec2 st = materialInput.st;\nfloat noise1 = (czm_snoise(st * patchiness * 1.0)) * 1.0;\nfloat noise2 = (czm_snoise(st * patchiness * 2.0)) * 0.5;\nfloat noise3 = (czm_snoise(st * patchiness * 4.0)) * 0.25;\nfloat noise = sin(noise1 + noise2 + noise3) * 0.1;\nvec4 color = mix(grassColor, dirtColor, noise);\nfloat verticalNoise = czm_snoise(vec2(st.x * 100.0, st.y * 20.0)) * 0.02;\nfloat horizontalNoise = czm_snoise(vec2(st.x * 20.0, st.y * 100.0)) * 0.02;\nfloat stripeNoise = min(verticalNoise, horizontalNoise);\ncolor.rgb += stripeNoise;\nmaterial.diffuse = color.rgb;\nmaterial.alpha = color.a;\nreturn material;\n}\n"
    }), n("Shaders/Materials/GridMaterial", [], function () {
        "use strict";
        return"#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\nuniform vec4 color;\nuniform float cellAlpha;\nuniform vec2 lineCount;\nuniform vec2 lineThickness;\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nvec2 st = materialInput.st;\nfloat scaledWidth = fract(lineCount.s * st.s);\nscaledWidth = abs(scaledWidth - floor(scaledWidth + 0.5));\nfloat scaledHeight = fract(lineCount.t * st.t);\nscaledHeight = abs(scaledHeight - floor(scaledHeight + 0.5));\nfloat value;\n#ifdef GL_OES_standard_derivatives\nconst float fuzz = 1.2;\nvec2 thickness = lineThickness - 1.0;\nvec2 dx = abs(dFdx(st));\nvec2 dy = abs(dFdy(st));\nvec2 dF = vec2(max(dx.s, dy.s), max(dx.t, dy.t)) * lineCount;\nvalue = min(\nsmoothstep(dF.s * thickness.s, dF.s * (fuzz + thickness.s), scaledWidth),\nsmoothstep(dF.t * thickness.t, dF.t * (fuzz + thickness.t), scaledHeight));\n#else\nconst float fuzz = 0.05;\nvec2 range = 0.5 - (lineThickness * 0.05);\nvalue = min(\n1.0 - smoothstep(range.s, range.s + fuzz, scaledWidth),\n1.0 - smoothstep(range.t, range.t + fuzz, scaledHeight));\n#endif\nfloat dRim = 1.0 - dot(materialInput.normalEC, normalize(materialInput.positionToEyeEC));\nfloat sRim = smoothstep(0.8, 1.0, dRim);\nvalue *= (1.0 - sRim);\nvec3 halfColor = color.rgb * 0.5;\nmaterial.diffuse = halfColor;\nmaterial.emission = halfColor;\nmaterial.alpha = color.a * (1.0 - ((1.0 - cellAlpha) * value));\nreturn material;\n}\n"
    }), n("Shaders/Materials/NormalMapMaterial", [], function () {
        "use strict";
        return"uniform sampler2D image;\nuniform float strength;\nuniform vec2 repeat;\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nvec4 textureValue = texture2D(image, fract(repeat * materialInput.st));\nvec3 normalTangentSpace = textureValue.channels;\nnormalTangentSpace.xy = normalTangentSpace.xy * 2.0 - 1.0;\nnormalTangentSpace.z = clamp(1.0 - strength, 0.1, 1.0);\nnormalTangentSpace = normalize(normalTangentSpace);\nvec3 normalEC = materialInput.tangentToEyeMatrix * normalTangentSpace;\nmaterial.normal = normalEC;\nreturn material;\n}\n"
    }), n("Shaders/Materials/ReflectionMaterial", [], function () {
        "use strict";
        return"uniform samplerCube cubeMap;\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nvec3 normalWC = normalize(czm_inverseViewRotation * material.normal);\nvec3 positionWC = normalize(czm_inverseViewRotation * materialInput.positionToEyeEC);\nvec3 reflectedWC = reflect(positionWC, normalWC);\nmaterial.diffuse = textureCube(cubeMap, reflectedWC).channels;\nreturn material;\n}\n"
    }), n("Shaders/Materials/RefractionMaterial", [], function () {
        "use strict";
        return"uniform samplerCube cubeMap;\nuniform float indexOfRefractionRatio;\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nvec3 normalWC = normalize(czm_inverseViewRotation * material.normal);\nvec3 positionWC = normalize(czm_inverseViewRotation * materialInput.positionToEyeEC);\nvec3 refractedWC = refract(positionWC, -normalWC, indexOfRefractionRatio);\nmaterial.diffuse = textureCube(cubeMap, refractedWC).channels;\nreturn material;\n}\n"
    }), n("Shaders/Materials/StripeMaterial", [], function () {
        "use strict";
        return"uniform vec4 lightColor;\nuniform vec4 darkColor;\nuniform float offset;\nuniform float repeat;\nuniform bool horizontal;\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nfloat coord = mix(materialInput.st.s, materialInput.st.t, float(horizontal));\nfloat value = fract((coord - offset) * (repeat * 0.5));\nfloat dist = min(value, min(abs(value - 0.5), 1.0 - value));\nvec4 currentColor = mix(lightColor, darkColor, step(0.5, value));\nvec4 color = czm_antialias(lightColor, darkColor, currentColor, dist);\nmaterial.diffuse = color.rgb;\nmaterial.alpha = color.a;\nreturn material;\n}\n"
    }), n("Shaders/Materials/TieDyeMaterial", [], function () {
        "use strict";
        return"uniform vec4 lightColor;\nuniform vec4 darkColor;\nuniform float frequency;\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nvec3 scaled = materialInput.str * frequency;\nfloat t = abs(czm_snoise(scaled));\nvec4 color = mix(lightColor, darkColor, t);\nmaterial.diffuse = color.rgb;\nmaterial.alpha = color.a;\nreturn material;\n}\n"
    }), n("Shaders/Materials/Water", [], function () {
        "use strict";
        return"uniform sampler2D specularMap;\nuniform sampler2D normalMap;\nuniform vec4 baseWaterColor;\nuniform vec4 blendColor;\nuniform float frequency;\nuniform float animationSpeed;\nuniform float amplitude;\nuniform float specularIntensity;\nuniform float fadeFactor;\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nfloat time = czm_frameNumber * animationSpeed;\nfloat fade = max(1.0, (length(materialInput.positionToEyeEC) / 10000000000.0) * frequency * fadeFactor);\nfloat specularMapValue = texture2D(specularMap, materialInput.st).r;\nvec4 noise = czm_getWaterNoise(normalMap, materialInput.st * frequency, time, 0.0);\nvec3 normalTangentSpace = noise.xyz * vec3(1.0, 1.0, (1.0 / amplitude));\nnormalTangentSpace.xy /= fade;\nnormalTangentSpace = mix(vec3(0.0, 0.0, 50.0), normalTangentSpace, specularMapValue);\nnormalTangentSpace = normalize(normalTangentSpace);\nfloat tsPerturbationRatio = clamp(dot(normalTangentSpace, vec3(0.0, 0.0, 1.0)), 0.0, 1.0);\nmaterial.alpha = specularMapValue;\nmaterial.diffuse = mix(blendColor.rgb, baseWaterColor.rgb, specularMapValue);\nmaterial.diffuse += (0.1 * tsPerturbationRatio);\nmaterial.normal = normalize(materialInput.tangentToEyeMatrix * normalTangentSpace);\nmaterial.specular = specularIntensity;\nmaterial.shininess = 10.0;\nreturn material;\n}\n"
    }), n("Shaders/Materials/WoodMaterial", [], function () {
        "use strict";
        return"uniform vec4 lightWoodColor;\nuniform vec4 darkWoodColor;\nuniform float ringFrequency;\nuniform vec2 noiseScale;\nuniform float grainFrequency;\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nvec2 st = materialInput.st;\nvec2 noisevec;\nnoisevec.x = czm_snoise(st * noiseScale.x);\nnoisevec.y = czm_snoise(st * noiseScale.y);\nvec2 location = st + noisevec;\nfloat dist = sqrt(location.x * location.x + location.y * location.y);\ndist *= ringFrequency;\nfloat r = fract(dist + noisevec[0] + noisevec[1]) * 2.0;\nif(r > 1.0)\nr = 2.0 - r;\nvec4 color = mix(lightWoodColor, darkWoodColor, r);\nr = abs(czm_snoise(vec2(st.x * grainFrequency, st.y * grainFrequency * 0.02))) * 0.2;\ncolor.rgb += lightWoodColor.rgb * r;\nmaterial.diffuse = color.rgb;\nmaterial.alpha = color.a;\nreturn material;\n}\n"
    }), n("Shaders/Materials/RimLightingMaterial", [], function () {
        "use strict";
        return"uniform vec4 color;\nuniform vec4 rimColor;\nuniform float width;\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nfloat d = 1.0 - dot(materialInput.normalEC, normalize(materialInput.positionToEyeEC));\nfloat s = smoothstep(1.0 - width, 1.0, d);\nmaterial.diffuse = color.rgb;\nmaterial.emission = rimColor.rgb * s;\nmaterial.alpha = mix(color.a, rimColor.a, s);\nreturn material;\n}\n"
    }), n("Shaders/Materials/ErosionMaterial", [], function () {
        "use strict";
        return"uniform vec4 color;\nuniform float time;\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nfloat alpha = 1.0;\nif (time != 1.0)\n{\nfloat t = 0.5 + (0.5 * czm_snoise(materialInput.str / (1.0 / 10.0)));\nif (t > time)\n{\nalpha = 0.0;\n}\n}\nmaterial.diffuse = color.rgb;\nmaterial.alpha = color.a * alpha;\nreturn material;\n}\n"
    }), n("Shaders/Materials/FadeMaterial", [], function () {
        "use strict";
        return"uniform vec4 fadeInColor;\nuniform vec4 fadeOutColor;\nuniform float maximumDistance;\nuniform bool repeat;\nuniform vec2 fadeDirection;\nuniform vec2 time;\nfloat getTime(float t, float coord)\n{\nfloat scalar = 1.0 / maximumDistance;\nfloat q  = distance(t, coord) * scalar;\nif (repeat)\n{\nfloat r = distance(t, coord + 1.0) * scalar;\nfloat s = distance(t, coord - 1.0) * scalar;\nq = min(min(r, s), q);\n}\nreturn clamp(q, 0.0, 1.0);\n}\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nvec2 st = materialInput.st;\nfloat s = getTime(time.x, st.s) * fadeDirection.s;\nfloat t = getTime(time.y, st.t) * fadeDirection.t;\nfloat u = length(vec2(s, t));\nvec4 color = mix(fadeInColor, fadeOutColor, u);\nmaterial.emission = color.rgb;\nmaterial.alpha = color.a;\nreturn material;\n}\n"
    }), n("Shaders/Materials/PolylineArrowMaterial", [], function () {
        "use strict";
        return"#extension GL_OES_standard_derivatives : enable\nuniform vec4 color;\nvarying float v_width;\nfloat getPointOnLine(vec2 p0, vec2 p1, float x)\n{\nfloat slope = (p0.y - p1.y) / (p0.x - p1.x);\nreturn slope * (x - p0.x) + p0.y;\n}\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nvec2 st = materialInput.st;\nfloat base = 1.0 - abs(fwidth(st.s)) * 10.0;\nvec2 center = vec2(1.0, 0.5);\nfloat ptOnUpperLine = getPointOnLine(vec2(base, 1.0), center, st.s);\nfloat ptOnLowerLine = getPointOnLine(vec2(base, 0.0), center, st.s);\nfloat halfWidth = 0.15;\nfloat s = step(0.5 - halfWidth, st.t);\ns *= 1.0 - step(0.5 + halfWidth, st.t);\ns *= 1.0 - step(base, st.s);\nfloat t = step(base, materialInput.st.s);\nt *= 1.0 - step(ptOnUpperLine, st.t);\nt *= step(ptOnLowerLine, st.t);\nfloat dist;\nif (st.s < base)\n{\nfloat d1 = abs(st.t - (0.5 - halfWidth));\nfloat d2 = abs(st.t - (0.5 + halfWidth));\ndist = min(d1, d2);\n}\nelse\n{\nfloat d1 = czm_infinity;\nif (st.t < 0.5 - halfWidth && st.t > 0.5 + halfWidth)\n{\nd1 = abs(st.s - base);\n}\nfloat d2 = abs(st.t - ptOnUpperLine);\nfloat d3 = abs(st.t - ptOnLowerLine);\ndist = min(min(d1, d2), d3);\n}\nvec4 outsideColor = vec4(0.0);\nvec4 currentColor = mix(outsideColor, color, clamp(s + t, 0.0, 1.0));\nvec4 outColor = czm_antialias(outsideColor, color, currentColor, dist);\nmaterial.diffuse = outColor.rgb;\nmaterial.alpha = outColor.a;\nreturn material;\n}\n"
    }), n("Shaders/Materials/PolylineGlowMaterial", [], function () {
        "use strict";
        return"uniform vec4 color;\nuniform float glowPower;\nvarying float v_width;\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nvec2 st = materialInput.st;\nfloat glow = glowPower / abs(st.t - 0.5);\nmaterial.emission = max(vec3(glow - 1.0 + color.rgb), color.rgb);\nmaterial.alpha = clamp(0.0, 1.0, glow) * color.a;\nreturn material;\n}\n"
    }), n("Shaders/Materials/PolylineOutlineMaterial", [], function () {
        "use strict";
        return"uniform vec4 color;\nuniform vec4 outlineColor;\nuniform float outlineWidth;\nvarying float v_width;\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nvec2 st = materialInput.st;\nfloat halfInteriorWidth =  0.5 * (v_width - outlineWidth) / v_width;\nfloat b = step(0.5 - halfInteriorWidth, st.t);\nb *= 1.0 - step(0.5 + halfInteriorWidth, st.t);\nfloat d1 = abs(st.t - (0.5 - halfInteriorWidth));\nfloat d2 = abs(st.t - (0.5 + halfInteriorWidth));\nfloat dist = min(d1, d2);\nvec4 currentColor = mix(outlineColor, color, b);\nvec4 outColor = czm_antialias(outlineColor, color, currentColor, dist);\nmaterial.diffuse = outColor.rgb;\nmaterial.alpha = outColor.a;\nreturn material;\n}\n"
    }), n("Scene/Material", ["../ThirdParty/when", "../Core/loadImage", "../Core/DeveloperError", "../Core/createGuid", "../Core/clone", "../Core/Color", "../Core/combine", "../Core/defaultValue", "../Core/destroyObject", "../Core/Cartesian2", "../Core/Matrix2", "../Core/Matrix3", "../Core/Matrix4", "../Renderer/Texture", "../Renderer/CubeMap", "../Shaders/Materials/AsphaltMaterial", "../Shaders/Materials/BlobMaterial", "../Shaders/Materials/BrickMaterial", "../Shaders/Materials/BumpMapMaterial", "../Shaders/Materials/CementMaterial", "../Shaders/Materials/CheckerboardMaterial", "../Shaders/Materials/DotMaterial", "../Shaders/Materials/FacetMaterial", "../Shaders/Materials/FresnelMaterial", "../Shaders/Materials/GrassMaterial", "../Shaders/Materials/GridMaterial", "../Shaders/Materials/NormalMapMaterial", "../Shaders/Materials/ReflectionMaterial", "../Shaders/Materials/RefractionMaterial", "../Shaders/Materials/StripeMaterial", "../Shaders/Materials/TieDyeMaterial", "../Shaders/Materials/Water", "../Shaders/Materials/WoodMaterial", "../Shaders/Materials/RimLightingMaterial", "../Shaders/Materials/ErosionMaterial", "../Shaders/Materials/FadeMaterial", "../Shaders/Materials/PolylineArrowMaterial", "../Shaders/Materials/PolylineGlowMaterial", "../Shaders/Materials/PolylineOutlineMaterial"], function (e, t, n, i, r, o, a, s, u, l, c, d, f, h, p, m, y, v, g, _, w, C, x, S, b, T, E, A, M, D, I, P, O, R, z, L, N, F, V) {
        "use strict";
        function B(e, t) {
            e = s(e, s.EMPTY_OBJECT), t._context = e.context, t._strict = s(e.strict, !1), t._count = s(e.count, 0), t._template = r(s(e.fabric, s.EMPTY_OBJECT)), t._template.uniforms = r(s(t._template.uniforms, s.EMPTY_OBJECT)), t._template.materials = r(s(t._template.materials, s.EMPTY_OBJECT)), t.type = "undefined" != typeof t._template.type ? t._template.type : i(), t.shaderSource = "", t.materials = {}, t.uniforms = {}, t._uniforms = {};
            var n = Q._materialCache.getMaterial(t.type);
            if ("undefined" != typeof n) {
                var o = r(n, !0);
                t._template = a([t._template, o])
            }
            W(t), "undefined" == typeof n && Q._materialCache.addMaterial(t.type, t._template), H(t), G(t), Z(t)
        }

        function k(e, t, n, i) {
            if ("undefined" != typeof e)for (var r in e)if (e.hasOwnProperty(r)) {
                var o = -1 !== t.indexOf(r);
                (i && !o || !i && o) && n(r, t)
            }
        }

        function U(e, t) {
            for (var i = "fabric: property name '" + e + "' is not valid. It should be ", r = 0; r < t.length; r++) {
                var o = "'" + t[r] + "'";
                i += r === t.length - 1 ? "or " + o + "." : o + ", "
            }
            throw new n(i)
        }

        function q(e) {
            var t = "fabric: uniforms and materials cannot share the same property '" + e + "'";
            throw new n(t)
        }

        function W(e) {
            var t = e._template, i = t.uniforms, r = t.materials, o = t.components;
            if ("undefined" != typeof o && "undefined" != typeof t.source)throw new n("fabric: cannot have source and components in the same template.");
            k(t, $, U, !0), k(o, et, U, !0);
            var a = [];
            for (var s in r)r.hasOwnProperty(s) && a.push(s);
            k(i, a, q, !1)
        }

        function H(e) {
            var t = e._template.components, n = e._template.source;
            if ("undefined" != typeof n)e.shaderSource += n + "\n"; else {
                if (e.shaderSource += "czm_material czm_getMaterial(czm_materialInput materialInput)\n{\n", e.shaderSource += "czm_material material = czm_getDefaultMaterial(materialInput);\n", "undefined" != typeof t)for (var i in t)t.hasOwnProperty(i) && (e.shaderSource += "material." + i + " = " + t[i] + ";\n");
                e.shaderSource += "return material;\n}\n"
            }
        }

        function G(e) {
            var t = e._template.uniforms;
            for (var n in t)t.hasOwnProperty(n) && j(e, n)
        }

        function j(e, t) {
            var i = e._strict, r = e._template.uniforms, o = r[t], a = X(o);
            if ("undefined" == typeof a)throw new n("fabric: uniform '" + t + "' has invalid type.");
            if ("channels" === a) {
                if (0 === K(e, t, o, !1) && i)throw new n("strict: shader source does not use channels '" + t + "'.")
            } else {
                if (-1 !== a.indexOf("sampler") && "undefined" == typeof e._context)throw new n("image: context is not defined");
                if ("sampler2D" === a) {
                    var s = t + "Dimensions";
                    J(e, s) > 0 && (r[s] = {type: "ivec3", x: 1, y: 1}, j(e, s))
                }
                var u = "uniform " + a + " " + t + ";\n";
                -1 === e.shaderSource.indexOf(u) && (e.shaderSource = u + e.shaderSource);
                var l = t + "_" + e._count++;
                if (1 === K(e, t, l) && i)throw new n("strict: shader source does not use uniform '" + t + "'.");
                e.uniforms[t] = o, e._uniforms[l] = Y(e, t, a)
            }
        }

        function Y(e, t, i) {
            var r;
            return function () {
                var o = e.uniforms, a = o[t];
                if ("undefined" == typeof r && (r = X(a)), "sampler2D" === i && (r === i || a instanceof h)) {
                    r === i && (a = Q._textureCache.registerTexture2DToMaterial(e, t, a));
                    var s = t + "Dimensions";
                    if (o.hasOwnProperty(s)) {
                        var u = o[s];
                        u.x = a._width, u.y = a._height
                    }
                } else if ("samplerCube" === i && (r === i || a instanceof p))r === i && (a = Q._textureCache.registerCubeMapToMaterial(e, t, a)); else if (-1 !== i.indexOf("mat") && (r === i || a instanceof tt[i]))r === i && (a = tt[i].fromColumnMajorArray(a)); else if ("undefined" == typeof r || i !== r)throw new n("fabric: uniform '" + t + "' has invalid value.");
                return o[t] = a, o[t]
            }
        }

        function X(e) {
            var t = e.type;
            if ("undefined" == typeof t) {
                var n = typeof e;
                if ("number" === n)t = "float"; else if ("boolean" === n)t = "bool"; else if ("string" === n)t = /^([rgba]){1,4}$/i.test(e) ? "channels" : e === Q.DefaultCubeMapId ? "samplerCube" : "sampler2D"; else if ("object" === n)if (Array.isArray(e))(4 === e.length || 9 === e.length || 16 === e.length) && (t = "mat" + Math.sqrt(e.length)); else {
                    var i = 0;
                    for (var r in e)e.hasOwnProperty(r) && (i += 1);
                    i >= 2 && 4 >= i ? t = "vec" + i : 6 === i && (t = "samplerCube")
                }
            }
            return t
        }

        function Z(e) {
            var t = e._context, i = e._strict, r = e._template.materials;
            for (var o in r)if (r.hasOwnProperty(o)) {
                var s = new Q({context: t, strict: i, fabric: r[o], count: e._count});
                e._count = s._count, e._uniforms = a([e._uniforms, s._uniforms]), e.materials[o] = s;
                var u = "czm_getMaterial", l = u + "_" + e._count++;
                K(s, u, l), e.shaderSource = s.shaderSource + e.shaderSource;
                var c = l + "(materialInput)";
                if (0 === K(e, o, c) && i)throw new n("strict: shader source does not use material '" + o + "'.")
            }
        }

        function K(e, t, n, i) {
            i = s(i, !0);
            var r = 0, o = "a-zA-Z0-9_", a = "([" + o + "])?", u = "([" + o + (i ? "." : "") + "])?", l = new RegExp(u + t + a, "g");
            return e.shaderSource = e.shaderSource.replace(l, function (e, t, i) {
                return t || i ? e : (r += 1, n)
            }), r
        }

        function J(e, t, n) {
            return K(e, t, t, n)
        }

        var Q = function (e) {
            this.type = void 0, this.shaderSource = void 0, this.materials = void 0, this.uniforms = void 0, this._uniforms = void 0, this._context = void 0, this._strict = void 0, this._template = void 0, this._count = void 0, B(e, this), Object.defineProperty(this, "type", {value: this.type, writable: !1}), "undefined" == typeof Q._uniformList[this.type] && (Q._uniformList[this.type] = Object.keys(this._uniforms))
        };
        Q._uniformList = {}, Q.fromType = function (e, t) {
            if ("undefined" == typeof Q._materialCache.getMaterial(t))throw new n("material with type '" + t + "' does not exist.");
            return new Q({context: e, fabric: {type: t}})
        }, Q.prototype.isDestroyed = function () {
            return!1
        }, Q.prototype.destroy = function () {
            var e = this.materials, t = this.uniforms;
            for (var n in t)if (t.hasOwnProperty(n)) {
                var i = t[n];
                (i instanceof h || i instanceof p) && Q._textureCache.releaseTexture(this, i)
            }
            for (var r in e)e.hasOwnProperty(r) && e[r].destroy();
            return u(this)
        };
        var $ = ["type", "materials", "uniforms", "components", "source"], et = ["diffuse", "specular", "shininess", "normal", "emission", "alpha"], tt = {mat2: c, mat3: d, mat4: f};
        return Q._textureCache = {_pathsToMaterials: {}, _pathsToTextures: {}, _updateMaterialsOnLoad: function (e, t) {
            this._pathsToTextures[t] = e;
            for (var n = this._pathsToMaterials[t], i = 0; i < n.length; i++) {
                var r = n[i], o = r.material, a = r.property;
                this.releaseTexture(o, o.uniforms[a]), o.uniforms[a] = e
            }
        }, releaseTexture: function (e, t) {
            var n = this._pathsToTextures;
            for (var i in n)if (n[i] === t)for (var r = this._pathsToMaterials[i], o = 0; o < r.length; o++)if (r[o].material === e) {
                r.splice(o, 1);
                var a = r.length;
                0 === a && (t.destroy(), delete n.path, delete r.path)
            }
        }, registerCubeMapToMaterial: function (n, i, r) {
            var o, a = this;
            if (r === Q.DefaultCubeMapId)o = n._context.getDefaultCubeMap(); else {
                var u = r.positiveX + r.negativeX + r.positiveY + r.negativeY + r.positiveZ + r.negativeZ;
                if (this._pathsToMaterials[u] = s(this._pathsToMaterials[u], []), this._pathsToMaterials[u].push({material: n, property: i}), o = this._pathsToTextures[u], "undefined" == typeof o) {
                    var l = n.uniforms[i], c = l instanceof p;
                    o = c ? l : n._context.getDefaultCubeMap(), 1 === this._pathsToMaterials[u].length && e.all([t(r.positiveX), t(r.negativeX), t(r.positiveY), t(r.negativeY), t(r.positiveZ), t(r.negativeZ)]).then(function (e) {
                        o = n._context.createCubeMap({source: {positiveX: e[0], negativeX: e[1], positiveY: e[2], negativeY: e[3], positiveZ: e[4], negativeZ: e[5]}}), a._updateMaterialsOnLoad(o, u)
                    })
                }
            }
            return o
        }, registerTexture2DToMaterial: function (n, i, r) {
            var o, a = this;
            if (r === Q.DefaultImageId)o = n._context.getDefaultTexture(); else {
                var u = r;
                if (this._pathsToMaterials[u] = s(this._pathsToMaterials[u], []), this._pathsToMaterials[u].push({material: n, property: i}), o = this._pathsToTextures[u], "undefined" == typeof o) {
                    var l = n.uniforms[i], c = l instanceof h;
                    o = c ? l : n._context.getDefaultTexture(), 1 === this._pathsToMaterials[u].length && e(t(u), function (e) {
                        o = n._context.createTexture2D({source: e}), a._updateMaterialsOnLoad(o, u)
                    })
                }
            }
            return o
        }}, Q._materialCache = {_materials: {}, addMaterial: function (e, t) {
            this._materials[e] = t
        }, getMaterial: function (e) {
            return this._materials[e]
        }}, Q.DefaultImageId = "czm_defaultImage", Q.DefaultCubeMapId = "czm_defaultCubeMap", Q.ColorType = "Color", Q._materialCache.addMaterial(Q.ColorType, {type: Q.ColorType, uniforms: {color: new o(1, 0, 0, .5)}, components: {diffuse: "color.rgb", alpha: "color.a"}}), Q.ImageType = "Image", Q._materialCache.addMaterial(Q.ImageType, {type: Q.ImageType, uniforms: {image: Q.DefaultImageId, repeat: new l(1, 1)}, components: {diffuse: "texture2D(image, fract(repeat * materialInput.st)).rgb", alpha: "texture2D(image, fract(repeat * materialInput.st)).a"}}), Q.DiffuseMapType = "DiffuseMap", Q._materialCache.addMaterial(Q.DiffuseMapType, {type: Q.DiffuseMapType, uniforms: {image: Q.DefaultImageId, channels: "rgb", repeat: new l(1, 1)}, components: {diffuse: "texture2D(image, fract(repeat * materialInput.st)).channels"}}), Q.AlphaMapType = "AlphaMap", Q._materialCache.addMaterial(Q.AlphaMapType, {type: Q.AlphaMapType, uniforms: {image: Q.DefaultImageId, channel: "a", repeat: new l(1, 1)}, components: {alpha: "texture2D(image, fract(repeat * materialInput.st)).channel"}}), Q.SpecularMapType = "SpecularMap", Q._materialCache.addMaterial(Q.SpecularMapType, {type: Q.SpecularMapType, uniforms: {image: Q.DefaultImageId, channel: "r", repeat: new l(1, 1)}, components: {specular: "texture2D(image, fract(repeat * materialInput.st)).channel"}}), Q.EmissionMapType = "EmissionMap", Q._materialCache.addMaterial(Q.EmissionMapType, {type: Q.EmissionMapType, uniforms: {image: Q.DefaultImageId, channels: "rgb", repeat: new l(1, 1)}, components: {emission: "texture2D(image, fract(repeat * materialInput.st)).channels"}}), Q.BumpMapType = "BumpMap", Q._materialCache.addMaterial(Q.BumpMapType, {type: Q.BumpMapType, uniforms: {image: Q.DefaultImageId, channel: "r", strength: .8, repeat: new l(1, 1)}, source: g}), Q.NormalMapType = "NormalMap", Q._materialCache.addMaterial(Q.NormalMapType, {type: Q.NormalMapType, uniforms: {image: Q.DefaultImageId, channels: "rgb", strength: .8, repeat: new l(1, 1)}, source: E}), Q.ReflectionType = "Reflection", Q._materialCache.addMaterial(Q.ReflectionType, {type: Q.ReflectionType, uniforms: {cubeMap: Q.DefaultCubeMapId, channels: "rgb"}, source: A}), Q.RefractionType = "Refraction", Q._materialCache.addMaterial(Q.RefractionType, {type: Q.RefractionType, uniforms: {cubeMap: Q.DefaultCubeMapId, channels: "rgb", indexOfRefractionRatio: .9}, source: M}), Q.FresnelType = "Fresnel", Q._materialCache.addMaterial(Q.FresnelType, {type: Q.FresnelType, materials: {reflection: {type: Q.ReflectionType}, refraction: {type: Q.RefractionType}}, source: S}), Q.BrickType = "Brick", Q._materialCache.addMaterial(Q.BrickType, {type: Q.BrickType, uniforms: {brickColor: new o(.6, .3, .1, 1), mortarColor: new o(.8, .8, .7, 1), brickSize: new l(.3, .15), brickPct: new l(.9, .85), brickRoughness: .2, mortarRoughness: .1}, source: v}), Q.WoodType = "Wood", Q._materialCache.addMaterial(Q.WoodType, {type: Q.WoodType, uniforms: {lightWoodColor: new o(.6, .3, .1, 1), darkWoodColor: new o(.4, .2, .07, 1), ringFrequency: 3, noiseScale: new l(.7, .5), grainFrequency: 27}, source: O}), Q.AsphaltType = "Asphalt", Q._materialCache.addMaterial(Q.AsphaltType, {type: Q.AsphaltType, uniforms: {asphaltColor: new o(.15, .15, .15, 1), bumpSize: .02, roughness: .2}, source: m}), Q.CementType = "Cement", Q._materialCache.addMaterial(Q.CementType, {type: Q.CementType, uniforms: {cementColor: new o(.95, .95, .85, 1), grainScale: .01, roughness: .3}, source: _}), Q.GrassType = "Grass", Q._materialCache.addMaterial(Q.GrassType, {type: Q.GrassType, uniforms: {grassColor: new o(.25, .4, .1, 1), dirtColor: new o(.1, .1, .1, 1), patchiness: 1.5}, source: b}), Q.GridType = "Grid", Q._materialCache.addMaterial(Q.GridType, {type: Q.GridType, uniforms: {color: new o(0, 1, 0, 1), cellAlpha: .1, lineCount: new l(8, 8), lineThickness: new l(1, 1)}, source: T}), Q.StripeType = "Stripe", Q._materialCache.addMaterial(Q.StripeType, {type: Q.StripeType, uniforms: {horizontal: !0, lightColor: new o(1, 1, 1, .5), darkColor: new o(0, 0, 1, .5), offset: 0, repeat: 5}, source: D}), Q.CheckerboardType = "Checkerboard", Q._materialCache.addMaterial(Q.CheckerboardType, {type: Q.CheckerboardType, uniforms: {lightColor: new o(1, 1, 1, .5), darkColor: new o(0, 0, 0, .5), repeat: new l(5, 5)}, source: w}), Q.DotType = "Dot", Q._materialCache.addMaterial(Q.DotType, {type: Q.DotType, uniforms: {lightColor: new o(1, 1, 0, .75), darkColor: new o(0, 1, 1, .75), repeat: new l(5, 5)}, source: C}), Q.TyeDyeType = "TieDye", Q._materialCache.addMaterial(Q.TyeDyeType, {type: Q.TyeDyeType, uniforms: {lightColor: new o(1, 1, 0, .75), darkColor: new o(1, 0, 0, .75), frequency: 5}, source: I}), Q.FacetType = "Facet", Q._materialCache.addMaterial(Q.FacetType, {type: Q.FacetType, uniforms: {lightColor: new o(.25, .25, .25, .75), darkColor: new o(.75, .75, .75, .75), frequency: 10}, source: x}), Q.BlobType = "Blob", Q._materialCache.addMaterial(Q.BlobType, {type: Q.BlobType, uniforms: {lightColor: new o(1, 1, 1, .5), darkColor: new o(0, 0, 1, .5), frequency: 10}, source: y}), Q.WaterType = "Water", Q._materialCache.addMaterial(Q.WaterType, {type: Q.WaterType, uniforms: {baseWaterColor: {red: .2, green: .3, blue: .6, alpha: 1}, blendColor: {red: 0, green: 1, blue: .699, alpha: 1}, specularMap: Q.DefaultImageId, normalMap: Q.DefaultImageId, frequency: 10, animationSpeed: .01, amplitude: 1, specularIntensity: .5, fadeFactor: 1}, source: P}), Q.RimLightingType = "RimLighting", Q._materialCache.addMaterial(Q.RimLightingType, {type: Q.RimLightingType, uniforms: {color: new o(1, 0, 0, .7), rimColor: new o(1, 1, 1, .4), width: .3}, source: R}), Q.ErosionType = "Erosion", Q._materialCache.addMaterial(Q.ErosionType, {type: Q.ErosionType, uniforms: {color: new o(1, 0, 0, .5), time: 1}, source: z}), Q.FadeType = "Fade", Q._materialCache.addMaterial(Q.FadeType, {type: Q.FadeType, uniforms: {fadeInColor: new o(1, 0, 0, 1), fadeOutColor: new o(0, 0, 0, 0), maximumDistance: .5, repeat: !0, fadeDirection: {x: !0, y: !0}, time: new l(.5, .5)}, source: L}), Q.PolylineArrowType = "PolylineArrow", Q._materialCache.addMaterial(Q.PolylineArrowType, {type: Q.PolylineArrowType, uniforms: {color: new o(1, 1, 1, 1)}, source: N}), Q.PolylineGlowType = "PolylineGlow", Q._materialCache.addMaterial(Q.PolylineGlowType, {type: Q.PolylineGlowType, uniforms: {color: new o(0, .5, 1, 1), glowPower: .1}, source: F}), Q.PolylineOutlineType = "PolylineOutline", Q._materialCache.addMaterial(Q.PolylineOutlineType, {type: Q.PolylineOutlineType, uniforms: {color: new o(1, 1, 1, 1), outlineColor: new o(1, 0, 0, 1), outlineWidth: 1}, source: V}), Q
    }), n("DynamicScene/DynamicColorMaterial", ["./DynamicProperty", "./CzmlColor", "../Scene/Material"], function (e, t, n) {
        "use strict";
        var i = function () {
            this.color = void 0
        };
        return i.isMaterial = function (e) {
            return"undefined" != typeof e && "undefined" != typeof e.solidColor
        }, i.prototype.isMaterial = i.isMaterial, i.prototype.processCzmlIntervals = function (n) {
            var i = n.solidColor;
            if ("undefined" != typeof i && "undefined" != typeof i.color) {
                var r = this.color;
                "undefined" == typeof r && (this.color = r = new e(t)), r.processCzmlIntervals(i.color)
            }
        }, i.prototype.getValue = function (e, t, i) {
            return("undefined" == typeof i || i.type !== n.ColorType) && (i = n.fromType(t, n.ColorType)), i.uniforms.color = this.color.getValue(e, i.uniforms.color), i
        }, i
    }), n("DynamicScene/DynamicImageMaterial", ["./DynamicProperty", "./CzmlImage", "./CzmlNumber", "../Scene/Material"], function (e, t, n, i) {
        "use strict";
        var r = function () {
            this.image = void 0, this.verticalRepeat = void 0, this.horizontalRepeat = void 0
        };
        return r.isMaterial = function (e) {
            return"undefined" != typeof e.image
        }, r.prototype.isMaterial = r.isMaterial, r.prototype.processCzmlIntervals = function (i, r) {
            var o = i.image;
            if ("undefined" != typeof o) {
                if ("undefined" != typeof o.image) {
                    var a = this.image;
                    "undefined" == typeof a && (this.image = a = new e(t)), a.processCzmlIntervals(o.image, void 0, r)
                }
                if ("undefined" != typeof o.verticalRepeat) {
                    var s = this.verticalRepeat;
                    "undefined" == typeof s && (this.verticalRepeat = s = new e(n)), s.processCzmlIntervals(o.verticalRepeat)
                }
                if ("undefined" != typeof o.horizontalRepeat) {
                    var u = this.horizontalRepeat;
                    "undefined" == typeof u && (this.horizontalRepeat = u = new e(n)), u.processCzmlIntervals(o.horizontalRepeat)
                }
            }
        }, r.prototype.getValue = function (e, t, n) {
            ("undefined" == typeof n || n.type !== i.ImageType) && (n = i.fromType(t, i.ImageType));
            var r, o = this.verticalRepeat;
            "undefined" != typeof o && (r = o.getValue(e), "undefined" != typeof r && (n.uniforms.repeat.x = r));
            var a;
            if (o = this.horizontalRepeat, "undefined" != typeof o && (a = o.getValue(e), "undefined" != typeof a && (n.uniforms.repeat.y = a)), o = this.image, "undefined" != typeof o) {
                var s = this.image.getValue(e);
                "undefined" != typeof s && n.currentUrl !== s && (n.currentUrl = s, n.uniforms.image = s)
            }
            return n
        }, r
    }), n("DynamicScene/DynamicGridMaterial", ["./DynamicProperty", "./CzmlColor", "./CzmlNumber", "../Scene/Material"], function (e, t, n, i) {
        "use strict";
        var r = function () {
            this.color = void 0, this.cellAlpha = void 0, this.rowCount = void 0, this.columnCount = void 0, this.rowThickness = void 0, this.columnThickness = void 0
        };
        return r.isMaterial = function (e) {
            return"undefined" != typeof e.grid
        }, r.prototype.isMaterial = r.isMaterial, r.prototype.processCzmlIntervals = function (i, r) {
            var o = i.grid;
            if ("undefined" != typeof o) {
                if ("undefined" != typeof o.color) {
                    var a = this.color;
                    "undefined" == typeof a && (this.color = a = new e(t)), a.processCzmlIntervals(o.color, void 0, r)
                }
                if ("undefined" != typeof o.cellAlpha) {
                    var s = this.cellAlpha;
                    "undefined" == typeof s && (this.cellAlpha = s = new e(n)), s.processCzmlIntervals(o.cellAlpha, void 0, r)
                }
                if ("undefined" != typeof o.rowCount) {
                    var u = this.rowCount;
                    "undefined" == typeof u && (this.rowCount = u = new e(n)), u.processCzmlIntervals(o.rowCount, void 0, r)
                }
                if ("undefined" != typeof o.columnCount) {
                    var l = this.columnCount;
                    "undefined" == typeof l && (this.columnCount = l = new e(n)), l.processCzmlIntervals(o.columnCount, void 0, r)
                }
                if ("undefined" != typeof o.rowThickness) {
                    var c = this.rowThickness;
                    "undefined" == typeof c && (this.rowThickness = c = new e(n)), c.processCzmlIntervals(o.rowThickness, void 0, r)
                }
                if ("undefined" != typeof o.columnThickness) {
                    var d = this.columnThickness;
                    "undefined" == typeof d && (this.columnThickness = d = new e(n)), d.processCzmlIntervals(o.columnThickness, void 0, r)
                }
            }
        }, r.prototype.getValue = function (e, t, n) {
            ("undefined" == typeof n || n.type !== i.GridType) && (n = i.fromType(t, i.GridType));
            var r = this.color;
            if ("undefined" != typeof r && r.getValue(e, n.uniforms.color), r = this.cellAlpha, "undefined" != typeof r) {
                var o = r.getValue(e);
                "undefined" != typeof o && (n.uniforms.cellAlpha = o)
            }
            var a = n.uniforms.lineCount;
            if (r = this.rowCount, "undefined" != typeof r) {
                var s = r.getValue(e);
                "undefined" != typeof s && (a.x = s)
            }
            if (r = this.columnCount, "undefined" != typeof r) {
                var u = r.getValue(e);
                "undefined" != typeof u && (a.y = u)
            }
            var l = n.uniforms.lineThickness;
            if (r = this.rowThickness, "undefined" != typeof r) {
                var c = r.getValue(e);
                "undefined" != typeof c && (l.x = c)
            }
            if (r = this.columnThickness, "undefined" != typeof r) {
                var d = r.getValue(e);
                "undefined" != typeof d && (l.y = d)
            }
            return n
        }, r
    }), n("DynamicScene/DynamicMaterialProperty", ["../Core/TimeInterval", "../Core/TimeIntervalCollection", "../Core/Iso8601", "./DynamicColorMaterial", "./DynamicImageMaterial", "./DynamicGridMaterial"], function (e, t, n, i, r, o) {
        "use strict";
        function a(t, i, r, o) {
            var a = i.interval;
            a = "undefined" == typeof a ? n.MAXIMUM_INTERVAL.clone() : e.fromIso8601(a), "undefined" != typeof r && (a = a.intersect(r));
            var u, l = t._intervals, c = l.findInterval(a.start, a.stop), d = !1;
            if ("undefined" != typeof c ? (u = c.data, d = u.isMaterial(i)) : (c = a, l.addInterval(c)), d === !1)for (var f = 0, h = s.length; h > f; f++) {
                var p = s[f];
                if (d = p.isMaterial(i)) {
                    c.data = u = new p;
                    break
                }
            }
            d && u.processCzmlIntervals(i, o)
        }

        var s = [i, r, o], u = function () {
            this._intervals = new t
        };
        return u.prototype.processCzmlIntervals = function (e, t, n) {
            if (Array.isArray(e))for (var i = 0, r = e.length; r > i; i++)a(this, e[i], t, n); else a(this, e, t, n)
        }, u.prototype.getValue = function (e, t, n) {
            var i = this._intervals.findIntervalContainingDate(e), r = "undefined" != typeof i ? i.data : void 0;
            return"undefined" != typeof r ? r.getValue(e, t, n) : n
        }, u
    }), n("DynamicScene/DynamicEllipsoid", ["../Core/TimeInterval", "../Core/defaultValue", "./CzmlBoolean", "./CzmlCartesian3", "./DynamicProperty", "./DynamicMaterialProperty"], function (e, t, n, i, r, o) {
        "use strict";
        var a = function () {
            this.show = void 0, this.radii = void 0, this.material = void 0
        };
        return a.processCzmlPacket = function (t, s) {
            var u = s.ellipsoid;
            if ("undefined" == typeof u)return!1;
            var l = !1, c = t.ellipsoid;
            l = "undefined" == typeof c, l && (t.ellipsoid = c = new a);
            var d = u.interval;
            if ("undefined" != typeof d && (d = e.fromIso8601(d)), "undefined" != typeof u.show) {
                var f = c.show;
                "undefined" == typeof f && (c.show = f = new r(n), l = !0), f.processCzmlIntervals(u.show, d)
            }
            if ("undefined" != typeof u.radii) {
                var h = c.radii;
                "undefined" == typeof h && (c.radii = h = new r(i), l = !0), h.processCzmlIntervals(u.radii, d)
            }
            if ("undefined" != typeof u.material) {
                var p = c.material;
                "undefined" == typeof p && (c.material = p = new o, l = !0), p.processCzmlIntervals(u.material, d)
            }
            return l
        }, a.mergeProperties = function (e, n) {
            var i = n.ellipsoid;
            if ("undefined" != typeof i) {
                var r = e.ellipsoid;
                "undefined" == typeof r && (e.ellipsoid = r = new a), r.show = t(r.show, i.show), r.radii = t(r.radii, i.radii), r.material = t(r.material, i.material)
            }
        }, a.undefineProperties = function (e) {
            e.ellipsoid = void 0
        }, a
    }), n("DynamicScene/DynamicCone", ["../Core/TimeInterval", "../Core/defaultValue", "./CzmlBoolean", "./CzmlNumber", "./CzmlColor", "./DynamicProperty", "./DynamicMaterialProperty"], function (e, t, n, i, r, o, a) {
        "use strict";
        var s = function () {
            this.minimumClockAngle = void 0, this.maximumClockAngle = void 0, this.innerHalfAngle = void 0, this.outerHalfAngle = void 0, this.capMaterial = void 0, this.innerMaterial = void 0, this.outerMaterial = void 0, this.silhouetteMaterial = void 0, this.intersectionColor = void 0, this.intersectionWidth = void 0, this.showIntersection = void 0, this.radius = void 0, this.show = void 0
        };
        return s.processCzmlPacket = function (t, u) {
            var l = u.cone;
            if ("undefined" == typeof l)return!1;
            var c = !1, d = t.cone;
            c = "undefined" == typeof d, c && (t.cone = d = new s);
            var f = l.interval;
            if ("undefined" != typeof f && (f = e.fromIso8601(f)), "undefined" != typeof l.show) {
                var h = d.show;
                "undefined" == typeof h && (d.show = h = new o(n), c = !0), h.processCzmlIntervals(l.show, f)
            }
            if ("undefined" != typeof l.innerHalfAngle) {
                var p = d.innerHalfAngle;
                "undefined" == typeof p && (d.innerHalfAngle = p = new o(i), c = !0), p.processCzmlIntervals(l.innerHalfAngle, f)
            }
            if ("undefined" != typeof l.outerHalfAngle) {
                var m = d.outerHalfAngle;
                "undefined" == typeof m && (d.outerHalfAngle = m = new o(i), c = !0), m.processCzmlIntervals(l.outerHalfAngle, f)
            }
            if ("undefined" != typeof l.minimumClockAngle) {
                var y = d.minimumClockAngle;
                "undefined" == typeof y && (d.minimumClockAngle = y = new o(i), c = !0), y.processCzmlIntervals(l.minimumClockAngle, f)
            }
            if ("undefined" != typeof l.maximumClockAngle) {
                var v = d.maximumClockAngle;
                "undefined" == typeof v && (d.maximumClockAngle = v = new o(i), c = !0), v.processCzmlIntervals(l.maximumClockAngle, f)
            }
            if ("undefined" != typeof l.radius) {
                var g = d.radius;
                "undefined" == typeof g && (d.radius = g = new o(i), c = !0), g.processCzmlIntervals(l.radius, f)
            }
            if ("undefined" != typeof l.showIntersection) {
                var _ = d.showIntersection;
                "undefined" == typeof _ && (d.showIntersection = _ = new o(n), c = !0), _.processCzmlIntervals(l.showIntersection, f)
            }
            if ("undefined" != typeof l.intersectionColor) {
                var w = d.intersectionColor;
                "undefined" == typeof w && (d.intersectionColor = w = new o(r), c = !0), w.processCzmlIntervals(l.intersectionColor, f)
            }
            if ("undefined" != typeof l.intersectionWidth) {
                var C = d.intersectionWidth;
                "undefined" == typeof C && (d.intersectionWidth = C = new o(i), c = !0), C.processCzmlIntervals(l.intersectionWidth, f)
            }
            if ("undefined" != typeof l.capMaterial) {
                var x = d.capMaterial;
                "undefined" == typeof x && (d.capMaterial = x = new a, c = !0), x.processCzmlIntervals(l.capMaterial, f)
            }
            if ("undefined" != typeof l.innerMaterial) {
                var S = d.innerMaterial;
                "undefined" == typeof S && (d.innerMaterial = S = new a, c = !0), S.processCzmlIntervals(l.innerMaterial, f)
            }
            if ("undefined" != typeof l.outerMaterial) {
                var b = d.outerMaterial;
                "undefined" == typeof b && (d.outerMaterial = b = new a, c = !0), b.processCzmlIntervals(l.outerMaterial, f)
            }
            if ("undefined" != typeof l.silhouetteMaterial) {
                var T = d.silhouetteMaterial;
                "undefined" == typeof T && (d.silhouetteMaterial = T = new a, c = !0), T.processCzmlIntervals(l.silhouetteMaterial, f)
            }
            return c
        }, s.mergeProperties = function (e, n) {
            var i = n.cone;
            if ("undefined" != typeof i) {
                var r = e.cone;
                "undefined" == typeof r && (e.cone = r = new s), r.show = t(r.show, i.show), r.innerHalfAngle = t(r.innerHalfAngle, i.innerHalfAngle), r.outerHalfAngle = t(r.outerHalfAngle, i.outerHalfAngle), r.minimumClockAngle = t(r.minimumClockAngle, i.minimumClockAngle), r.maximumClockAngle = t(r.maximumClockAngle, i.maximumClockAngle), r.radius = t(r.radius, i.radius), r.showIntersection = t(r.showIntersection, i.showIntersection), r.intersectionColor = t(r.intersectionColor, i.intersectionColor), r.intersectionWidth = t(r.intersectionWidth, i.intersectionWidth), r.capMaterial = t(r.capMaterial, i.capMaterial), r.innerMaterial = t(r.innerMaterial, i.innerMaterial), r.outerMaterial = t(r.outerMaterial, i.outerMaterial), r.silhouetteMaterial = t(r.silhouetteMaterial, i.silhouetteMaterial)
            }
        }, s.undefineProperties = function (e) {
            e.cone = void 0
        }, s
    }), n("DynamicScene/CzmlString", ["../Core/defaultValue"], function (e) {
        "use strict";
        var t = {unwrapInterval: function (t) {
            return e(t.string, t)
        }, isSampled: function () {
            return!1
        }, getValue: function (e) {
            return e
        }};
        return t
    }), n("Scene/LabelStyle", ["../Core/Enumeration"], function (e) {
        "use strict";
        var t = {FILL: new e(0, "FILL"), OUTLINE: new e(1, "OUTLINE"), FILL_AND_OUTLINE: new e(2, "FILL_AND_OUTLINE")};
        return t
    }), n("DynamicScene/CzmlLabelStyle", ["../Core/defaultValue", "../Scene/LabelStyle"], function (e, t) {
        "use strict";
        var n = {unwrapInterval: function (t) {
            return e(t.labelStyle, t)
        }, isSampled: function () {
            return!1
        }, getValue: function (e) {
            return t[e]
        }};
        return n
    }), n("DynamicScene/DynamicLabel", ["../Core/TimeInterval", "../Core/defaultValue", "./CzmlBoolean", "./CzmlCartesian2", "./CzmlCartesian3", "./CzmlNumber", "./CzmlString", "./CzmlHorizontalOrigin", "./CzmlVerticalOrigin", "./CzmlLabelStyle", "./CzmlColor", "./DynamicProperty"], function (e, t, n, i, r, o, a, s, u, l, c, d) {
        "use strict";
        var f = function () {
            this.text = void 0, this.font = void 0, this.style = void 0, this.fillColor = void 0, this.outlineColor = void 0, this.outlineWidth = void 0, this.horizontalOrigin = void 0, this.verticalOrigin = void 0, this.eyeOffset = void 0, this.pixelOffset = void 0, this.scale = void 0, this.show = void 0
        };
        return f.processCzmlPacket = function (t, h) {
            var p = h.label;
            if ("undefined" == typeof p)return!1;
            var m = !1, y = t.label;
            m = "undefined" == typeof y, m && (t.label = y = new f);
            var v = p.interval;
            if ("undefined" != typeof v && (v = e.fromIso8601(v)), "undefined" != typeof p.fillColor) {
                var g = y.fillColor;
                "undefined" == typeof g && (y.fillColor = g = new d(c), m = !0), g.processCzmlIntervals(p.fillColor, v)
            }
            if ("undefined" != typeof p.outlineColor) {
                var _ = y.outlineColor;
                "undefined" == typeof _ && (y.outlineColor = _ = new d(c), m = !0), _.processCzmlIntervals(p.outlineColor, v)
            }
            if ("undefined" != typeof p.outlineWidth) {
                var w = y.outlineWidth;
                "undefined" == typeof w && (y.outlineWidth = w = new d(o), m = !0), w.processCzmlIntervals(p.outlineWidth, v)
            }
            if ("undefined" != typeof p.eyeOffset) {
                var C = y.eyeOffset;
                "undefined" == typeof C && (y.eyeOffset = C = new d(r), m = !0), C.processCzmlIntervals(p.eyeOffset, v)
            }
            if ("undefined" != typeof p.horizontalOrigin) {
                var x = y.horizontalOrigin;
                "undefined" == typeof x && (y.horizontalOrigin = x = new d(s), m = !0), x.processCzmlIntervals(p.horizontalOrigin, v)
            }
            if ("undefined" != typeof p.text) {
                var S = y.text;
                "undefined" == typeof S && (y.text = S = new d(a), m = !0), S.processCzmlIntervals(p.text, v)
            }
            if ("undefined" != typeof p.pixelOffset) {
                var b = y.pixelOffset;
                "undefined" == typeof b && (y.pixelOffset = b = new d(i), m = !0), b.processCzmlIntervals(p.pixelOffset, v)
            }
            if ("undefined" != typeof p.scale) {
                var T = y.scale;
                "undefined" == typeof T && (y.scale = T = new d(o), m = !0), T.processCzmlIntervals(p.scale, v)
            }
            if ("undefined" != typeof p.show) {
                var E = y.show;
                "undefined" == typeof E && (y.show = E = new d(n), m = !0), E.processCzmlIntervals(p.show, v)
            }
            if ("undefined" != typeof p.verticalOrigin) {
                var A = y.verticalOrigin;
                "undefined" == typeof A && (y.verticalOrigin = A = new d(u), m = !0), A.processCzmlIntervals(p.verticalOrigin, v)
            }
            if ("undefined" != typeof p.font) {
                var M = y.font;
                "undefined" == typeof M && (y.font = M = new d(a), m = !0), M.processCzmlIntervals(p.font, v)
            }
            if ("undefined" != typeof p.style) {
                var D = y.style;
                "undefined" == typeof D && (y.style = D = new d(l), m = !0), D.processCzmlIntervals(p.style, v)
            }
            return m
        }, f.mergeProperties = function (e, n) {
            var i = n.label;
            if ("undefined" != typeof i) {
                var r = e.label;
                "undefined" == typeof r && (e.label = r = new f), r.text = t(r.text, i.text), r.font = t(r.font, i.font), r.show = t(r.show, i.show), r.style = t(r.style, i.style), r.fillColor = t(r.fillColor, i.fillColor), r.outlineColor = t(r.outlineColor, i.outlineColor), r.outlineWidth = t(r.outlineWidth, i.outlineWidth), r.scale = t(r.scale, i.scale), r.horizontalOrigin = t(r.horizontalOrigin, i.horizontalOrigin), r.verticalOrigin = t(r.verticalOrigin, i.verticalOrigin), r.eyeOffset = t(r.eyeOffset, i.eyeOffset), r.pixelOffset = t(r.pixelOffset, i.pixelOffset)
            }
        }, f.undefineProperties = function (e) {
            e.label = void 0
        }, f
    }), n("DynamicScene/DynamicPath", ["../Core/TimeInterval", "../Core/defaultValue", "./CzmlBoolean", "./CzmlNumber", "./CzmlColor", "./DynamicProperty"], function (e, t, n, i, r, o) {
        "use strict";
        var a = function () {
            this.color = void 0, this.outlineColor = void 0, this.outlineWidth = void 0, this.show = void 0, this.width = void 0, this.resolution = void 0, this.leadTime = void 0, this.trailTime = void 0
        };
        return a.processCzmlPacket = function (t, s) {
            var u = s.path;
            if ("undefined" == typeof u)return!1;
            var l = !1, c = t.path;
            l = "undefined" == typeof c, l && (t.path = c = new a);
            var d = u.interval;
            if ("undefined" != typeof d && (d = e.fromIso8601(d)), "undefined" != typeof u.color) {
                var f = c.color;
                "undefined" == typeof f && (c.color = f = new o(r), l = !0), f.processCzmlIntervals(u.color, d)
            }
            if ("undefined" != typeof u.width) {
                var h = c.width;
                "undefined" == typeof h && (c.width = h = new o(i), l = !0), h.processCzmlIntervals(u.width, d)
            }
            if ("undefined" != typeof u.resolution) {
                var p = c.resolution;
                "undefined" == typeof p && (c.resolution = p = new o(i), l = !0), p.processCzmlIntervals(u.resolution, d)
            }
            if ("undefined" != typeof u.outlineColor) {
                var m = c.outlineColor;
                "undefined" == typeof m && (c.outlineColor = m = new o(r), l = !0), m.processCzmlIntervals(u.outlineColor, d)
            }
            if ("undefined" != typeof u.outlineWidth) {
                var y = c.outlineWidth;
                "undefined" == typeof y && (c.outlineWidth = y = new o(i), l = !0), y.processCzmlIntervals(u.outlineWidth, d)
            }
            if ("undefined" != typeof u.show) {
                var v = c.show;
                "undefined" == typeof v && (c.show = v = new o(n), l = !0), v.processCzmlIntervals(u.show, d)
            }
            if ("undefined" != typeof u.leadTime) {
                var g = c.leadTime;
                "undefined" == typeof g && (c.leadTime = g = new o(i), l = !0), g.processCzmlIntervals(u.leadTime, d)
            }
            if ("undefined" != typeof u.trailTime) {
                var _ = c.trailTime;
                "undefined" == typeof _ && (c.trailTime = _ = new o(i), l = !0), _.processCzmlIntervals(u.trailTime, d)
            }
            return l
        }, a.mergeProperties = function (e, n) {
            var i = n.path;
            if ("undefined" != typeof i) {
                var r = e.path;
                "undefined" == typeof r && (e.path = r = new a), r.color = t(r.color, i.color), r.width = t(r.width, i.width), r.resolution = t(r.resolution, i.resolution), r.outlineColor = t(r.outlineColor, i.outlineColor), r.outlineWidth = t(r.outlineWidth, i.outlineWidth), r.show = t(r.show, i.show), r.leadTime = t(r.leadTime, i.leadTime), r.trailTime = t(r.trailTime, i.trailTime)
            }
        }, a.undefineProperties = function (e) {
            e.path = void 0
        }, a
    }), n("DynamicScene/DynamicPoint", ["../Core/TimeInterval", "../Core/defaultValue", "./CzmlBoolean", "./CzmlNumber", "./CzmlColor", "./DynamicProperty"], function (e, t, n, i, r, o) {
        "use strict";
        var a = function () {
            this.color = void 0, this.pixelSize = void 0, this.outlineColor = void 0, this.outlineWidth = void 0, this.show = void 0
        };
        return a.processCzmlPacket = function (t, s) {
            var u = s.point;
            if ("undefined" == typeof u)return!1;
            var l = !1, c = t.point;
            l = "undefined" == typeof c, l && (t.point = c = new a);
            var d = u.interval;
            if ("undefined" != typeof d && (d = e.fromIso8601(d)), "undefined" != typeof u.color) {
                var f = c.color;
                "undefined" == typeof f && (c.color = f = new o(r), l = !0), f.processCzmlIntervals(u.color, d)
            }
            if ("undefined" != typeof u.pixelSize) {
                var h = c.pixelSize;
                "undefined" == typeof h && (c.pixelSize = h = new o(i), l = !0), h.processCzmlIntervals(u.pixelSize, d)
            }
            if ("undefined" != typeof u.outlineColor) {
                var p = c.outlineColor;
                "undefined" == typeof p && (c.outlineColor = p = new o(r), l = !0), p.processCzmlIntervals(u.outlineColor, d)
            }
            if ("undefined" != typeof u.outlineWidth) {
                var m = c.outlineWidth;
                "undefined" == typeof m && (c.outlineWidth = m = new o(i), l = !0), m.processCzmlIntervals(u.outlineWidth, d)
            }
            if ("undefined" != typeof u.show) {
                var y = c.show;
                "undefined" == typeof y && (c.show = y = new o(n), l = !0), y.processCzmlIntervals(u.show, d)
            }
            return l
        }, a.mergeProperties = function (e, n) {
            var i = n.point;
            if ("undefined" != typeof i) {
                var r = e.point;
                "undefined" == typeof r && (e.point = r = new a), r.color = t(r.color, i.color), r.pixelSize = t(r.pixelSize, i.pixelSize), r.outlineColor = t(r.outlineColor, i.outlineColor), r.outlineWidth = t(r.outlineWidth, i.outlineWidth), r.show = t(r.show, i.show)
            }
        }, a.undefineProperties = function (e) {
            e.point = void 0
        }, a
    }), n("DynamicScene/DynamicPolygon", ["../Core/TimeInterval", "../Core/defaultValue", "./CzmlBoolean", "./DynamicProperty", "./DynamicMaterialProperty"], function (e, t, n, i, r) {
        "use strict";
        var o = function () {
            this.show = void 0, this.material = void 0
        };
        return o.processCzmlPacket = function (t, a, s, u) {
            var l = a.polygon;
            if ("undefined" == typeof l)return!1;
            var c = !1, d = t.polygon;
            c = "undefined" == typeof d, c && (t.polygon = d = new o);
            var f = l.interval;
            if ("undefined" != typeof f && (f = e.fromIso8601(f)), "undefined" != typeof l.show) {
                var h = d.show;
                "undefined" == typeof h && (d.show = h = new i(n), c = !0), h.processCzmlIntervals(l.show, f)
            }
            if ("undefined" != typeof l.material) {
                var p = d.material;
                "undefined" == typeof p && (d.material = p = new r, c = !0), p.processCzmlIntervals(l.material, f, u)
            }
            return c
        }, o.mergeProperties = function (e, n) {
            var i = n.polygon;
            if ("undefined" != typeof i) {
                var r = e.polygon;
                "undefined" == typeof r && (e.polygon = r = new o), r.show = t(r.show, i.show), r.material = t(r.material, i.material)
            }
        }, o.undefineProperties = function (e) {
            e.polygon = void 0
        }, o
    }), n("DynamicScene/DynamicPolyline", ["../Core/TimeInterval", "../Core/defaultValue", "./CzmlBoolean", "./CzmlNumber", "./CzmlColor", "./DynamicProperty"], function (e, t, n, i, r, o) {
        "use strict";
        var a = function () {
            this.color = void 0, this.outlineColor = void 0, this.outlineWidth = void 0, this.show = void 0, this.width = void 0
        };
        return a.processCzmlPacket = function (t, s) {
            var u = s.polyline;
            if ("undefined" == typeof u)return!1;
            var l = !1, c = t.polyline;
            l = "undefined" == typeof c, l && (t.polyline = c = new a);
            var d = u.interval;
            if ("undefined" != typeof d && (d = e.fromIso8601(d)), "undefined" != typeof u.color) {
                var f = c.color;
                "undefined" == typeof f && (c.color = f = new o(r), l = !0), f.processCzmlIntervals(u.color, d)
            }
            if ("undefined" != typeof u.width) {
                var h = c.width;
                "undefined" == typeof h && (c.width = h = new o(i), l = !0), h.processCzmlIntervals(u.width, d)
            }
            if ("undefined" != typeof u.outlineColor) {
                var p = c.outlineColor;
                "undefined" == typeof p && (c.outlineColor = p = new o(r), l = !0), p.processCzmlIntervals(u.outlineColor, d)
            }
            if ("undefined" != typeof u.outlineWidth) {
                var m = c.outlineWidth;
                "undefined" == typeof m && (c.outlineWidth = m = new o(i), l = !0), m.processCzmlIntervals(u.outlineWidth, d)
            }
            if ("undefined" != typeof u.show) {
                var y = c.show;
                "undefined" == typeof y && (c.show = y = new o(n), l = !0), y.processCzmlIntervals(u.show, d)
            }
            return l
        }, a.mergeProperties = function (e, n) {
            var i = n.polyline;
            if ("undefined" != typeof i) {
                var r = e.polyline;
                "undefined" == typeof r && (e.polyline = r = new a), r.color = t(r.color, i.color), r.width = t(r.width, i.width), r.outlineColor = t(r.outlineColor, i.outlineColor), r.outlineWidth = t(r.outlineWidth, i.outlineWidth), r.show = t(r.show, i.show)
            }
        }, a.undefineProperties = function (e) {
            e.polyline = void 0
        }, a
    }), n("DynamicScene/DynamicDirectionsProperty", ["../Core/TimeInterval", "../Core/TimeIntervalCollection", "../Core/Cartesian3", "../Core/Spherical", "../Core/Iso8601"], function (e, t, n, i, r) {
        "use strict";
        function o(e) {
            var t, r, o = [], a = e.unitSpherical;
            if ("undefined" != typeof a) {
                for (t = 0, r = a.length; r > t; t += 2)o.push(new i(a[t], a[t + 1]));
                this.spherical = o
            }
            if (a = e.unitCartesian, "undefined" != typeof a) {
                for (t = 0, r = a.length; r > t; t += 3)o.push(new n(a[t], a[t + 1], a[t + 2], !0));
                this.cartesian = o
            }
        }

        function a(t, n, i) {
            var a = n.interval;
            a = "undefined" == typeof a ? r.MAXIMUM_INTERVAL.clone() : e.fromIso8601(a), "undefined" != typeof i && (a = a.intersect(i));
            var s = t._propertyIntervals, u = s.findInterval(a.start, a.stop);
            "undefined" == typeof u && (u = a, s.addInterval(u)), u.data = new o(n)
        }

        o.prototype.getValueSpherical = function () {
            var e = this.spherical;
            if ("undefined" == typeof e) {
                e = [], this.spherical = e;
                for (var t = this.cartesian, n = 0, r = t.length; r > n; n++)e.push(i.fromCartesian3(t[n]))
            }
            return e
        }, o.prototype.getValueCartesian = function () {
            var e = this.cartesian;
            if ("undefined" == typeof e) {
                e = [], this.cartesian = e;
                for (var t = this.spherical, i = 0, r = t.length; r > i; i++)e.push(n.fromSpherical(t[i]))
            }
            return e
        };
        var s = function () {
            this._propertyIntervals = new t
        };
        return s.prototype.processCzmlIntervals = function (e, t, n) {
            if (Array.isArray(e))for (var i = 0, r = e.length; r > i; i++)a(this, e[i], t, n); else a(this, e, t, n)
        }, s.prototype.getValueSpherical = function (e) {
            var t = this._propertyIntervals.findIntervalContainingDate(e);
            return"undefined" == typeof t ? void 0 : t.data.getValueSpherical()
        }, s.prototype.getValueCartesian = function (e) {
            var t = this._propertyIntervals.findIntervalContainingDate(e);
            return"undefined" == typeof t ? void 0 : t.data.getValueCartesian()
        }, s
    }), n("DynamicScene/DynamicPyramid", ["../Core/TimeInterval", "../Core/defaultValue", "./CzmlBoolean", "./CzmlNumber", "./CzmlColor", "./DynamicProperty", "./DynamicDirectionsProperty", "./DynamicMaterialProperty"], function (e, t, n, i, r, o, a, s) {
        "use strict";
        var u = function () {
            this.show = void 0, this.directions = void 0, this.radius = void 0, this.showIntersection = void 0, this.intersectionColor = void 0, this.intersectionWidth = void 0, this.material = void 0
        };
        return u.processCzmlPacket = function (t, l) {
            var c = l.pyramid;
            if ("undefined" == typeof c)return!1;
            var d = !1, f = t.pyramid;
            d = "undefined" == typeof f, d && (t.pyramid = f = new u);
            var h = c.interval;
            if ("undefined" != typeof h && (h = e.fromIso8601(h)), "undefined" != typeof c.show) {
                var p = f.show;
                "undefined" == typeof p && (f.show = p = new o(n), d = !0), p.processCzmlIntervals(c.show, h)
            }
            if ("undefined" != typeof c.radius) {
                var m = f.radius;
                "undefined" == typeof m && (f.radius = m = new o(i), d = !0), m.processCzmlIntervals(c.radius, h)
            }
            if ("undefined" != typeof c.showIntersection) {
                var y = f.showIntersection;
                "undefined" == typeof y && (f.showIntersection = y = new o(n), d = !0), y.processCzmlIntervals(c.showIntersection, h)
            }
            if ("undefined" != typeof c.intersectionColor) {
                var v = f.intersectionColor;
                "undefined" == typeof v && (f.intersectionColor = v = new o(r), d = !0), v.processCzmlIntervals(c.intersectionColor, h)
            }
            if ("undefined" != typeof c.intersectionWidth) {
                var g = f.intersectionWidth;
                "undefined" == typeof g && (f.intersectionWidth = g = new o(i), d = !0), g.processCzmlIntervals(c.intersectionWidth, h)
            }
            if ("undefined" != typeof c.material) {
                var _ = f.material;
                "undefined" == typeof _ && (f.material = _ = new s, d = !0), _.processCzmlIntervals(c.material, h)
            }
            if ("undefined" != typeof c.directions) {
                var w = f.directions;
                "undefined" == typeof w && (f.directions = w = new a, d = !0), w.processCzmlIntervals(c.directions, h)
            }
            return d
        }, u.mergeProperties = function (e, n) {
            var i = n.pyramid;
            if ("undefined" != typeof i) {
                var r = e.pyramid;
                "undefined" == typeof r && (e.pyramid = r = new u), r.show = t(r.show, i.show), r.directions = t(r.directions, i.directions), r.radius = t(r.radius, i.radius), r.showIntersection = t(r.showIntersection, i.showIntersection), r.intersectionColor = t(r.intersectionColor, i.intersectionColor), r.intersectionWidth = t(r.intersectionWidth, i.intersectionWidth), r.material = t(r.material, i.material)
            }
        }, u.undefineProperties = function (e) {
            e.pyramid = void 0
        }, u
    }), n("DynamicScene/CzmlDirection", ["../Core/Cartesian3", "../Core/Spherical", "../Core/Math", "../Core/Ellipsoid"], function (e, t) {
        "use strict";
        var n = 3, i = new e, r = new t, o = {doublesPerValue: n, doublesPerInterpolationValue: n, unwrapInterval: function (t) {
            var n = t.unitCartesian;
            if ("undefined" != typeof n)return n;
            var o = t.unitSpherical;
            if ("undefined" != typeof o) {
                var a = o.length;
                if (2 === a)r.clock = o[0], r.cone = o[1], e.fromSpherical(r, i), n = [i.x, i.y, i.z]; else {
                    var s = 0;
                    n = new Array(4 * (a / 3));
                    for (var u = 0; a > u; u += 4)n[u] = o[s++], r.clock = o[s++], r.cone = o[s++], e.fromSpherical(r, i), n[u + 1] = i.x, n[u + 2] = i.y, n[u + 3] = i.z
                }
            }
            return n
        }, isSampled: function (e) {
            return Array.isArray(e) && e.length > n
        }, getValue: function (t, n) {
            return"undefined" == typeof n && (n = new e), n.x = t[0], n.y = t[1], n.z = t[2], n
        }, getValueFromArray: function (t, n, i) {
            return"undefined" == typeof i && (i = new e), i.x = t[n], i.y = t[n + 1], i.z = t[n + 2], i
        }};
        return o
    }), n("DynamicScene/DynamicVector", ["../Core/TimeInterval", "../Core/defaultValue", "./CzmlBoolean", "./CzmlDirection", "./CzmlNumber", "./CzmlColor", "./DynamicProperty"], function (e, t, n, i, r, o, a) {
        "use strict";
        var s = function () {
            this.color = void 0, this.show = void 0, this.width = void 0, this.direction = void 0, this.length = void 0
        };
        return s.processCzmlPacket = function (t, u) {
            var l = u.vector;
            if ("undefined" == typeof l)return!1;
            var c = !1, d = t.vector;
            c = "undefined" == typeof d, c && (t.vector = d = new s);
            var f = l.interval;
            if ("undefined" != typeof f && (f = e.fromIso8601(f)), "undefined" != typeof l.color) {
                var h = d.color;
                "undefined" == typeof h && (d.color = h = new a(o), c = !0), h.processCzmlIntervals(l.color, f)
            }
            if ("undefined" != typeof l.width) {
                var p = d.width;
                "undefined" == typeof p && (d.width = p = new a(r), c = !0), p.processCzmlIntervals(l.width, f)
            }
            if ("undefined" != typeof l.direction) {
                var m = d.direction;
                "undefined" == typeof m && (d.direction = m = new a(i), c = !0), m.processCzmlIntervals(l.direction, f)
            }
            if ("undefined" != typeof l.length) {
                var y = d.length;
                "undefined" == typeof y && (d.length = y = new a(r), c = !0), y.processCzmlIntervals(l.length, f)
            }
            if ("undefined" != typeof l.show) {
                var v = d.show;
                "undefined" == typeof v && (d.show = v = new a(n), c = !0), v.processCzmlIntervals(l.show, f)
            }
            return c
        }, s.mergeProperties = function (e, n) {
            var i = n.vector;
            if ("undefined" != typeof i) {
                var r = e.vector;
                "undefined" == typeof r && (e.vector = r = new s), r.color = t(r.color, i.color), r.width = t(r.width, i.width), r.direction = t(r.direction, i.direction), r.length = t(r.length, i.length), r.show = t(r.show, i.show)
            }
        }, s.undefineProperties = function (e) {
            e.vector = void 0
        }, s
    }), n("Renderer/BlendEquation", ["../Core/Enumeration"], function (e) {
        "use strict";
        var t = {ADD: new e(32774, "ADD"), SUBTRACT: new e(32778, "SUBTRACT"), REVERSE_SUBTRACT: new e(32779, "REVERSE_SUBTRACT"), validate: function (e) {
            return e === t.ADD || e === t.SUBTRACT || e === t.REVERSE_SUBTRACT
        }};
        return t
    }), n("Renderer/BlendFunction", ["../Core/Enumeration"], function (e) {
        "use strict";
        var t = {ZERO: new e(0, "ZERO"), ONE: new e(1, "ONE"), SOURCE_COLOR: new e(768, "SOURCE_COLOR"), ONE_MINUS_SOURCE_COLOR: new e(769, "ONE_MINUS_SOURCE_COLOR"), DESTINATION_COLOR: new e(774, "DESTINATION_COLOR"), ONE_MINUS_DESTINATION_COLOR: new e(775, "ONE_MINUS_DESTINATION_COLOR"), SOURCE_ALPHA: new e(770, "SOURCE_ALPHA"), ONE_MINUS_SOURCE_ALPHA: new e(771, "ONE_MINUS_SOURCE_ALPHA"), DESTINATION_ALPHA: new e(772, "DESTINATION_ALPHA"), ONE_MINUS_DESTINATION_ALPHA: new e(773, "ONE_MINUS_DESTINATION_ALPHA"), CONSTANT_COLOR: new e(32769, "CONSTANT_COLOR"), ONE_MINUS_CONSTANT_COLOR: new e(32770, "ONE_MINUS_CONSTANT_COLOR"), CONSTANT_ALPHA: new e(32771, "CONSTANT_ALPHA"), ONE_MINUS_CONSTANT_ALPHA: new e(32772, "ONE_MINUS_CONSTANT_ALPHA"), SOURCE_ALPHA_SATURATE: new e(776, "SOURCE_ALPHA_SATURATE"), validate: function (e) {
            return e === t.ZERO || e === t.ONE || e === t.SOURCE_COLOR || e === t.ONE_MINUS_SOURCE_COLOR || e === t.DESTINATION_COLOR || e === t.ONE_MINUS_DESTINATION_COLOR || e === t.SOURCE_ALPHA || e === t.ONE_MINUS_SOURCE_ALPHA || e === t.DESTINATION_ALPHA || e === t.ONE_MINUS_DESTINATION_ALPHA || e === t.CONSTANT_COLOR || e === t.ONE_MINUS_CONSTANT_COLOR || e === t.CONSTANT_ALPHA || e === t.ONE_MINUS_CONSTANT_ALPHA || e === t.SOURCE_ALPHA_SATURATE
        }};
        return t
    }), n("Renderer/BlendingState", ["./BlendEquation", "./BlendFunction"], function (e, t) {
        "use strict";
        var n = {DISABLED: {enabled: !1}, ALPHA_BLEND: {enabled: !0, equationRgb: e.ADD, equationAlpha: e.ADD, functionSourceRgb: t.SOURCE_ALPHA, functionSourceAlpha: t.SOURCE_ALPHA, functionDestinationRgb: t.ONE_MINUS_SOURCE_ALPHA, functionDestinationAlpha: t.ONE_MINUS_SOURCE_ALPHA}, PRE_MULTIPLIED_ALPHA_BLEND: {enabled: !0, equationRgb: e.ADD, equationAlpha: e.ADD, functionSourceRgb: t.ONE, functionSourceAlpha: t.ONE, functionDestinationRgb: t.ONE_MINUS_SOURCE_ALPHA, functionDestinationAlpha: t.ONE_MINUS_SOURCE_ALPHA}, ADDITIVE_BLEND: {enabled: !0, equationRgb: e.ADD, equationAlpha: e.ADD, functionSourceRgb: t.SOURCE_ALPHA, functionSourceAlpha: t.SOURCE_ALPHA, functionDestinationRgb: t.ONE, functionDestinationAlpha: t.ONE}};
        return n
    }), n("Renderer/BufferUsage", ["../Core/Enumeration"], function (e) {
        "use strict";
        var t = {STREAM_DRAW: new e(35040, "STREAM_DRAW"), STATIC_DRAW: new e(35044, "STATIC_DRAW"), DYNAMIC_DRAW: new e(35048, "DYNAMIC_DRAW"), validate: function (e) {
            return e === t.STREAM_DRAW || e === t.STATIC_DRAW || e === t.DYNAMIC_DRAW
        }};
        return t
    }), n("Renderer/CommandLists", [], function () {
        "use strict";
        var e = function () {
            this.colorList = [], this.pickList = [], this.overlayList = []
        };
        return e.prototype.empty = function () {
            return 0 === this.colorList.length && 0 === this.pickList.length && 0 === this.overlayList.length
        }, e.prototype.removeAll = function () {
            this.colorList.length = 0, this.pickList.length = 0, this.overlayList.length = 0
        }, e
    }), n("Renderer/DrawCommand", [], function () {
        "use strict";
        var e = function () {
            this.boundingVolume = void 0, this.cull = !0, this.modelMatrix = void 0, this.primitiveType = void 0, this.vertexArray = void 0, this.count = void 0, this.offset = void 0, this.shaderProgram = void 0, this.uniformMap = void 0, this.renderState = void 0, this.framebuffer = void 0, this.executeInClosestFrustum = !1, this.owner = void 0, this.debugShowBoundingVolume = !1
        };
        return e.prototype.execute = function (e, t) {
            e.draw(this, t)
        }, e
    }), n("Renderer/VertexArrayFacade", ["../Core/ComponentDatatype", "../Core/defaultValue", "../Core/destroyObject", "../Core/DeveloperError", "../Core/Math", "./BufferUsage"], function (e, t, n, i, r, o) {
        "use strict";
        function a(e, t) {
            if (t.needsCommit && t.vertexSizeInBytes > 0) {
                t.needsCommit = !1;
                var n = t.vertexBuffer, i = e._size * t.vertexSizeInBytes, r = "undefined" != typeof n;
                if (!r || n.getSizeInBytes() < i)return r && n.destroy(), t.vertexBuffer = e._context.createVertexBuffer(t.arrayBuffer, t.usage), t.vertexBuffer.setVertexArrayDestroyable(!1), !0;
                t.vertexBuffer.copyFromArrayView(t.arrayBuffer)
            }
            return!1
        }

        function s(e, t, n) {
            if (e.needsCommit && e.vertexSizeInBytes > 0) {
                var i = e.vertexSizeInBytes * t, r = e.vertexSizeInBytes * n;
                e.vertexBuffer.copyFromArrayView(new Uint8Array(e.arrayBuffer, i, r), i)
            }
        }

        function u(e) {
            var t = e.vaByPurpose;
            if ("undefined" != typeof t) {
                for (var n in t)if (t.hasOwnProperty(n))for (var i = t[n], r = i.length, o = 0; r > o; ++o)i[o].va.destroy();
                e.vaByPurpose = void 0
            }
        }

        var l = function (e, t, n) {
            function r(e, t) {
                return t.componentDatatype.sizeInBytes - e.componentDatatype.sizeInBytes
            }

            if (!e)throw new i("context is required.");
            if (!t || 0 === t.length)throw new i("At least one attribute is required.");
            var a = l._verifyAttributes(t);
            n = n || 0;
            for (var s, u, c, d, f = {}, h = [], p = a.length, m = 0; p > m; ++m) {
                var y = a[m];
                y.vertexBuffer ? h.push(y) : (c = y.purpose, s = f[c], "undefined" == typeof s && (s = f[c] = {}), d = y.usage.toString(), u = s[d], "undefined" == typeof u && (u = s[d] = []), u.push(y))
            }
            this._buffersByPurposeAndUsage = {}, this._allBuffers = [];
            for (c in f)if (f.hasOwnProperty(c)) {
                s = f[c];
                var v = this._buffersByPurposeAndUsage[c];
                "undefined" == typeof v && (v = this._buffersByPurposeAndUsage[c] = {});
                for (d in s)if (s.hasOwnProperty(d)) {
                    u = s[d], u.sort(r);
                    var g, _ = l._vertexSizeInBytes(u);
                    switch (d) {
                        case o.STATIC_DRAW.toString():
                            g = o.STATIC_DRAW;
                            break;
                        case o.STREAM_DRAW.toString():
                            g = o.STREAM_DRAW;
                            break;
                        case o.DYNAMIC_DRAW.toString():
                            g = o.DYNAMIC_DRAW
                    }
                    var w = {purpose: c, vertexSizeInBytes: _, vertexBuffer: void 0, usage: g, needsCommit: !1, arrayBuffer: void 0, arrayViews: l._createArrayViews(u, _)};
                    v[d] = w, this._allBuffers.push(w)
                }
            }
            this._size = 0, this._precreated = h, this._context = e, this.writers = void 0, this.vaByPurpose = void 0, this.resize(n)
        };
        l._verifyAttributes = function (n) {
            for (var r = [], a = 0; a < n.length; ++a) {
                var s = n[a], u = {index: t(s.index, a), enabled: t(s.enabled, !0), componentsPerAttribute: s.componentsPerAttribute, componentDatatype: s.componentDatatype || e.FLOAT, normalize: s.normalize || !1, purpose: t(s.purpose, "all"), vertexBuffer: s.vertexBuffer, usage: s.usage || o.STATIC_DRAW};
                if (r.push(u), 1 !== u.componentsPerAttribute && 2 !== u.componentsPerAttribute && 3 !== u.componentsPerAttribute && 4 !== u.componentsPerAttribute)throw new i("attribute.componentsPerAttribute must be in the range [1, 4].");
                var l = u.componentDatatype;
                if (!e.validate(l))throw new i("Attribute must have a valid componentDatatype or not specify it.");
                if (!o.validate(u.usage))throw new i("Attribute must have a valid usage or not specify it.")
            }
            for (var c = new Array(r.length), d = 0; d < r.length; ++d) {
                var f = r[d], h = f.index, p = f.purpose;
                if ("all" !== p) {
                    var m = c[h];
                    if (m === !0)throw new i("Index " + h + " is used by more than one attribute.");
                    if ("undefined" != typeof m) {
                        if (m[p])throw new i("Index " + h + " is used by more than one attribute with the same purpose.")
                    } else m = c[h] = {};
                    m[p] = !0
                } else {
                    if (c[h])throw new i("Index " + h + " is used by more than one attribute.");
                    c[h] = !0
                }
            }
            return r
        }, l._vertexSizeInBytes = function (e) {
            for (var t = 0, n = e.length, i = 0; n > i; ++i) {
                var r = e[i];
                t += r.componentsPerAttribute * r.componentDatatype.sizeInBytes
            }
            var o = n > 0 ? e[0].componentDatatype.sizeInBytes : 0, a = o > 0 ? t % o : 0, s = 0 === a ? 0 : o - a;
            return t += s
        }, l._createArrayViews = function (e, t) {
            for (var n = [], i = 0, r = e.length, o = 0; r > o; ++o) {
                var a = e[o], s = a.componentDatatype;
                n.push({index: a.index, enabled: a.enabled, componentsPerAttribute: a.componentsPerAttribute, componentDatatype: s, normalize: a.normalize, offsetInBytes: i, vertexSizeInComponentType: t / s.sizeInBytes, view: void 0}), i += a.componentsPerAttribute * s.sizeInBytes
            }
            return n
        }, l.prototype.resize = function (e) {
            this._size = e;
            var t = this._allBuffers;
            this.writers = {};
            for (var n = 0, i = t.length; i > n; ++n) {
                var r = t[n];
                l._resize(r, this._size);
                var o = this.writers[r.purpose];
                "undefined" == typeof o && (o = this.writers[r.purpose] = []), l._appendWriters(o, r)
            }
            u(this)
        }, l._resize = function (e, t) {
            if (e.vertexSizeInBytes > 0) {
                var n = new ArrayBuffer(t * e.vertexSizeInBytes);
                if (e.arrayBuffer)for (var i = new Uint8Array(n), r = new Uint8Array(e.arrayBuffer), o = r.length, a = 0; o > a; ++a)i[a] = r[a];
                for (var s = e.arrayViews, u = s.length, l = 0; u > l; ++l) {
                    var c = s[l];
                    c.view = c.componentDatatype.createArrayBufferView(n, c.offsetInBytes)
                }
                e.arrayBuffer = n
            }
        };
        var c = [function (e, t, n) {
            return function (i, r) {
                t[i * n] = r, e.needsCommit = !0
            }
        }, function (e, t, n) {
            return function (i, r, o) {
                var a = i * n;
                t[a] = r, t[a + 1] = o, e.needsCommit = !0
            }
        }, function (e, t, n) {
            return function (i, r, o, a) {
                var s = i * n;
                t[s] = r, t[s + 1] = o, t[s + 2] = a, e.needsCommit = !0
            }
        }, function (e, t, n) {
            return function (i, r, o, a, s) {
                var u = i * n;
                t[u] = r, t[u + 1] = o, t[u + 2] = a, t[u + 3] = s, e.needsCommit = !0
            }
        }];
        return l._appendWriters = function (e, t) {
            for (var n = t.arrayViews, i = n.length, r = 0; i > r; ++r) {
                var o = n[r];
                e[o.index] = c[o.componentsPerAttribute - 1](t, o.view, o.vertexSizeInComponentType)
            }
        }, l.prototype.commit = function (e) {
            for (var t, n = !1, i = this._allBuffers, o = 0, s = i.length; s > o; ++o)t = i[o], n = a(this, t) || n;
            if (n || "undefined" == typeof this.vaByPurpose) {
                var c = this._buffersByPurposeAndUsage;
                u(this), this.vaByPurpose = {};
                for (var d in c)if (c.hasOwnProperty(d)) {
                    for (var f = c[d], h = [], p = Math.ceil(this._size / r.SIXTY_FOUR_KILOBYTES), m = 0; p > m; ++m) {
                        var y = [], v = c.all;
                        if (v !== f)for (var g in v)if (v.hasOwnProperty(g)) {
                            var _ = v[g];
                            l._appendAttributes(y, _, m * _.vertexSizeInBytes * r.SIXTY_FOUR_KILOBYTES)
                        }
                        for (var w in f)f.hasOwnProperty(w) && (t = f[w], l._appendAttributes(y, t, m * t.vertexSizeInBytes * r.SIXTY_FOUR_KILOBYTES));
                        y = y.concat(this._precreated), h.push({va: this._context.createVertexArray(y, e), indicesCount: 1.5 * (m !== p - 1 ? r.SIXTY_FOUR_KILOBYTES : this._size % r.SIXTY_FOUR_KILOBYTES)})
                    }
                    this.vaByPurpose[d] = h
                }
            }
        }, l._appendAttributes = function (e, t, n) {
            for (var i = t.arrayViews, r = i.length, o = 0; r > o; ++o) {
                var a = i[o];
                e.push({index: a.index, enabled: a.enabled, componentsPerAttribute: a.componentsPerAttribute, componentDatatype: a.componentDatatype, normalize: a.normalize, vertexBuffer: t.vertexBuffer, offsetInBytes: n + a.offsetInBytes, strideInBytes: t.vertexSizeInBytes})
            }
        }, l.prototype.subCommit = function (e, t) {
            if (0 > e || e >= this._size)throw new i("offsetInVertices must be greater than or equal to zero and less than the vertex array size.");
            if (e + t > this._size)throw new i("offsetInVertices + lengthInVertices cannot exceed the vertex array size.");
            for (var n = this._allBuffers, r = 0, o = n.length; o > r; ++r)s(n[r], e, t)
        }, l.prototype.endSubCommits = function () {
            for (var e = this._allBuffers, t = 0, n = e.length; n > t; ++t)e[t].needsCommit = !1
        }, l.prototype.isDestroyed = function () {
            return!1
        }, l.prototype.destroy = function () {
            for (var e = this._allBuffers, t = 0, i = e.length; i > t; ++t) {
                var r = e[t];
                r.vertexBuffer = r.vertexBuffer && r.vertexBuffer.destroy()
            }
            return u(this), n(this)
        }, l
    }), n("Scene/SceneMode", ["../Core/Enumeration"], function (e) {
        "use strict";
        var t = {SCENE2D: new e(0, "SCENE2D", {morphTime: 0}), COLUMBUS_VIEW: new e(1, "COLUMBUS_VIEW", {morphTime: 0}), SCENE3D: new e(2, "SCENE3D", {morphTime: 1}), MORPHING: new e(3, "MORPHING")};
        return t
    }), n("Scene/SceneTransforms", ["../Core/defaultValue", "../Core/DeveloperError", "../Core/Cartographic", "../Core/Cartesian2", "../Core/Cartesian3", "../Core/Cartesian4", "../Core/Matrix4", "../Core/BoundingRectangle", "../Core/Math", "./SceneMode"], function (e, t, n, i, r, o, a, s, u, l) {
        "use strict";
        var c = {}, d = new r, f = new o;
        c.wgs84ToWindowCoordinates = function (e, n, i) {
            if ("undefined" == typeof e)throw new t("scene is required.");
            if ("undefined" == typeof n)throw new t("position is required.");
            if (c.computeActualWgs84Position(e.getFrameState(), n, d), "undefined" == typeof d)return i = void 0, void 0;
            var r = e.getUniformState().getViewProjection();
            return r.multiplyByPoint(d, f), c.clipToWindowCoordinates(e.getCanvas(), f, i)
        };
        var h = new r, p = new n;
        c.computeActualWgs84Position = function (e, t, n) {
            var i = e.mode;
            if (i === l.SCENE3D)return r.clone(t, n);
            var o = e.scene2D.projection;
            if (o.getEllipsoid().cartesianToCartographic(t, p), "undefined" == typeof p)return n = void 0;
            if (o.project(p, h), i === l.COLUMBUS_VIEW)return r.fromElements(h.z, h.x, h.y, n);
            if (i === l.SCENE2D)return r.fromElements(0, h.x, h.y, n);
            var a = e.morphTime;
            return r.fromElements(u.lerp(h.z, t.x, a), u.lerp(h.x, t.y, a), u.lerp(h.y, t.z, a), n)
        };
        var m = new r, y = new o, v = new s, g = new a;
        return c.clipToWindowCoordinates = function (e, t, n) {
            return m.x = t.x / t.w, m.y = t.y / t.w, m.z = t.z / t.w, v.width = e.clientWidth, v.height = e.clientHeight, a.computeViewportTransformation(v, 0, 1, g), g.multiplyByPoint(m, y), i.fromCartesian4(y, n)
        }, c
    }), n("Scene/Billboard", ["../Core/defaultValue", "../Core/DeveloperError", "../Core/Color", "../Core/Cartesian2", "../Core/Cartesian3", "../Core/Cartesian4", "./HorizontalOrigin", "./VerticalOrigin", "./SceneMode", "./SceneTransforms"], function (e, t, n, i, r, o, a, s, u, l) {
        "use strict";
        function c(e, t) {
            var n = e._billboardCollection;
            "undefined" != typeof n && (n._updateBillboard(e, t), e._dirty = !0)
        }

        var d = {}, f = function (t, o) {
            t = e(t, d), this._show = e(t.show, !0), this._position = r.clone(e(t.position, r.ZERO)), this._actualPosition = this._position.clone(), this._pixelOffset = i.clone(e(t.pixelOffset, i.ZERO)), this._eyeOffset = r.clone(e(t.eyeOffset, r.ZERO)), this._verticalOrigin = e(t.verticalOrigin, s.CENTER), this._horizontalOrigin = e(t.horizontalOrigin, a.CENTER), this._scale = e(t.scale, 1), this._imageIndex = e(t.imageIndex, -1), this._color = n.clone(e(t.color, n.WHITE)), this._rotation = e(t.rotation, 0), this._alignedAxis = r.clone(e(t.alignedAxis, r.ZERO)), this._width = t.width, this._height = t.height, this._pickId = void 0, this._pickIdThis = t._pickIdThis, this._billboardCollection = o, this._dirty = !1, this._index = -1
        }, h = f.SHOW_INDEX = 0, p = f.POSITION_INDEX = 1, m = f.PIXEL_OFFSET_INDEX = 2, y = f.EYE_OFFSET_INDEX = 3, v = f.HORIZONTAL_ORIGIN_INDEX = 4, g = f.VERTICAL_ORIGIN_INDEX = 5, _ = f.SCALE_INDEX = 6, w = f.IMAGE_INDEX_INDEX = 7, C = f.COLOR_INDEX = 8, x = f.ROTATION_INDEX = 9, S = f.ALIGNED_AXIS_INDEX = 10;
        f.NUMBER_OF_PROPERTIES = 11, f.prototype.getPickId = function (t) {
            return"undefined" == typeof this._pickId && (this._pickId = t.createPickId(e(this._pickIdThis, this))), this._pickId
        }, f.prototype.getShow = function () {
            return this._show
        }, f.prototype.setShow = function (e) {
            if ("undefined" == typeof e)throw new t("value is required.");
            e !== this._show && (this._show = e, c(this, h))
        }, f.prototype.getPosition = function () {
            return this._position
        }, f.prototype.setPosition = function (e) {
            if ("undefined" == typeof e)throw new t("value is required.");
            var n = this._position;
            r.equals(n, e) || (r.clone(e, n), r.clone(e, this._actualPosition), c(this, p))
        }, f.prototype._getActualPosition = function () {
            return this._actualPosition
        }, f.prototype._setActualPosition = function (e) {
            r.clone(e, this._actualPosition), c(this, p)
        }, f.prototype.getPixelOffset = function () {
            return this._pixelOffset
        }, f.prototype.setPixelOffset = function (e) {
            if ("undefined" == typeof e)throw new t("value is required.");
            var n = this._pixelOffset;
            i.equals(n, e) || (i.clone(e, n), c(this, m))
        }, f.prototype.getEyeOffset = function () {
            return this._eyeOffset
        }, f.prototype.setEyeOffset = function (e) {
            if ("undefined" == typeof e)throw new t("value is required.");
            var n = this._eyeOffset;
            r.equals(n, e) || (r.clone(e, n), c(this, y))
        }, f.prototype.getHorizontalOrigin = function () {
            return this._horizontalOrigin
        }, f.prototype.setHorizontalOrigin = function (e) {
            if ("undefined" == typeof e)throw new t("value is required.");
            this._horizontalOrigin !== e && (this._horizontalOrigin = e, c(this, v))
        }, f.prototype.getVerticalOrigin = function () {
            return this._verticalOrigin
        }, f.prototype.setVerticalOrigin = function (e) {
            if ("undefined" == typeof e)throw new t("value is required.");
            this._verticalOrigin !== e && (this._verticalOrigin = e, c(this, g))
        }, f.prototype.getScale = function () {
            return this._scale
        }, f.prototype.setScale = function (e) {
            if ("undefined" == typeof e)throw new t("value is required.");
            this._scale !== e && (this._scale = e, c(this, _))
        }, f.prototype.getImageIndex = function () {
            return this._imageIndex
        }, f.prototype.setImageIndex = function (e) {
            if ("number" != typeof e)throw new t("value is required and must be a number.");
            this._imageIndex !== e && (this._imageIndex = e, c(this, w))
        }, f.prototype.getColor = function () {
            return this._color
        }, f.prototype.setColor = function (e) {
            if ("undefined" == typeof e)throw new t("value is required.");
            var i = this._color;
            n.equals(i, e) || (n.clone(e, i), c(this, C))
        }, f.prototype.getRotation = function () {
            return this._rotation
        }, f.prototype.setRotation = function (e) {
            if ("undefined" == typeof e)throw new t("value is required.");
            this._rotation !== e && (this._rotation = e, c(this, x))
        }, f.prototype.getAlignedAxis = function () {
            return this._alignedAxis
        }, f.prototype.setAlignedAxis = function (e) {
            if ("undefined" == typeof e)throw new t("value is required.");
            var n = this._alignedAxis;
            r.equals(n, e) || (r.clone(e, n), c(this, S))
        }, f.prototype.getWidth = function () {
            return this._width
        }, f.prototype.setWidth = function (e) {
            this._width !== e && (this._width = e, c(this, w))
        }, f.prototype.getHeight = function () {
            return this._height
        }, f.prototype.setHeight = function (e) {
            this._height !== e && (this._height = e, c(this, w))
        };
        var b = new o;
        return f._computeActualPosition = function (e, t, n) {
            return t.mode === u.SCENE3D ? e : (n.multiplyByPoint(e, b), l.computeActualWgs84Position(t, b))
        }, f._computeScreenSpacePosition = function (e, t, n, r, o, a) {
            var s = a.camera, u = s.getViewMatrix(), c = s.frustum.getProjectionMatrix(), d = u.multiply(e), f = d.multiplyByPoint(t), h = n.multiplyComponents(f.normalize());
            f.x += n.x + h.x, f.y += n.y + h.y, f.z += h.z;
            var p = c.multiplyByVector(f), m = l.clipToWindowCoordinates(o.getCanvas(), p), y = o.getUniformState(), v = r.multiplyByScalar(y.getHighResolutionSnapScale());
            return m.x += v.x, m.y += v.y, new i(m.x, m.y)
        }, f.prototype.computeScreenSpacePosition = function (e, n) {
            var i = this._billboardCollection;
            if ("undefined" == typeof i)throw new t("Billboard must be in a collection.  Was it removed?");
            if ("undefined" == typeof e)throw new t("context is required.");
            if ("undefined" == typeof n)throw new t("frameState is required.");
            var r = i.modelMatrix;
            return f._computeScreenSpacePosition(r, this._actualPosition, this._eyeOffset, this._pixelOffset, e, n)
        }, f.prototype.equals = function (e) {
            return this === e || "undefined" != typeof e && this._show === e._show && this._imageIndex === e._imageIndex && this._scale === e._scale && this._verticalOrigin === e._verticalOrigin && this._horizontalOrigin === e._horizontalOrigin && r.equals(this._position, e._position) && n.equals(this._color, e._color) && i.equals(this._pixelOffset, e._pixelOffset) && r.equals(this._eyeOffset, e._eyeOffset)
        }, f.prototype._destroy = function () {
            this._pickId = this._pickId && this._pickId.destroy(), this._billboardCollection = void 0
        }, f
    }), n("Shaders/BillboardCollectionVS", [], function () {
        "use strict";
        return"attribute vec3 positionHigh;\nattribute vec3 positionLow;\nattribute vec2 direction;\nattribute vec4 textureCoordinatesAndImageSize;\nattribute vec3 originAndShow;\nattribute vec2 pixelOffset;\nattribute vec4 eyeOffsetAndScale;\nattribute vec4 rotationAndAlignedAxis;\n#ifdef RENDER_FOR_PICK\nattribute vec4 pickColor;\n#else\nattribute vec4 color;\n#endif\nconst vec2 czm_highResolutionSnapScale = vec2(1.0, 1.0);\nvarying vec2 v_textureCoordinates;\n#ifdef RENDER_FOR_PICK\nvarying vec4 v_pickColor;\n#else\nvarying vec4 v_color;\n#endif\nvoid main()\n{\nvec3 eyeOffset = eyeOffsetAndScale.xyz;\nfloat scale = eyeOffsetAndScale.w;\nvec2 textureCoordinates = textureCoordinatesAndImageSize.xy;\nvec2 imageSize = textureCoordinatesAndImageSize.zw;\nvec2 origin = originAndShow.xy;\nfloat show = originAndShow.z;\nvec4 p = czm_translateRelativeToEye(positionHigh, positionLow);\nvec4 positionEC = czm_modelViewRelativeToEye * p;\npositionEC = czm_eyeOffset(positionEC, eyeOffset);\npositionEC.xyz *= show;\nvec4 positionWC = czm_eyeToWindowCoordinates(positionEC);\nvec2 halfSize = imageSize * scale * czm_highResolutionSnapScale;\nhalfSize *= ((direction * 2.0) - 1.0);\npositionWC.xy += (origin * abs(halfSize));\n#ifdef ROTATION\nfloat rotation = rotationAndAlignedAxis.x;\nvec3 alignedAxis = rotationAndAlignedAxis.yzw;\nif (!all(equal(rotationAndAlignedAxis, vec4(0.0))))\n{\nfloat angle = rotation;\nif (!all(equal(alignedAxis, vec3(0.0))))\n{\nvec3 pos = positionEC.xyz + czm_encodedCameraPositionMCHigh + czm_encodedCameraPositionMCLow;\nvec3 normal = normalize(cross(alignedAxis, pos));\nvec4 tangent = vec4(normalize(cross(pos, normal)), 0.0);\ntangent = czm_modelViewProjection * tangent;\nangle += sign(-tangent.x) * acos(tangent.y / length(tangent.xy));\n}\nfloat cosTheta = cos(angle);\nfloat sinTheta = sin(angle);\nmat2 rotationMatrix = mat2(cosTheta, sinTheta, -sinTheta, cosTheta);\nhalfSize = rotationMatrix * halfSize;\n}\n#endif\npositionWC.xy += halfSize;\npositionWC.xy += (pixelOffset * czm_highResolutionSnapScale);\ngl_Position = czm_viewportOrthographic * vec4(positionWC.xy, -positionWC.z, 1.0);\nv_textureCoordinates = textureCoordinates;\n#ifdef RENDER_FOR_PICK\nv_pickColor = pickColor;\n#else\nv_color = color;\n#endif\n}\n"
    }), n("Shaders/BillboardCollectionFS", [], function () {
        "use strict";
        return"uniform sampler2D u_atlas;\nvarying vec2 v_textureCoordinates;\n#ifdef RENDER_FOR_PICK\nvarying vec4 v_pickColor;\n#else\nvarying vec4 v_color;\n#endif\nvoid main()\n{\n#ifdef RENDER_FOR_PICK\nvec4 vertexColor = vec4(1.0, 1.0, 1.0, 1.0);\n#else\nvec4 vertexColor = v_color;\n#endif\nvec4 color = texture2D(u_atlas, v_textureCoordinates) * vertexColor;\nif (color.a == 0.0)\n{\ndiscard;\n}\n#ifdef RENDER_FOR_PICK\ngl_FragColor = v_pickColor;\n#else\ngl_FragColor = color;\n#endif\n}\n"
    }), n("Scene/BillboardCollection", ["../Core/DeveloperError", "../Core/Color", "../Core/defaultValue", "../Core/destroyObject", "../Core/Cartesian2", "../Core/Cartesian3", "../Core/EncodedCartesian3", "../Core/Matrix4", "../Core/ComponentDatatype", "../Core/IndexDatatype", "../Core/PrimitiveType", "../Core/BoundingSphere", "../Renderer/BlendingState", "../Renderer/BufferUsage", "../Renderer/CommandLists", "../Renderer/DrawCommand", "../Renderer/VertexArrayFacade", "./SceneMode", "./Billboard", "./HorizontalOrigin", "../Shaders/BillboardCollectionVS", "../Shaders/BillboardCollectionFS"], function (e, t, n, i, r, o, a, s, u, l, c, d, f, h, p, m, y, v, g, _, w, C) {
        "use strict";
        function x(e) {
            if (e._billboardsRemoved) {
                e._billboardsRemoved = !1;
                for (var t = [], n = e._billboards, i = n.length, r = 0, o = 0; i > r; ++r) {
                    var a = n[r];
                    a && (a._index = o++, t.push(a))
                }
                e._billboards = t
            }
        }

        function S(e) {
            var t = 16384, n = e.cache.billboardCollection_directionsVertexBuffer;
            if ("undefined" != typeof n)return n;
            for (var i = new Uint8Array(2 * 4 * t), r = 0, o = 0; t > r; ++r)i[o++] = 0, i[o++] = 0, i[o++] = 255, i[o++] = 0, i[o++] = 255, i[o++] = 255, i[o++] = 0, i[o++] = 255;
            return n = e.createVertexBuffer(i, h.STATIC_DRAW), n.setVertexArrayDestroyable(!1), e.cache.billboardCollection_directionsVertexBuffer = n, n
        }

        function b(e) {
            var t = 16384, n = e.cache.billboardCollection_indexBuffer;
            if ("undefined" != typeof n)return n;
            for (var i = 6 * t, r = new Uint16Array(i), o = 0, a = 0; i > o; o += 6, a += 4)r[o + 0] = a + 0, r[o + 1] = a + 1, r[o + 2] = a + 2, r[o + 3] = a + 0, r[o + 4] = a + 2, r[o + 5] = a + 3;
            return n = e.createIndexBuffer(r, h.STATIC_DRAW, l.UNSIGNED_SHORT), n.setVertexArrayDestroyable(!1), e.cache.billboardCollection_indexBuffer = n, n
        }

        function T(e, t, n) {
            var i = S(e);
            return new y(e, [
                {index: K.positionHigh, componentsPerAttribute: 3, componentDatatype: u.FLOAT, usage: n[B]},
                {index: K.positionLow, componentsPerAttribute: 3, componentDatatype: u.FLOAT, usage: n[B]},
                {index: K.pixelOffset, componentsPerAttribute: 2, componentDatatype: u.FLOAT, usage: n[k]},
                {index: K.eyeOffsetAndScale, componentsPerAttribute: 4, componentDatatype: u.FLOAT, usage: n[H]},
                {index: K.textureCoordinatesAndImageSize, componentsPerAttribute: 4, componentDatatype: u.FLOAT, usage: n[G]},
                {index: K.pickColor, componentsPerAttribute: 4, normalize: !0, componentDatatype: u.UNSIGNED_BYTE, usage: h.STATIC_DRAW, purpose: $},
                {index: K.color, componentsPerAttribute: 4, normalize: !0, componentDatatype: u.UNSIGNED_BYTE, usage: n[j], purpose: Q},
                {index: K.originAndShow, componentsPerAttribute: 3, componentDatatype: u.BYTE, usage: n[V]},
                {index: K.direction, vertexBuffer: i, componentsPerAttribute: 2, normalize: !0, componentDatatype: u.UNSIGNED_BYTE},
                {index: K.rotationAndAlignedAxis, componentsPerAttribute: 4, componentDatatype: u.FLOAT, usage: n[Y]}
            ], 4 * t)
        }

        function E(e, t, n, i, r) {
            var o = 4 * r._index, s = r._getActualPosition();
            e._mode === v.SCENE3D && e._baseVolume.expand(s, e._baseVolume), a.fromCartesian(s, nt);
            var u = i[J], l = u[K.positionHigh], c = nt.high;
            l(o + 0, c.x, c.y, c.z), l(o + 1, c.x, c.y, c.z), l(o + 2, c.x, c.y, c.z), l(o + 3, c.x, c.y, c.z);
            var d = u[K.positionLow], f = nt.low;
            d(o + 0, f.x, f.y, f.z), d(o + 1, f.x, f.y, f.z), d(o + 2, f.x, f.y, f.z), d(o + 3, f.x, f.y, f.z)
        }

        function A(e, t, n, i, r) {
            var o = 4 * r._index, a = r.getPixelOffset();
            e._maxPixelOffset = Math.max(e._maxPixelOffset, a.x, a.y);
            var s = i[J], u = s[K.pixelOffset];
            u(o + 0, a.x, a.y), u(o + 1, a.x, a.y), u(o + 2, a.x, a.y), u(o + 3, a.x, a.y)
        }

        function M(e, t, n, i, r) {
            var o = 4 * r._index, a = r.getEyeOffset(), s = r.getScale();
            e._maxEyeOffset = Math.max(e._maxEyeOffset, Math.abs(a.x), Math.abs(a.y), Math.abs(a.z)), e._maxScale = Math.max(e._maxScale, s);
            var u = i[J], l = u[K.eyeOffsetAndScale];
            l(o + 0, a.x, a.y, a.z, s), l(o + 1, a.x, a.y, a.z, s), l(o + 2, a.x, a.y, a.z, s), l(o + 3, a.x, a.y, a.z, s)
        }

        function D(e, n, i, r, o) {
            var a = 4 * o._index, s = r[$], u = s[K.pickColor], l = o.getPickId(n).color, c = t.floatToByte(l.red), d = t.floatToByte(l.green), f = t.floatToByte(l.blue), h = t.floatToByte(l.alpha);
            u(a + 0, c, d, f, h), u(a + 1, c, d, f, h), u(a + 2, c, d, f, h), u(a + 3, c, d, f, h)
        }

        function I(e, n, i, r, o) {
            var a = 4 * o._index, s = r[Q], u = s[K.color], l = o.getColor(), c = t.floatToByte(l.red), d = t.floatToByte(l.green), f = t.floatToByte(l.blue), h = t.floatToByte(l.alpha);
            u(a + 0, c, d, f, h), u(a + 1, c, d, f, h), u(a + 2, c, d, f, h), u(a + 3, c, d, f, h)
        }

        function P(e, t, n, i, r) {
            var o = 4 * r._index, a = r.getHorizontalOrigin().value, s = r.getVerticalOrigin().value, u = r.getShow();
            0 === r.getColor().alpha && (u = !1), e._allHorizontalCenter = e._allHorizontalCenter && a === _.CENTER.value;
            var l = i[J], c = l[K.originAndShow];
            c(o + 0, a, s, u), c(o + 1, a, s, u), c(o + 2, a, s, u), c(o + 3, a, s, u)
        }

        function O(t, i, r, o, a) {
            var s = 4 * a._index, u = 0, l = 0, c = 0, d = 0, f = a.getImageIndex();
            if (-1 !== f) {
                var h = r[f];
                if ("undefined" == typeof h)throw new e("Invalid billboard image index: " + f);
                u = h.x, l = h.y, c = h.width, d = h.height
            }
            var p = u + c, m = l + d, y = t._textureAtlas.getTexture().getDimensions(), v = .5 * n(a.getWidth(), y.x * c), g = .5 * n(a.getHeight(), y.y * d);
            t._maxSize = Math.max(t._maxSize, v, g);
            var _ = o[J], w = _[K.textureCoordinatesAndImageSize];
            w(s + 0, u, l, v, g), w(s + 1, p, l, v, g), w(s + 2, p, m, v, g), w(s + 3, u, m, v, g)
        }

        function R(e, t, n, i, r) {
            var a = 4 * r._index, s = r.getRotation(), u = r.getAlignedAxis();
            0 === s && o.equals(u, o.ZERO) || (e._shaderRotation = !0);
            var l = u.x, c = u.y, d = u.z, f = i[J], h = f[K.rotationAndAlignedAxis];
            h(a + 0, s, l, c, d), h(a + 1, s, l, c, d), h(a + 2, s, l, c, d), h(a + 3, s, l, c, d)
        }

        function z(e, t, n, i, r) {
            E(e, t, n, i, r), A(e, t, n, i, r), M(e, t, n, i, r), D(e, t, n, i, r), I(e, t, n, i, r), P(e, t, n, i, r), O(e, t, n, i, r), R(e, t, n, i, r)
        }

        function L(e, t, n, i, r, o) {
            var a;
            a = i.mode === v.SCENE3D ? e._baseVolume : e._baseVolume2D;
            for (var s = [], u = 0; n > u; ++u) {
                var l = t[u], c = l.getPosition(), f = g._computeActualPosition(c, i, r);
                "undefined" != typeof f && (l._setActualPosition(f), o ? s.push(f) : a.expand(f, a))
            }
            o && d.fromPoints(s, a)
        }

        function N(e, t) {
            var n = t.mode, i = t.scene2D.projection, r = e._billboards, o = e._billboardsToUpdate, a = e._modelMatrix;
            e._mode !== n || e._projection !== i || n !== v.SCENE3D && !a.equals(e.modelMatrix) ? (e._mode = n, e._projection = i, e.modelMatrix.clone(a), e._createVertexArray = !0, (n === v.SCENE3D || n === v.SCENE2D || n === v.COLUMBUS_VIEW) && L(e, r, r.length, t, a, !0)) : n === v.MORPHING ? L(e, r, r.length, t, a, !0) : (n === v.SCENE2D || n === v.COLUMBUS_VIEW) && L(e, o, e._billboardsToUpdateIndex, t, a, !1)
        }

        function F(e, t, n, i) {
            var r, o, a, s = n.camera, u = s.frustum, l = s.getPositionWC().subtract(i.center, rt), c = s.getDirectionWC().multiplyByScalar(l.dot(s.getDirectionWC()), ot), d = Math.max(0, c.magnitude() - i.radius), f = t.getCanvas();
            it.x = f.clientWidth, it.y = f.clientHeight;
            var h = u.getPixelSize(it, d);
            r = Math.max(h.x, h.y), o = 2 * r * e._maxScale * e._maxSize, e._allHorizontalCenter && (o *= .5), a = r * e._maxPixelOffset + e._maxEyeOffset, i.radius += o + a
        }

        var V = g.SHOW_INDEX, B = g.POSITION_INDEX, k = g.PIXEL_OFFSET_INDEX, U = g.EYE_OFFSET_INDEX, q = g.HORIZONTAL_ORIGIN_INDEX, W = g.VERTICAL_ORIGIN_INDEX, H = g.SCALE_INDEX, G = g.IMAGE_INDEX_INDEX, j = g.COLOR_INDEX, Y = g.ROTATION_INDEX, X = g.ALIGNED_AXIS_INDEX, Z = g.NUMBER_OF_PROPERTIES, K = {positionHigh: 0, positionLow: 1, pixelOffset: 2, eyeOffsetAndScale: 3, textureCoordinatesAndImageSize: 4, originAndShow: 5, direction: 6, pickColor: 7, color: 7, rotationAndAlignedAxis: 8}, J = "all", Q = "color", $ = "pick", et = [], tt = function () {
            this._textureAtlas = void 0, this._textureAtlasGUID = void 0, this._destroyTextureAtlas = !0, this._sp = void 0, this._rs = void 0, this._vaf = void 0, this._spPick = void 0, this._billboards = [], this._billboardsToUpdate = [], this._billboardsToUpdateIndex = 0, this._billboardsRemoved = !1, this._createVertexArray = !1, this._shaderRotation = !1, this._compiledShaderRotation = !1, this._compiledShaderRotationPick = !1, this._propertiesChanged = new Uint32Array(Z), this._maxSize = 0, this._maxEyeOffset = 0, this._maxScale = 1, this._maxPixelOffset = 0, this._allHorizontalCenter = !0, this._baseVolume = new d, this._baseVolume2D = new d, this._boundingVolume = new d, this._colorCommands = [], this._pickCommands = [], this._commandLists = new p, this.modelMatrix = s.IDENTITY.clone(), this._modelMatrix = s.IDENTITY.clone(), this._mode = v.SCENE3D, this._projection = void 0, this._buffersUsage = [h.STATIC_DRAW, h.STATIC_DRAW, h.STATIC_DRAW, h.STATIC_DRAW, h.STATIC_DRAW, h.STATIC_DRAW, h.STATIC_DRAW, h.STATIC_DRAW, h.STATIC_DRAW, h.STATIC_DRAW, h.STATIC_DRAW];
            var e = this;
            this._uniforms = {u_atlas: function () {
                return e._textureAtlas.getTexture()
            }}
        };
        tt.prototype.add = function (e) {
            var t = new g(e, this);
            return t._index = this._billboards.length, this._billboards.push(t), this._createVertexArray = !0, t
        }, tt.prototype.remove = function (e) {
            return this.contains(e) ? (this._billboards[e._index] = null, this._billboardsRemoved = !0, this._createVertexArray = !0, e._destroy(), !0) : !1
        }, tt.prototype.removeAll = function () {
            this._destroyBillboards(), this._billboards = [], this._billboardsToUpdate = [], this._billboardsToUpdateIndex = 0, this._billboardsRemoved = !1, this._createVertexArray = !0
        }, tt.prototype._updateBillboard = function (e, t) {
            e._dirty || (this._billboardsToUpdate[this._billboardsToUpdateIndex++] = e), ++this._propertiesChanged[t]
        }, tt.prototype.contains = function (e) {
            return"undefined" != typeof e && e._billboardCollection === this
        }, tt.prototype.get = function (t) {
            if ("undefined" == typeof t)throw new e("index is required.");
            return x(this), this._billboards[t]
        }, tt.prototype.getLength = function () {
            return x(this), this._billboards.length
        }, tt.prototype.getTextureAtlas = function () {
            return this._textureAtlas
        }, tt.prototype.setTextureAtlas = function (e) {
            this._textureAtlas !== e && (this._textureAtlas = this._destroyTextureAtlas && this._textureAtlas && this._textureAtlas.destroy(), this._textureAtlas = e, this._createVertexArray = !0)
        }, tt.prototype.getDestroyTextureAtlas = function () {
            return this._destroyTextureAtlas
        }, tt.prototype.setDestroyTextureAtlas = function (e) {
            this._destroyTextureAtlas = e
        }, tt.prototype.computeNewBuffersUsage = function () {
            for (var e = this._buffersUsage, t = !1, n = this._propertiesChanged, i = 0; Z > i; ++i) {
                var r = 0 === n[i] ? h.STATIC_DRAW : h.STREAM_DRAW;
                t = t || e[i] !== r, e[i] = r
            }
            return t
        };
        var nt = new a, it = new r, rt = new o, ot = new o;
        return tt.prototype.update = function (e, t, n) {
            var i = this._textureAtlas;
            if ("undefined" != typeof i) {
                var r = i.getTextureCoordinates();
                if (0 !== r.length) {
                    x(this), N(this, t);
                    var o = this._billboards, a = o.length, u = this._billboardsToUpdate, l = this._billboardsToUpdateIndex, h = this._propertiesChanged, p = i.getGUID(), y = this._createVertexArray || this._textureAtlasGUID !== p;
                    this._textureAtlasGUID = p;
                    var g, _ = t.passes, S = _.pick;
                    if (y || !S && this.computeNewBuffersUsage()) {
                        this._createVertexArray = !1;
                        for (var D = 0; Z > D; ++D)h[D] = 0;
                        if (this._vaf = this._vaf && this._vaf.destroy(), a > 0) {
                            this._vaf = T(e, a, this._buffersUsage), g = this._vaf.writers;
                            for (var L = 0; a > L; ++L) {
                                var J = this._billboards[L];
                                J._dirty = !1, z(this, e, r, g, J)
                            }
                            this._vaf.commit(b(e))
                        }
                        this._billboardsToUpdateIndex = 0
                    } else if (l > 0) {
                        var tt = [];
                        if (h[B] && tt.push(E), h[k] && tt.push(A), (h[U] || h[H]) && tt.push(M), h[G] && tt.push(O), h[j] && tt.push(I), (h[q] || h[W] || h[V]) && tt.push(P), (h[Y] || h[X]) && tt.push(R), g = this._vaf.writers, l / a > .1) {
                            for (var nt = 0; l > nt; ++nt) {
                                var it = u[nt];
                                it._dirty = !1;
                                for (var rt = 0; rt < tt.length; ++rt)tt[rt](this, e, r, g, it)
                            }
                            this._vaf.commit(b(e))
                        } else {
                            for (var ot = 0; l > ot; ++ot) {
                                var at = u[ot];
                                at._dirty = !1;
                                for (var st = 0; st < tt.length; ++st)tt[st](this, e, r, g, at);
                                this._vaf.subCommit(4 * at._index, 4)
                            }
                            this._vaf.endSubCommits()
                        }
                        this._billboardsToUpdateIndex = 0
                    }
                    if (l > 1.5 * a && (u.length = a), "undefined" != typeof this._vaf && "undefined" != typeof this._vaf.vaByPurpose) {
                        var ut, lt = s.IDENTITY;
                        t.mode === v.SCENE3D ? (lt = this.modelMatrix, ut = d.clone(this._baseVolume, this._boundingVolume)) : ut = d.clone(this._baseVolume2D, this._boundingVolume), F(this, e, t, ut);
                        var ct, dt, ft, ht, pt = this._commandLists;
                        if (pt.colorList = et, pt.pickList = et, _.color) {
                            var mt = this._colorCommands;
                            for (pt.colorList = mt, "undefined" == typeof this._rs && (this._rs = e.createRenderState({depthTest: {enabled: !0}, blending: f.ALPHA_BLEND})), ("undefined" == typeof this._sp || this._shaderRotation && !this._compiledShaderRotation) && (this._sp = e.getShaderCache().replaceShaderProgram(this._sp, (this._shaderRotation ? "#define ROTATION 1\n" : "") + w, C, K), this._compiledShaderRotation = this._shaderRotation), ct = this._vaf.vaByPurpose[Q], dt = ct.length, mt.length = dt, ht = 0; dt > ht; ++ht)ft = mt[ht], "undefined" == typeof ft && (ft = mt[ht] = new m), ft.boundingVolume = ut, ft.modelMatrix = lt, ft.primitiveType = c.TRIANGLES, ft.count = ct[ht].indicesCount, ft.shaderProgram = this._sp, ft.uniformMap = this._uniforms, ft.vertexArray = ct[ht].va, ft.renderState = this._rs, ft.owner = this
                        }
                        if (S) {
                            var yt = this._pickCommands;
                            for (pt.pickList = yt, ("undefined" == typeof this._spPick || this._shaderRotation && !this._compiledShaderRotationPick) && (this._spPick = e.getShaderCache().replaceShaderProgram(this._spPick, (this._shaderRotation ? "#define ROTATION 1\n" : "") + "#define RENDER_FOR_PICK 1\n" + w, "#define RENDER_FOR_PICK 1\n" + C, K), this._compiledShaderRotation = this._shaderRotationPick), ct = this._vaf.vaByPurpose[$], dt = ct.length, yt.length = dt, ht = 0; dt > ht; ++ht)ft = yt[ht], "undefined" == typeof ft && (ft = yt[ht] = new m), ft.boundingVolume = ut, ft.modelMatrix = lt, ft.primitiveType = c.TRIANGLES, ft.count = ct[ht].indicesCount, ft.shaderProgram = this._spPick, ft.uniformMap = this._uniforms, ft.vertexArray = ct[ht].va, ft.renderState = this._rs, ft.owner = this
                        }
                        pt.empty() || n.push(pt)
                    }
                }
            }
        }, tt.prototype.isDestroyed = function () {
            return!1
        }, tt.prototype.destroy = function () {
            return this._textureAtlas = this._destroyTextureAtlas && this._textureAtlas && this._textureAtlas.destroy(), this._sp = this._sp && this._sp.release(), this._spPick = this._spPick && this._spPick.release(), this._vaf = this._vaf && this._vaf.destroy(), this._destroyBillboards(), i(this)
        }, tt.prototype._destroyBillboards = function () {
            for (var e = this._billboards, t = e.length, n = 0; t > n; ++n)e[n] && e[n]._destroy()
        }, tt
    }), n("Renderer/TextureAtlasBuilder", ["../Core/Event", "../Core/DeveloperError", "../Core/loadImage"], function (e, t, n) {
        "use strict";
        function i() {
            this.imageLoaded = new e, this.index = -1, this.loaded = !1
        }

        var r = function (e) {
            if ("undefined" == typeof e)throw new t("textureAtlas is required.");
            this.textureAtlas = e, this._idHash = {}
        };
        return r.prototype.addTextureFromUrl = function (e, i) {
            if ("undefined" == typeof e)throw new t("url is required.");
            if ("undefined" == typeof i)throw new t("textureAvailableCallback is required.");
            this.addTextureFromFunction(e, function (e, t) {
                n(e).then(t)
            }, i)
        }, r.prototype.addTextureFromFunction = function (e, n, r) {
            if ("undefined" == typeof e)throw new t("id is required.");
            if ("undefined" == typeof n)throw new t("getImageCallback is required.");
            if ("undefined" == typeof r)throw new t("textureAvailableCallback is required.");
            var o = this._idHash[e];
            if ("undefined" != typeof o)return o.loaded ? r(o.index) : o.imageLoaded.addEventListener(r), void 0;
            this._idHash[e] = o = new i, o.imageLoaded.addEventListener(r);
            var a = this;
            n(e, function (t) {
                if (!a.textureAtlas.isDestroyed()) {
                    var n = o.index = a.textureAtlas.addImage(t);
                    o.loaded = !0, o.imageLoaded.raiseEvent(n, e), o.imageLoaded = void 0
                }
            })
        }, r
    }), n("DynamicScene/DynamicBillboardVisualizer", ["../Core/DeveloperError", "../Core/destroyObject", "../Core/Color", "../Core/Cartesian2", "../Core/Cartesian3", "../Scene/BillboardCollection", "../Scene/HorizontalOrigin", "../Scene/VerticalOrigin", "../Renderer/TextureAtlasBuilder"], function (e, t, n, i, r, o, a, s, u) {
        "use strict";
        function l(e, t, n) {
            return function (i) {
                var r = e._billboardVisualizerIndex;
                if ("undefined" != typeof r) {
                    var o = t.get(r);
                    o._visualizerUrl === n && (o._visualizerTextureAvailable = !0, o.setImageIndex(i))
                }
            }
        }

        function c(e, t, o) {
            var u = o.billboard;
            if ("undefined" != typeof u) {
                var c = o.position;
                if ("undefined" != typeof c) {
                    var d = u.image;
                    if ("undefined" != typeof d) {
                        var y, v = u.show, g = o._billboardVisualizerIndex, _ = o.isAvailable(t) && ("undefined" == typeof v || v.getValue(t));
                        if (!_)return"undefined" != typeof g && (y = e._billboardCollection.get(g), y.setShow(!1), y.setImageIndex(-1), y._visualizerUrl = void 0, y._visualizerTextureAvailable = !1, o._billboardVisualizerIndex = void 0, e._unusedIndexes.push(g)), void 0;
                        if ("undefined" == typeof g) {
                            var w = e._unusedIndexes, C = w.length;
                            C > 0 ? (g = w.pop(), y = e._billboardCollection.get(g)) : (g = e._billboardCollection.getLength(), y = e._billboardCollection.add()), o._billboardVisualizerIndex = g, y.dynamicObject = o, y._visualizerUrl = void 0, y._visualizerTextureAvailable = !1, y.setColor(n.WHITE), y.setEyeOffset(r.ZERO), y.setPixelOffset(i.ZERO), y.setScale(1), y.setHorizontalOrigin(a.CENTER), y.setVerticalOrigin(s.CENTER)
                        } else y = e._billboardCollection.get(g);
                        var x = d.getValue(t);
                        if (x !== y._visualizerUrl && (y._visualizerUrl = x, y._visualizerTextureAvailable = !1, e._textureAtlasBuilder.addTextureFromUrl(x, l(o, e._billboardCollection, x))), y.setShow(y._visualizerTextureAvailable), y._visualizerTextureAvailable) {
                            f = c.getValueCartesian(t, f), "undefined" != typeof f && y.setPosition(f);
                            var S = u.color;
                            if ("undefined" != typeof S && (h = S.getValue(t, h), "undefined" != typeof h && y.setColor(h)), S = u.eyeOffset, "undefined" != typeof S && (p = S.getValue(t, p), "undefined" != typeof p && y.setEyeOffset(p)), S = u.pixelOffset, "undefined" != typeof S && (m = S.getValue(t, m), "undefined" != typeof m && y.setPixelOffset(m)), S = u.scale, "undefined" != typeof S) {
                                var b = S.getValue(t);
                                "undefined" != typeof b && y.setScale(b)
                            }
                            if (S = u.rotation, "undefined" != typeof S) {
                                var T = S.getValue(t);
                                "undefined" != typeof T && y.setRotation(T)
                            }
                            if (S = u.alignedAxis, "undefined" != typeof S) {
                                var E = S.getValue(t);
                                "undefined" != typeof E && y.setAlignedAxis(E)
                            }
                            if (S = u.horizontalOrigin, "undefined" != typeof S) {
                                var A = S.getValue(t);
                                "undefined" != typeof A && y.setHorizontalOrigin(A)
                            }
                            if (S = u.verticalOrigin, "undefined" != typeof S) {
                                var M = S.getValue(t);
                                "undefined" != typeof M && y.setVerticalOrigin(M)
                            }
                        }
                    }
                }
            }
        }

        var d = function (t, n) {
            if ("undefined" == typeof t)throw new e("scene is required.");
            this._scene = t, this._unusedIndexes = [], this._dynamicObjectCollection = void 0;
            var i = this._billboardCollection = new o, r = this._textureAtlas = t.getContext().createTextureAtlas();
            this._textureAtlasBuilder = new u(r), i.setTextureAtlas(r), t.getPrimitives().add(i), this.setDynamicObjectCollection(n)
        };
        d.prototype.getScene = function () {
            return this._scene
        }, d.prototype.getDynamicObjectCollection = function () {
            return this._dynamicObjectCollection
        }, d.prototype.setDynamicObjectCollection = function (e) {
            var t = this._dynamicObjectCollection;
            t !== e && ("undefined" != typeof t && (t.objectsRemoved.removeEventListener(d.prototype._onObjectsRemoved, this), this.removeAllPrimitives()), this._dynamicObjectCollection = e, "undefined" != typeof e && e.objectsRemoved.addEventListener(d.prototype._onObjectsRemoved, this))
        }, d.prototype.update = function (t) {
            if ("undefined" == typeof t)throw new e("time is requied.");
            if ("undefined" != typeof this._dynamicObjectCollection)for (var n = this._dynamicObjectCollection.getObjects(), i = 0, r = n.length; r > i; i++)c(this, t, n[i])
        }, d.prototype.removeAllPrimitives = function () {
            if ("undefined" != typeof this._dynamicObjectCollection) {
                this._unusedIndexes = [], this._billboardCollection.removeAll();
                for (var e = this._dynamicObjectCollection.getObjects(), t = e.length - 1; t > -1; t--)e[t]._billboardVisualizerIndex = void 0
            }
        }, d.prototype.isDestroyed = function () {
            return!1
        }, d.prototype.destroy = function () {
            return this.removeAllPrimitives(), this._scene.getPrimitives().remove(this._billboardCollection), t(this)
        };
        var f, h, p, m;
        return d.prototype._onObjectsRemoved = function (e, t) {
            for (var n = this._billboardCollection, i = this._unusedIndexes, r = t.length - 1; r > -1; r--) {
                var o = t[r], a = o._billboardVisualizerIndex;
                if ("undefined" != typeof a) {
                    var s = n.get(a);
                    s.setShow(!1), s.setImageIndex(-1), s._visualizerUrl = void 0, s._visualizerTextureAvailable = !1, o._billboardVisualizerIndex = void 0, i.push(a)
                }
            }
        }, d
    }), n("Renderer/CullFace", ["../Core/Enumeration"], function (e) {
        "use strict";
        var t = {FRONT: new e(1028, "FRONT"), BACK: new e(1029, "BACK"), FRONT_AND_BACK: new e(1032, "FRONT_AND_BACK"), validate: function (e) {
            return e === t.FRONT || e === t.BACK || e === t.FRONT_AND_BACK
        }};
        return t
    }), n("Renderer/createPickFragmentShaderSource", ["../Core/defaultValue", "../Core/DeveloperError"], function (e, t) {
        "use strict";
        function n(e, n) {
            if ("undefined" == typeof e)throw new t("fragmentShaderSource is required.");
            if ("uniform" !== n && "varying" !== n)throw new t("qualifier must be 'uniform' or 'varying'.");
            var i = e.replace(/void\s+main\s*\(\s*(?:void)?\s*\)/g, "void czm_old_main()"), r = n + " vec4 czm_pickColor; \n" + "void main() \n" + "{ \n" + "    czm_old_main(); \n" + "    if (gl_FragColor.a == 0.0) { \n" + "        discard; \n" + "    } \n" + "    gl_FragColor = czm_pickColor; \n" + "}";
            return i + "\n" + r
        }

        return n
    }), n("Shaders/EllipsoidVS", [], function () {
        "use strict";
        return"attribute vec3 position;\nuniform vec3 u_radii;\nvarying vec3 v_positionEC;\nvoid main()\n{\nvec4 p = vec4(u_radii * position, 1.0);\nv_positionEC = (czm_modelView * p).xyz;\ngl_Position = czm_modelViewProjection * p;\ngl_Position.z = clamp(gl_Position.z, gl_DepthRange.near, gl_DepthRange.far);\n}\n"
    }), n("Shaders/EllipsoidFS", [], function () {
        "use strict";
        return"uniform vec3 u_radii;\nuniform vec3 u_oneOverEllipsoidRadiiSquared;\nvarying vec3 v_positionEC;\nvec4 computeEllipsoidColor(czm_ray ray, float intersection, float side)\n{\nvec3 positionEC = czm_pointAlongRay(ray, intersection);\nvec3 positionMC = (czm_inverseModelView * vec4(positionEC, 1.0)).xyz;\nvec3 geodeticNormal = normalize(czm_geodeticSurfaceNormal(positionMC, vec3(0.0), u_oneOverEllipsoidRadiiSquared));\nvec3 sphericalNormal = normalize(positionMC / u_radii);\nvec3 normalMC = geodeticNormal * side;\nvec3 normalEC = normalize(czm_normal * normalMC);\nvec2 st = czm_ellipsoidWgs84TextureCoordinates(sphericalNormal);\nvec3 positionToEyeEC = -positionEC;\nczm_materialInput materialInput;\nmaterialInput.s = st.s;\nmaterialInput.st = st;\nmaterialInput.str = (positionMC + u_radii) / u_radii;\nmaterialInput.normalEC = normalEC;\nmaterialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(positionMC, normalEC);\nmaterialInput.positionToEyeEC = positionToEyeEC;\nczm_material material = czm_getMaterial(materialInput);\nreturn czm_phong(normalize(positionToEyeEC), material);\n}\nvoid main()\n{\nczm_ellipsoid ellipsoid = czm_ellipsoidNew(czm_modelView[3].xyz, u_radii);\nvec3 direction = normalize(v_positionEC);\nczm_ray ray = czm_ray(vec3(0.0), direction);\nczm_raySegment intersection = czm_rayEllipsoidIntersectionInterval(ray, ellipsoid);\nif (czm_isEmpty(intersection))\n{\ndiscard;\n}\nvec4 outsideFaceColor = (intersection.start != 0.0) ? computeEllipsoidColor(ray, intersection.start, 1.0) : vec4(0.0);\nvec4 insideFaceColor = (outsideFaceColor.a < 1.0) ? computeEllipsoidColor(ray, intersection.stop, -1.0) : vec4(0.0);\ngl_FragColor = mix(insideFaceColor, outsideFaceColor, outsideFaceColor.a);\ngl_FragColor.a = 1.0 - (1.0 - insideFaceColor.a) * (1.0 - outsideFaceColor.a);\n}\n"
    }), n("Scene/EllipsoidPrimitive", ["../Core/BoxGeometry", "../Core/Cartesian3", "../Core/Cartesian4", "../Core/combine", "../Core/DeveloperError", "../Core/destroyObject", "../Core/Matrix4", "../Core/BoundingSphere", "../Core/PrimitiveType", "../Renderer/CullFace", "../Renderer/BlendingState", "../Renderer/BufferUsage", "../Renderer/CommandLists", "../Renderer/DrawCommand", "../Renderer/createPickFragmentShaderSource", "./Material", "./SceneMode", "../Shaders/EllipsoidVS", "../Shaders/EllipsoidFS"], function (e, t, n, i, r, o, a, s, u, l, c, d, f, h, p, m, y, v, g) {
        "use strict";
        function _(n) {
            var i = n.cache.ellipsoidPrimitive_vertexArray;
            if ("undefined" != typeof i)return i;
            var r = e.fromDimensions({dimensions: new t(2, 2, 2)});
            return i = n.createVertexArrayFromGeometry({geometry: r, attributeIndices: w, bufferUsage: d.STATIC_DRAW}), n.cache.ellipsoidPrimitive_vertexArray = i, i
        }

        var w = {position: 0}, C = function () {
            this.center = t.ZERO.clone(), this.radii = void 0, this._radii = new t, this._oneOverEllipsoidRadiiSquared = new t, this._boundingSphere = new s, this.modelMatrix = a.IDENTITY.clone(), this._computedModelMatrix = a.IDENTITY.clone(), this.show = !0, this.material = m.fromType(void 0, m.ColorType), this._material = void 0, this._sp = void 0, this._rs = void 0, this._va = void 0, this._pickSP = void 0, this._pickId = void 0, this._colorCommand = new h, this._colorCommand.owner = this, this._pickCommand = new h, this._pickCommand.owner = this, this._commandLists = new f;
            var e = this;
            this._uniforms = {u_radii: function () {
                return e.radii
            }, u_oneOverEllipsoidRadiiSquared: function () {
                return e._oneOverEllipsoidRadiiSquared
            }}, this._pickUniforms = {czm_pickColor: function () {
                return e._pickId.color
            }}
        };
        return C.prototype.update = function (e, n, o) {
            if (this.show && n.mode === y.SCENE3D && "undefined" != typeof this.center && "undefined" != typeof this.radii) {
                if ("undefined" == typeof this.material)throw new r("this.material must be defined.");
                "undefined" == typeof this._rs && (this._rs = e.createRenderState({cull: {enabled: !0, face: l.FRONT}, depthTest: {enabled: !0}, depthMask: !1, blending: c.ALPHA_BLEND})), "undefined" == typeof this._va && (this._va = _(e));
                var s = this.radii;
                if (!t.equals(this._radii, s)) {
                    t.clone(s, this._radii);
                    var d = this._oneOverEllipsoidRadiiSquared;
                    d.x = 1 / (s.x * s.x), d.y = 1 / (s.y * s.y), d.z = 1 / (s.z * s.z), this._boundingSphere.radius = t.getMaximumComponent(s)
                }
                a.multiplyByTranslation(this.modelMatrix, this.center, this._computedModelMatrix);
                var f = this._commandLists;
                f.removeAll();
                var h = this._material !== this.material;
                if (this._material = this.material, n.passes.color) {
                    var m = this._colorCommand;
                    if (h) {
                        var C = "#line 0\n" + this.material.shaderSource + "#line 0\n" + g;
                        this._sp = e.getShaderCache().replaceShaderProgram(this._sp, v, C, w), m.primitiveType = u.TRIANGLES, m.vertexArray = this._va, m.renderState = this._rs, m.shaderProgram = this._sp, m.uniformMap = i([this._uniforms, this.material._uniforms], !1, !1), m.executeInClosestFrustum = !0
                    }
                    m.boundingVolume = this._boundingSphere, m.modelMatrix = this._computedModelMatrix, f.colorList.push(m)
                }
                if (n.passes.pick) {
                    var x = this._pickCommand;
                    if ("undefined" == typeof this._pickId && (this._pickId = e.createPickId(this)), h || "undefined" == typeof this._pickSP) {
                        var S = p("#line 0\n" + this.material.shaderSource + "#line 0\n" + g, "uniform");
                        this._pickSP = e.getShaderCache().replaceShaderProgram(this._pickSP, v, S, w), x.primitiveType = u.TRIANGLES, x.vertexArray = this._va, x.renderState = this._rs, x.shaderProgram = this._pickSP, x.uniformMap = i([this._uniforms, this._pickUniforms, this.material._uniforms], !1, !1), x.executeInClosestFrustum = !0
                    }
                    x.boundingVolume = this._boundingSphere, x.modelMatrix = this._computedModelMatrix, f.pickList.push(x)
                }
                o.push(f)
            }
        }, C.prototype.isDestroyed = function () {
            return!1
        }, C.prototype.destroy = function () {
            return this._sp = this._sp && this._sp.release(), this._pickSP = this._pickSP && this._pickSP.release(), this._pickId = this._pickId && this._pickId.destroy(), o(this)
        }, C
    }), n("DynamicScene/DynamicEllipsoidVisualizer", ["../Core/defaultValue", "../Core/DeveloperError", "../Core/destroyObject", "../Core/Matrix3", "../Core/Matrix4", "../Scene/EllipsoidPrimitive", "../Scene/Material"], function (e, t, n, i, r, o, a) {
        "use strict";
        function s(t, n, s) {
            var l = t._scene.getContext(), f = s.ellipsoid;
            if ("undefined" != typeof f) {
                var h = f.radii;
                if ("undefined" != typeof h) {
                    var p = s.position;
                    if ("undefined" != typeof p) {
                        var m = s.orientation;
                        if ("undefined" != typeof m) {
                            var y, v = f.show, g = s._ellipsoidVisualizerIndex, _ = s.isAvailable(n) && ("undefined" == typeof v || v.getValue(n));
                            if (!_)return"undefined" != typeof g && (y = t._ellipsoidCollection[g], y.show = !1, s._ellipsoidVisualizerIndex = void 0, t._unusedIndexes.push(g)), void 0;
                            if ("undefined" == typeof g) {
                                var w = t._unusedIndexes, C = w.length;
                                C > 0 ? (g = w.pop(), y = t._ellipsoidCollection[g]) : (g = t._ellipsoidCollection.length, y = new o, t._ellipsoidCollection.push(y), t._primitives.add(y)), s._ellipsoidVisualizerIndex = g, y.dynamicObject = s, y.material = a.fromType(l, a.ColorType)
                            } else y = t._ellipsoidCollection[g];
                            y.show = !0, y.radii = h.getValue(n, y.radii), c = e(p.getValueCartesian(n, c), y._visualizerPosition), d = e(m.getValue(n, d), y._visualizerOrientation), "undefined" == typeof c || "undefined" == typeof d || c.equals(y._visualizerPosition) && d.equals(y._visualizerOrientation) || (r.fromRotationTranslation(i.fromQuaternion(d, u), c, y.modelMatrix), y._visualizerPosition = c.clone(y._visualizerPosition), y._visualizerOrientation = d.clone(y._visualizerOrientation));
                            var x = f.material;
                            "undefined" != typeof x && (y.material = x.getValue(n, l, y.material))
                        }
                    }
                }
            }
        }

        var u = new i, l = function (e, n) {
            if ("undefined" == typeof e)throw new t("scene is required.");
            this._scene = e, this._unusedIndexes = [], this._primitives = e.getPrimitives(), this._ellipsoidCollection = [], this._dynamicObjectCollection = void 0, this.setDynamicObjectCollection(n)
        };
        l.prototype.getScene = function () {
            return this._scene
        }, l.prototype.getDynamicObjectCollection = function () {
            return this._dynamicObjectCollection
        }, l.prototype.setDynamicObjectCollection = function (e) {
            var t = this._dynamicObjectCollection;
            t !== e && ("undefined" != typeof t && (t.objectsRemoved.removeEventListener(l.prototype._onObjectsRemoved, this), this.removeAllPrimitives()), this._dynamicObjectCollection = e, "undefined" != typeof e && e.objectsRemoved.addEventListener(l.prototype._onObjectsRemoved, this))
        }, l.prototype.update = function (e) {
            if ("undefined" == typeof e)throw new t("time is requied.");
            if ("undefined" != typeof this._dynamicObjectCollection)for (var n = this._dynamicObjectCollection.getObjects(), i = 0, r = n.length; r > i; i++)s(this, e, n[i])
        }, l.prototype.removeAllPrimitives = function () {
            var e, t;
            for (e = 0, t = this._ellipsoidCollection.length; t > e; e++)this._primitives.remove(this._ellipsoidCollection[e]);
            if ("undefined" != typeof this._dynamicObjectCollection) {
                var n = this._dynamicObjectCollection.getObjects();
                for (e = n.length - 1; e > -1; e--)n[e]._ellipsoidVisualizerIndex = void 0
            }
            this._unusedIndexes = [], this._ellipsoidCollection = []
        }, l.prototype.isDestroyed = function () {
            return!1
        }, l.prototype.destroy = function () {
            return this.removeAllPrimitives(), n(this)
        };
        var c, d;
        return l.prototype._onObjectsRemoved = function (e, t) {
            for (var n = this._ellipsoidCollection, i = this._unusedIndexes, r = t.length - 1; r > -1; r--) {
                var o = t[r], a = o._ellipsoidVisualizerIndex;
                if ("undefined" != typeof a) {
                    var s = n[a];
                    s.show = !1, i.push(a), o._ellipsoidVisualizerIndex = void 0
                }
            }
        }, l
    }), n("Shaders/SensorVolume", [], function () {
        "use strict";
        return"uniform vec4 u_intersectionColor;\nuniform float u_intersectionWidth;\nbool inSensorShadow(vec3 coneVertexWC, czm_ellipsoid ellipsoidEC, vec3 pointWC)\n{\nvec3 D = ellipsoidEC.inverseRadii;\nvec3 q = D * coneVertexWC;\nfloat qMagnitudeSquared = dot(q, q);\nfloat test = qMagnitudeSquared - 1.0;\nvec3 temp = D * pointWC - q;\nfloat d = dot(temp, q);\nreturn (d < -test) && (d / length(temp) < -sqrt(test));\n}\n#ifndef RENDER_FOR_PICK\nvec4 getIntersectionColor()\n{\nreturn u_intersectionColor;\n}\nfloat getIntersectionWidth()\n{\nreturn u_intersectionWidth;\n}\nvec2 sensor2dTextureCoordinates(float sensorRadius, vec3 pointMC)\n{\nfloat t = pointMC.z / sensorRadius;\nfloat s = 1.0 + (atan(pointMC.y, pointMC.x) / czm_twoPi);\ns = s - floor(s);\nreturn vec2(s, t);\n}\n#endif\n"
    }), n("Shaders/CustomSensorVolumeVS", [], function () {
        "use strict";
        return"attribute vec4 position;\nattribute vec3 normal;\nvarying vec3 v_positionWC;\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvoid main()\n{\ngl_Position = czm_modelViewProjection * position;\nv_positionWC = (czm_model * position).xyz;\nv_positionEC = (czm_modelView * position).xyz;\nv_normalEC = czm_normal * normal;\n}\n"
    }), n("Shaders/CustomSensorVolumeFS", [], function () {
        "use strict";
        return"#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\nuniform bool u_showIntersection;\nuniform bool u_showThroughEllipsoid;\nuniform float u_sensorRadius;\nuniform float u_normalDirection;\nvarying vec3 v_positionWC;\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvec4 getColor(float sensorRadius, vec3 pointEC)\n{\nczm_materialInput materialInput;\nvec3 pointMC = (czm_inverseModelView * vec4(pointEC, 1.0)).xyz;\nmaterialInput.st = sensor2dTextureCoordinates(sensorRadius, pointMC);\nmaterialInput.str = pointMC / sensorRadius;\nvec3 positionToEyeEC = -v_positionEC;\nmaterialInput.positionToEyeEC = positionToEyeEC;\nvec3 normalEC = normalize(v_normalEC);\nmaterialInput.normalEC = u_normalDirection * normalEC;\nczm_material material = czm_getMaterial(materialInput);\nreturn mix(czm_phong(normalize(positionToEyeEC), material), vec4(material.diffuse, material.alpha), 0.4);\n}\nbool isOnBoundary(float value, float epsilon)\n{\nfloat width = getIntersectionWidth();\nfloat tolerance = width * epsilon;\n#ifdef GL_OES_standard_derivatives\nfloat delta = max(abs(dFdx(value)), abs(dFdy(value)));\nfloat pixels = width * delta;\nfloat temp = abs(value);\nreturn temp < tolerance && temp < pixels || (delta < 10.0 * tolerance && temp - delta < tolerance && temp < pixels);\n#else\nreturn abs(value) < tolerance;\n#endif\n}\nvec4 shade(bool isOnBoundary)\n{\nif (u_showIntersection && isOnBoundary)\n{\nreturn getIntersectionColor();\n}\nreturn getColor(u_sensorRadius, v_positionEC);\n}\nfloat ellipsoidSurfaceFunction(czm_ellipsoid ellipsoid, vec3 point)\n{\nvec3 scaled = ellipsoid.inverseRadii * point;\nreturn dot(scaled, scaled) - 1.0;\n}\nvoid main()\n{\nvec3 sensorVertexWC = czm_model[3].xyz;\nvec3 sensorVertexEC = czm_modelView[3].xyz;\nczm_ellipsoid ellipsoid = czm_getWgs84EllipsoidEC();\nfloat ellipsoidValue = ellipsoidSurfaceFunction(ellipsoid, v_positionWC);\nif (!u_showThroughEllipsoid)\n{\nif (ellipsoidValue < 0.0)\n{\ndiscard;\n}\nif (inSensorShadow(sensorVertexWC, ellipsoid, v_positionWC))\n{\ndiscard;\n}\n}\nif (distance(v_positionEC, sensorVertexEC) > u_sensorRadius)\n{\ndiscard;\n}\nbool isOnEllipsoid = isOnBoundary(ellipsoidValue, czm_epsilon3);\ngl_FragColor = shade(isOnEllipsoid);\n}\n"
    }), n("Scene/CustomSensorVolume", ["../Core/defaultValue", "../Core/DeveloperError", "../Core/Color", "../Core/combine", "../Core/destroyObject", "../Core/FAR", "../Core/Cartesian3", "../Core/Matrix4", "../Core/ComponentDatatype", "../Core/PrimitiveType", "../Core/BoundingSphere", "../Renderer/BufferUsage", "../Renderer/BlendingState", "../Renderer/CommandLists", "../Renderer/DrawCommand", "../Renderer/createPickFragmentShaderSource", "../Renderer/CullFace", "./Material", "../Shaders/SensorVolume", "../Shaders/CustomSensorVolumeVS", "../Shaders/CustomSensorVolumeFS", "./SceneMode"], function (e, t, n, i, r, o, a, s, u, l, c, d, f, h, p, m, y, v, g, _, w, C) {
        "use strict";
        function x(e) {
            for (var t = e._directions, n = t.length, i = new Float32Array(3 * n), r = isFinite(e.radius) ? e.radius : o, s = [a.ZERO], u = n - 2, l = n - 1, d = 0; n > d; u = l++, l = d++) {
                var f = a.fromSpherical(t[u]), h = a.fromSpherical(t[l]), p = a.fromSpherical(t[d]), m = Math.max(a.angleBetween(f, h), a.angleBetween(h, p)), y = r / Math.cos(.5 * m), v = h.multiplyByScalar(y);
                i[3 * l + 0] = v.x, i[3 * l + 1] = v.y, i[3 * l + 2] = v.z, s.push(v)
            }
            return c.fromPoints(s, e._frontFaceColorCommand.boundingVolume), i
        }

        function S(e, t) {
            for (var n = x(e), i = e._directions.length, r = new Float32Array(18 * i), o = 0, s = i - 1, l = 0; i > l; s = l++) {
                var c = new a(n[3 * s + 0], n[3 * s + 1], n[3 * s + 2]), d = new a(n[3 * l + 0], n[3 * l + 1], n[3 * l + 2]), f = d.cross(c).normalize();
                r[o++] = 0, r[o++] = 0, r[o++] = 0, r[o++] = f.x, r[o++] = f.y, r[o++] = f.z, r[o++] = d.x, r[o++] = d.y, r[o++] = d.z, r[o++] = f.x, r[o++] = f.y, r[o++] = f.z, r[o++] = c.x, r[o++] = c.y, r[o++] = c.z, r[o++] = f.x, r[o++] = f.y, r[o++] = f.z
            }
            var h = t.createVertexBuffer(new Float32Array(r), e.bufferUsage), p = 6 * Float32Array.BYTES_PER_ELEMENT, m = [
                {index: b.position, vertexBuffer: h, componentsPerAttribute: 3, componentDatatype: u.FLOAT, offsetInBytes: 0, strideInBytes: p},
                {index: b.normal, vertexBuffer: h, componentsPerAttribute: 3, componentDatatype: u.FLOAT, offsetInBytes: 3 * Float32Array.BYTES_PER_ELEMENT, strideInBytes: p}
            ];
            return t.createVertexArray(m)
        }

        var b = {position: 0, normal: 1}, T = function (t) {
            t = e(t, e.EMPTY_OBJECT), this._pickId = void 0, this._pickIdThis = e(t._pickIdThis, this), this._frontFaceColorCommand = new p, this._backFaceColorCommand = new p, this._pickCommand = new p, this._commandLists = new h, this._frontFaceColorCommand.primitiveType = l.TRIANGLES, this._frontFaceColorCommand.boundingVolume = new c, this._frontFaceColorCommand.owner = this, this._backFaceColorCommand.primitiveType = this._frontFaceColorCommand.primitiveType, this._backFaceColorCommand.boundingVolume = this._frontFaceColorCommand.boundingVolume, this._backFaceColorCommand.owner = this, this._pickCommand.primitiveType = this._frontFaceColorCommand.primitiveType, this._pickCommand.boundingVolume = this._frontFaceColorCommand.boundingVolume, this._pickCommand.owner = this, this.show = e(t.show, !0), this.showIntersection = e(t.showIntersection, !0), this.showThroughEllipsoid = e(t.showThroughEllipsoid, !1), this._showThroughEllipsoid = this.showThroughEllipsoid, this.modelMatrix = s.clone(e(t.modelMatrix, s.IDENTITY)), this.bufferUsage = e(t.bufferUsage, d.STATIC_DRAW), this._bufferUsage = this.bufferUsage, this.radius = e(t.radius, Number.POSITIVE_INFINITY), this._directions = void 0, this._directionsDirty = !1, this.setDirections(t.directions), this.material = "undefined" != typeof t.material ? t.material : v.fromType(void 0, v.ColorType), this._material = void 0, this.intersectionColor = n.clone(e(t.intersectionColor, n.WHITE)), this.intersectionWidth = e(t.intersectionWidth, 5);
            var i = this;
            this._uniforms = {u_showThroughEllipsoid: function () {
                return i.showThroughEllipsoid
            }, u_showIntersection: function () {
                return i.showIntersection
            }, u_sensorRadius: function () {
                return isFinite(i.radius) ? i.radius : o
            }, u_intersectionColor: function () {
                return i.intersectionColor
            }, u_intersectionWidth: function () {
                return i.intersectionWidth
            }, u_normalDirection: function () {
                return 1
            }}, this._mode = C.SCENE3D
        };
        return T.prototype.setDirections = function (e) {
            this._directions = e, this._directionsDirty = !0
        }, T.prototype.getDirections = function () {
            return this._directions
        }, T.prototype.update = function (e, n, r) {
            if (this._mode = n.mode, this.show && this._mode === C.SCENE3D) {
                if (this.radius < 0)throw new t("this.radius must be greater than or equal to zero.");
                if ("undefined" == typeof this.material)throw new t("this.material must be defined.");
                if (this._showThroughEllipsoid !== this.showThroughEllipsoid || "undefined" == typeof this._frontFaceColorCommand.renderState) {
                    this._showThroughEllipsoid = this.showThroughEllipsoid;
                    var o = e.createRenderState({depthTest: {enabled: !this.showThroughEllipsoid}, depthMask: !1, blending: f.ALPHA_BLEND, cull: {enabled: !0, face: y.BACK}});
                    this._frontFaceColorCommand.renderState = o, o = e.createRenderState({depthTest: {enabled: !this.showThroughEllipsoid}, depthMask: !1, blending: f.ALPHA_BLEND, cull: {enabled: !0, face: y.FRONT}}), this._backFaceColorCommand.renderState = o, o = e.createRenderState({depthTest: {enabled: !this.showThroughEllipsoid}, depthMask: !1, blending: f.ALPHA_BLEND}), this._pickCommand.renderState = o
                }
                if (this._directionsDirty || this._bufferUsage !== this.bufferUsage) {
                    this._directionsDirty = !1, this._bufferUsage = this.bufferUsage, this._va = this._va && this._va.destroy();
                    var a = this._directions;
                    a && a.length >= 3 && (this._frontFaceColorCommand.vertexArray = S(this, e), this._backFaceColorCommand.vertexArray = this._frontFaceColorCommand.vertexArray, this._pickCommand.vertexArray = this._frontFaceColorCommand.vertexArray)
                }
                if ("undefined" != typeof this._frontFaceColorCommand.vertexArray) {
                    var s = n.passes;
                    this._commandLists.removeAll(), this._frontFaceColorCommand.modelMatrix = this.modelMatrix, this._backFaceColorCommand.modelMatrix = this._frontFaceColorCommand.modelMatrix, this._pickCommand.modelMatrix = this._frontFaceColorCommand.modelMatrix;
                    var u = this._material !== this.material;
                    if (this._material = this.material, s.color) {
                        var l = this._frontFaceColorCommand, c = this._backFaceColorCommand;
                        if (u || "undefined" == typeof l.shaderProgram) {
                            var d = "#line 0\n" + g + "#line 0\n" + this._material.shaderSource + "#line 0\n" + w;
                            l.shaderProgram = e.getShaderCache().replaceShaderProgram(l.shaderProgram, _, d, b), l.uniformMap = i([this._uniforms, this._material._uniforms], !1, !1), c.shaderProgram = l.shaderProgram, c.uniformMap = i([this._uniforms, this._material._uniforms], !1, !1), c.uniformMap.u_normalDirection = function () {
                                return-1
                            }
                        }
                        this._commandLists.colorList.push(c), this._commandLists.colorList.push(l)
                    }
                    if (s.pick) {
                        var h = this._pickCommand;
                        if ("undefined" == typeof this._pickId && (this._pickId = e.createPickId(this._pickIdThis)), u || "undefined" == typeof h.shaderProgram) {
                            var p = m("#line 0\n" + g + "#line 0\n" + this._material.shaderSource + "#line 0\n" + w, "uniform");
                            h.shaderProgram = e.getShaderCache().replaceShaderProgram(h.shaderProgram, _, p, b);
                            var v = this;
                            h.uniformMap = i([this._uniforms, this._material._uniforms, {czm_pickColor: function () {
                                return v._pickId.color
                            }}], !1, !1)
                        }
                        this._commandLists.pickList.push(h)
                    }
                    this._commandLists.empty() || r.push(this._commandLists)
                }
            }
        }, T.prototype.isDestroyed = function () {
            return!1
        }, T.prototype.destroy = function () {
            return this._frontFaceColorCommand.vertexArray = this._frontFaceColorCommand.vertexArray && this._frontFaceColorCommand.vertexArray.destroy(), this._frontFaceColorCommand.shaderProgram = this._frontFaceColorCommand.shaderProgram && this._frontFaceColorCommand.shaderProgram.release(), this._pickCommand.shaderProgram = this._pickCommand.shaderProgram && this._pickCommand.shaderProgram.release(), this._pickId = this._pickId && this._pickId.destroy(), r(this)
        }, T
    }), n("DynamicScene/DynamicConeVisualizerUsingCustomSensor", ["../Core/Cartesian3", "../Core/Color", "../Core/defaultValue", "../Core/destroyObject", "../Core/DeveloperError", "../Core/Quaternion", "../Core/Math", "../Core/Matrix3", "../Core/Matrix4", "../Core/Spherical", "../Scene/CustomSensorVolume", "../Scene/Material"], function (e, t, n, i, r, o, a, s, u, l, c, d) {
        "use strict";
        function f(e, t, n, i) {
            var r = t[e];
            "undefined" == typeof r && (t[e] = r = new l), r.clock = n, r.cone = i, r.magnitude = 1
        }

        function h(e, t, n, i, r) {
            var o, s = 0, u = a.toRadians(2);
            if (0 === e && t === a.TWO_PI)for (o = 0; o < a.TWO_PI; o += u)f(s++, r, o, i); else {
                for (o = e; t > o; o += u)f(s++, r, o, i);
                if (f(s++, r, t, i), n) {
                    for (o = t; o > e; o -= u)f(s++, r, o, n);
                    f(s++, r, e, n)
                } else f(s++, r, t, 0)
            }
            return r.length = s, r
        }

        function p(e, n, i) {
            var r = e._scene.getContext(), o = i.cone;
            if ("undefined" != typeof o) {
                var l = i.position;
                if ("undefined" != typeof l) {
                    var f = i.orientation;
                    if ("undefined" != typeof f) {
                        var p, y = o.show, _ = i._coneVisualizerIndex, w = i.isAvailable(n) && ("undefined" == typeof y || y.getValue(n));
                        if (!w)return"undefined" != typeof _ && (p = e._coneCollection[_], p.show = !1, i._coneVisualizerIndex = void 0, e._unusedIndexes.push(_)), void 0;
                        if ("undefined" == typeof _) {
                            var C = e._unusedIndexes, x = C.length;
                            x > 0 ? (_ = C.pop(), p = e._coneCollection[_]) : (_ = e._coneCollection.length, p = new c, p._directionsScratch = [], e._coneCollection.push(p), e._primitives.add(p)), i._coneVisualizerIndex = _, p.dynamicObject = i, p.material = d.fromType(r, d.ColorType), p.intersectionColor = t.YELLOW.clone(), p.intersectionWidth = 5, p.radius = Number.POSITIVE_INFINITY, p.showIntersection = !0
                        } else p = e._coneCollection[_];
                        p.show = !0;
                        var S, b = o.minimumClockAngle;
                        "undefined" != typeof b && (S = b.getValue(n)), "undefined" == typeof S && (S = 0);
                        var T;
                        b = o.maximumClockAngle, "undefined" != typeof b && (T = b.getValue(n)), "undefined" == typeof T && (T = a.TWO_PI);
                        var E;
                        b = o.innerHalfAngle, "undefined" != typeof b && (E = b.getValue(n)), "undefined" == typeof E && (E = 0);
                        var A;
                        if (b = o.outerHalfAngle, "undefined" != typeof b && (A = b.getValue(n)), "undefined" == typeof A && (A = Math.PI), (S !== p.minimumClockAngle || T !== p.maximumClockAngle || E !== p.innerHalfAngle || A !== p.outerHalfAngle) && (p.setDirections(h(S, T, E, A, p._directionsScratch)), p.innerHalfAngle = E, p.maximumClockAngle = T, p.outerHalfAngle = A, p.minimumClockAngle = S), b = o.radius, "undefined" != typeof b) {
                            var M = b.getValue(n);
                            "undefined" != typeof M && (p.radius = M)
                        }
                        var D = l.getValueCartesian(n, v), I = f.getValue(n, g);
                        "undefined" == typeof D || "undefined" == typeof I || D.equals(p._visualizerPosition) && I.equals(p._visualizerOrientation) || (u.fromRotationTranslation(s.fromQuaternion(I, m), D, p.modelMatrix), p._visualizerPosition = D.clone(p._visualizerPosition), p._visualizerOrientation = I.clone(p._visualizerOrientation));
                        var P = o.outerMaterial;
                        if ("undefined" != typeof P && (p.material = P.getValue(n, r, p.material)), b = o.intersectionColor, "undefined" != typeof b && b.getValue(n, p.intersectionColor), b = o.intersectionWidth, "undefined" != typeof b) {
                            var O = b.getValue(n);
                            "undefined" != typeof O && (p.intersectionWidth = O)
                        }
                    }
                }
            }
        }

        var m = new s, y = function (e, t) {
            if ("undefined" == typeof e)throw new r("scene is required.");
            this._scene = e, this._unusedIndexes = [], this._primitives = e.getPrimitives(), this._coneCollection = [], this._dynamicObjectCollection = void 0, this.setDynamicObjectCollection(t)
        };
        y.prototype.getScene = function () {
            return this._scene
        }, y.prototype.getDynamicObjectCollection = function () {
            return this._dynamicObjectCollection
        }, y.prototype.setDynamicObjectCollection = function (e) {
            var t = this._dynamicObjectCollection;
            t !== e && ("undefined" != typeof t && (t.objectsRemoved.removeEventListener(y.prototype._onObjectsRemoved, this), this.removeAllPrimitives()), this._dynamicObjectCollection = e, "undefined" != typeof e && e.objectsRemoved.addEventListener(y.prototype._onObjectsRemoved, this))
        }, y.prototype.update = function (e) {
            if ("undefined" == typeof e)throw new r("time is requied.");
            if ("undefined" != typeof this._dynamicObjectCollection)for (var t = this._dynamicObjectCollection.getObjects(), n = 0, i = t.length; i > n; n++)p(this, e, t[n])
        }, y.prototype.removeAllPrimitives = function () {
            var e, t;
            for (e = 0, t = this._coneCollection.length; t > e; e++)this._primitives.remove(this._coneCollection[e]);
            if ("undefined" != typeof this._dynamicObjectCollection) {
                var n = this._dynamicObjectCollection.getObjects();
                for (e = n.length - 1; e > -1; e--)n[e]._coneVisualizerIndex = void 0
            }
            this._unusedIndexes = [], this._coneCollection = []
        }, y.prototype.isDestroyed = function () {
            return!1
        }, y.prototype.destroy = function () {
            return this.removeAllPrimitives(), i(this)
        };
        var v = new e, g = new o;
        return y.prototype._onObjectsRemoved = function (e, t) {
            for (var n = this._coneCollection, i = this._unusedIndexes, r = t.length - 1; r > -1; r--) {
                var o = t[r], a = o._coneVisualizerIndex;
                if ("undefined" != typeof a) {
                    var s = n[a];
                    s.show = !1, i.push(a), o._coneVisualizerIndex = void 0
                }
            }
        }, y
    }), n("Scene/Label", ["../Core/defaultValue", "../Core/DeveloperError", "../Core/Cartesian2", "../Core/Cartesian3", "../Core/Color", "./Billboard", "./LabelStyle", "./HorizontalOrigin", "./VerticalOrigin"], function (e, t, n, i, r, o, a, s, u) {
        "use strict";
        function l(e) {
            e._rebindAllGlyphs || e._repositionAllGlyphs || e._labelCollection._labelsToUpdate.push(e), e._rebindAllGlyphs = !0
        }

        function c(e) {
            e._rebindAllGlyphs || e._repositionAllGlyphs || e._labelCollection._labelsToUpdate.push(e), e._repositionAllGlyphs = !0
        }

        var d = function (t, o) {
            t = e(t, e.EMPTY_OBJECT), this._text = e(t.text, ""), this._show = e(t.show, !0), this._font = e(t.font, "30px sans-serif"), this._fillColor = r.clone(e(t.fillColor, r.WHITE)), this._outlineColor = r.clone(e(t.outlineColor, r.BLACK)), this._outlineWidth = e(t.outlineWidth, 1), this._style = e(t.style, a.FILL), this._verticalOrigin = e(t.verticalOrigin, u.BOTTOM), this._horizontalOrigin = e(t.horizontalOrigin, s.LEFT), this._pixelOffset = n.clone(e(t.pixelOffset, n.ZERO)), this._eyeOffset = i.clone(e(t.eyeOffset, i.ZERO)), this._position = i.clone(e(t.position, i.ZERO)), this._scale = e(t.scale, 1), this._labelCollection = o, this._glyphs = [], this._rebindAllGlyphs = !0, this._repositionAllGlyphs = !0
        };
        return d.prototype.getShow = function () {
            return this._show
        }, d.prototype.setShow = function (e) {
            if ("undefined" == typeof e)throw new t("value is required.");
            if (e !== this._show) {
                this._show = e;
                for (var n = this._glyphs, i = 0, r = n.length; r > i; i++) {
                    var o = n[i];
                    "undefined" != typeof o.billboard && o.billboard.setShow(e)
                }
            }
        }, d.prototype.getPosition = function () {
            return this._position
        }, d.prototype.setPosition = function (e) {
            if ("undefined" == typeof e)throw new t("value is required.");
            var n = this._position;
            if (!i.equals(n, e)) {
                i.clone(e, n);
                for (var r = this._glyphs, o = 0, a = r.length; a > o; o++) {
                    var s = r[o];
                    "undefined" != typeof s.billboard && s.billboard.setPosition(e)
                }
            }
        }, d.prototype.getText = function () {
            return this._text
        }, d.prototype.setText = function (e) {
            if ("undefined" == typeof e)throw new t("value is required.");
            e !== this._text && (this._text = e, l(this))
        }, d.prototype.getFont = function () {
            return this._font
        }, d.prototype.setFont = function (e) {
            if ("undefined" == typeof e)throw new t("value is required.");
            this._font !== e && (this._font = e, l(this))
        }, d.prototype.getFillColor = function () {
            return this._fillColor
        }, d.prototype.setFillColor = function (e) {
            if ("undefined" == typeof e)throw new t("value is required.");
            var n = this._fillColor;
            r.equals(n, e) || (r.clone(e, n), l(this))
        }, d.prototype.getOutlineColor = function () {
            return this._outlineColor
        }, d.prototype.setOutlineColor = function (e) {
            if ("undefined" == typeof e)throw new t("value is required.");
            var n = this._outlineColor;
            r.equals(n, e) || (r.clone(e, n), l(this))
        }, d.prototype.getOutlineWidth = function () {
            return this._outlineWidth
        }, d.prototype.setOutlineWidth = function (e) {
            if ("undefined" == typeof e)throw new t("value is required.");
            this._outlineWidth !== e && (this._outlineWidth = e, l(this))
        }, d.prototype.getStyle = function () {
            return this._style
        }, d.prototype.setStyle = function (e) {
            if ("undefined" == typeof e)throw new t("value is required.");
            this._style !== e && (this._style = e, l(this))
        }, d.prototype.getPixelOffset = function () {
            return this._pixelOffset
        }, d.prototype.setPixelOffset = function (e) {
            if ("undefined" == typeof e)throw new t("value is required.");
            var i = this._pixelOffset;
            n.equals(i, e) || (n.clone(e, i), c(this))
        }, d.prototype.getEyeOffset = function () {
            return this._eyeOffset
        }, d.prototype.setEyeOffset = function (e) {
            if ("undefined" == typeof e)throw new t("value is required.");
            var n = this._eyeOffset;
            if (!i.equals(n, e)) {
                i.clone(e, n);
                for (var r = this._glyphs, o = 0, a = r.length; a > o; o++) {
                    var s = r[o];
                    "undefined" != typeof s.billboard && s.billboard.setEyeOffset(e)
                }
            }
        }, d.prototype.getHorizontalOrigin = function () {
            return this._horizontalOrigin
        }, d.prototype.setHorizontalOrigin = function (e) {
            if ("undefined" == typeof e)throw new t("value is required.");
            this._horizontalOrigin !== e && (this._horizontalOrigin = e, c(this))
        }, d.prototype.getVerticalOrigin = function () {
            return this._verticalOrigin
        }, d.prototype.setVerticalOrigin = function (e) {
            if ("undefined" == typeof e)throw new t("value is required.");
            this._verticalOrigin !== e && (this._verticalOrigin = e, c(this))
        }, d.prototype.getScale = function () {
            return this._scale
        }, d.prototype.setScale = function (e) {
            if ("undefined" == typeof e)throw new t("value is required.");
            if (this._scale !== e) {
                this._scale = e;
                for (var n = this._glyphs, i = 0, r = n.length; r > i; i++) {
                    var o = n[i];
                    "undefined" != typeof o.billboard && o.billboard.setScale(e)
                }
                c(this)
            }
        }, d.prototype.computeScreenSpacePosition = function (e, n) {
            if ("undefined" == typeof e)throw new t("context is required.");
            if ("undefined" == typeof n)throw new t("frameState is required.");
            var i = this._labelCollection, r = i.modelMatrix, a = o._computeActualPosition(this._position, n, r);
            return o._computeScreenSpacePosition(r, a, this._eyeOffset, this._pixelOffset, e, n)
        }, d.prototype.equals = function (e) {
            return this === e || "undefined" != typeof e && this._show === e._show && this._scale === e._scale && this._style === e._style && this._verticalOrigin === e._verticalOrigin && this._horizontalOrigin === e._horizontalOrigin && this._text === e._text && this._font === e._font && i.equals(this._position, e._position) && r.equals(this._fillColor, e._fillColor) && r.equals(this._outlineColor, e._outlineColor) && n.equals(this._pixelOffset, e._pixelOffset) && i.equals(this._eyeOffset, e._eyeOffset)
        }, d.prototype.isDestroyed = function () {
            return!1
        }, d
    }), n("Scene/LabelCollection", ["../Core/DeveloperError", "../Core/destroyObject", "../Core/Cartesian2", "../Core/Matrix4", "../Core/writeTextToCanvas", "./BillboardCollection", "./Label", "./LabelStyle", "./HorizontalOrigin", "./VerticalOrigin"], function (e, t, n, i, r, o, a, s, u, l) {
        "use strict";
        function c() {
            this.textureInfo = void 0, this.dimensions = void 0, this.billboard = void 0
        }

        function d(e, t, n) {
            this.labelCollection = e, this.index = t, this.dimensions = n
        }

        function f(e, t, n, i, o, a, u) {
            return v.font = t, v.fillColor = n, v.strokeColor = i, v.strokeWidth = o, v.textBaseline = u === l.BOTTOM ? "bottom" : u === l.TOP ? "top" : "middle", v.fill = a === s.FILL || a === s.FILL_AND_OUTLINE, v.stroke = a === s.OUTLINE || a === s.FILL_AND_OUTLINE, r(e, v)
        }

        function h(e, t) {
            t.textureInfo = void 0, t.dimensions = void 0;
            var n = t.billboard;
            "undefined" != typeof n && (n.setShow(!1), n.setImageIndex(-1), e._spareBillboards.push(n), t.billboard = void 0)
        }

        function p(e, t) {
            var n, i, r, o = t._text, a = o.length, s = t._glyphs, l = s.length;
            if (l > a)for (i = a; l > i; ++i)h(e, s[i]);
            s.length = a;
            var p = e._glyphTextureCache, m = e._textureAtlas;
            for (r = 0; a > r; ++r) {
                var y = o.charAt(r), v = t._font, g = t._fillColor, _ = t._outlineColor, w = t._outlineWidth, C = t._style, x = t._verticalOrigin, S = JSON.stringify([y, v, g.toRgba(), _.toRgba(), w, +C, +x]), b = p[S];
                if ("undefined" == typeof b) {
                    var T = f(y, v, g, _, w, C, x), E = -1;
                    T.width > 0 && T.height > 0 && (E = m.addImage(T)), b = new d(e, E, T.dimensions), p[S] = b
                }
                if (n = s[r], "undefined" != typeof n ? -1 === b.index ? h(e, n) : "undefined" != typeof n.textureInfo && (n.textureInfo = void 0) : (n = new c, s[r] = n), n.textureInfo = b, n.dimensions = b.dimensions, -1 !== b.index) {
                    var A = n.billboard;
                    "undefined" == typeof A && (n.billboard = A = e._spareBillboards.length > 0 ? e._spareBillboards.pop() : e._billboardCollection.add(), A.setShow(t._show), A.setPosition(t._position), A.setEyeOffset(t._eyeOffset), A.setHorizontalOrigin(u.LEFT), A.setVerticalOrigin(t._verticalOrigin), A.setScale(t._scale), A._pickIdThis = t), n.billboard.setImageIndex(b.index)
                }
            }
            t._repositionAllGlyphs = !0
        }

        function m(e) {
            var t, n, i = e._glyphs, r = 0, o = 0, a = 0, s = i.length;
            for (a = 0; s > a; ++a)t = i[a], n = t.dimensions, r += n.width, o = Math.max(o, n.height);
            var c = e._scale, d = e._horizontalOrigin, f = 0;
            d === u.CENTER ? f -= r / 2 * c : d === u.RIGHT && (f -= r * c);
            var h = e._pixelOffset;
            g.x = h.x + f, g.y = 0;
            var p = e._verticalOrigin;
            for (a = 0; s > a; ++a)t = i[a], n = t.dimensions, p === l.BOTTOM || n.height === o ? g.y = h.y - n.descent * c : p === l.TOP ? g.y = h.y - (o - n.height) * c - n.descent * c : p === l.CENTER && (g.y = h.y - (o - n.height) / 2 * c - n.descent * c), "undefined" != typeof t.billboard && t.billboard.setPixelOffset(g), g.x += n.width * c
        }

        function y(e, n) {
            for (var i = n._glyphs, r = 0, o = i.length; o > r; ++r)h(e, i[r]);
            n._labelCollection = void 0, t(n)
        }

        var v = {}, g = new n, _ = function () {
            this._textureAtlas = void 0, this._billboardCollection = new o, this._billboardCollection.setDestroyTextureAtlas(!1), this._spareBillboards = [], this._glyphTextureCache = {}, this._labels = [], this._labelsToUpdate = [], this._totalGlyphCount = 0, this.modelMatrix = i.IDENTITY.clone()
        };
        return _.prototype.add = function (e) {
            var t = new a(e, this);
            return this._labels.push(t), this._labelsToUpdate.push(t), t
        }, _.prototype.remove = function (e) {
            if ("undefined" != typeof e && e._labelCollection === this) {
                var t = this._labels.indexOf(e);
                if (-1 !== t)return this._labels.splice(t, 1), y(this, e), !0
            }
            return!1
        }, _.prototype.removeAll = function () {
            for (var e = this._labels, t = 0, n = e.length; n > t; ++t)y(this, e[t]);
            e.length = 0
        }, _.prototype.contains = function (e) {
            return"undefined" != typeof e && e._labelCollection === this
        }, _.prototype.get = function (t) {
            if ("undefined" == typeof t)throw new e("index is required.");
            return this._labels[t]
        }, _.prototype.getLength = function () {
            return this._labels.length
        }, _.prototype.update = function (e, t, n) {
            var i = this._billboardCollection;
            i.modelMatrix = this.modelMatrix, "undefined" == typeof this._textureAtlas && (this._textureAtlas = e.createTextureAtlas(), i.setTextureAtlas(this._textureAtlas));
            for (var r = this._labelsToUpdate, o = 0, a = r.length; a > o; ++o) {
                var s = r[o];
                if (!s.isDestroyed()) {
                    var u = s._glyphs.length;
                    s._rebindAllGlyphs && (p(this, s), s._rebindAllGlyphs = !1), s._repositionAllGlyphs && (m(s), s._repositionAllGlyphs = !1);
                    var l = s._glyphs.length - u;
                    this._totalGlyphCount += l
                }
            }
            r.length = 0, this._billboardCollection.update(e, t, n)
        }, _.prototype.isDestroyed = function () {
            return!1
        }, _.prototype.destroy = function () {
            return this.removeAll(), this._billboardCollection = this._billboardCollection.destroy(), this._textureAtlas = this._textureAtlas && this._textureAtlas.destroy(), t(this)
        }, _
    }), n("DynamicScene/DynamicLabelVisualizer", ["../Core/DeveloperError", "../Core/destroyObject", "../Core/Color", "../Core/Cartesian2", "../Core/Cartesian3", "../Scene/LabelCollection", "../Scene/LabelStyle", "../Scene/HorizontalOrigin", "../Scene/VerticalOrigin"], function (e, t, n, i, r, o, a, s, u) {
        "use strict";
        function l(e, t, o) {
            var l = o.label;
            if ("undefined" != typeof l) {
                var c = l.text;
                if ("undefined" != typeof c) {
                    var y = o.position;
                    if ("undefined" != typeof y) {
                        var v, g = l.show, _ = o._labelVisualizerIndex, w = o.isAvailable(t) && ("undefined" == typeof g || g.getValue(t));
                        if (!w)return"undefined" != typeof _ && (v = e._labelCollection.get(_), v.setShow(!1), e._unusedIndexes.push(_), o._labelVisualizerIndex = void 0), void 0;
                        if ("undefined" == typeof _) {
                            var C = e._unusedIndexes, x = C.length;
                            x > 0 ? (_ = C.pop(), v = e._labelCollection.get(_)) : (_ = e._labelCollection.getLength(), v = e._labelCollection.add()), o._labelVisualizerIndex = _, v.dynamicObject = o, v.setText(""), v.setScale(1), v.setFont("30px sans-serif"), v.setFillColor(n.WHITE), v.setOutlineColor(n.BLACK), v.setOutlineWidth(1), v.setStyle(a.FILL), v.setPixelOffset(i.ZERO), v.setEyeOffset(r.ZERO), v.setHorizontalOrigin(s.CENTER), v.setVerticalOrigin(u.CENTER)
                        } else v = e._labelCollection.get(_);
                        v.setShow(w);
                        var S = c.getValue(t);
                        "undefined" != typeof S && v.setText(S), d = y.getValueCartesian(t, d), "undefined" != typeof d && v.setPosition(d);
                        var b = l.scale;
                        if ("undefined" != typeof b) {
                            var T = b.getValue(t);
                            "undefined" != typeof T && v.setScale(T)
                        }
                        if (b = l.font, "undefined" != typeof b) {
                            var E = b.getValue(t);
                            "undefined" != typeof E && v.setFont(E)
                        }
                        if (b = l.fillColor, "undefined" != typeof b && (f = b.getValue(t, f), "undefined" != typeof f && v.setFillColor(f)), b = l.outlineColor, "undefined" != typeof b && (h = b.getValue(t, h), "undefined" != typeof h && v.setOutlineColor(h)), b = l.outlineWidth, "undefined" != typeof b) {
                            var A = b.getValue(t);
                            "undefined" != typeof A && v.setOutlineWidth(A)
                        }
                        if (b = l.style, "undefined" != typeof b) {
                            var M = b.getValue(t);
                            "undefined" != typeof M && v.setStyle(M)
                        }
                        if (b = l.pixelOffset, "undefined" != typeof b && (m = b.getValue(t, m), "undefined" != typeof m && v.setPixelOffset(m)), b = l.eyeOffset, "undefined" != typeof b && (p = b.getValue(t, p), "undefined" != typeof p && v.setEyeOffset(p)), b = l.horizontalOrigin, "undefined" != typeof b) {
                            var D = b.getValue(t);
                            "undefined" != typeof D && v.setHorizontalOrigin(D)
                        }
                        if (b = l.verticalOrigin, "undefined" != typeof b) {
                            var I = b.getValue(t);
                            "undefined" != typeof I && v.setVerticalOrigin(I)
                        }
                    }
                }
            }
        }

        var c = function (t, n) {
            if ("undefined" == typeof t)throw new e("scene is required.");
            this._scene = t, this._unusedIndexes = [], this._dynamicObjectCollection = void 0;
            var i = this._labelCollection = new o;
            t.getPrimitives().add(i), this.setDynamicObjectCollection(n)
        };
        c.prototype.getScene = function () {
            return this._scene
        }, c.prototype.getDynamicObjectCollection = function () {
            return this._dynamicObjectCollection
        }, c.prototype.setDynamicObjectCollection = function (e) {
            var t = this._dynamicObjectCollection;
            t !== e && ("undefined" != typeof t && (t.objectsRemoved.removeEventListener(c.prototype._onObjectsRemoved, this), this.removeAllPrimitives()), this._dynamicObjectCollection = e, "undefined" != typeof e && e.objectsRemoved.addEventListener(c.prototype._onObjectsRemoved, this))
        }, c.prototype.update = function (t) {
            if ("undefined" == typeof t)throw new e("time is requied.");
            if ("undefined" != typeof this._dynamicObjectCollection)for (var n = this._dynamicObjectCollection.getObjects(), i = 0, r = n.length; r > i; i++)l(this, t, n[i])
        }, c.prototype.removeAllPrimitives = function () {
            if (this._unusedIndexes = [], this._labelCollection.removeAll(), "undefined" != typeof this._dynamicObjectCollection)for (var e = this._dynamicObjectCollection.getObjects(), t = e.length - 1; t > -1; t--)e[t]._labelVisualizerIndex = void 0
        }, c.prototype.isDestroyed = function () {
            return!1
        }, c.prototype.destroy = function () {
            return this.removeAllPrimitives(), this._scene.getPrimitives().remove(this._labelCollection), t(this)
        };
        var d, f, h, p, m;
        return c.prototype._onObjectsRemoved = function (e, t) {
            for (var n = this._labelCollection, i = this._unusedIndexes, r = t.length - 1; r > -1; r--) {
                var o = t[r], a = o._labelVisualizerIndex;
                if ("undefined" != typeof a) {
                    var s = n.get(a);
                    s.setShow(!1), i.push(a), o._labelVisualizerIndex = void 0
                }
            }
        }, c
    }), n("Scene/Polyline", ["../Core/defaultValue", "../Core/DeveloperError", "../Core/BoundingSphere", "../Core/Color", "../Core/PolylinePipeline", "../Core/Matrix4", "./Material"], function (e, t, n, i, r, o, a) {
        "use strict";
        function s(e, t) {
            ++e._propertiesChanged[t];
            var n = e._polylineCollection;
            "undefined" != typeof n && (n._updatePolyline(e, t), e._dirty = !0)
        }

        var u = {}, l = function (t, s) {
            t = e(t, u), this._show = e(t.show, !0), this._width = e(t.width, 1), this._material = t.material, "undefined" == typeof this._material && (this._material = a.fromType(void 0, a.ColorType), this._material.uniforms.color = new i(1, 1, 1, 1));
            var l = t.positions;
            "undefined" == typeof l && (l = []), this._positions = l;
            var c;
            "undefined" != typeof this._polylineCollection && (c = o.clone(this._polylineCollection.modelMatrix)), this._modelMatrix = c, this._segments = r.wrapLongitude(l, c), this._actualLength = void 0, this._propertiesChanged = new Uint32Array(m), this._polylineCollection = s, this._dirty = !1, this._pickId = void 0, this._pickIdThis = t._pickIdThis, this._boundingVolume = n.fromPoints(this._positions), this._boundingVolume2D = new n
        }, c = l.SHOW_INDEX = 0, d = l.WIDTH_INDEX = 1, f = l.POSITION_INDEX = 2, h = l.MATERIAL_INDEX = 3, p = l.POSITION_SIZE_INDEX = 4, m = l.NUMBER_OF_PROPERTIES = 5;
        return l.prototype.getShow = function () {
            return this._show
        }, l.prototype.setShow = function (e) {
            if ("undefined" == typeof e)throw new t("value is required.");
            e !== this._show && (this._show = e, s(this, c))
        }, l.prototype.getPositions = function () {
            return this._positions
        }, l.prototype.setPositions = function (e) {
            if ("undefined" == typeof e)throw new t("value is required.");
            this._positions.length !== e.length && s(this, p), this._positions = e, this._boundingVolume = n.fromPoints(this._positions, this._boundingVolume), s(this, f), this.update()
        }, l.prototype.update = function () {
            var e = o.IDENTITY;
            "undefined" != typeof this._polylineCollection && (e = this._polylineCollection.modelMatrix);
            var t = this._segments.positions.length, n = this._segments.lengths, i = this._propertiesChanged[f] > 0 || this._propertiesChanged[p] > 0;
            if ((!e.equals(this._modelMatrix) || i) && (this._segments = r.wrapLongitude(this._positions, e)), this._modelMatrix = e, this._segments.positions.length !== t)s(this, p); else for (var a = n.length, u = 0; a > u; ++u)if (n[u] !== this._segments.lengths[u]) {
                s(this, p);
                break
            }
        }, l.prototype.getMaterial = function () {
            return this._material
        }, l.prototype.setMaterial = function (e) {
            if ("undefined" == typeof e)throw new t("material is required.");
            this._material = e, s(this, h)
        }, l.prototype.getWidth = function () {
            return this._width
        }, l.prototype.setWidth = function (e) {
            if ("undefined" == typeof e)throw new t("value is required.");
            var n = this._width;
            e !== n && (this._width = e, s(this, d))
        }, l.prototype.getPickId = function (t) {
            return"undefined" == typeof this._pickId && (this._pickId = t.createPickId(e(this._pickIdThis, this))), this._pickId
        }, l.prototype._clean = function () {
            this._dirty = !1;
            for (var e = this._propertiesChanged, t = 0; m - 1 > t; ++t)e[t] = 0
        }, l.prototype._destroy = function () {
            this._pickId = this._pickId && this._pickId.destroy(), this._material = this._material && this._material.destroy(), this._polylineCollection = void 0
        }, l
    }), n("Shaders/PolylineVS", [], function () {
        "use strict";
        return"attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 position2DHigh;\nattribute vec3 position2DLow;\nattribute vec3 prevPosition3DHigh;\nattribute vec3 prevPosition3DLow;\nattribute vec3 prevPosition2DHigh;\nattribute vec3 prevPosition2DLow;\nattribute vec3 nextPosition3DHigh;\nattribute vec3 nextPosition3DLow;\nattribute vec3 nextPosition2DHigh;\nattribute vec3 nextPosition2DLow;\nattribute vec4 texCoordExpandWidthAndShow;\nattribute vec4 pickColor;\nvarying vec2  v_textureCoordinates;\nvarying float v_width;\nvarying vec4  czm_pickColor;\nconst vec2 czm_highResolutionSnapScale = vec2(1.0, 1.0);\nvoid clipLineSegmentToNearPlane(\nvec3 p0,\nvec3 p1,\nout vec4 positionWC,\nout bool clipped,\nout bool culledByNearPlane)\n{\nculledByNearPlane = false;\nclipped = false;\nvec3 p1ToP0 = p1 - p0;\nfloat magnitude = length(p1ToP0);\nvec3 direction = normalize(p1ToP0);\nfloat endPoint0Distance =  -(czm_currentFrustum.x + p0.z);\nfloat denominator = -direction.z;\nif (endPoint0Distance < 0.0 && abs(denominator) < czm_epsilon7)\n{\nculledByNearPlane = true;\n}\nelse if (endPoint0Distance < 0.0 && abs(denominator) > czm_epsilon7)\n{\nfloat t = (czm_currentFrustum.x + p0.z) / denominator;\nif (t < 0.0 || t > magnitude)\n{\nculledByNearPlane = true;\n}\nelse\n{\np0 = p0 + t * direction;\nclipped = true;\n}\n}\npositionWC = czm_eyeToWindowCoordinates(vec4(p0, 1.0));\n}\nvoid main()\n{\nfloat texCoord = texCoordExpandWidthAndShow.x;\nfloat expandDir = texCoordExpandWidthAndShow.y;\nfloat width = abs(texCoordExpandWidthAndShow.z) + 0.5;\nbool usePrev = texCoordExpandWidthAndShow.z < 0.0;\nfloat show = texCoordExpandWidthAndShow.w;\nvec4 p, prev, next;\nif (czm_morphTime == 1.0)\n{\np = czm_translateRelativeToEye(position3DHigh.xyz, position3DLow.xyz);\nprev = czm_translateRelativeToEye(prevPosition3DHigh.xyz, prevPosition3DLow.xyz);\nnext = czm_translateRelativeToEye(nextPosition3DHigh.xyz, nextPosition3DLow.xyz);\n}\nelse if (czm_morphTime == 0.0)\n{\np = czm_translateRelativeToEye(position2DHigh.zxy, position2DLow.zxy);\nprev = czm_translateRelativeToEye(prevPosition2DHigh.zxy, prevPosition2DLow.zxy);\nnext = czm_translateRelativeToEye(nextPosition2DHigh.zxy, nextPosition2DLow.zxy);\n}\nelse\n{\np = czm_columbusViewMorph(\nczm_translateRelativeToEye(position2DHigh.zxy, position2DLow.zxy),\nczm_translateRelativeToEye(position3DHigh.xyz, position3DLow.xyz),\nczm_morphTime);\nprev = czm_columbusViewMorph(\nczm_translateRelativeToEye(prevPosition2DHigh.zxy, prevPosition2DLow.zxy),\nczm_translateRelativeToEye(prevPosition3DHigh.xyz, prevPosition3DLow.xyz),\nczm_morphTime);\nnext = czm_columbusViewMorph(\nczm_translateRelativeToEye(nextPosition2DHigh.zxy, nextPosition2DLow.zxy),\nczm_translateRelativeToEye(nextPosition3DHigh.xyz, nextPosition3DLow.xyz),\nczm_morphTime);\n}\nvec4 endPointWC, p0, p1;\nbool culledByNearPlane, clipped;\nvec4 positionEC = czm_modelViewRelativeToEye * p;\nvec4 prevEC = czm_modelViewRelativeToEye * prev;\nvec4 nextEC = czm_modelViewRelativeToEye * next;\nclipLineSegmentToNearPlane(prevEC.xyz, positionEC.xyz, p0, clipped, culledByNearPlane);\nclipLineSegmentToNearPlane(nextEC.xyz, positionEC.xyz, p1, clipped, culledByNearPlane);\nclipLineSegmentToNearPlane(positionEC.xyz, usePrev ? prevEC.xyz : nextEC.xyz, endPointWC, clipped, culledByNearPlane);\nif (culledByNearPlane)\n{\ngl_Position = czm_projection * vec4(0.0, 0.0, 0.0, 1.0);\nreturn;\n}\nvec2 prevWC = normalize(p0.xy - endPointWC.xy);\nvec2 nextWC = normalize(p1.xy - endPointWC.xy);\nfloat expandWidth = width * 0.5;\nvec2 direction;\nif (czm_equalsEpsilon(normalize(prev.xyz - p.xyz), vec3(0.0), czm_epsilon1) || czm_equalsEpsilon(prevWC, -nextWC, czm_epsilon1))\n{\ndirection = vec2(-nextWC.y, nextWC.x);\n}\nelse if (czm_equalsEpsilon(normalize(next.xyz - p.xyz), vec3(0.0), czm_epsilon1) || clipped)\n{\ndirection = vec2(prevWC.y, -prevWC.x);\n}\nelse\n{\nvec2 normal = vec2(-nextWC.y, nextWC.x);\ndirection = normalize((nextWC + prevWC) * 0.5);\nif (dot(direction, normal) < 0.0)\n{\ndirection = -direction;\n}\nfloat sinAngle = abs(direction.x * nextWC.y - direction.y * nextWC.x);\nexpandWidth = clamp(expandWidth / sinAngle, 0.0, width * 2.0);\n}\nvec2 offset = direction * expandDir * expandWidth * czm_highResolutionSnapScale;\nvec4 positionWC = vec4(endPointWC.xy + offset, -endPointWC.z, 1.0);\ngl_Position = czm_viewportOrthographic * positionWC * show;\nv_textureCoordinates = vec2(texCoord, clamp(expandDir, 0.0, 1.0));\nv_width = width;\nczm_pickColor = pickColor;\n}\n"
    }), n("Shaders/PolylineFS", [], function () {
        "use strict";
        return"varying vec2 v_textureCoordinates;\nvoid main()\n{\nczm_materialInput materialInput;\nmaterialInput.s = v_textureCoordinates.s;\nmaterialInput.st = v_textureCoordinates;\nmaterialInput.str = vec3(v_textureCoordinates, 0.0);\nczm_material material = czm_getMaterial(materialInput);\ngl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n}\n"
    }), n("Scene/PolylineCollection", ["../Core/DeveloperError", "../Core/Color", "../Core/combine", "../Core/destroyObject", "../Core/Cartesian3", "../Core/Cartesian4", "../Core/EncodedCartesian3", "../Core/Matrix4", "../Core/Math", "../Core/ComponentDatatype", "../Core/IndexDatatype", "../Core/PrimitiveType", "../Core/BoundingSphere", "../Core/Intersect", "../Renderer/BlendingState", "../Renderer/BufferUsage", "../Renderer/CommandLists", "../Renderer/DrawCommand", "../Renderer/createPickFragmentShaderSource", "./Material", "./SceneMode", "./Polyline", "../Shaders/PolylineVS", "../Shaders/PolylineFS"], function (e, t, n, i, r, o, a, s, u, l, c, d, f, h, p, m, y, v, g, _, w, C, x, S) {
        "use strict";
        function b(e, t, n, i, r, o, a) {
            for (var s = r.length, u = t.length, l = 0, c = 0; s > c; ++c)for (var f = r[c], h = f.buckets, p = h.length, m = 0; p > m; ++m) {
                for (var y, g, _, w = h[m], C = w.offset, x = a ? w.bucket.shaderProgram : w.bucket.pickShaderProgram, S = w.bucket.polylines, b = S.length, T = 0, E = 0; b > E; ++E) {
                    var M = S[E], D = A(M._material);
                    D !== y && ("undefined" != typeof y && (l >= u ? (_ = new v, _.owner = e, t.push(_)) : _ = t[l], ++l, _.boundingVolume = n, _.modelMatrix = i, _.primitiveType = d.TRIANGLES, _.shaderProgram = x, _.vertexArray = f.va, _.renderState = o, _.uniformMap = g._uniforms, _.count = T, _.offset = C, C += T, T = 0), g = M._material, y = D);
                    for (var I = M._locatorBuckets, P = I.length, O = 0; P > O; ++O) {
                        var R = I[O];
                        R.locator === w && (T += R.count)
                    }
                }
                "undefined" != typeof y && T > 0 && (l >= u ? (_ = new v, _.owner = e, t.push(_)) : _ = t[l], ++l, _.boundingVolume = n, _.modelMatrix = i, _.primitiveType = d.TRIANGLES, _.shaderProgram = x, _.vertexArray = f.va, _.renderState = o, _.uniformMap = g._uniforms, _.count = T, _.offset = C), y = void 0
            }
            t.length = l
        }

        function T(e) {
            for (var t = e._buffersUsage, n = !1, i = e._propertiesChanged, r = 0; U - 2 > r; ++r) {
                var o = t[r];
                i[r] ? o.bufferUsage !== m.STREAM_DRAW ? (n = !0, o.bufferUsage = m.STREAM_DRAW, o.frameCount = 100) : o.frameCount = 100 : o.bufferUsage !== m.STATIC_DRAW && (0 === o.frameCount ? (n = !0, o.bufferUsage = m.STATIC_DRAW) : o.frameCount--)
            }
            return n
        }

        function E(e, t) {
            e._createVertexArray = !1, P(e), O(e), M(e);
            var n, i, r = [
                []
            ], o = r[0], a = [0], s = 0, d = [
                []
            ], f = 0, h = e._polylineBuckets;
            for (n in h)h.hasOwnProperty(n) && (i = h[n], i.updateShader(t), f += i.lengthOfPositions);
            if (f > 0) {
                var p, y = e._mode, v = new Float32Array(3 * 6 * f), g = new Uint8Array(4 * f), _ = new Float32Array(4 * f), C = 0, x = 0, S = 0;
                for (n in h)if (h.hasOwnProperty(n)) {
                    i = h[n], i.write(v, g, _, C, x, S, t), y === w.MORPHING && ("undefined" == typeof p && (p = new Float32Array(3 * 6 * f)), i.writeForMorph(p, C));
                    var b = i.lengthOfPositions;
                    C += 3 * 6 * b, x += 4 * b, S += 4 * b, s = i.updateIndices(r, a, d, s)
                }
                var T = e._buffersUsage[V].bufferUsage, E = e._buffersUsage[N].bufferUsage, A = e._buffersUsage[F].bufferUsage, D = E === m.STREAM_DRAW || A === m.STREAM_DRAW ? m.STREAM_DRAW : m.STATIC_DRAW;
                e._positionBuffer = t.createVertexBuffer(v, T);
                var I;
                "undefined" != typeof p && (I = t.createVertexBuffer(p, T)), e._pickColorBuffer = t.createVertexBuffer(g, m.STATIC_DRAW), e._texCoordExpandWidthAndShowBuffer = t.createVertexBuffer(_, D);
                for (var R = 4 * Uint8Array.BYTES_PER_ELEMENT, z = 3 * Float32Array.BYTES_PER_ELEMENT, L = 4 * Float32Array.BYTES_PER_ELEMENT, B = 0, k = r.length, U = 0; k > U; ++U)if (o = r[U], o.length > 0) {
                    var W = new Uint16Array(o), H = t.createIndexBuffer(W, m.STATIC_DRAW, c.UNSIGNED_SHORT);
                    B += a[U];
                    var j, Y, X, Z, K = 6 * (U * z * u.SIXTY_FOUR_KILOBYTES - B * z), J = z + K, Q = z + J, $ = z + Q, et = z + $, tt = z + et, nt = U * R * u.SIXTY_FOUR_KILOBYTES - B * R, it = U * L * u.SIXTY_FOUR_KILOBYTES - B * L, rt = [
                        {index: q.position3DHigh, componentsPerAttribute: 3, componentDatatype: l.FLOAT, offsetInBytes: K, strideInBytes: 6 * z},
                        {index: q.position3DLow, componentsPerAttribute: 3, componentDatatype: l.FLOAT, offsetInBytes: J, strideInBytes: 6 * z},
                        {index: q.position2DHigh, componentsPerAttribute: 3, componentDatatype: l.FLOAT, offsetInBytes: K, strideInBytes: 6 * z},
                        {index: q.position2DLow, componentsPerAttribute: 3, componentDatatype: l.FLOAT, offsetInBytes: J, strideInBytes: 6 * z},
                        {index: q.prevPosition3DHigh, componentsPerAttribute: 3, componentDatatype: l.FLOAT, offsetInBytes: Q, strideInBytes: 6 * z},
                        {index: q.prevPosition3DLow, componentsPerAttribute: 3, componentDatatype: l.FLOAT, offsetInBytes: $, strideInBytes: 6 * z},
                        {index: q.prevPosition2DHigh, componentsPerAttribute: 3, componentDatatype: l.FLOAT, offsetInBytes: Q, strideInBytes: 6 * z},
                        {index: q.prevPosition2DLow, componentsPerAttribute: 3, componentDatatype: l.FLOAT, offsetInBytes: $, strideInBytes: 6 * z},
                        {index: q.nextPosition3DHigh, componentsPerAttribute: 3, componentDatatype: l.FLOAT, offsetInBytes: et, strideInBytes: 6 * z},
                        {index: q.nextPosition3DLow, componentsPerAttribute: 3, componentDatatype: l.FLOAT, offsetInBytes: tt, strideInBytes: 6 * z},
                        {index: q.nextPosition2DHigh, componentsPerAttribute: 3, componentDatatype: l.FLOAT, offsetInBytes: et, strideInBytes: 6 * z},
                        {index: q.nextPosition2DLow, componentsPerAttribute: 3, componentDatatype: l.FLOAT, offsetInBytes: tt, strideInBytes: 6 * z},
                        {index: q.texCoordExpandWidthAndShow, componentsPerAttribute: 4, componentDatatype: l.FLOAT, vertexBuffer: e._texCoordExpandWidthAndShowBuffer, offsetInBytes: it},
                        {index: q.pickColor, componentsPerAttribute: 4, componentDatatype: l.UNSIGNED_BYTE, vertexBuffer: e._pickColorBuffer, offsetInBytes: nt, normalize: !0}
                    ];
                    y === w.SCENE3D ? (j = e._positionBuffer, Y = "vertexBuffer", X = G, Z = "value") : y === w.SCENE2D || y === w.COLUMBUS_VIEW ? (j = G, Y = "value", X = e._positionBuffer, Z = "vertexBuffer") : (j = I, Y = "vertexBuffer", X = e._positionBuffer, Z = "vertexBuffer"), rt[0][Y] = j, rt[1][Y] = j, rt[2][Z] = X, rt[3][Z] = X, rt[4][Y] = j, rt[5][Y] = j, rt[6][Z] = X, rt[7][Z] = X, rt[8][Y] = j, rt[9][Y] = j, rt[10][Z] = X, rt[11][Z] = X;
                    var ot = t.createVertexArray(rt, H);
                    e._vertexArrays.push({va: ot, buckets: d[U]})
                }
            }
        }

        function A(e) {
            var t = _._uniformList[e.type], n = t.length;
            j.length = 2 * n;
            for (var i = 0, r = 0; n > r; ++r) {
                var o = t[r];
                j[i] = o, j[i + 1] = e._uniforms[o](), i += 2
            }
            return e.type + ":" + JSON.stringify(j)
        }

        function M(e) {
            for (var t = e._mode, n = e._projection, i = e._modelMatrix, r = e._polylineBuckets = {}, o = e._polylines, a = o.length, s = 0; a > s; ++s) {
                var u = o[s];
                if (u.getPositions().length > 1) {
                    u.update();
                    var l = u.getMaterial(), c = r[l.type];
                    "undefined" == typeof c && (c = r[l.type] = new Y(l, t, n, i)), c.addPolyline(u)
                }
            }
        }

        function D(e, t) {
            var n = t.mode, i = t.scene2D.projection;
            e._mode === n && e._projection === i && e._modelMatrix.equals(e.modelMatrix) || (e._mode = n, e._projection = i, e._modelMatrix = e.modelMatrix.clone(), e._createVertexArray = !0)
        }

        function I(e) {
            if (e._polylinesRemoved) {
                e._polylinesRemoved = !1;
                for (var t = [], n = e._polylines.length, i = 0, r = 0; n > i; ++i) {
                    var o = e._polylines[i];
                    "undefined" != typeof o && (o._index = r++, t.push(o))
                }
                e._polylines = t
            }
        }

        function P(e) {
            for (var t = e._polylines, n = t.length, i = 0; n > i; ++i)if ("undefined" != typeof t[i]) {
                var r = t[i]._bucket;
                "undefined" != typeof r && (r.shaderProgram = r.shaderProgram && r.shaderProgram.release())
            }
        }

        function O(e) {
            for (var t = e._vertexArrays.length, n = 0; t > n; ++n)e._vertexArrays[n].va.destroy();
            e._vertexArrays.length = 0
        }

        function R(e) {
            for (var t = e._polylines, n = t.length, i = 0; n > i; ++i)"undefined" != typeof t[i] && t[i]._destroy()
        }

        function z(e, t, n) {
            this.count = e, this.offset = t, this.bucket = n
        }

        function L(e) {
            return r.dot(r.UNIT_X, e._boundingVolume.center) < 0 || e._boundingVolume.intersect(o.UNIT_Y) === h.INTERSECTING
        }

        var N = C.SHOW_INDEX, F = C.WIDTH_INDEX, V = C.POSITION_INDEX, B = C.MATERIAL_INDEX, k = C.POSITION_SIZE_INDEX, U = C.NUMBER_OF_PROPERTIES, q = {texCoordExpandWidthAndShow: 0, position3DHigh: 1, position3DLow: 2, position2DHigh: 3, position2DLow: 4, prevPosition3DHigh: 5, prevPosition3DLow: 6, prevPosition2DHigh: 7, prevPosition2DLow: 8, nextPosition3DHigh: 9, nextPosition3DLow: 10, nextPosition2DHigh: 11, nextPosition2DLow: 12, pickColor: 13}, W = function () {
            this.modelMatrix = s.IDENTITY.clone(), this._modelMatrix = s.IDENTITY.clone(), this._rs = void 0, this._boundingVolume = void 0, this._boundingVolume2D = void 0, this._boundingVolumeScratch = new f, this._commandLists = new y, this._colorCommands = [], this._pickCommands = [], this._polylinesUpdated = !1, this._polylinesRemoved = !1, this._createVertexArray = !1, this._propertiesChanged = new Uint32Array(U), this._polylines = [], this._polylineBuckets = {}, this._buffersUsage = [
                {bufferUsage: m.STATIC_DRAW, frameCount: 0},
                {bufferUsage: m.STATIC_DRAW, frameCount: 0},
                {bufferUsage: m.STATIC_DRAW, frameCount: 0}
            ], this._mode = void 0, this._polylinesToUpdate = [], this._vertexArrays = [], this._positionBuffer = void 0, this._pickColorBuffer = void 0, this._texCoordExpandWidthAndShowBuffer = void 0
        };
        W.prototype.add = function (e) {
            var t = new C(e, this);
            return t._index = this._polylines.length, this._polylines.push(t), this._createVertexArray = !0, t
        }, W.prototype.remove = function (e) {
            if (this.contains(e)) {
                if (this._polylines[e._index] = void 0, this._polylinesRemoved = !0, this._createVertexArray = !0, "undefined" != typeof e._bucket) {
                    var t = e._bucket;
                    t.shaderProgram = t.shaderProgram && t.shaderProgram.release(), t.pickShaderProgram = t.pickShaderProgram && t.pickShaderProgram.release()
                }
                return e._destroy(), !0
            }
            return!1
        }, W.prototype.removeAll = function () {
            P(this), R(this), this._polylineBuckets = {}, this._polylinesRemoved = !1, this._polylines.length = 0, this._polylinesToUpdate.length = 0, this._createVertexArray = !0
        }, W.prototype.contains = function (e) {
            return"undefined" != typeof e && e._polylineCollection === this
        }, W.prototype.get = function (t) {
            if ("undefined" == typeof t)throw new e("index is required.");
            return I(this), this._polylines[t]
        }, W.prototype.getLength = function () {
            return I(this), this._polylines.length
        };
        var H = [];
        W.prototype.update = function (e, t, n) {
            if (I(this), 0 !== this._polylines.length) {
                D(this, t);
                var i, r = this._propertiesChanged;
                if (this._createVertexArray || T(this))E(this, e); else if (this._polylinesUpdated) {
                    var o = this._polylinesToUpdate;
                    if (this._mode !== w.SCENE3D)for (var a = o.length, u = 0; a > u; ++u)i = o[u], i.update();
                    if (r[k] || r[B])E(this, e); else for (var l = o.length, c = this._polylineBuckets, d = 0; l > d; ++d) {
                        i = o[d], r = i._propertiesChanged;
                        var h = i._bucket, m = 0;
                        for (var y in c)if (c.hasOwnProperty(y)) {
                            if (c[y] === h) {
                                (r[V] || r[N] || r[F]) && h.writeUpdate(m, i, this._positionBuffer, this._texCoordExpandWidthAndShowBuffer);
                                break
                            }
                            m += c[y].lengthOfPositions
                        }
                        i._clean()
                    }
                    o.length = 0, this._polylinesUpdated = !1
                }
                for (var v = 0; U > v; ++v)r[v] = 0;
                var g, _ = s.IDENTITY;
                if (t.mode === w.SCENE3D ? (g = this._boundingVolume, _ = this.modelMatrix) : t.mode === w.COLUMBUS_VIEW ? g = this._boundingVolume2D : t.mode === w.SCENE2D ? "undefined" != typeof this._boundingVolume2D && (g = f.clone(this._boundingVolume2D, this._boundingVolumeScratch), g.center.x = 0) : "undefined" != typeof this._boundingVolume && "undefined" != typeof this._boundingVolume2D && (g = f.union(this._boundingVolume, this._boundingVolume2D, this._boundingVolumeScratch)), "undefined" != typeof g) {
                    var C = t.passes, x = 0 !== t.morphTime, S = this._commandLists;
                    if (S.colorList = H, S.pickList = H, ("undefined" == typeof this._rs || this._rs.depthTest.enabled !== x) && (this._rs = e.createRenderState({blending: p.ALPHA_BLEND, depthMask: !x, depthTest: {enabled: x}})), C.color) {
                        var A = this._colorCommands;
                        S.colorList = A, b(this, A, g, _, this._vertexArrays, this._rs, !0)
                    }
                    if (C.pick) {
                        var M = this._pickCommands;
                        S.pickList = M, b(this, M, g, _, this._vertexArrays, this._rs, !1)
                    }
                    this._commandLists.empty() || n.push(this._commandLists)
                }
            }
        }, W.prototype.isDestroyed = function () {
            return!1
        }, W.prototype.destroy = function () {
            return O(this), P(this), R(this), i(this)
        };
        var G = [0, 0, 0], j = [];
        W.prototype._updatePolyline = function (e, t) {
            this._polylinesUpdated = !0, this._polylinesToUpdate.push(e), ++this._propertiesChanged[t]
        };
        var Y = function (e, t, n, i) {
            this.polylines = [], this.lengthOfPositions = 0, this.material = e, this.shaderProgram = void 0, this.pickShaderProgram = void 0, this.mode = t, this.projection = n, this.ellipsoid = n.getEllipsoid(), this.modelMatrix = i
        };
        Y.prototype.addPolyline = function (e) {
            var t = this.polylines;
            t.push(e), e._actualLength = this.getPolylinePositionsLength(e), this.lengthOfPositions += e._actualLength, e._bucket = this
        }, Y.prototype.updateShader = function (e) {
            if ("undefined" == typeof this.shaderProgram) {
                var t = "#line 0\n" + this.material.shaderSource + "#line 0\n" + S;
                this.shaderProgram = e.getShaderCache().getShaderProgram(x, t, q), this.pickShaderProgram = e.getShaderCache().getShaderProgram(x, g(t, "varying"), q)
            }
        }, Y.prototype.getPolylinePositionsLength = function (e) {
            var t;
            if (this.mode === w.SCENE3D || !L(e))return t = e.getPositions().length, 4 * t - 4;
            var n = 0, i = e._segments.lengths;
            t = i.length;
            for (var r = 0; t > r; ++r)n += 4 * i[r] - 4;
            return n
        };
        var X = new r, Z = new r, K = new r, J = new r;
        Y.prototype.write = function (e, n, i, o, s, u, l) {
            for (var c = this.mode, d = this.polylines, f = d.length, h = 0; f > h; ++h)for (var p, m = d[h], y = m.getWidth(), v = m.getShow() && y > 0, g = this.getSegments(m), _ = g.positions, C = g.lengths, x = _.length, S = m.getPickId(l).color, b = 0, T = 0, E = 0; x > E; ++E) {
                0 === E ? (p = J, r.subtract(_[0], _[1], p), r.add(_[0], p, p)) : p = _[E - 1], Z.x = p.x, Z.y = p.y, Z.z = c !== w.SCENE2D ? p.z : 0, p = _[E], X.x = p.x, X.y = p.y, X.z = c !== w.SCENE2D ? p.z : 0, E === x - 1 ? (p = J, r.subtract(_[x - 1], _[x - 2], p), r.add(_[x - 1], p, p)) : p = _[E + 1], K.x = p.x, K.y = p.y, K.z = c !== w.SCENE2D ? p.z : 0;
                var A = C[b];
                E === T + A && (T += A, ++b);
                for (var M = 0 === E - T, D = E === T + C[b] - 1, I = M ? 2 : 0, P = D ? 2 : 4, O = I; P > O; ++O) {
                    a.writeElements(X, e, o), a.writeElements(Z, e, o + 6), a.writeElements(K, e, o + 12), n[s] = t.floatToByte(S.red), n[s + 1] = t.floatToByte(S.green), n[s + 2] = t.floatToByte(S.blue), n[s + 3] = t.floatToByte(S.alpha);
                    var R = 0 > O - 2 ? -1 : 1;
                    i[u] = E / (x - 1), i[u + 1] = 2 * (O % 2) - 1, i[u + 2] = R * y, i[u + 3] = v, o += 18, s += 4, u += 4
                }
            }
        };
        var Q = new r, $ = new r, et = new r, tt = new r;
        Y.prototype.writeForMorph = function (e, t) {
            for (var n = this.modelMatrix, i = this.polylines, o = i.length, u = 0; o > u; ++u)for (var l = i[u], c = l._segments.positions, d = l._segments.lengths, f = c.length, h = 0, p = 0, m = 0; f > m; ++m) {
                var y;
                0 === m ? (y = tt, r.subtract(c[0], c[1], y), r.add(c[0], y, y)) : y = c[m - 1], y = s.multiplyByPoint(n, y, $);
                var v, g = s.multiplyByPoint(n, c[m], Q);
                m === f - 1 ? (v = tt, r.subtract(c[f - 1], c[f - 2], v), r.add(c[f - 1], v, v)) : v = c[m + 1], v = s.multiplyByPoint(n, v, et);
                var _ = d[h];
                m === p + _ && (p += _, ++h);
                for (var w = 0 === m - p, C = m === p + d[h] - 1, x = w ? 2 : 0, S = C ? 2 : 4, b = x; S > b; ++b)a.writeElements(g, e, t), a.writeElements(y, e, t + 6), a.writeElements(v, e, t + 12), t += 18
            }
        };
        var nt = new Array(1);
        Y.prototype.updateIndices = function (e, t, n, i) {
            var r = n.length - 1, o = new z(0, i, this);
            n[r].push(o);
            var a = 0, s = e[e.length - 1], l = 0;
            s.length > 0 && (l = s[s.length - 1] + 1);
            for (var c = this.polylines, d = c.length, f = 0; d > f; ++f) {
                var h = c[f];
                h._locatorBuckets = [];
                var p;
                if (this.mode === w.SCENE3D) {
                    p = nt;
                    var m = h.getPositions().length;
                    if (!(m > 0))continue;
                    p[0] = m
                } else p = h._segments.lengths;
                var y = p.length;
                if (y > 0) {
                    for (var v = 0, g = 0; y > g; ++g)for (var _ = p[g] - 1, C = 0; _ > C; ++C)l + 4 >= u.SIXTY_FOUR_KILOBYTES - 1 && (h._locatorBuckets.push({locator: o, count: v}), v = 0, t.push(4), s = [], e.push(s), l = 0, o.count = a, a = 0, i = 0, o = new z(0, 0, this), n[++r] = [o]), s.push(l, l + 2, l + 1), s.push(l + 1, l + 2, l + 3), v += 6, a += 6, i += 6, l += 4;
                    h._locatorBuckets.push({locator: o, count: v}), l + 4 >= u.SIXTY_FOUR_KILOBYTES - 1 && (t.push(0), s = [], e.push(s), l = 0, o.count = a, i = 0, a = 0, o = new z(0, 0, this), n[++r] = [o])
                }
                h._clean()
            }
            return o.count = a, i
        }, Y.prototype.getPolylineStartIndex = function (e) {
            for (var t = this.polylines, n = 0, i = t.length, r = 0; i > r; ++r) {
                var o = t[r];
                if (o === e)break;
                n += o._actualLength
            }
            return n
        };
        var it = {positions: void 0, lengths: void 0}, rt = new Array(1);
        return Y.prototype.getSegments = function (e) {
            var t = e.getPositions();
            if (t.length > 0 && (e._polylineCollection._boundingVolume = "undefined" == typeof e._polylineCollection._boundingVolume ? f.clone(e._boundingVolume) : e._polylineCollection._boundingVolume.union(e._boundingVolume, e._polylineCollection._boundingVolume)), this.mode === w.SCENE3D)return rt[0] = t.length, it.positions = t, it.lengths = rt, it;
            L(e) && (t = e._segments.positions);
            for (var n, i, o = this.ellipsoid, a = this.projection, s = [], u = this.modelMatrix, l = t.length, c = 0; l > c; ++c)n = t[c], i = u.multiplyByPoint(n), s.push(a.project(o.cartesianToCartographic(r.fromCartesian4(i))));
            if (s.length > 0) {
                e._boundingVolume2D = f.fromPoints(s, e._boundingVolume2D);
                var d = e._boundingVolume2D.center;
                e._boundingVolume2D.center = new r(d.z, d.x, d.y), e._polylineCollection._boundingVolume2D = "undefined" == typeof e._polylineCollection._boundingVolume2D ? f.clone(e._boundingVolume2D) : e._polylineCollection._boundingVolume2D.union(e._boundingVolume2D, e._polylineCollection._boundingVolume2D)
            }
            return it.positions = s, it.lengths = e._segments.lengths, it
        }, Y.prototype.writeUpdate = function (e, t, n, i) {
            var o = this.mode, s = t._actualLength;
            if (s) {
                e += this.getPolylineStartIndex(t);
                var u, l = new Float32Array(3 * 6 * s), c = new Float32Array(4 * s), d = 0, f = 0, h = this.getSegments(t), p = h.positions, m = h.lengths, y = 0, v = 0, g = t.getWidth(), _ = t.getShow() && g > 0;
                s = p.length;
                for (var C = 0; s > C; ++C) {
                    0 === C ? (u = J, r.subtract(p[0], p[1], u), r.add(p[0], u, u)) : u = p[C - 1], Z.x = u.x, Z.y = u.y, Z.z = o !== w.SCENE2D ? u.z : 0, u = p[C], X.x = u.x, X.y = u.y, X.z = o !== w.SCENE2D ? u.z : 0, C === s - 1 ? (u = J, r.subtract(p[s - 1], p[s - 2], u), r.add(p[s - 1], u, u)) : u = p[C + 1], K.x = u.x, K.y = u.y, K.z = o !== w.SCENE2D ? u.z : 0;
                    var x = m[y];
                    C === v + x && (v += x, ++y);
                    for (var S = 0 === C - v, b = C === v + m[y] - 1, T = S ? 2 : 0, E = b ? 2 : 4, A = T; E > A; ++A) {
                        a.writeElements(X, l, d), a.writeElements(Z, l, d + 6), a.writeElements(K, l, d + 12);
                        var M = 0 > A - 2 ? -1 : 1;
                        c[f] = C / (s - 1), c[f + 1] = 2 * (A % 2) - 1, c[f + 2] = M * g, c[f + 3] = _, d += 18, f += 4
                    }
                }
                n.copyFromArrayView(l, 18 * Float32Array.BYTES_PER_ELEMENT * e), i.copyFromArrayView(c, 4 * Float32Array.BYTES_PER_ELEMENT * e)
            }
        }, W
    }), n("DynamicScene/DynamicPathVisualizer", ["../Core/DeveloperError", "../Core/destroyObject", "../Core/Cartesian3", "../Core/Matrix3", "../Core/Matrix4", "../Core/Color", "../Core/Transforms", "../Core/ReferenceFrame", "../Scene/Material", "../Scene/SceneMode", "../Scene/PolylineCollection"], function (e, t, n, i, r, o, a, s, u, l, c) {
        "use strict";
        var d = new i, f = function (e, t) {
            this._unusedIndexes = [], this._polylineCollection = new c, this._scene = e, this._referenceFrame = t, e.getPrimitives().add(this._polylineCollection)
        };
        f.prototype.update = function (e) {
            if (this._referenceFrame === s.INERTIAL) {
                var t = a.computeIcrfToFixedMatrix(e, d);
                "undefined" == typeof t && (t = a.computeTemeToPseudoFixedMatrix(e, d)), r.fromRotationTranslation(t, n.ZERO, this._polylineCollection.modelMatrix)
            }
        }, f.prototype.updateObject = function (e, t) {
            var n = t.path;
            if ("undefined" != typeof n) {
                var i = t.position;
                if ("undefined" != typeof i) {
                    var r, a, s, l, c = n.show, d = t._pathVisualizerIndex, f = "undefined" == typeof c || c.getValue(e);
                    if (f) {
                        a = n.leadTime;
                        var h;
                        "undefined" != typeof a && (h = a.getValue(e)), a = n.trailTime;
                        var p;
                        "undefined" != typeof a && (p = a.getValue(e));
                        var m = t.availability, y = "undefined" != typeof m, v = "undefined" != typeof h, g = "undefined" != typeof p;
                        f = y || v && g, f && (g && (s = e.addSeconds(-p)), !y || g && !m.start.greaterThan(s) || (s = m.start), v && (l = e.addSeconds(h)), !y || v && !m.stop.lessThan(l) || (l = m.stop), f = s.lessThan(l))
                    }
                    if (!f)return"undefined" != typeof d && (r = this._polylineCollection.get(d), r.setShow(!1), t._pathVisualizerIndex = void 0, this._unusedIndexes.push(d)), void 0;
                    var _;
                    if ("undefined" == typeof d) {
                        var w = this._unusedIndexes, C = w.length;
                        C > 0 ? (d = w.pop(), r = this._polylineCollection.get(d)) : (d = this._polylineCollection.getLength(), r = this._polylineCollection.add()), t._pathVisualizerIndex = d, r.dynamicObject = t, r.setWidth(1);
                        var x = r.getMaterial();
                        ("undefined" == typeof x || x.type !== u.PolylineOutlineType) && (x = u.fromType(this._scene.getContext(), u.PolylineOutlineType), r.setMaterial(x)), _ = x.uniforms, o.clone(o.WHITE, _.color), o.clone(o.BLACK, _.outlineColor), _.outlineWidth = 0
                    } else r = this._polylineCollection.get(d), _ = r.getMaterial().uniforms;
                    r.setShow(!0);
                    var S = 60;
                    if (a = n.resolution, "undefined" != typeof a && (S = a.getValue(e)), r.setPositions(i._getValueRangeInReferenceFrame(s, l, e, this._referenceFrame, S, r.getPositions())), a = n.color, "undefined" != typeof a && (_.color = a.getValue(e, _.color)), a = n.outlineColor, "undefined" != typeof a && (_.outlineColor = a.getValue(e, _.outlineColor)), a = n.outlineWidth, "undefined" != typeof a && (_.outlineWidth = a.getValue(e)), a = n.width, "undefined" != typeof a) {
                        var b = a.getValue(e);
                        "undefined" != typeof b && r.setWidth(b)
                    }
                }
            }
        }, f.prototype.removeObject = function (e) {
            var t = e._pathVisualizerIndex;
            if ("undefined" != typeof t) {
                var n = this._polylineCollection.get(t);
                n.setShow(!1), this._unusedIndexes.push(t), e._pathVisualizerIndex = void 0
            }
        }, f.prototype.destroy = function () {
            return this._scene.getPrimitives().remove(this._polylineCollection), t(this)
        };
        var h = function (t, n) {
            if ("undefined" == typeof t)throw new e("scene is required.");
            this._scene = t, this._updaters = {}, this._dynamicObjectCollection = void 0, this.setDynamicObjectCollection(n)
        };
        return h.prototype.getScene = function () {
            return this._scene
        }, h.prototype.getDynamicObjectCollection = function () {
            return this._dynamicObjectCollection
        }, h.prototype.setDynamicObjectCollection = function (e) {
            var t = this._dynamicObjectCollection;
            t !== e && ("undefined" != typeof t && (t.objectsRemoved.removeEventListener(h.prototype._onObjectsRemoved, this), this.removeAllPrimitives()), this._dynamicObjectCollection = e, "undefined" != typeof e && e.objectsRemoved.addEventListener(h.prototype._onObjectsRemoved, this))
        }, h.prototype.update = function (t) {
            if ("undefined" == typeof t)throw new e("time is requied.");
            if ("undefined" != typeof this._dynamicObjectCollection) {
                var n = this._updaters;
                for (var i in n)n.hasOwnProperty(i) && n[i].update(t);
                for (var r = this._dynamicObjectCollection.getObjects(), o = 0, a = r.length; a > o; o++) {
                    var u = r[o];
                    if ("undefined" != typeof u.path) {
                        var c = u.position;
                        if ("undefined" != typeof c) {
                            var d = u._pathUpdater, h = s.FIXED;
                            this._scene.mode === l.SCENE3D && (h = c._getReferenceFrame());
                            var p = this._updaters[h];
                            d !== p || "undefined" == typeof p ? ("undefined" != typeof d && d.removeObject(u), "undefined" == typeof p && (p = new f(this._scene, h), p.update(t), this._updaters[h] = p), u._pathUpdater = p, "undefined" != typeof p && p.updateObject(t, u)) : p.updateObject(t, u)
                        }
                    }
                }
            }
        }, h.prototype.removeAllPrimitives = function () {
            var e = this._updaters;
            for (var t in e)e.hasOwnProperty(t) && e[t].destroy();
            if (this._updaters = {}, "undefined" != typeof this._dynamicObjectCollection)for (var n = this._dynamicObjectCollection.getObjects(), i = n.length - 1; i > -1; i--)n[i]._pathUpdater = void 0, n[i]._pathVisualizerIndex = void 0
        }, h.prototype.isDestroyed = function () {
            return!1
        }, h.prototype.destroy = function () {
            return this.removeAllPrimitives(), t(this)
        }, h.prototype._onObjectsRemoved = function (e, t) {
            for (var n = t.length - 1; n > -1; n--) {
                var i = t[n], r = i._pathUpdater;
                "undefined" != typeof r && r.removeObject(i)
            }
        }, h
    }), n("DynamicScene/DynamicPointVisualizer", ["../Core/Color", "../Core/defaultValue", "../Core/destroyObject", "../Core/DeveloperError", "../Scene/BillboardCollection", "../Renderer/TextureAtlasBuilder"], function (e, t, n, i, r, o) {
        "use strict";
        function a(n, i, r) {
            var o = r.point;
            if ("undefined" != typeof o) {
                var a = r.position;
                if ("undefined" != typeof a) {
                    var s, d = o.show, f = r._pointVisualizerIndex, h = r.isAvailable(i) && ("undefined" == typeof d || d.getValue(i));
                    if (!h)return"undefined" != typeof f && (s = n._billboardCollection.get(f), s.setShow(!1), s.setImageIndex(-1), r._pointVisualizerIndex = void 0, n._unusedIndexes.push(f)), void 0;
                    var p = !1;
                    if ("undefined" == typeof f) {
                        var m = n._unusedIndexes, y = m.length;
                        y > 0 ? (f = m.pop(), s = n._billboardCollection.get(f)) : (f = n._billboardCollection.getLength(), s = n._billboardCollection.add()), r._pointVisualizerIndex = f, s.dynamicObject = r, s._visualizerColor = e.WHITE.clone(s._visualizerColor), s._visualizerOutlineColor = e.BLACK.clone(s._visualizerOutlineColor), s._visualizerOutlineWidth = 0, s._visualizerPixelSize = 1, p = !0
                    } else s = n._billboardCollection.get(f);
                    s.setShow(!0), l = a.getValueCartesian(i, l), "undefined" != typeof l && s.setPosition(l);
                    var v = o.color;
                    if ("undefined" != typeof v && (u = v.getValue(i, u), e.equals(s._visualizerColor, u) || (e.clone(u, s._visualizerColor), p = !0)), v = o.outlineColor, "undefined" != typeof v && (c = v.getValue(i, c), e.equals(s._visualizerOutlineColor, c) || (e.clone(c, s._visualizerOutlineColor), p = !0)), v = o.outlineWidth, "undefined" != typeof v) {
                        var g = v.getValue(i);
                        s._visualizerOutlineWidth !== g && (s._visualizerOutlineWidth = g, p = !0)
                    }
                    if (v = o.pixelSize, "undefined" != typeof v) {
                        var _ = v.getValue(i);
                        s._visualizerPixelSize !== _ && (s._visualizerPixelSize = _, p = !0)
                    }
                    if (p) {
                        var w = t(s._visualizerColor, e.WHITE).toCssColorString(), C = t(s._visualizerOutlineColor, e.BLACK).toCssColorString(), x = t(s._visualizerPixelSize, 3), S = t(s._visualizerOutlineWidth, 2), b = JSON.stringify([w, x, C, S]);
                        n._textureAtlasBuilder.addTextureFromFunction(b, function (e, t) {
                            var n = document.createElement("canvas"), i = x + 2 * S;
                            n.height = n.width = i;
                            var r = n.getContext("2d");
                            r.clearRect(0, 0, i, i), 0 !== S && (r.beginPath(), r.arc(i / 2, i / 2, i / 2, 0, 2 * Math.PI, !0), r.closePath(), r.fillStyle = C, r.fill()), r.beginPath(), r.arc(i / 2, i / 2, x / 2, 0, 2 * Math.PI, !0), r.closePath(), r.fillStyle = w, r.fill(), t(n)
                        }, function (e) {
                            s.setImageIndex(e)
                        })
                    }
                }
            }
        }

        var s = function (e, t) {
            if ("undefined" == typeof e)throw new i("scene is required.");
            this._scene = e, this._unusedIndexes = [], this._dynamicObjectCollection = void 0;
            var n = this._billboardCollection = new r, a = this._textureAtlas = e.getContext().createTextureAtlas();
            this._textureAtlasBuilder = new o(a), n.setTextureAtlas(a), e.getPrimitives().add(n), this.setDynamicObjectCollection(t)
        };
        s.prototype.getScene = function () {
            return this._scene
        }, s.prototype.getDynamicObjectCollection = function () {
            return this._dynamicObjectCollection
        }, s.prototype.setDynamicObjectCollection = function (e) {
            var t = this._dynamicObjectCollection;
            t !== e && ("undefined" != typeof t && (t.objectsRemoved.removeEventListener(s.prototype._onObjectsRemoved, this), this.removeAllPrimitives()), this._dynamicObjectCollection = e, "undefined" != typeof e && e.objectsRemoved.addEventListener(s.prototype._onObjectsRemoved, this))
        }, s.prototype.update = function (e) {
            if ("undefined" == typeof e)throw new i("time is requied.");
            if ("undefined" != typeof this._dynamicObjectCollection)for (var t = this._dynamicObjectCollection.getObjects(), n = 0, r = t.length; r > n; n++)a(this, e, t[n])
        }, s.prototype.removeAllPrimitives = function () {
            if (this._unusedIndexes = [], this._billboardCollection.removeAll(), "undefined" != typeof this._dynamicObjectCollection)for (var e = this._dynamicObjectCollection.getObjects(), t = e.length - 1; t > -1; t--)e[t]._pointVisualizerIndex = void 0
        }, s.prototype.isDestroyed = function () {
            return!1
        }, s.prototype.destroy = function () {
            return this.removeAllPrimitives(), this._scene.getPrimitives().remove(this._billboardCollection), n(this)
        };
        var u, l, c;
        return s.prototype._onObjectsRemoved = function (e, t) {
            for (var n = this._billboardCollection, i = this._unusedIndexes, r = t.length - 1; r > -1; r--) {
                var o = t[r], a = o._pointVisualizerIndex;
                if ("undefined" != typeof a) {
                    var s = n.get(a);
                    s.setShow(!1), s.setImageIndex(-1), o._pointVisualizerIndex = void 0, i.push(a)
                }
            }
        }, s
    }), n("Scene/Appearance", ["../Core/defaultValue", "../Renderer/BlendingState", "../Renderer/CullFace"], function (e, t, n) {
        "use strict";
        var i = function (t) {
            t = e(t, e.EMPTY_OBJECT), this.material = t.material, this.vertexShaderSource = t.vertexShaderSource, this.fragmentShaderSource = t.fragmentShaderSource, this.renderState = t.renderState
        };
        return i.prototype.getFragmentShaderSource = function () {
            var e = this.flat ? "#define FLAT 1\n#line 0 \n" : "#line 0 \n", t = this.faceForward ? "#define FACE_FORWARD 1\n#line 0 \n" : "#line 0 \n";
            return"undefined" != typeof this.material ? "#line 0\n" + this.material.shaderSource + e + t + this.fragmentShaderSource : e + t + this.fragmentShaderSource
        }, i.getDefaultRenderState = function (e, i) {
            var r = {depthTest: {enabled: !0}};
            return e && (r.depthMask = !1, r.blending = t.ALPHA_BLEND), i && (r.cull = {enabled: !0, face: n.BACK}), r
        }, i
    }), n("Shaders/Appearances/BasicMaterialAppearanceVS", [], function () {
        "use strict";
        return"attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 normal;\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvoid main()\n{\nvec4 p = czm_computePosition();\nv_positionEC = (czm_modelViewRelativeToEye * p).xyz;\nv_normalEC = czm_normal * normal;\ngl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"
    }), n("Shaders/Appearances/BasicMaterialAppearanceFS", [], function () {
        "use strict";
        return"varying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvoid main()\n{\nvec3 positionToEyeEC = -v_positionEC;\nvec3 normalEC;\n#ifdef FACE_FORWARD\nnormalEC = normalize(faceforward(v_normalEC, vec3(0.0, 0.0, 1.0), -v_normalEC));\n#else\nnormalEC = normalize(v_normalEC);\n#endif\nczm_materialInput materialInput;\nmaterialInput.normalEC = normalEC;\nmaterialInput.positionToEyeEC = positionToEyeEC;\nczm_material material = czm_getMaterial(materialInput);\n#ifdef FLAT\ngl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#else\ngl_FragColor = czm_phong(normalize(positionToEyeEC), material);\n#endif\n}\n"
    }), n("Shaders/Appearances/TexturedMaterialAppearanceVS", [], function () {
        "use strict";
        return"attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 normal;\nattribute vec2 st;\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec2 v_st;\nvoid main()\n{\nvec4 p = czm_computePosition();\nv_positionEC = (czm_modelViewRelativeToEye * p).xyz;\nv_normalEC = czm_normal * normal;\nv_st = st;\ngl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"
    }), n("Shaders/Appearances/TexturedMaterialAppearanceFS", [], function () {
        "use strict";
        return"varying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec2 v_st;\nvoid main()\n{\nvec3 positionToEyeEC = -v_positionEC;\nvec3 normalEC;\n#ifdef FACE_FORWARD\nnormalEC = normalize(faceforward(v_normalEC, vec3(0.0, 0.0, 1.0), -v_normalEC));\n#else\nnormalEC = normalize(v_normalEC);\n#endif\nczm_materialInput materialInput;\nmaterialInput.normalEC = normalEC;\nmaterialInput.positionToEyeEC = positionToEyeEC;\nmaterialInput.st = v_st;\nczm_material material = czm_getMaterial(materialInput);\n#ifdef FLAT\ngl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#else\ngl_FragColor = czm_phong(normalize(positionToEyeEC), material);\n#endif\n}\n"
    }), n("Shaders/Appearances/AllMaterialAppearanceVS", [], function () {
        "use strict";
        return"attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 normal;\nattribute vec3 tangent;\nattribute vec3 binormal;\nattribute vec2 st;\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec3 v_tangentEC;\nvarying vec3 v_binormalEC;\nvarying vec2 v_st;\nvoid main()\n{\nvec4 p = czm_computePosition();\nv_positionEC = (czm_modelViewRelativeToEye * p).xyz;\nv_normalEC = czm_normal * normal;\nv_tangentEC = czm_normal * tangent;\nv_binormalEC = czm_normal * binormal;\nv_st = st;\ngl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"
    }), n("Shaders/Appearances/AllMaterialAppearanceFS", [], function () {
        "use strict";
        return"varying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec3 v_tangentEC;\nvarying vec3 v_binormalEC;\nvarying vec2 v_st;\nvoid main()\n{\nvec3 positionToEyeEC = -v_positionEC;\nmat3 tangentToEyeMatrix = czm_tangentToEyeSpaceMatrix(v_normalEC, v_tangentEC, v_binormalEC);\nvec3 normalEC;\n#ifdef FACE_FORWARD\nnormalEC = normalize(faceforward(v_normalEC, vec3(0.0, 0.0, 1.0), -v_normalEC));\n#else\nnormalEC = normalize(v_normalEC);\n#endif\nczm_materialInput materialInput;\nmaterialInput.normalEC = normalEC;\nmaterialInput.tangentToEyeMatrix = tangentToEyeMatrix;\nmaterialInput.positionToEyeEC = positionToEyeEC;\nmaterialInput.st = v_st;\nczm_material material = czm_getMaterial(materialInput);\n#ifdef FLAT\ngl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#else\ngl_FragColor = czm_phong(normalize(positionToEyeEC), material);\n#endif\n}\n"
    }), n("Scene/MaterialAppearance", ["../Core/defaultValue", "../Core/freezeObject", "../Core/VertexFormat", "./Material", "./Appearance", "../Shaders/Appearances/BasicMaterialAppearanceVS", "../Shaders/Appearances/BasicMaterialAppearanceFS", "../Shaders/Appearances/TexturedMaterialAppearanceVS", "../Shaders/Appearances/TexturedMaterialAppearanceFS", "../Shaders/Appearances/AllMaterialAppearanceVS", "../Shaders/Appearances/AllMaterialAppearanceFS"], function (e, t, n, i, r, o, a, s, u, l, c) {
        "use strict";
        var d = function (t) {
            t = e(t, e.EMPTY_OBJECT);
            var n = e(t.translucent, !0), o = e(t.closed, !1), a = e(t.materialSupport, d.MaterialSupport.TEXTURED);
            this.material = "undefined" != typeof t.material ? t.material : i.fromType(void 0, i.ColorType), this.vertexShaderSource = e(t.vertexShaderSource, a.vertexShaderSource), this.fragmentShaderSource = e(t.fragmentShaderSource, a.fragmentShaderSource), this.renderState = e(t.renderState, r.getDefaultRenderState(n, o)), this.materialSupport = a, this.vertexFormat = a.vertexFormat, this.flat = e(t.flat, !1), this.faceForward = e(t.faceForward, !1), this.translucent = n, this.closed = o
        };
        return d.prototype.getFragmentShaderSource = r.prototype.getFragmentShaderSource, d.MaterialSupport = {BASIC: t({vertexFormat: n.POSITION_AND_NORMAL, vertexShaderSource: o, fragmentShaderSource: a}), TEXTURED: t({vertexFormat: n.POSITION_NORMAL_AND_ST, vertexShaderSource: s, fragmentShaderSource: u}), ALL: t({vertexFormat: n.ALL, vertexShaderSource: l, fragmentShaderSource: c})}, d
    }), n("Shaders/Appearances/EllipsoidSurfaceAppearanceVS", [], function () {
        "use strict";
        return"attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec2 st;\nvarying vec3 v_positionMC;\nvarying vec3 v_positionEC;\nvarying vec2 v_st;\nvoid main()\n{\nvec4 p = czm_computePosition();\nv_positionMC = position3DHigh + position3DLow;\nv_positionEC = (czm_modelViewRelativeToEye * p).xyz;\nv_st = st;\ngl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"
    }), n("Shaders/Appearances/EllipsoidSurfaceAppearanceFS", [], function () {
        "use strict";
        return"varying vec3 v_positionMC;\nvarying vec3 v_positionEC;\nvarying vec2 v_st;\nvoid main()\n{\nczm_materialInput materialInput;\nvec3 normalEC = czm_normal3D * czm_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0));\n#ifdef FACE_FORWARD\nnormalEC = normalize(faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC));\n#else\nnormalEC = normalize(normalEC);\n#endif\nmaterialInput.s = v_st.s;\nmaterialInput.st = v_st;\nmaterialInput.str = vec3(v_st, 0.0);\nmaterialInput.normalEC = normalEC;\nmaterialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(v_positionMC, materialInput.normalEC);\nvec3 positionToEyeEC = -v_positionEC;\nmaterialInput.positionToEyeEC = positionToEyeEC;\nczm_material material = czm_getMaterial(materialInput);\n#ifdef FLAT\ngl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#else\ngl_FragColor = czm_phong(normalize(positionToEyeEC), material);\n#endif\n}\n"
    }), n("Scene/EllipsoidSurfaceAppearance", ["../Core/defaultValue", "../Core/VertexFormat", "./Material", "./Appearance", "./MaterialAppearance", "../Shaders/Appearances/EllipsoidSurfaceAppearanceVS", "../Shaders/Appearances/EllipsoidSurfaceAppearanceFS"], function (e, t, n, i, r, o, a) {
        "use strict";
        var s = function (t) {
            t = e(t, e.EMPTY_OBJECT);
            var r = e(t.translucent, !0), u = e(t.aboveGround, !1);
            this.material = "undefined" != typeof t.material ? t.material : n.fromType(void 0, n.ColorType), this.vertexShaderSource = e(t.vertexShaderSource, o), this.fragmentShaderSource = e(t.fragmentShaderSource, a), this.renderState = e(t.renderState, i.getDefaultRenderState(r, !u)), this.vertexFormat = s.VERTEX_FORMAT, this.flat = e(t.flat, !1), this.faceForward = e(t.faceForward, !1), this.translucent = r, this.aboveGround = u
        };
        return s.VERTEX_FORMAT = t.POSITION_AND_ST, s.prototype.getFragmentShaderSource = i.prototype.getFragmentShaderSource, s
    }), n("Renderer/VertexLayout", ["../Core/Enumeration"], function (e) {
        "use strict";
        var t = {SEPARATE: new e(0, "SEPARATE"), INTERLEAVED: new e(1, "INTERLEAVED"), validate: function (e) {
            return e === t.SEPARATE || e === t.INTERLEAVED
        }};
        return t
    }), n("Scene/Primitive", ["../Core/clone", "../Core/defaultValue", "../Core/DeveloperError", "../Core/destroyObject", "../Core/Matrix4", "../Core/Color", "../Core/GeometryPipeline", "../Core/PrimitiveType", "../Core/BoundingSphere", "../Core/Geometry", "../Core/GeometryAttribute", "../Core/GeometryAttributes", "../Core/GeometryInstance", "../Core/GeometryInstanceAttribute", "../Core/ComponentDatatype", "../Core/Cartesian3", "../Renderer/BufferUsage", "../Renderer/VertexLayout", "../Renderer/CommandLists", "../Renderer/DrawCommand", "../Renderer/createPickFragmentShaderSource", "./SceneMode"], function (e, t, n, i, r, o, a, s, u, l, c, d, f, h, p, m, y, v, g, _, w, C) {
        "use strict";
        function x(e) {
            return new c({componentDatatype: e.componentDatatype, componentsPerAttribute: e.componentsPerAttribute, normalize: e.normalize, values: new e.values.constructor(e.values)})
        }

        function S(e) {
            var t = e.attributes, n = new d;
            for (var i in t)t.hasOwnProperty(i) && "undefined" != typeof t[i] && (n[i] = x(t[i]));
            var r;
            if ("undefined" != typeof e.indices) {
                var o = e.indices;
                r = new o.constructor(o)
            }
            return new l({attributes: n, indices: r, primitiveType: e.primitiveType, boundingSphere: u.clone(e.boundingSphere)})
        }

        function b(e) {
            return new h({componentDatatype: e.componentDatatype, componentsPerAttribute: e.componentsPerAttribute, normalize: e.normalize, value: new e.value.constructor(e.value)})
        }

        function T(e) {
            var t = e.attributes, n = {};
            for (var i in t)t.hasOwnProperty(i) && (n[i] = b(t[i]));
            return new f({geometry: S(e.geometry), modelMatrix: r.clone(e.modelMatrix), id: e.id, attributes: n})
        }

        function E(e, n, i) {
            for (var r = n.length, a = 0; r > a; ++a) {
                var s = n[a], u = s.geometry, l = u.attributes, d = l.position, f = 4 * (d.values.length / d.componentsPerAttribute);
                l.pickColor = new c({componentDatatype: p.UNSIGNED_BYTE, componentsPerAttribute: 4, normalize: !0, values: new Uint8Array(f)});
                var h = i.createPickId(t(s.id, e));
                e._pickIds.push(h);
                for (var m = h.color, y = o.floatToByte(m.red), v = o.floatToByte(m.green), g = o.floatToByte(m.blue), _ = o.floatToByte(m.alpha), w = l.pickColor.values, C = 0; f > C; C += 4)w[C] = y, w[C + 1] = v, w[C + 2] = g, w[C + 3] = _
            }
        }

        function A(e, t) {
            var n, i = !e._allow3DOnly, o = t.length;
            if (!i && o > 1) {
                var s = t[0].modelMatrix;
                for (n = 1; o > n; ++n)if (!r.equals(s, t[n].modelMatrix)) {
                    i = !0;
                    break
                }
            }
            if (i)for (n = 0; o > n; ++n)a.transformToWorldCoordinates(t[n]); else r.clone(t[0].modelMatrix, e.modelMatrix)
        }

        function M(e) {
            var t, n = e.length, i = [], r = e[0].attributes;
            for (t in r)if (r.hasOwnProperty(t)) {
                for (var o = r[t], a = !0, s = 1; n > s; ++s) {
                    var u = e[s].attributes[t];
                    if ("undefined" == typeof u || o.componentDatatype !== u.componentDatatype || o.componentsPerAttribute !== u.componentsPerAttribute || o.normalize !== u.normalize) {
                        a = !1;
                        break
                    }
                }
                a && i.push(t)
            }
            return i
        }

        function D(e, t, n) {
            for (var i = t.length, r = 0; i > r; ++r)for (var o = t[r], a = o.attributes, s = o.geometry, u = l.computeNumberOfVertices(s), d = n.length, f = 0; d > f; ++f) {
                for (var h = n[f], p = a[h], m = p.componentDatatype, y = p.value, v = y.length, g = m.createTypedArray(u * v), _ = 0; u > _; ++_)g.set(y, _ * v);
                s.attributes[h] = new c({componentDatatype: m, componentsPerAttribute: v, normalize: p.normalize, values: g})
            }
        }

        function I(e, t, i, r) {
            for (var o = t.length, s = t[0].geometry.primitiveType, u = 1; o > u; ++u)if (t[u].geometry.primitiveType !== s)throw new n("All instance geometries must have the same primitiveType.");
            if (A(e, t), !e._allow3DOnly)for (u = 0; o > u; ++u)a.wrapLongitude(t[u].geometry);
            E(e, t, i);
            var l = M(t);
            if (D(e, t, l), e._vertexCacheOptimize)for (u = 0; o > u; ++u)a.reorderForPostVertexCache(t[u].geometry), a.reorderForPreVertexCache(t[u].geometry);
            var c = a.combine(t);
            return e._allow3DOnly ? a.encodeAttribute(c, "position", "position3DHigh", "position3DLow") : (a.projectTo2D(c, r), a.encodeAttribute(c, "position3D", "position3DHigh", "position3DLow"), a.encodeAttribute(c, "position2D", "position2DHigh", "position2DLow")), i.getElementIndexUint() ? [c] : a.fitToUnsignedShortIndices(c)
        }

        function P(e, t, n, i) {
            for (var r = [], o = y.DYNAMIC_DRAW, a = t.attributes, s = i.length, u = 0; s > u; ++u) {
                var l = i[u], c = a[l], d = c.componentDatatype;
                d === p.DOUBLE && (d = p.FLOAT);
                var f = e.createVertexBuffer(d.createTypedArray(c.values), o);
                r.push({index: n[l], vertexBuffer: f, componentDatatype: d, componentsPerAttribute: c.componentsPerAttribute, normalize: c.normalize}), delete a[l]
            }
            return r
        }

        function O(e, n, i) {
            for (var r = [], o = [], a = M(e), s = e.length, u = {}, c = {}, d = 0; s > d; ++d)for (var f = e[d], h = l.computeNumberOfVertices(f.geometry), p = a.length, m = 0; p > m; ++m)for (var y = a[m], v = i[y], g = h; g > 0;) {
                for (var _, w = t(c[y], 0), C = n[w], x = C.getNumberOfAttributes(), S = 0; x > S && (_ = C.getAttribute(S), _.index !== v); ++S);
                "undefined" == typeof r[d] && (r[d] = f.id), "undefined" == typeof o[d] && (o[d] = {}), "undefined" == typeof o[d][y] && (o[d][y] = {dirty: !1, value: f.attributes[y].value, indices: []});
                var b = _.vertexBuffer.getSizeInBytes() / _.componentDatatype.sizeInBytes;
                b /= _.componentsPerAttribute;
                var T, E = t(u[y], 0);
                b > E + g ? (T = g, o[d][y].indices.push({attribute: _, offset: E, count: T}), u[y] = E + g) : (T = b - E, o[d][y].indices.push({attribute: _, offset: E, count: T}), u[y] = 0, c[y] = w + 1), g -= T
            }
            return{ids: r, indices: o}
        }

        function R(e, t) {
            var n;
            n = e._allow3DOnly ? "" : "attribute vec3 position2DHigh;\nattribute vec3 position2DLow;\n";
            var i = "\nvec4 czm_computePosition()\n{\n";
            return i += e._allow3DOnly ? "    return czm_translateRelativeToEye(position3DHigh, position3DLow);\n" : "    vec4 p;\n    if (czm_morphTime == 1.0)\n    {\n        p = czm_translateRelativeToEye(position3DHigh, position3DLow);\n    }\n    else if (czm_morphTime == 0.0)\n    {\n        p = czm_translateRelativeToEye(position2DHigh.zxy, position2DLow.zxy);\n    }\n    else\n    {\n        p = czm_columbusViewMorph(\n                czm_translateRelativeToEye(position2DHigh.zxy, position2DLow.zxy),\n                czm_translateRelativeToEye(position3DHigh, position3DLow),\n                czm_morphTime);\n    }\n    return p;\n", i += "}\n\n", n + t + i
        }

        function z(e) {
            var t = e.replace(/void\s+main\s*\(\s*(?:void)?\s*\)/g, "void czm_old_main()"), n = "attribute vec4 pickColor; \nvarying vec4 czm_pickColor; \nvoid main() \n{ \n    czm_old_main(); \n    czm_pickColor = pickColor; \n}";
            return t + "\n" + n
        }

        function L(e, t) {
            if ("undefined" == typeof e._attributeIndices.show)return t;
            var n = t.replace(/void\s+main\s*\(\s*(?:void)?\s*\)/g, "void czm_non_show_main()"), i = "attribute float show;\nvoid main() \n{ \n    czm_non_show_main(); \n    gl_Position *= show; \n}";
            return n + "\n" + i
        }

        function N(e, t) {
            var i = e.getVertexAttributes();
            for (var r in i)if (i.hasOwnProperty(r) && "undefined" == typeof t[r])throw new n("Appearance/Geometry mismatch.  The appearance requires vertex shader attribute input '" + r + "', which was not computed as part of the Geometry.  Use the appearance's vertexFormat property when constructing the geometry.")
        }

        function F(e, t) {
            return function () {
                return t[e].value
            }
        }

        function V(e, t, i) {
            return function (r) {
                if ("undefined" == typeof r || "undefined" == typeof r.length || r.length < 1 || r.length > 4)throw new n("value must be and array with length between 1 and 4.");
                var o = t[e];
                o.value = r, o.dirty || (i.push(o), o.dirty = !0)
            }
        }

        var B = function (e) {
            e = t(e, t.EMPTY_OBJECT), this.geometryInstances = e.geometryInstances, this.appearance = e.appearance, this._appearance = void 0, this._material = void 0, this.modelMatrix = r.IDENTITY.clone(), this.show = !0, this._vertexCacheOptimize = t(e.vertexCacheOptimize, !0), this._releaseGeometryInstances = t(e.releaseGeometryInstances, !0), this._allow3DOnly = t(e.allow3DOnly, !1), this._boundingSphere = void 0, this._boundingSphere2D = void 0, this._perInstanceAttributes = {}, this._lastPerInstanceAttributeIndex = 0, this._dirtyAttributes = [], this._va = [], this._attributeIndices = void 0, this._rs = void 0, this._sp = void 0, this._pickSP = void 0, this._pickIds = [], this._commandLists = new g
        };
        return B.prototype.update = function (e, t, n) {
            if (!(!this.show || "undefined" == typeof this.geometryInstances && 0 === this._va.length || "undefined" == typeof this.appearance || t.mode !== C.SCENE3D && this._allow3DOnly || !t.passes.color && !t.passes.pick)) {
                var i, r, o, s, l = this._commandLists.colorList, c = this._commandLists.pickList;
                if (0 === this._va.length) {
                    var d = t.scene2D.projection, f = Array.isArray(this.geometryInstances) ? this.geometryInstances : [this.geometryInstances];
                    o = f.length;
                    var h = new Array(o);
                    for (s = 0; o > s; ++s)h[s] = T(f[s]);
                    var p = I(this, h, e, d);
                    this._attributeIndices = a.createAttributeIndices(p[0]), this._boundingSphere = p[0].boundingSphere, this._allow3DOnly || "undefined" == typeof this._boundingSphere || (this._boundingSphere2D = u.projectTo2D(this._boundingSphere, d));
                    var m, g = M(h), x = [];
                    for (o = p.length, s = 0; o > s; ++s) {
                        m = p[s];
                        var S = P(e, m, this._attributeIndices, g);
                        x.push(e.createVertexArrayFromGeometry({geometry: m, attributeIndices: this._attributeIndices, bufferUsage: y.STATIC_DRAW, vertexLayout: v.INTERLEAVED, vertexArrayAttributes: S}))
                    }
                    for (this._va = x, this._perInstanceAttributes = O(h, x, this._attributeIndices), s = 0; o > s; ++s)m = p[s], i = new _, i.owner = this, i.primitiveType = m.primitiveType, i.vertexArray = this._va[s], l.push(i), r = new _, r.owner = this, r.primitiveType = m.primitiveType, r.vertexArray = this._va[s], c.push(r);
                    this._releaseGeometryInstances && (this.geometryInstances = void 0)
                }
                var b = this.appearance, E = b.material, A = !1, D = !1;
                if (this._appearance !== b ? (this._appearance = b, this._material = E, A = !0, D = !0) : this._material !== E && (this._material = E, D = !0), A && (this._rs = e.createRenderState(b.renderState)), D) {
                    var F = e.getShaderCache(), V = R(this, b.vertexShaderSource);
                    V = L(this, V);
                    var B = b.getFragmentShaderSource();
                    this._sp = F.replaceShaderProgram(this._sp, V, B, this._attributeIndices), this._pickSP = F.replaceShaderProgram(this._pickSP, z(V), w(B, "varying"), this._attributeIndices), N(this._sp, this._attributeIndices), N(this._pickSP, this._attributeIndices)
                }
                if (A || D) {
                    var k = "undefined" != typeof E ? E._uniforms : void 0;
                    for (o = l.length, s = 0; o > s; ++s)i = l[s], i.renderState = this._rs, i.shaderProgram = this._sp, i.uniformMap = k, r = c[s], r.renderState = this._rs, r.shaderProgram = this._pickSP, r.uniformMap = k
                }
                if (this._dirtyAttributes.length > 0) {
                    var U = this._dirtyAttributes;
                    for (o = U.length, s = 0; o > s; ++s) {
                        for (var q = U[s], W = q.value, H = q.indices, G = H.length, j = 0; G > j; ++j) {
                            for (var Y = H[j], X = Y.offset, Z = Y.count, K = Y.attribute, J = K.componentDatatype, Q = K.componentsPerAttribute, $ = J.createTypedArray(Z * Q), et = 0; Z > et; ++et)$.set(W, et * Q);
                            var tt = X * Q * J.sizeInBytes;
                            K.vertexBuffer.copyFromArrayView($, tt)
                        }
                        q.dirty = !1
                    }
                    U.length = 0
                }
                var nt;
                for (t.mode === C.SCENE3D ? nt = this._boundingSphere : t.mode === C.COLUMBUS_VIEW ? nt = this._boundingSphere2D : t.mode === C.SCENE2D && "undefined" != typeof this._boundingSphere2D ? (nt = u.clone(this._boundingSphere2D), nt.center.x = 0) : "undefined" != typeof this._boundingSphere && "undefined" != typeof this._boundingSphere2D && (nt = u.union(this._boundingSphere, this._boundingSphere2D)), o = l.length, s = 0; o > s; ++s)l[s].modelMatrix = this.modelMatrix, c[s].modelMatrix = this.modelMatrix, l[s].boundingVolume = nt, c[s].boundingVolume = nt;
                n.push(this._commandLists)
            }
        }, B.prototype.getGeometryInstanceAttributes = function (e) {
            if ("undefined" == typeof e)throw new n("id is required");
            if ("undefined" == typeof this._perInstanceAttributes)throw new n("must call update before calling getGeometryInstanceAttributes");
            for (var t = -1, i = this._lastPerInstanceAttributeIndex, r = this._perInstanceAttributes.ids, o = r.length, a = 0; o > a; ++a) {
                var s = (i + a) % o;
                if (e === r[s]) {
                    t = s;
                    break
                }
            }
            if (-1 === t)return void 0;
            var u = this._perInstanceAttributes.indices[t], l = {};
            for (var c in u)u.hasOwnProperty(c) && Object.defineProperty(l, c, {get: F(c, u), set: V(c, u, this._dirtyAttributes)});
            return this._lastPerInstanceAttributeIndex = t, l
        }, B.prototype.isDestroyed = function () {
            return!1
        }, B.prototype.destroy = function () {
            var e, t;
            this._sp = this._sp && this._sp.release(), this._pickSP = this._pickSP && this._pickSP.release();
            var n = this._va;
            for (e = n.length, t = 0; e > t; ++t)n[t].destroy();
            this._va = void 0;
            var r = this._pickIds;
            for (e = r.length, t = 0; e > t; ++t)r[t].destroy();
            return this._pickIds = void 0, i(this)
        }, B
    }), n("Scene/Polygon", ["../Core/DeveloperError", "../Core/defaultValue", "../Core/Color", "../Core/destroyObject", "../Core/Math", "../Core/Ellipsoid", "../Core/GeometryInstance", "../Core/PolygonGeometry", "../Core/PolygonPipeline", "../Core/Queue", "./EllipsoidSurfaceAppearance", "./Primitive", "./Material"], function (e, t, n, i, r, o, a, s, u, l, c, d, f) {
        "use strict";
        var h = function (e) {
            e = t(e, t.EMPTY_OBJECT), this.ellipsoid = t(e.ellipsoid, o.WGS84), this._ellipsoid = void 0, this.granularity = t(e.granularity, r.RADIANS_PER_DEGREE), this._granularity = void 0, this.height = t(e.height, 0), this._height = void 0, this.textureRotationAngle = t(e.textureRotationAngle, 0), this._textureRotationAngle = void 0, this.show = t(e.show, !0);
            var i = f.fromType(void 0, f.ColorType);
            i.uniforms.color = new n(1, 1, 0, .5), this.material = t(e.material, i), this._positions = e.positions, this._polygonHierarchy = e.polygonHierarchy, this._createPrimitive = !1, this._primitive = void 0
        };
        return h.prototype.getPositions = function () {
            return this._positions
        }, h.prototype.setPositions = function (t) {
            if ("undefined" != typeof t && t.length < 3)throw new e("At least three positions are required.");
            this._positions = t, this._polygonHierarchy = void 0, this._createPrimitive = !0
        }, h.prototype.configureFromPolygonHierarchy = function (e) {
            this._positions = void 0, this._polygonHierarchy = e, this._createPrimitive = !0
        }, h.prototype.update = function (t, n, i) {
            if ("undefined" == typeof this.ellipsoid)throw new e("this.ellipsoid must be defined.");
            if ("undefined" == typeof this.material)throw new e("this.material must be defined.");
            if (this.granularity < 0)throw new e("this.granularity and scene2D/scene3D overrides must be greater than zero.");
            if (this.show && (this._createPrimitive || "undefined" != typeof this._primitive)) {
                if (this._createPrimitive || this._ellipsoid !== this.ellipsoid || this._granularity !== this.granularity || this._height !== this.height || this._textureRotationAngle !== this.textureRotationAngle) {
                    if (this._createPrimitive = !1, this._ellipsoid = this.ellipsoid, this._granularity = this.granularity, this._height = this.height, this._textureRotationAngle = this.textureRotationAngle, this._primitive = this._primitive && this._primitive.destroy(), "undefined" == typeof this._positions && "undefined" == typeof this._polygonHierarchy)return;
                    var r;
                    r = "undefined" != typeof this._positions ? new a({geometry: s.fromPositions({positions: this._positions, height: this.height, vertexFormat: c.VERTEX_FORMAT, stRotation: this.textureRotationAngle, ellipsoid: this.ellipsoid, granularity: this.granularity}), id: this}) : new a({geometry: new s({polygonHierarchy: this._polygonHierarchy, height: this.height, vertexFormat: c.VERTEX_FORMAT, stRotation: this.textureRotationAngle, ellipsoid: this.ellipsoid, granularity: this.granularity}), id: this}), this._primitive = new d({geometryInstances: r, appearance: new c({aboveGround: this.height > 0})})
                }
                this._primitive.appearance.material = this.material, this._primitive.update(t, n, i)
            }
        }, h.prototype.isDestroyed = function () {
            return!1
        }, h.prototype.destroy = function () {
            return this._primitive = this._primitive && this._primitive.destroy(), i(this)
        }, h
    }), n("DynamicScene/DynamicPolygonVisualizer", ["../Core/Cartesian3", "../Core/DeveloperError", "../Core/destroyObject", "../Scene/Polygon", "../Scene/Material"], function (e, t, n, i, r) {
        "use strict";
        function o(e, t, n) {
            var o = n.polygon;
            if ("undefined" != typeof o) {
                var a, u = o.show, l = n.ellipse, c = n.position, d = n.vertexPositions, f = n._polygonVisualizerIndex, h = n.isAvailable(t) && ("undefined" == typeof u || u.getValue(t)), p = "undefined" != typeof d;
                if (!h || !p && ("undefined" == typeof l || "undefined" == typeof c))return"undefined" != typeof f && (a = e._polygonCollection[f], a.show = !1, n._polygonVisualizerIndex = void 0, e._unusedIndexes.push(f)), void 0;
                var m = e._scene.getContext();
                if ("undefined" == typeof f) {
                    var y = e._unusedIndexes, v = y.length;
                    v > 0 ? (f = y.pop(), a = e._polygonCollection[f]) : (f = e._polygonCollection.length, a = new i, e._polygonCollection.push(a), e._primitives.add(a)), n._polygonVisualizerIndex = f, a.dynamicObject = n, a.material = r.fromType(m, r.ColorType)
                } else a = e._polygonCollection[f];
                a.show = !0;
                var g;
                g = p ? d.getValueCartesian(t) : l.getValue(t, c.getValueCartesian(t, s)), a._visualizerPositions !== g && "undefined" != typeof g && g.length > 3 && (a.setPositions(g), a._visualizerPositions = g);
                var _ = o.material;
                "undefined" != typeof _ && (a.material = _.getValue(t, m, a.material))
            }
        }

        var a = function (e, n) {
            if ("undefined" == typeof e)throw new t("scene is required.");
            this._scene = e, this._unusedIndexes = [], this._primitives = e.getPrimitives(), this._polygonCollection = [], this._dynamicObjectCollection = void 0, this.setDynamicObjectCollection(n)
        };
        a.prototype.getScene = function () {
            return this._scene
        }, a.prototype.getDynamicObjectCollection = function () {
            return this._dynamicObjectCollection
        }, a.prototype.setDynamicObjectCollection = function (e) {
            var t = this._dynamicObjectCollection;
            t !== e && ("undefined" != typeof t && (t.objectsRemoved.removeEventListener(a.prototype._onObjectsRemoved, this), this.removeAllPrimitives()), this._dynamicObjectCollection = e, "undefined" != typeof e && e.objectsRemoved.addEventListener(a.prototype._onObjectsRemoved, this))
        }, a.prototype.update = function (e) {
            if ("undefined" == typeof e)throw new t("time is requied.");
            if ("undefined" != typeof this._dynamicObjectCollection)for (var n = this._dynamicObjectCollection.getObjects(), i = 0, r = n.length; r > i; i++)o(this, e, n[i])
        }, a.prototype.removeAllPrimitives = function () {
            var e, t;
            for (e = 0, t = this._polygonCollection.length; t > e; e++)this._primitives.remove(this._polygonCollection[e]);
            if ("undefined" != typeof this._dynamicObjectCollection) {
                var n = this._dynamicObjectCollection.getObjects();
                for (e = n.length - 1; e > -1; e--)n[e]._polygonVisualizerIndex = void 0
            }
            this._unusedIndexes = [], this._polygonCollection = []
        }, a.prototype.isDestroyed = function () {
            return!1
        }, a.prototype.destroy = function () {
            return this.removeAllPrimitives(), n(this)
        };
        var s = new e;
        return a.prototype._onObjectsRemoved = function (e, t) {
            for (var n = this._polygonCollection, i = this._unusedIndexes, r = t.length - 1; r > -1; r--) {
                var o = t[r], a = o._polygonVisualizerIndex;
                if ("undefined" != typeof a) {
                    var s = n[a];
                    s.show = !1, i.push(a), o._polygonVisualizerIndex = void 0
                }
            }
        }, a
    }), n("DynamicScene/DynamicPolylineVisualizer", ["../Core/DeveloperError", "../Core/destroyObject", "../Core/Cartesian3", "../Core/Color", "../Scene/Material", "../Scene/PolylineCollection"], function (e, t, n, i, r, o) {
        "use strict";
        function a(e, t, n) {
            var o = n.polyline;
            if ("undefined" != typeof o) {
                var a, s = o.show, l = n.ellipse, c = n.position, d = n.vertexPositions, f = n._polylineVisualizerIndex, h = n.isAvailable(t) && ("undefined" == typeof s || s.getValue(t));
                if (!h || "undefined" == typeof d && ("undefined" == typeof l || "undefined" == typeof c))return"undefined" != typeof f && (a = e._polylineCollection.get(f), a.setShow(!1), n._polylineVisualizerIndex = void 0, e._unusedIndexes.push(f)), void 0;
                var p;
                if ("undefined" == typeof f) {
                    var m = e._unusedIndexes, y = m.length;
                    y > 0 ? (f = m.pop(), a = e._polylineCollection.get(f)) : (f = e._polylineCollection.getLength(), a = e._polylineCollection.add()), n._polylineVisualizerIndex = f, a.dynamicObject = n, a.setWidth(1);
                    var v = a.getMaterial();
                    ("undefined" == typeof v || v.type !== r.PolylineOutlineType) && (v = r.fromType(e._scene.getContext(), r.PolylineOutlineType), a.setMaterial(v)), p = v.uniforms, i.clone(i.WHITE, p.color), i.clone(i.BLACK, p.outlineColor), p.outlineWidth = 0
                } else a = e._polylineCollection.get(f), p = a.getMaterial().uniforms;
                a.setShow(!0);
                var g;
                g = "undefined" != typeof l ? l.getValue(t, c.getValueCartesian(t, u)) : d.getValueCartesian(t), "undefined" != typeof g && a._visualizerPositions !== g && (a.setPositions(g), a._visualizerPositions = g);
                var _ = o.color;
                if ("undefined" != typeof _ && (p.color = _.getValue(t, p.color)), _ = o.outlineColor, "undefined" != typeof _ && (p.outlineColor = _.getValue(t, p.outlineColor)), _ = o.outlineWidth, "undefined" != typeof _ && (p.outlineWidth = _.getValue(t)), _ = o.width, "undefined" != typeof _) {
                    var w = _.getValue(t);
                    "undefined" != typeof w && a.setWidth(w)
                }
            }
        }

        var s = function (t, n) {
            if ("undefined" == typeof t)throw new e("scene is required.");
            this._scene = t, this._unusedIndexes = [], this._primitives = t.getPrimitives();
            var i = this._polylineCollection = new o;
            t.getPrimitives().add(i), this._dynamicObjectCollection = void 0, this.setDynamicObjectCollection(n)
        };
        s.prototype.getScene = function () {
            return this._scene
        }, s.prototype.getDynamicObjectCollection = function () {
            return this._dynamicObjectCollection
        }, s.prototype.setDynamicObjectCollection = function (e) {
            var t = this._dynamicObjectCollection;
            t !== e && ("undefined" != typeof t && (t.objectsRemoved.removeEventListener(s.prototype._onObjectsRemoved, this), this.removeAllPrimitives()), this._dynamicObjectCollection = e, "undefined" != typeof e && e.objectsRemoved.addEventListener(s.prototype._onObjectsRemoved, this))
        }, s.prototype.update = function (t) {
            if ("undefined" == typeof t)throw new e("time is requied.");
            if ("undefined" != typeof this._dynamicObjectCollection)for (var n = this._dynamicObjectCollection.getObjects(), i = 0, r = n.length; r > i; i++)a(this, t, n[i])
        }, s.prototype.removeAllPrimitives = function () {
            var e;
            if (this._polylineCollection.removeAll(), "undefined" != typeof this._dynamicObjectCollection) {
                var t = this._dynamicObjectCollection.getObjects();
                for (e = t.length - 1; e > -1; e--)t[e]._polylineVisualizerIndex = void 0
            }
            this._unusedIndexes = []
        }, s.prototype.isDestroyed = function () {
            return!1
        }, s.prototype.destroy = function () {
            return this.removeAllPrimitives(), this._scene.getPrimitives().remove(this._polylineCollection), t(this)
        };
        var u = new n;
        return s.prototype._onObjectsRemoved = function (e, t) {
            for (var n = this._polylineCollection, i = this._unusedIndexes, r = t.length - 1; r > -1; r--) {
                var o = t[r], a = o._polylineVisualizerIndex;
                if ("undefined" != typeof a) {
                    var s = n.get(a);
                    s.setShow(!1), i.push(a), o._polylineVisualizerIndex = void 0
                }
            }
        }, s
    }), n("DynamicScene/DynamicPyramidVisualizer", ["../Core/defaultValue", "../Core/DeveloperError", "../Core/destroyObject", "../Core/Color", "../Core/Matrix3", "../Core/Matrix4", "../Scene/CustomSensorVolume", "../Scene/Material"], function (e, t, n, i, r, o, a, s) {
        "use strict";
        function u(t, n, u) {
            var c = t._scene.getContext(), h = u.pyramid;
            if ("undefined" != typeof h) {
                var p = h.directions;
                if ("undefined" != typeof p) {
                    var m = u.position;
                    if ("undefined" != typeof m) {
                        var y = u.orientation;
                        if ("undefined" != typeof y) {
                            var v, g = h.show, _ = u._pyramidVisualizerIndex, w = u.isAvailable(n) && ("undefined" == typeof g || g.getValue(n));
                            if (!w)return"undefined" != typeof _ && (v = t._pyramidCollection[_], v.show = !1, u._pyramidVisualizerIndex = void 0, t._unusedIndexes.push(_)), void 0;
                            if ("undefined" == typeof _) {
                                var C = t._unusedIndexes, x = C.length;
                                x > 0 ? (_ = C.pop(), v = t._pyramidCollection[_]) : (_ = t._pyramidCollection.length, v = new a, t._pyramidCollection.push(v), t._primitives.add(v)), u._pyramidVisualizerIndex = _, v.dynamicObject = u, v.radius = Number.POSITIVE_INFINITY, v.showIntersection = !0, v.intersectionColor = i.YELLOW, v.intersectionWidth = 5, v.material = s.fromType(c, s.ColorType)
                            } else v = t._pyramidCollection[_];
                            v.show = !0;
                            var S = p.getValueSpherical(n);
                            "undefined" != typeof S && v._visualizerDirections !== S && (v.setDirections(S), v._visualizerDirections = S), d = e(m.getValueCartesian(n, d), v._visualizerPosition), f = e(y.getValue(n, f), v._visualizerOrientation), "undefined" == typeof d || "undefined" == typeof f || d.equals(v._visualizerPosition) && f.equals(v._visualizerOrientation) || (o.fromRotationTranslation(r.fromQuaternion(f, l), d, v.modelMatrix), d.clone(v._visualizerPosition), f.clone(v._visualizerOrientation));
                            var b = h.material;
                            "undefined" != typeof b && (v.material = b.getValue(n, c, v.material));
                            var T = h.intersectionColor;
                            if ("undefined" != typeof T) {
                                var E = T.getValue(n, E);
                                "undefined" != typeof E && (v.intersectionColor = E)
                            }
                            if (T = h.intersectionWidth, "undefined" != typeof T) {
                                var A = T.getValue(n, A);
                                "undefined" != typeof A && (v.intersectionWidth = A)
                            }
                            if (T = h.radius, "undefined" != typeof T) {
                                var M = T.getValue(n, M);
                                "undefined" != typeof M && (v.radius = M)
                            }
                        }
                    }
                }
            }
        }

        var l = new r, c = function (e, n) {
            if ("undefined" == typeof e)throw new t("scene is required.");
            this._scene = e, this._unusedIndexes = [], this._primitives = e.getPrimitives(), this._pyramidCollection = [], this._dynamicObjectCollection = void 0, this.setDynamicObjectCollection(n)
        };
        c.prototype.getScene = function () {
            return this._scene
        }, c.prototype.getDynamicObjectCollection = function () {
            return this._dynamicObjectCollection
        }, c.prototype.setDynamicObjectCollection = function (e) {
            var t = this._dynamicObjectCollection;
            t !== e && ("undefined" != typeof t && (t.objectsRemoved.removeEventListener(c.prototype._onObjectsRemoved, this), this.removeAllPrimitives()), this._dynamicObjectCollection = e, "undefined" != typeof e && e.objectsRemoved.addEventListener(c.prototype._onObjectsRemoved, this))
        }, c.prototype.update = function (e) {
            if ("undefined" == typeof e)throw new t("time is requied.");
            if ("undefined" != typeof this._dynamicObjectCollection)for (var n = this._dynamicObjectCollection.getObjects(), i = 0, r = n.length; r > i; i++)u(this, e, n[i])
        }, c.prototype.removeAllPrimitives = function () {
            var e, t;
            for (e = 0, t = this._pyramidCollection.length; t > e; e++)this._primitives.remove(this._pyramidCollection[e]);
            if ("undefined" != typeof this._dynamicObjectCollection) {
                var n = this._dynamicObjectCollection.getObjects();
                for (e = n.length - 1; e > -1; e--)n[e]._pyramidVisualizerIndex = void 0
            }
            this._unusedIndexes = [], this._pyramidCollection = []
        }, c.prototype.isDestroyed = function () {
            return!1
        }, c.prototype.destroy = function () {
            return this.removeAllPrimitives(), n(this)
        };
        var d, f;
        return c.prototype._onObjectsRemoved = function (e, t) {
            for (var n = this._pyramidCollection, i = this._unusedIndexes, r = t.length - 1; r > -1; r--) {
                var o = t[r], a = o._pyramidVisualizerIndex;
                if ("undefined" != typeof a) {
                    var s = n[a];
                    s.show = !1, i.push(a), o._pyramidVisualizerIndex = void 0
                }
            }
        }, c
    }), n("DynamicScene/DynamicVectorVisualizer", ["../Core/DeveloperError", "../Core/destroyObject", "../Core/Cartesian3", "../Core/Color", "../Scene/Material", "../Scene/PolylineCollection"], function (e, t, n, i, r, o) {
        "use strict";
        function a(e, t, o) {
            var a = o.vector;
            if ("undefined" != typeof a) {
                var s, u = a.show, l = o.position, c = a.direction, d = a.length, f = o._vectorVisualizerIndex, h = o.isAvailable(t) && ("undefined" == typeof u || u.getValue(t));
                if (!h || "undefined" == typeof c || "undefined" == typeof l || "undefined" == typeof d)return"undefined" != typeof f && (s = e._polylineCollection.get(f), s.setShow(!1), o._vectorVisualizerIndex = void 0, e._unusedIndexes.push(f)), void 0;
                var p;
                if ("undefined" == typeof f) {
                    var m = e._unusedIndexes;
                    m.length > 0 ? (f = m.pop(), s = e._polylineCollection.get(f)) : (f = e._polylineCollection.getLength(), s = e._polylineCollection.add(), s._visualizerPositions = [new n, new n]), o._vectorVisualizerIndex = f, s.dynamicObject = o, s.setWidth(1);
                    var y = s.getMaterial();
                    ("undefined" == typeof y || y.type !== r.PolylineArrowType) && (y = r.fromType(e._scene.getContext(), r.PolylineArrowType), s.setMaterial(y)), p = y.uniforms, i.clone(i.WHITE, p.color)
                } else s = e._polylineCollection.get(f), p = s.getMaterial().uniforms;
                s.setShow(!0);
                var v = s._visualizerPositions, g = l.getValueCartesian(t, v[0]), _ = c.getValue(t, v[1]), w = d.getValue(t);
                "undefined" != typeof g && "undefined" != typeof _ && "undefined" != typeof w && (n.add(g, _.normalize(_).multiplyByScalar(w, _), _), s.setPositions(v));
                var C = a.color;
                if ("undefined" != typeof C && (p.color = C.getValue(t, p.color)), C = a.width, "undefined" != typeof C) {
                    var x = C.getValue(t);
                    "undefined" != typeof x && s.setWidth(x)
                }
            }
        }

        var s = function (t, n) {
            if ("undefined" == typeof t)throw new e("scene is required.");
            this._scene = t, this._unusedIndexes = [], this._primitives = t.getPrimitives();
            var i = this._polylineCollection = new o;
            t.getPrimitives().add(i), this._dynamicObjectCollection = void 0, this.setDynamicObjectCollection(n)
        };
        return s.prototype.getScene = function () {
            return this._scene
        }, s.prototype.getDynamicObjectCollection = function () {
            return this._dynamicObjectCollection
        }, s.prototype.setDynamicObjectCollection = function (e) {
            var t = this._dynamicObjectCollection;
            t !== e && ("undefined" != typeof t && (t.objectsRemoved.removeEventListener(s.prototype._onObjectsRemoved, this), this.removeAllPrimitives()), this._dynamicObjectCollection = e, "undefined" != typeof e && e.objectsRemoved.addEventListener(s.prototype._onObjectsRemoved, this))
        }, s.prototype.update = function (t) {
            if ("undefined" == typeof t)throw new e("time is requied.");
            if ("undefined" != typeof this._dynamicObjectCollection)for (var n = this._dynamicObjectCollection.getObjects(), i = 0, r = n.length; r > i; i++)a(this, t, n[i])
        }, s.prototype.removeAllPrimitives = function () {
            var e;
            if (this._polylineCollection.removeAll(), "undefined" != typeof this._dynamicObjectCollection) {
                var t = this._dynamicObjectCollection.getObjects();
                for (e = t.length - 1; e > -1; e--)t[e]._vectorVisualizerIndex = void 0
            }
            this._unusedIndexes = []
        }, s.prototype.isDestroyed = function () {
            return!1
        }, s.prototype.destroy = function () {
            return this.removeAllPrimitives(), this._scene.getPrimitives().remove(this._polylineCollection), t(this)
        }, s.prototype._onObjectsRemoved = function (e, t) {
            for (var n = this._polylineCollection, i = this._unusedIndexes, r = t.length - 1; r > -1; r--) {
                var o = t[r], a = o._vectorVisualizerIndex;
                if ("undefined" != typeof a) {
                    var s = n.get(a);
                    s.setShow(!1), i.push(a), o._vectorVisualizerIndex = void 0
                }
            }
        }, s
    }), n("DynamicScene/CzmlDefaults", ["./DynamicObject", "./DynamicBillboard", "./DynamicClock", "./DynamicEllipse", "./DynamicEllipsoid", "./DynamicCone", "./DynamicLabel", "./DynamicPath", "./DynamicPoint", "./DynamicPolygon", "./DynamicPolyline", "./DynamicPyramid", "./DynamicVector", "./DynamicBillboardVisualizer", "./DynamicEllipsoidVisualizer", "./DynamicConeVisualizerUsingCustomSensor", "./DynamicLabelVisualizer", "./DynamicPathVisualizer", "./DynamicPointVisualizer", "./DynamicPolygonVisualizer", "./DynamicPolylineVisualizer", "./DynamicPyramidVisualizer", "./DynamicVectorVisualizer"], function (e, t, n, i, r, o, a, s, u, l, c, d, f, h, p, m, y, v, g, _, w, C, x) {
        "use strict";
        var S = {updaters: [n.processCzmlPacket, t.processCzmlPacket, i.processCzmlPacket, r.processCzmlPacket, o.processCzmlPacket, a.processCzmlPacket, s.processCzmlPacket, u.processCzmlPacket, l.processCzmlPacket, c.processCzmlPacket, d.processCzmlPacket, f.processCzmlPacket, e.processCzmlPacketPosition, e.processCzmlPacketViewFrom, e.processCzmlPacketOrientation, e.processCzmlPacketVertexPositions, e.processCzmlPacketAvailability], mergers: [n.mergeProperties, t.mergeProperties, i.mergeProperties, r.mergeProperties, o.mergeProperties, a.mergeProperties, s.mergeProperties, u.mergeProperties, l.mergeProperties, c.mergeProperties, d.mergeProperties, f.mergeProperties, e.mergeProperties], cleaners: [t.undefineProperties, i.undefineProperties, r.undefineProperties, o.undefineProperties, a.undefineProperties, s.undefineProperties, u.undefineProperties, l.undefineProperties, c.undefineProperties, d.undefineProperties, f.undefineProperties, e.undefineProperties, n.undefineProperties], createVisualizers: function (e) {
            return[new h(e), new p(e), new m(e), new y(e), new g(e), new _(e), new w(e), new C(e), new x(e), new v(e)]
        }};
        return S
    }), n("DynamicScene/CompositeDynamicObjectCollection", ["../Core/defaultValue", "../Core/Event", "../Core/Iso8601", "../Core/TimeInterval", "../Core/DeveloperError", "./DynamicObject", "./CzmlDefaults"], function (e, t, n, i, r, o, a) {
        "use strict";
        function s(e, t) {
            var n = e._hash[t];
            return n || (n = new o(t), e._hash[t] = n, e._array.push(n)), n
        }

        function u(e) {
            var t = e._array;
            e._hash = {}, e._array = [], t.length > 0 && e.objectsRemoved.raiseEvent(e, t)
        }

        var l = function (n, i, r) {
            this._hash = {}, this._array = [], this._collections = [], this.mergeFunctions = e(i, a.mergers), this.cleanFunctions = e(r, a.cleaners), this.objectPropertiesChanged = new t, this.objectsRemoved = new t, this.setCollections(n)
        };
        return l.prototype.computeAvailability = function () {
            for (var e = n.MAXIMUM_VALUE, t = n.MINIMUM_VALUE, r = this._collections, o = 0, a = r.length; a > o; ++o) {
                var s = r[o], u = s.computeAvailability(), l = u.start, c = u.stop;
                l.lessThan(e) && !l.equals(n.MINIMUM_VALUE) && (e = u.start), c.greaterThan(t) && !c.equals(n.MAXIMUM_VALUE) && (t = u.stop)
            }
            return n.MAXIMUM_VALUE.equals(e) && (e = n.MINIMUM_VALUE), n.MINIMUM_VALUE.equals(t) && (t = n.MAXIMUM_VALUE), new i(e, t, !0, !0)
        }, l.prototype.getCollections = function () {
            return this._collections.slice(0)
        }, l.prototype.setCollections = function (e) {
            e = "undefined" != typeof e ? e : [];
            var t = this._collections;
            if (e !== t) {
                var n, i;
                for (i = t.length - 1; i > -1; i--)n = t[i], n.compositeCollection = void 0, n.objectPropertiesChanged.removeEventListener(l.prototype._onObjectPropertiesChanged, this);
                t = this._collections = e, u(this);
                var r = this.mergeFunctions;
                for (i = t.length - 1; i > -1; i--) {
                    n = t[i], n.compositeCollection = this, n.objectPropertiesChanged.addEventListener(l.prototype._onObjectPropertiesChanged, this);
                    for (var o = n.getObjects(), a = o.length - 1; a > -1; a--)for (var c = o[a], d = s(this, c.id), f = r.length - 1; f > -1; f--) {
                        var h = r[f];
                        h(d, c)
                    }
                }
            }
        }, l.prototype.getObject = function (e) {
            if ("undefined" == typeof e)throw new r("id is required.");
            return this._hash[e]
        }, l.prototype.getObjects = function () {
            return this._array
        }, l.prototype.clear = function () {
            this.setCollections([])
        }, l.prototype._onObjectPropertiesChanged = function (e, t) {
            for (var n, i, r = this.mergeFunctions, o = this.cleanFunctions, a = this._collections, u = [], l = t.length - 1; l > -1; l--) {
                if (n = t[l], i = this.getObject(n.id), "undefined" != typeof i)for (var c = o.length - 1; c > -1; c--) {
                    var d = o[c];
                    d(i)
                } else i = s(this, n.id);
                u.push(i);
                for (var f = a.length - 1; f > -1; f--) {
                    var h = a[f], p = h.getObject(n.id);
                    if ("undefined" != typeof p)for (var m = r.length - 1; m > -1; m--) {
                        var y = r[m];
                        y(i, p)
                    }
                }
            }
            u.length > 0 && this.objectPropertiesChanged.raiseEvent(this, u)
        }, l
    }), n("DynamicScene/ConstantProperty", [], function () {
        "use strict";
        var e = function (e) {
            this._value = e, this._clonable = "undefined" != typeof e && "function" == typeof e.clone
        };
        return e.prototype.getValue = function (e, t) {
            var n = this._value;
            return this._clonable ? n.clone(t) : n
        }, e
    }), n("DynamicScene/processCzml", ["../Core/createGuid", "../Core/DeveloperError", "./CzmlDefaults"], function (e, t, n) {
        "use strict";
        function i(t, n, i, r, o, a) {
            var s = t.id;
            if ("undefined" == typeof s && (s = e()), t["delete"] === !0)n.removeObject(s); else for (var u = n.getOrCreateObject(s), l = o.length - 1; l > -1; l--)o[l](u, t, n, a) && "undefined" == typeof r[s] && (r[s] = !0, i.push(u))
        }

        var r = function (e, r, o, a) {
            if ("undefined" == typeof e)throw new t("czml is required.");
            if ("undefined" == typeof r)throw new t("dynamicObjectCollection is required.");
            var s = [], u = {};
            if (a = "undefined" != typeof a ? a : n.updaters, Array.isArray(e))for (var l = 0, c = e.length; c > l; l++)i(e[l], r, s, u, a, o); else i(e, r, s, u, a, o);
            return s.length > 0 && r.objectPropertiesChanged.raiseEvent(r, s), s
        };
        return r
    }), n("DynamicScene/DynamicObjectCollection", ["../Core/Event", "../Core/TimeInterval", "../Core/Iso8601", "../Core/DeveloperError", "./DynamicObject"], function (e, t, n, i, r) {
        "use strict";
        var o = function () {
            this._hash = {}, this._array = [], this.compositeCollection = void 0, this.objectPropertiesChanged = new e, this.objectsRemoved = new e
        };
        return o.prototype.computeAvailability = function () {
            for (var e = n.MAXIMUM_VALUE, i = n.MINIMUM_VALUE, r = this._array, o = 0, a = r.length; a > o; o++) {
                var s = r[o], u = s.availability;
                if ("undefined" != typeof u) {
                    var l = u.start, c = u.stop;
                    l.lessThan(e) && !l.equals(n.MINIMUM_VALUE) && (e = s.availability.start), c.greaterThan(i) && !c.equals(n.MAXIMUM_VALUE) && (i = s.availability.stop)
                }
            }
            return n.MAXIMUM_VALUE.equals(e) && (e = n.MINIMUM_VALUE), n.MINIMUM_VALUE.equals(i) && (i = n.MAXIMUM_VALUE), new t(e, i, !0, !0)
        }, o.prototype.getObject = function (e) {
            if ("undefined" == typeof e)throw new i("id is required.");
            return this._hash[e]
        }, o.prototype.removeObject = function (e) {
            if ("undefined" == typeof e)throw new i("id is required.");
            var t = this._hash[e], n = "undefined" != typeof t;
            return n && (this._hash[e] = void 0, this._array.splice(this._array.indexOf(t), 1), this.objectsRemoved.raiseEvent(this, [t])), n
        }, o.prototype.getObjects = function () {
            return this._array
        }, o.prototype.getOrCreateObject = function (e) {
            if ("undefined" == typeof e)throw new i("id is required.");
            var t = this._hash[e];
            return t || (t = new r(e), this._hash[e] = t, this._array.push(t)), t
        }, o.prototype.clear = function () {
            var e = this._array;
            this._hash = {}, this._array = [], e.length > 0 && this.objectsRemoved.raiseEvent(this, e)
        }, o
    }), n("DynamicScene/CzmlDataSource", ["../Core/ClockRange", "../Core/ClockStep", "../Core/DeveloperError", "../Core/Event", "../Core/Iso8601", "../Core/loadJson", "./DynamicClock", "./processCzml", "./DynamicObjectCollection", "../ThirdParty/when"], function (e, t, n, i, r, o, a, s, u, l) {
        "use strict";
        function c(n, i, o) {
            var u = n._dynamicObjectCollection;
            s(i, u, o);
            var l, c = u.computeAvailability(), d = u.getObject("document");
            if ("undefined" != typeof d && "undefined" != typeof d.clock)l = new a, l.startTime = d.clock.startTime, l.stopTime = d.clock.stopTime, l.clockRange = d.clock.clockRange, l.clockStep = d.clock.clockStep, l.multiplier = d.clock.multiplier, l.currentTime = d.clock.currentTime; else if (!c.start.equals(r.MINIMUM_VALUE)) {
                l = new a, l.startTime = c.start, l.stopTime = c.stop, l.clockRange = e.LOOP_STOP;
                var f = l.startTime.getSecondsDifference(l.stopTime), h = Math.round(f / 120);
                l.multiplier = h, l.currentTime = l.startTime, l.clockStep = t.SYSTEM_CLOCK_MULTIPLIER
            }
            return l
        }

        var d = function () {
            this._changed = new i, this._error = new i, this._clock = void 0, this._dynamicObjectCollection = new u, this._timeVarying = !0
        };
        return d.prototype.getChangedEvent = function () {
            return this._changed
        }, d.prototype.getErrorEvent = function () {
            return this._error
        }, d.prototype.getClock = function () {
            return this._clock
        }, d.prototype.getDynamicObjectCollection = function () {
            return this._dynamicObjectCollection
        }, d.prototype.getIsTimeVarying = function () {
            return this._timeVarying
        }, d.prototype.process = function (e, t) {
            if ("undefined" == typeof e)throw new n("czml is required.");
            this._clock = c(this, e, t)
        }, d.prototype.load = function (e, t) {
            if ("undefined" == typeof e)throw new n("czml is required.");
            this._dynamicObjectCollection.clear(), this._clock = c(this, e, t)
        }, d.prototype.processUrl = function (e) {
            if ("undefined" == typeof e)throw new n("url is required.");
            var t = this;
            return l(o(e), function (n) {
                t.process(n, e)
            }, function (e) {
                return t._error.raiseEvent(t, e), l.reject(e)
            })
        }, d.prototype.loadUrl = function (e) {
            if ("undefined" == typeof e)throw new n("url is required.");
            var t = this;
            return l(o(e), function (n) {
                t.load(n, e)
            }, function (e) {
                return t._error.raiseEvent(t, e), l.reject(e)
            })
        }, d
    }), n("DynamicScene/CzmlUnitCartesian3", ["../Core/Cartesian3"], function (e) {
        "use strict";
        var t = 3, n = {doublesPerValue: t, doublesPerInterpolationValue: t, unwrapInterval: function (e) {
            return e.unitCartesian
        }, isSampled: function (e) {
            return Array.isArray(e) && e.length > t
        }, getValue: function (t, n) {
            return"undefined" == typeof n && (n = new e), n.x = t[0], n.y = t[1], n.z = t[2], n.normalize(n)
        }, getValueFromArray: function (t, n, i) {
            return"undefined" == typeof i && (i = new e), i.x = t[n], i.y = t[n + 1], i.z = t[n + 2], i.normalize(i)
        }};
        return n
    }), n("DynamicScene/CzmlUnitSpherical", ["../Core/Spherical"], function (e) {
        "use strict";
        var t = 2, n = {doublesPerValue: t, doublesPerInterpolationValue: t, unwrapInterval: function (e) {
            return e.unitSpherical
        }, isSampled: function (e) {
            return Array.isArray(e) && e.length > t
        }, getValue: function (t, n) {
            return"undefined" == typeof n && (n = new e), n.clock = t[0], n.cone = t[1], n.magnitude = 1, n
        }, getValueFromArray: function (t, n, i) {
            return"undefined" == typeof i && (i = new e), i.clock = t[n], i.cone = t[n + 1], i.magnitude = 1, i
        }};
        return n
    }), n("DynamicScene/DataSource", ["../Core/DeveloperError"], function (e) {
        "use strict";
        function t() {
            throw new e("This type should not be instantiated directly.")
        }

        var n = t;
        return n.prototype.getChangedEvent = t, n.prototype.getErrorEvent = t, n.prototype.getClock = t, n.prototype.getDynamicObjectCollection = t, n.prototype.getIsTimeVarying = t, n
    }), n("DynamicScene/DataSourceCollection", ["../Core/DeveloperError", "../Core/destroyObject", "../Core/Event"], function (e, t, n) {
        "use strict";
        var i = function () {
            this._dataSources = [], this.dataSourceAdded = new n, this.dataSourceRemoved = new n
        };
        return i.prototype.add = function (t) {
            if ("undefined" == typeof t)throw new e("dataSource is required.");
            this._dataSources.push(t), this.dataSourceAdded.raiseEvent(this, t)
        }, i.prototype.remove = function (e, t) {
            var n = this._dataSources.indexOf(e);
            return-1 !== n ? (this._dataSources.splice(n, 1), this.dataSourceRemoved.raiseEvent(this, e), "function" == typeof e.destroy && t && e.destroy(), !0) : !1
        }, i.prototype.removeAll = function (e) {
            for (var t = this._dataSources, n = t.length - 1; n >= 0; n--)this.remove(t[n], e)
        }, i.prototype.contains = function (e) {
            return-1 !== this.indexOf(e)
        }, i.prototype.indexOf = function (e) {
            return this._dataSources.indexOf(e)
        }, i.prototype.get = function (t) {
            if ("undefined" == typeof t)throw new e("index is required.");
            return this._dataSources[t]
        }, i.prototype.getLength = function () {
            return this._dataSources.length
        }, i.prototype.isDestroyed = function () {
            return!1
        }, i.prototype.destroy = function () {
            return this.removeAll(!0), t(this)
        }, i
    }), n("DynamicScene/VisualizerCollection", ["../Core/defaultValue", "../Core/destroyObject", "../Core/DeveloperError", "./CzmlDefaults"], function (e, t, n, i) {
        "use strict";
        var r = function (e, t) {
            this._visualizers = "undefined" != typeof e ? e : [], this._dynamicObjectCollection = void 0, this.setDynamicObjectCollection(t)
        };
        return r.createCzmlStandardCollection = function (e, t) {
            if ("undefined" == typeof e)throw new n("scene is required.");
            return new r(i.createVisualizers(e), t)
        }, r.prototype.getVisualizers = function () {
            return this._visualizers.slice(0)
        }, r.prototype.setVisualizers = function (t, n) {
            n = e(n, !0);
            var i, r = this._visualizers;
            if (n)for (i = r.length - 1; i > -1; i--) {
                var o = r[i];
                -1 === t.indexOf(o) && o.destroy()
            }
            "undefined" == typeof t && (t = []), this._visualizers = t;
            var a = this._dynamicObjectCollection;
            for (i = t.length - 1; i > -1; i--)t[i].setDynamicObjectCollection(a)
        }, r.prototype.getDynamicObjectCollection = function () {
            return this._dynamicObjectCollection
        }, r.prototype.setDynamicObjectCollection = function (e) {
            var t = this._dynamicObjectCollection;
            if (t !== e) {
                this._dynamicObjectCollection = e;
                for (var n = this._visualizers, i = n.length - 1; i > -1; i--)n[i].setDynamicObjectCollection(e)
            }
        }, r.prototype.update = function (e) {
            for (var t = this._visualizers, n = t.length - 1; n > -1; n--)t[n].update(e)
        }, r.prototype.removeAllPrimitives = function () {
            for (var e = this._visualizers, t = e.length - 1; t > -1; t--)e[t].removeAllPrimitives()
        }, r.prototype.isDestroyed = function () {
            return!1
        }, r.prototype.destroy = function (n) {
            if (n = e(n, !0), this.removeAllPrimitives(), n)for (var i = this._visualizers, r = i.length - 1; r > -1; r--)i[r].destroy();
            return t(this)
        }, r
    }), n("DynamicScene/DataSourceDisplay", ["../Core/defaultValue", "../Core/destroyObject", "../Core/DeveloperError", "../Core/EventHelper", "./DataSourceCollection", "./DynamicBillboardVisualizer", "./DynamicEllipsoidVisualizer", "./DynamicConeVisualizerUsingCustomSensor", "./DynamicLabelVisualizer", "./DynamicPathVisualizer", "./DynamicPointVisualizer", "./DynamicPolygonVisualizer", "./DynamicPolylineVisualizer", "./DynamicPyramidVisualizer", "./VisualizerCollection"], function (e, t, n, i, r, o, a, s, u, l, c, d, f, h, p) {
        "use strict";
        var m = [o, a, s, u, c, d, f, h, l], y = function (t, o) {
            if ("undefined" == typeof t)throw new n("scene is required.");
            var a = new r;
            this._eventHelper = new i, this._eventHelper.add(a.dataSourceAdded, this._onDataSourceAdded, this), this._eventHelper.add(a.dataSourceRemoved, this._onDataSourceRemoved, this), this._dataSourceCollection = a, this._scene = t, this._timeVaryingSources = [], this._staticSourcesToUpdate = [], this._visualizersTypes = e(o, m).slice(0)
        };
        return y.prototype.getScene = function () {
            return this._scene
        }, y.prototype.getVisualizerTypes = function () {
            return this._visualizersTypes.slice(0)
        }, y.prototype.getDataSources = function () {
            return this._dataSourceCollection
        }, y.prototype.isDestroyed = function () {
            return!1
        }, y.prototype.destroy = function () {
            this._eventHelper.removeAll();
            for (var e = this._dataSourceCollection, n = 0, i = e.getLength(); i > n; ++n) {
                var r = e.get(n);
                this._onDataSourceRemoved(this._dataSourceCollection, r), "function" == typeof r.destroy && r.destroy()
            }
            return t(this)
        }, y.prototype.update = function (e) {
            if ("undefined" == typeof e)throw new n("time is required.");
            var t, i = this._timeVaryingSources, r = i.length;
            for (t = 0; r > t; t++)i[t]._visualizerCollection.update(e);
            var o = this._staticSourcesToUpdate;
            if (r = o.length, r > 0) {
                for (t = 0; r > t; t++)o[t]._visualizerCollection.update(e);
                o.length = 0
            }
        }, y.prototype._onDataSourceAdded = function (e, t) {
            for (var n = this._visualizersTypes, i = n.length, r = new Array(i), o = this._scene, a = 0; i > a; a++)r[a] = new n[a](o);
            var s = new p(r, t.getDynamicObjectCollection());
            t._visualizerCollection = s, t.getChangedEvent().addEventListener(this._onDataSourceChanged, this), this._onDataSourceChanged(t)
        }, y.prototype._onDataSourceRemoved = function (e, t) {
            t.getChangedEvent().removeEventListener(this._onDataSourceChanged, this);
            var n = this._timeVaryingSources.indexOf(t);
            -1 !== n && this._timeVaryingSources.splice(n, 1);
            var i = this._staticSourcesToUpdate.indexOf(t);
            -1 !== i && this._staticSourcesToUpdate.splice(i, 1), t._visualizerCollection.destroy(), t._visualizerCollection = void 0
        }, y.prototype._onDataSourceChanged = function (e) {
            var t = this._timeVaryingSources.indexOf(e), n = this._staticSourcesToUpdate.indexOf(e);
            e.getIsTimeVarying() ? (-1 === t && this._timeVaryingSources.push(e), -1 !== n && this._staticSourcesToUpdate.splice(n, 1)) : (-1 === n && this._staticSourcesToUpdate.push(e), -1 !== t && this._timeVaryingSources.splice(n, 1))
        }, y
    }), n("Scene/CameraColumbusViewMode", ["../Core/Enumeration"], function (e) {
        "use strict";
        var t = {FREE: new e(0, "FREE"), LOCKED: new e(1, "LOCKED")};
        return t
    }), n("DynamicScene/DynamicObjectView", ["../Core/defaultValue", "../Core/DeveloperError", "../Core/Math", "../Core/Cartesian2", "../Core/Cartesian3", "../Core/Cartesian4", "../Core/Cartographic", "../Core/Quaternion", "../Core/Matrix3", "../Core/Matrix4", "../Core/Ellipsoid", "../Core/Transforms", "../Scene/CameraColumbusViewMode", "../Scene/SceneMode"], function (e, t, n, i, r, o, a, s, u, l, c, d, f, h) {
        "use strict";
        function p(e, t, n, o, a, s, u) {
            var l, c = e.scene, d = c.mode !== e._mode;
            d ? (e._mode = c.mode, e._screenSpaceCameraController.enableTranslate = !1, l = o.magnitude()) : l = n ? o.magnitude() : t.position.z;
            var f = a.getValueCartographic(s, e._lastCartographic);
            "undefined" != typeof f && (f.height = l, n || d ? (t.controller.setPositionCartographic(f), t.up.z = 0, r.normalize(t.up, t.up), t.right.z = 0, r.normalize(t.right, t.right), i.clone(t.right, e._first2dUp)) : t.position = u.project(f), e._lastDistance = t.frustum.right - t.frustum.left, i.clone(t.right, e._last2dUp))
        }

        function m(e, t, i, o, a, s, l) {
            v(e, t, i, o);
            var f = a.getValueCartesian(s, e._lastCartesian);
            if ("undefined" != typeof f) {
                var h = !1, p = s.addSeconds(.01), m = a.getValueCartesian(p, x);
                if ("undefined" != typeof m && !r.equalsEpsilon(f, m, n.EPSILON6)) {
                    var y, T = d.computeFixedToIcrfMatrix(s, _), E = d.computeFixedToIcrfMatrix(p, w);
                    "undefined" == typeof T || "undefined" == typeof E ? (y = d.computeTemeToPseudoFixedMatrix(s, C), T = u.transpose(y, _), E = d.computeTemeToPseudoFixedMatrix(p, w), u.transpose(E, E)) : y = u.transpose(T, C);
                    var A = S;
                    r.normalize(f, A), r.normalize(m, m), u.multiplyByVector(T, A, A), u.multiplyByVector(E, m, m);
                    var M = r.cross(A, m, b);
                    if (!r.equalsEpsilon(M, r.ZERO, n.EPSILON6)) {
                        var D = r.cross(M, A, x);
                        u.multiplyByVector(y, D, D), u.multiplyByVector(y, M, M), u.multiplyByVector(y, A, A), r.normalize(D, D), r.normalize(M, M), r.normalize(A, A);
                        var I = g;
                        I[0] = D.x, I[1] = D.y, I[2] = D.z, I[3] = 0, I[4] = M.x, I[5] = M.y, I[6] = M.z, I[7] = 0, I[8] = A.x, I[9] = A.y, I[10] = A.z, I[11] = 0, I[12] = f.x, I[13] = f.y, I[14] = f.z, I[15] = 0, t.transform = I, h = !0
                    }
                }
                h || (t.transform = d.eastNorthUpToFixedFrame(f, l, g)), e._screenSpaceCameraController.setEllipsoid(c.UNIT_SPHERE);
                var P = t.position;
                r.clone(P, e._lastOffset), e._lastDistance = r.magnitude(P)
            }
        }

        function y(e, t, n, i, o, a, s, u) {
            v(e, t, n, i);
            var l = o.getValueCartographic(a, e._lastCartographic);
            if ("undefined" != typeof l) {
                var d = u.project(l);
                T.x = d.z, T.y = d.x, T.z = d.y;
                var h = t.transform;
                h.setColumn(3, T, h);
                var p = e._screenSpaceCameraController;
                p.enableTranslate = !1, p.setEllipsoid(c.UNIT_SPHERE), p.columbusViewMode = f.LOCKED, t.controller.constrainedAxis = r.UNIT_Z;
                var m = t.position;
                r.clone(m, e._lastOffset), e._lastDistance = r.magnitude(m)
            }
        }

        function v(e, t, o, a) {
            var l = e.scene;
            if (t.controller.constrainedAxis = r.UNIT_Z, o)t.controller.lookAt(a, r.ZERO, r.UNIT_Z); else if (l.mode !== e._mode) {
                e._mode = l.mode;
                var c = e._first2dUp, d = e._last2dUp;
                if (!i.equals(c, d)) {
                    var f = Math.acos(c.x);
                    c.y < 0 && (f = n.TWO_PI - f);
                    var h = Math.acos(d.x);
                    d.y < 0 && (h = n.TWO_PI - h), d.x = 0, d.y = 0, c.x = 0, c.y = 0;
                    var p = f - h, m = s.fromAxisAngle(r.UNIT_Z, p, E);
                    u.fromQuaternion(m, A).multiplyByVector(a, a)
                }
                a.normalize(a).multiplyByScalar(e._lastDistance, a), t.controller.lookAt(a, r.ZERO, r.UNIT_Z)
            }
        }

        var g = new l, _ = new u, w = new u, C = new u, x = new r, S = new r, b = new r, T = new o(0, 0, 0, 1), E = new s, A = new u, M = new r(1e4, -1e4, 1e4), D = new r, I = function (t, n, o) {
            this.dynamicObject = t, this.scene = n, this._lastScene = void 0, this.ellipsoid = e(o, c.WGS84), this._lastDynamicObject = void 0, this._mode = void 0, this._lastCartesian = new r, this._lastCartographic = new a, this._lastDistance = void 0, this._lastOffset = new r, this._offsetScratch = new r, this._first2dUp = new i, this._last2dUp = new i
        };
        return I.prototype.update = function (e) {
            if ("undefined" == typeof e)throw new t("time is required.");
            var n = this.scene;
            if ("undefined" == typeof n)throw new t("DynamicObjectView.scene is required.");
            n !== this._lastScene && (this._lastScene = n, this._screenSpaceCameraController = n.getScreenSpaceCameraController());
            var i = this.dynamicObject;
            if ("undefined" == typeof i)throw new t("DynamicObjectView.dynamicObject is required.");
            var o = this.ellipsoid;
            if ("undefined" == typeof o)throw new t("DynamicObjectView.ellipsoid is required.");
            var a = this.dynamicObject.position;
            if ("undefined" == typeof a)throw new t("dynamicObject.position is required.");
            var s = i !== this._lastDynamicObject, u = this._offsetScratch;
            if (s) {
                this._lastDynamicObject = i;
                var l = this.dynamicObject.viewFrom;
                ("undefined" == typeof l || "undefined" == typeof l.getValue(e, u)) && r.clone(M, u);
                var c = this._first2dUp, d = this._last2dUp;
                c.x = c.y = 0, d.x = d.y = 0, r.clone(u, this._lastOffset), this._lastDistance = u.magnitude(), r.equals(u.normalize(D), r.UNIT_Z) && (u.y -= .01)
            } else"undefined" != typeof this._lastOffset ? u = this._lastOffset : r.clone(M, u);
            var f = n.mode;
            f === h.SCENE2D ? p(this, n.getCamera(), s, u, a, e, n.scene2D.projection) : f === h.SCENE3D ? m(this, n.getCamera(), s, u, a, e, o) : f === h.COLUMBUS_VIEW && y(this, n.getCamera(), s, u, a, e, o, n.scene2D.projection)
        }, I
    }), n("ThirdParty/topojson", [], function () {
        var e = function () {
            function e(e, t) {
                function n(t) {
                    var n = e.arcs[t], i = n[0], r = [0, 0];
                    return n.forEach(function (e) {
                        r[0] += e[0], r[1] += e[1]
                    }), [i, r]
                }

                var i = {}, r = {}, o = {};
                t.forEach(function (e) {
                    var t = n(e);
                    (i[t[0]] || (i[t[0]] = [])).push(e), (i[t[1]] || (i[t[1]] = [])).push(~e)
                }), t.forEach(function (e) {
                    var t, i, a = n(e), s = a[0], u = a[1];
                    if (t = o[s])if (delete o[t.end], t.push(e), t.end = u, i = r[u]) {
                        delete r[i.start];
                        var l = i === t ? t : t.concat(i);
                        r[l.start = t.start] = o[l.end = i.end] = l
                    } else if (i = o[u]) {
                        delete r[i.start], delete o[i.end];
                        var l = t.concat(i.map(function (e) {
                            return~e
                        }).reverse());
                        r[l.start = t.start] = o[l.end = i.start] = l
                    } else r[t.start] = o[t.end] = t; else if (t = r[u])if (delete r[t.start], t.unshift(e), t.start = s, i = o[s]) {
                        delete o[i.end];
                        var c = i === t ? t : i.concat(t);
                        r[c.start = i.start] = o[c.end = t.end] = c
                    } else if (i = r[s]) {
                        delete r[i.start], delete o[i.end];
                        var c = i.map(function (e) {
                            return~e
                        }).reverse().concat(t);
                        r[c.start = i.end] = o[c.end = t.end] = c
                    } else r[t.start] = o[t.end] = t; else if (t = r[s])if (delete r[t.start], t.unshift(~e), t.start = u, i = o[u]) {
                        delete o[i.end];
                        var c = i === t ? t : i.concat(t);
                        r[c.start = i.start] = o[c.end = t.end] = c
                    } else if (i = r[u]) {
                        delete r[i.start], delete o[i.end];
                        var c = i.map(function (e) {
                            return~e
                        }).reverse().concat(t);
                        r[c.start = i.end] = o[c.end = t.end] = c
                    } else r[t.start] = o[t.end] = t; else if (t = o[u])if (delete o[t.end], t.push(~e), t.end = s, i = o[s]) {
                        delete r[i.start];
                        var l = i === t ? t : t.concat(i);
                        r[l.start = t.start] = o[l.end = i.end] = l
                    } else if (i = r[s]) {
                        delete r[i.start], delete o[i.end];
                        var l = t.concat(i.map(function (e) {
                            return~e
                        }).reverse());
                        r[l.start = t.start] = o[l.end = i.start] = l
                    } else r[t.start] = o[t.end] = t; else t = [e], r[t.start = s] = o[t.end = u] = t
                });
                var a = [];
                for (var s in o)a.push(o[s]);
                return a
            }

            function t(t, n, i) {
                function o(e) {
                    0 > e && (e = ~e), (d[e] || (d[e] = [])).push(c)
                }

                function a(e) {
                    e.forEach(o)
                }

                function s(e) {
                    e.forEach(a)
                }

                function u(e) {
                    "GeometryCollection" === e.type ? e.geometries.forEach(u) : e.type in f && (c = e, f[e.type](e.arcs))
                }

                var l = [];
                if (arguments.length > 1) {
                    var c, d = [], f = {LineString: a, MultiLineString: s, Polygon: s, MultiPolygon: function (e) {
                        e.forEach(s)
                    }};
                    u(n), d.forEach(arguments.length < 3 ? function (e, t) {
                        l.push(t)
                    } : function (e, t) {
                        i(e[0], e[e.length - 1]) && l.push(t)
                    })
                } else for (var h = 0, p = t.arcs.length; p > h; ++h)l.push(h);
                return r(t, {type: "MultiLineString", arcs: e(t, l)})
            }

            function n(e, t) {
                return"GeometryCollection" === t.type ? {type: "FeatureCollection", features: t.geometries.map(function (t) {
                    return i(e, t)
                })} : i(e, t)
            }

            function i(e, t) {
                var n = {type: "Feature", id: t.id, properties: t.properties || {}, geometry: r(e, t)};
                return null == t.id && delete n.id, n
            }

            function r(e, t) {
                function n(e, t) {
                    t.length && t.pop();
                    for (var n, i = p[0 > e ? ~e : e], r = 0, a = i.length, s = 0, u = 0; a > r; ++r)t.push([(s += (n = i[r])[0]) * c + f, (u += n[1]) * d + h]);
                    0 > e && o(t, a)
                }

                function i(e) {
                    return[e[0] * c + f, e[1] * d + h]
                }

                function r(e) {
                    for (var t = [], i = 0, r = e.length; r > i; ++i)n(e[i], t);
                    return t.length < 2 && t.push(t[0]), t
                }

                function a(e) {
                    for (var t = r(e); t.length < 4;)t.push(t[0]);
                    return t
                }

                function s(e) {
                    return e.map(a)
                }

                function u(e) {
                    var t = e.type;
                    return"GeometryCollection" === t ? {type: t, geometries: e.geometries.map(u)} : t in m ? {type: t, coordinates: m[t](e)} : null
                }

                var l = e.transform, c = l.scale[0], d = l.scale[1], f = l.translate[0], h = l.translate[1], p = e.arcs, m = {Point: function (e) {
                    return i(e.coordinates)
                }, MultiPoint: function (e) {
                    return e.coordinates.map(i)
                }, LineString: function (e) {
                    return r(e.arcs)
                }, MultiLineString: function (e) {
                    return e.arcs.map(r)
                }, Polygon: function (e) {
                    return s(e.arcs)
                }, MultiPolygon: function (e) {
                    return e.arcs.map(s)
                }};
                return u(t)
            }

            function o(e, t) {
                for (var n, i = e.length, r = i - t; r < --i;)n = e[r], e[r++] = e[i], e[i] = n
            }

            function a(e, t) {
                for (var n = 0, i = e.length; i > n;) {
                    var r = n + i >>> 1;
                    e[r] < t ? n = r + 1 : i = r
                }
                return n
            }

            function s(e) {
                function t(e, t) {
                    e.forEach(function (e) {
                        0 > e && (e = ~e);
                        var n = r[e];
                        n ? n.push(t) : r[e] = [t]
                    })
                }

                function n(e, n) {
                    e.forEach(function (e) {
                        t(e, n)
                    })
                }

                function i(e, t) {
                    "GeometryCollection" === e.type ? e.geometries.forEach(function (e) {
                        i(e, t)
                    }) : e.type in s && s[e.type](e.arcs, t)
                }

                var r = {}, o = e.map(function () {
                    return[]
                }), s = {LineString: t, MultiLineString: n, Polygon: n, MultiPolygon: function (e, t) {
                    e.forEach(function (e) {
                        n(e, t)
                    })
                }};
                e.forEach(i);
                for (var u in r)for (var l = r[u], c = l.length, d = 0; c > d; ++d)for (var f = d + 1; c > f; ++f) {
                    var h, p = l[d], m = l[f];
                    (h = o[p])[u = a(h, m)] !== m && h.splice(u, 0, m), (h = o[m])[u = a(h, p)] !== p && h.splice(u, 0, p)
                }
                return o
            }

            return{version: "1.1.4", mesh: t, feature: n, neighbors: s}
        }();
        return e
    }), n("DynamicScene/GeoJsonDataSource", ["../Core/createGuid", "../Core/Cartographic", "../Core/Color", "../Core/defineProperties", "../Core/DeveloperError", "../Core/RuntimeError", "../Core/Ellipsoid", "../Core/Event", "../Core/loadJson", "./ConstantProperty", "./DynamicObject", "./DynamicPoint", "./DynamicPolyline", "./DynamicPolygon", "./DynamicMaterialProperty", "./DynamicObjectCollection", "../ThirdParty/when", "../ThirdParty/topojson"], function (e, t, n, i, r, o, a, s, u, l, c, d, f, h, p, m, y, v) {
        "use strict";
        function g(t, n) {
            var i = t.id;
            if ("undefined" == typeof i || "Feature" !== t.type)i = e(); else {
                for (var r = 2, o = i; "undefined" != typeof n.getObject(o);)o = i + "_" + r, r++;
                i = o
            }
            var a = n.getOrCreateObject(i);
            return a.geoJson = t, a
        }

        function _(e, t) {
            for (var n = new Array(e.length), i = 0; i < e.length; i++)n[i] = t(e[i]);
            return n
        }

        function w(e, t, n, i, r) {
            if ("undefined" == typeof t.geometry)throw new o("feature.geometry is required.");
            if (null === t.geometry)g(t, e._dynamicObjectCollection); else {
                var a = t.geometry.type, s = R[a];
                if ("undefined" == typeof s)throw new o("Unknown geometry type: " + a);
                s(e, t, t.geometry, i, r)
            }
        }

        function C(e, t, n, i, r) {
            for (var o = t.features, a = 0, s = o.length; s > a; a++)w(e, o[a], void 0, i, r)
        }

        function x(e, t, n, i, r) {
            for (var a = n.geometries, s = 0, u = a.length; u > s; s++) {
                var l = a[s], c = l.type, d = R[c];
                if ("undefined" == typeof d)throw new o("Unknown geometry type: " + c);
                d(e, t, l, i, r)
            }
        }

        function S(e, t, n, i) {
            var r = g(t, e._dynamicObjectCollection);
            r.merge(e.defaultPoint), r.position = new P(i(n.coordinates))
        }

        function b(e, t, n, i) {
            for (var r = n.coordinates, o = 0; o < r.length; o++) {
                var a = g(t, e._dynamicObjectCollection);
                a.merge(e.defaultPoint), a.position = new P(i(r[o]))
            }
        }

        function T(e, t, n, i) {
            var r = g(t, e._dynamicObjectCollection);
            r.merge(e.defaultLine), r.vertexPositions = new P(_(n.coordinates, i))
        }

        function E(e, t, n, i) {
            for (var r = n.coordinates, o = 0; o < r.length; o++) {
                var a = g(t, e._dynamicObjectCollection);
                a.merge(e.defaultLine), a.vertexPositions = new P(_(r[o], i))
            }
        }

        function A(e, t, n, i) {
            var r = g(t, e._dynamicObjectCollection);
            r.merge(e.defaultPolygon), r.vertexPositions = new P(_(n.coordinates[0], i))
        }

        function M(e, t, n, i, r) {
            for (var o in n.objects)if (n.objects.hasOwnProperty(o)) {
                var a = v.feature(n, n.objects[o]), s = O[a.type];
                s(e, a, a, i, r)
            }
        }

        function D(e, t, n, i) {
            for (var r = n.coordinates, o = 0; o < r.length; o++) {
                var a = r[o], s = g(t, e._dynamicObjectCollection);
                s.merge(e.defaultPolygon), s.vertexPositions = new P(_(a[0], i))
            }
        }

        function I(e) {
            var n = t.fromDegrees(e[0], e[1], e[2]);
            return a.WGS84.cartographicToCartesian(n)
        }

        var P = function (e) {
            this._value = e
        };
        P.prototype.getValueCartesian = function (e, t) {
            var n = this._value;
            return"function" == typeof n.clone ? n.clone(t) : n
        };
        var O = {Feature: w, FeatureCollection: C, GeometryCollection: x, LineString: T, MultiLineString: E, MultiPoint: b, MultiPolygon: D, Point: S, Polygon: A, Topology: M}, R = {GeometryCollection: x, LineString: T, MultiLineString: E, MultiPoint: b, MultiPolygon: D, Point: S, Polygon: A, Topology: M}, z = function () {
            var e = new c("GeoJsonDataSource.defaultPoint"), t = new d;
            t.color = new l(n.YELLOW), t.pixelSize = new l(10), t.outlineColor = new l(n.BLACK), t.outlineWidth = new l(1), e.point = t;
            var i = new c("GeoJsonDataSource.defaultLine"), r = new f;
            r.color = new l(n.YELLOW), r.width = new l(2), r.outlineColor = new l(n.BLACK), r.outlineWidth = new l(1), i.polyline = r;
            var o = new c("GeoJsonDataSource.defaultPolygon"), a = new p;
            r = new f, r.color = new l(n.YELLOW), r.width = new l(1), r.outlineColor = new l(n.BLACK), r.outlineWidth = new l(0), o.polyline = r;
            var u = new h;
            u.material = a, a.processCzmlIntervals({solidColor: {color: {rgba: [255, 255, 0, 25]}}}, void 0, void 0), o.polygon = u, this._changed = new s, this._error = new s, this._dynamicObjectCollection = new m, this.defaultPoint = e, this.defaultLine = i, this.defaultPolygon = o
        };
        return z.prototype.getChangedEvent = function () {
            return this._changed
        }, z.prototype.getErrorEvent = function () {
            return this._error
        }, z.prototype.getClock = function () {
            return void 0
        }, z.prototype.getDynamicObjectCollection = function () {
            return this._dynamicObjectCollection
        }, z.prototype.getIsTimeVarying = function () {
            return!1
        }, z.prototype.loadUrl = function (e) {
            if ("undefined" == typeof e)throw new r("url is required.");
            var t = this;
            return y(u(e), function (n) {
                return t.load(n, e)
            }, function (e) {
                return t._error.raiseEvent(t, e), y.reject(e)
            })
        }, z.prototype.load = function (e, t) {
            if ("undefined" == typeof e)throw new r("geoJson is required.");
            var n = O[e.type];
            if ("undefined" == typeof n)throw new r("Unsupported GeoJSON object type: " + e.type);
            var i = I, a = e.crs;
            if ("undefined" != typeof a) {
                if (null === a)throw new o("crs is null.");
                if ("undefined" == typeof a.properties)throw new o("crs.properties is undefined.");
                var s = a.properties;
                if ("name" === a.type) {
                    if (i = z.crsNames[s.name], "undefined" == typeof i)throw new o("Unknown crs name: " + s.name)
                } else if ("link" === a.type) {
                    var u = z.crsLinkHrefs[s.href];
                    if ("undefined" == typeof u && (u = z.crsLinkTypes[s.type]), "undefined" == typeof u)throw new o("Unable to resolve crs link: " + JSON.stringify(s));
                    i = u(s)
                } else {
                    if ("EPSG" !== a.type)throw new o("Unknown crs type: " + a.type);
                    if (i = z.crsNames["EPSG:" + s.code], "undefined" == typeof i)throw new o("Unknown crs EPSG code: " + s.code)
                }
            }
            this._dynamicObjectCollection.clear();
            var l = this;
            return y(i, function (i) {
                n(l, e, e, i, t), l._changed.raiseEvent(l)
            }, function (e) {
                return l._error.raiseEvent(l, e), y.reject(e)
            })
        }, z.crsNames = {"urn:ogc:def:crs:OGC:1.3:CRS84": I, "EPSG:4326": I}, z.crsLinkHrefs = {}, z.crsLinkTypes = {}, z
    }), n("Renderer/Buffer", ["../Core/DeveloperError", "../Core/destroyObject"], function (e, t) {
        "use strict";
        var n = function (e, t, n, i, r) {
            this._gl = e, this._bufferTarget = t, this._sizeInBytes = n, this._usage = i, this._buffer = r, this._vertexArrayDestroyable = !0
        };
        return n.prototype.copyFromArrayView = function (t, n) {
            if (!t)throw new e("arrayView is required.");
            if (n = n || 0, n + t.byteLength > this._sizeInBytes)throw new e("This buffer is not large enough.");
            var i = this._gl, r = this._bufferTarget;
            i.bindBuffer(r, this._buffer), i.bufferSubData(r, n, t), i.bindBuffer(r, null)
        }, n.prototype._getBuffer = function () {
            return this._buffer
        }, n.prototype.getSizeInBytes = function () {
            return this._sizeInBytes
        }, n.prototype.getUsage = function () {
            return this._usage
        }, n.prototype.getVertexArrayDestroyable = function () {
            return this._vertexArrayDestroyable
        }, n.prototype.setVertexArrayDestroyable = function (e) {
            this._vertexArrayDestroyable = e
        }, n.prototype.isDestroyed = function () {
            return!1
        }, n.prototype.destroy = function () {
            return this._gl.deleteBuffer(this._buffer), t(this)
        }, n
    }), n("Renderer/ClearCommand", ["../Core/Color", "../Core/freezeObject"], function (e, t) {
        "use strict";
        var n = function () {
            this.color = void 0, this.depth = void 0, this.stencil = void 0, this.renderState = void 0, this.framebuffer = void 0, this.owner = void 0
        }, i = new n;
        return i.color = new e(0, 0, 0, 0), i.depth = 1, i.stencil = 0, n.ALL = t(i), n.prototype.execute = function (e, t) {
            e.clear(this, t)
        }, n
    }), n("Renderer/Framebuffer", ["../Core/DeveloperError", "../Core/destroyObject", "./PixelFormat"], function (e, t, n) {
        "use strict";
        function i(e, t, n) {
            e._bind();
            var i = e._gl;
            n ? i.framebufferTexture2D(i.FRAMEBUFFER, t, n._getTarget(), n._getTexture(), 0) : i.framebufferTexture2D(i.FRAMEBUFFER, t, i.TEXTURE_2D, null, 0), e._unBind()
        }

        function r(e, t, n) {
            e._bind();
            var i = e._gl;
            n ? i.framebufferRenderbuffer(i.FRAMEBUFFER, t, i.RENDERBUFFER, n._getRenderbuffer()) : i.framebufferRenderbuffer(i.FRAMEBUFFER, t, i.RENDERBUFFER, null), e._unBind()
        }

        function o(e, t) {
            e.destroyAttachments && t && t.destroy && t.destroy()
        }

        var a = function (t, n) {
            if (this._gl = t, this._framebuffer = t.createFramebuffer(), this._colorTexture = void 0, this._colorRenderbuffer = void 0, this._depthTexture = void 0, this._depthRenderbuffer = void 0, this._stencilRenderbuffer = void 0, this._depthStencilTexture = void 0, this._depthStencilRenderbuffer = void 0, this.destroyAttachments = !0, n) {
                if (n.colorTexture && n.colorRenderbuffer)throw new e("Cannot have both a color texture and color renderbuffer attachment.");
                if (n.depthTexture && n.depthRenderbuffer)throw new e("Cannot have both a depth texture and depth renderbuffer attachment.");
                if (n.depthStencilTexture && n.depthStencilRenderbuffer)throw new e("Cannot have both a depth-stencil texture and depth-stencil renderbuffer attachment.");
                var i = n.depthTexture || n.depthRenderbuffer, r = n.depthStencilTexture || n.depthStencilRenderbuffer;
                if (i && r)throw new e("Cannot have both a depth and depth-stencil attachment.");
                if (n.stencilRenderbuffer && r)throw new e("Cannot have both a stencil and depth-stencil attachment.");
                if (i && n.stencilRenderbuffer)throw new e("Cannot have both a depth and stencil attachment.");
                n.colorTexture && this.setColorTexture(n.colorTexture), n.colorRenderbuffer && this.setColorRenderbuffer(n.colorRenderbuffer), n.depthTexture && this.setDepthTexture(n.depthTexture), n.depthRenderbuffer && this.setDepthRenderbuffer(n.depthRenderbuffer), n.stencilRenderbuffer && this.setStencilRenderbuffer(n.stencilRenderbuffer), n.depthStencilTexture && this.setDepthStencilTexture(n.depthStencilTexture), n.depthStencilRenderbuffer && this.setDepthStencilRenderbuffer(n.depthStencilRenderbuffer)
            }
        };
        return a.prototype._bind = function () {
            var e = this._gl;
            e.bindFramebuffer(e.FRAMEBUFFER, this._framebuffer)
        }, a.prototype._unBind = function () {
            var e = this._gl;
            e.bindFramebuffer(e.FRAMEBUFFER, null)
        }, a.prototype.setColorTexture = function (t) {
            if (t && !n.isColorFormat(t.getPixelFormat()))throw new e("The color-texture pixel-format must be a color format.");
            i(this, this._gl.COLOR_ATTACHMENT0, t), o(this, this._colorTexture), this._colorTexture = t
        }, a.prototype.getColorTexture = function () {
            return this._colorTexture
        }, a.prototype.setColorRenderbuffer = function (e) {
            r(this, this._gl.COLOR_ATTACHMENT0, e), o(this, this._colorRenderbuffer), this._colorRenderbuffer = e
        }, a.prototype.getColorRenderbuffer = function () {
            return this._colorRenderbuffer
        }, a.prototype.setDepthTexture = function (t) {
            if (t && t.getPixelFormat() !== n.DEPTH_COMPONENT)throw new e("The depth-texture pixel-format must be DEPTH_COMPONENT.");
            i(this, this._gl.DEPTH_ATTACHMENT, t), o(this, this._depthTexture), this._depthTexture = t
        }, a.prototype.getDepthTexture = function () {
            return this._depthTexture
        }, a.prototype.setDepthRenderbuffer = function (e) {
            r(this, this._gl.DEPTH_ATTACHMENT, e), o(this, this._depthRenderbuffer), this._depthRenderbuffer = e
        }, a.prototype.getDepthRenderbuffer = function () {
            return this._depthRenderbuffer
        }, a.prototype.setStencilRenderbuffer = function (e) {
            r(this, this._gl.STENCIL_ATTACHMENT, e), o(this, this._stencilRenderbuffer), this._stencilRenderbuffer = e
        }, a.prototype.getStencilRenderbuffer = function () {
            return this._stencilRenderbuffer
        }, a.prototype.setDepthStencilTexture = function (t) {
            if (t && t.getPixelFormat() !== n.DEPTH_STENCIL)throw new e("The depth-stencil pixel-format must be DEPTH_STENCIL.");
            i(this, this._gl.DEPTH_STENCIL_ATTACHMENT, t), o(this, this._depthStencilTexture), this._depthStencilTexture = t
        }, a.prototype.getDepthStencilTexture = function () {
            return this._depthStencilTexture
        }, a.prototype.setDepthStencilRenderbuffer = function (e) {
            r(this, this._gl.DEPTH_STENCIL_ATTACHMENT, e), o(this, this._depthStencilRenderbuffer), this._depthStencilRenderbuffer = e
        }, a.prototype.getDepthStencilRenderbuffer = function () {
            return this._depthStencilRenderbuffer
        }, a.prototype.hasDepthAttachment = function () {
            return!!(this.getDepthTexture() || this.getDepthRenderbuffer() || this.getDepthStencilTexture() || this.getDepthStencilRenderbuffer())
        }, a.prototype.isDestroyed = function () {
            return!1
        }, a.prototype.destroy = function () {
            return this.destroyAttachments && (this._colorTexture = this._colorTexture && this._colorTexture.destroy && this._colorTexture.destroy(), this._colorRenderbuffer = this._colorRenderbuffer && this._colorRenderbuffer.destroy(), this._depthTexture = this._depthTexture && this._depthTexture.destroy(), this._depthRenderbuffer = this._depthRenderbuffer && this._depthRenderbuffer.destroy(), this._stencilRenderbuffer = this._stencilRenderbuffer && this._stencilRenderbuffer.destroy(), this._depthStencilTexture = this._depthStencilTexture && this._depthStencilTexture.destroy(), this._depthStencilRenderbuffer = this._depthStencilRenderbuffer && this._depthStencilRenderbuffer.destroy()), this._gl.deleteFramebuffer(this._framebuffer), t(this)
        }, a
    }), n("Renderer/PassState", [], function () {
        "use strict";
        var e = function (e) {
            this.context = e, this.framebuffer = void 0, this.blendingEnabled = void 0, this.scissorTest = void 0
        };
        return e
    }), n("Renderer/RenderbufferFormat", ["../Core/Enumeration"], function (e) {
        "use strict";
        var t = {RGBA4: new e(32854, "RGBA4"), RGB5_A1: new e(32855, "RGB5_A1"), RGB565: new e(36194, "RGB565"), DEPTH_COMPONENT16: new e(33189, "DEPTH_COMPONENT16"), STENCIL_INDEX8: new e(36168, "STENCIL_INDEX8"), DEPTH_STENCIL: new e(34041, "DEPTH_STENCIL"), validate: function (e) {
            return e === t.RGBA4 || e === t.RGB5_A1 || e === t.RGB565 || e === t.DEPTH_COMPONENT16 || e === t.STENCIL_INDEX8 || e === t.DEPTH_STENCIL
        }};
        return t
    }), n("Renderer/PickFramebuffer", ["../Core/defaultValue", "../Core/destroyObject", "../Core/Color", "../Core/BoundingRectangle", "./ClearCommand", "./PassState", "./RenderbufferFormat"], function (e, t, n, i, r, o, a) {
        "use strict";
        var s = function (e) {
            var t = new o(e);
            t.blendingEnabled = !1, t.scissorTest = {enabled: !0, rectangle: new i};
            var a = new r;
            a.color = new n(0, 0, 0, 0), a.depth = 1, a.stencil = 0, this._context = e, this._fb = void 0, this._passState = t, this._width = 0, this._height = 0, this._clearCommand = a
        };
        s.prototype.begin = function (e) {
            var t = this._context, n = t.getCanvas().clientWidth, r = t.getCanvas().clientHeight;
            return i.clone(e, this._passState.scissorTest.rectangle), ("undefined" == typeof this._fb || this._width !== n || this._height !== r) && (this._width = n, this._height = r, this._fb = this._fb && this._fb.destroy(), this._fb = t.createFramebuffer({colorTexture: t.createTexture2D({width: n, height: r}), depthRenderbuffer: t.createRenderbuffer({format: a.DEPTH_COMPONENT16})}), this._passState.framebuffer = this._fb), this._clearCommand.execute(t, this._passState), this._passState
        };
        var u = new n;
        return s.prototype.end = function (t) {
            for (var i = e(t.width, 1), r = e(t.height, 1), o = this._context, a = o.readPixels({x: t.x, y: t.y, width: i, height: r, framebuffer: this._fb}), s = Math.max(i, r), l = s * s, c = Math.floor(.5 * i), d = Math.floor(.5 * r), f = 0, h = 0, p = 0, m = -1, y = 0; l > y; ++y) {
                if (f >= -c && c >= f && h >= -d && d >= h) {
                    var v = 4 * ((d - h) * i + f + c);
                    u.red = n.byteToFloat(a[v]), u.green = n.byteToFloat(a[v + 1]), u.blue = n.byteToFloat(a[v + 2]), u.alpha = n.byteToFloat(a[v + 3]);
                    var g = o.getObjectByPickColor(u);
                    if ("undefined" != typeof g)return g
                }
                if (f === h || 0 > f && -f === h || f > 0 && f === 1 - h) {
                    var _ = p;
                    p = -m, m = _
                }
                f += p, h += m
            }
            return void 0
        }, s.prototype.isDestroyed = function () {
            return!1
        }, s.prototype.destroy = function () {
            return this._fb = this._fb && this._fb.destroy(), t(this)
        }, s
    }), n("Renderer/Renderbuffer", ["../Core/destroyObject"], function (e) {
        "use strict";
        function t(t, n, i, r) {
            var o = t.createRenderbuffer();
            t.bindRenderbuffer(t.RENDERBUFFER, o), t.renderbufferStorage(t.RENDERBUFFER, n, i, r), t.bindRenderbuffer(t.RENDERBUFFER, null), this.getFormat = function () {
                return n
            }, this.getWidth = function () {
                return i
            }, this.getHeight = function () {
                return r
            }, this._getRenderbuffer = function () {
                return o
            }, this.isDestroyed = function () {
                return!1
            }, this.destroy = function () {
                return t.deleteRenderbuffer(o), e(this)
            }
        }

        return t
    }), n("Renderer/DepthFunction", ["../Core/Enumeration"], function (e) {
        "use strict";
        var t = {NEVER: new e(512, "NEVER"), LESS: new e(513, "LESS"), EQUAL: new e(514, "EQUAL"), LESS_OR_EQUAL: new e(515, "LEQUAL"), GREATER: new e(516, "GREATER"), NOT_EQUAL: new e(517, "NOTEQUAL"), GREATER_OR_EQUAL: new e(518, "GEQUAL"), ALWAYS: new e(519, "ALWAYS"), validate: function (e) {
            return e === t.NEVER || e === t.LESS || e === t.EQUAL || e === t.LESS_OR_EQUAL || e === t.GREATER || e === t.NOT_EQUAL || e === t.GREATER_OR_EQUAL || e === t.ALWAYS
        }};
        return t
    }), n("Renderer/StencilFunction", ["../Core/Enumeration"], function (e) {
        "use strict";
        var t = {NEVER: new e(512, "NEVER"), LESS: new e(513, "LESS"), EQUAL: new e(514, "EQUAL"), LESS_OR_EQUAL: new e(515, "LESS_OR_EQUAL"), GREATER: new e(516, "GREATER"), NOT_EQUAL: new e(517, "NOT_EQUAL"), GREATER_OR_EQUAL: new e(518, "GREATER_OR_EQUAL"), ALWAYS: new e(519, "ALWAYS"), validate: function (e) {
            return e === t.NEVER || e === t.LESS || e === t.EQUAL || e === t.LESS_OR_EQUAL || e === t.GREATER || e === t.NOT_EQUAL || e === t.GREATER_OR_EQUAL || e === t.ALWAYS
        }};
        return t
    }), n("Renderer/StencilOperation", ["../Core/Enumeration"], function (e) {
        "use strict";
        var t = {ZERO: new e(0, "ZERO"), KEEP: new e(7680, "KEEP"), REPLACE: new e(7681, "REPLACE"), INCREMENT: new e(7682, "INCREMENT"), DECREMENT: new e(7683, "DECREMENT"), INVERT: new e(5386, "INVERT"), INCREMENT_WRAP: new e(34055, "INCREMENT_WRAP"), DECREMENT_WRAP: new e(34056, "DECREMENT_WRAP"), validate: function (e) {
            return e === t.ZERO || e === t.KEEP || e === t.REPLACE || e === t.INCREMENT || e === t.DECREMENT || e === t.INVERT || e === t.INCREMENT_WRAP || e === t.DECREMENT_WRAP
        }};
        return t
    }), n("Renderer/RenderState", ["../Core/Color", "../Core/defaultValue", "../Core/DeveloperError", "../Core/BoundingRectangle", "../Core/RuntimeError", "../Core/WindingOrder", "./CullFace", "./DepthFunction", "./BlendEquation", "./BlendFunction", "./StencilFunction", "./StencilOperation"], function (e, t, n, i, r, o, a, s, u, l, c, d) {
        "use strict";
        function f(e, t, n) {
            n ? e.enable(t) : e.disable(t)
        }

        function h(e, t) {
            e.frontFace(t.frontFace)
        }

        function p(e, t) {
            var n = t.cull, i = n.enabled;
            f(e, e.CULL_FACE, i), i && e.cullFace(n.face)
        }

        function m(e, t) {
            e.lineWidth(t.lineWidth)
        }

        function y(e, t) {
            var n = t.polygonOffset, i = n.enabled;
            f(e, e.POLYGON_OFFSET_FILL, i), i && e.polygonOffset(n.factor, n.units)
        }

        function v(e, t, n) {
            var i = t.scissorTest, r = "undefined" != typeof n.scissorTest ? n.scissorTest.enabled : i.enabled;
            if (f(e, e.SCISSOR_TEST, r), r) {
                var o = "undefined" != typeof n.scissorTest ? n.scissorTest.rectangle : i.rectangle;
                e.scissor(o.x, o.y, o.width, o.height)
            }
        }

        function g(e, t) {
            var n = t.depthRange;
            e.depthRange(n.near, n.far)
        }

        function _(e, t) {
            var n = t.depthTest, i = n.enabled;
            f(e, e.DEPTH_TEST, i), i && e.depthFunc(n.func)
        }

        function w(e, t) {
            var n = t.colorMask;
            e.colorMask(n.red, n.green, n.blue, n.alpha)
        }

        function C(e, t) {
            e.depthMask(t.depthMask)
        }

        function x(e, t) {
            e.stencilMask(t.stencilMask)
        }

        function S(e, t, n) {
            var i = t.blending, r = "undefined" != typeof n.blendingEnabled ? n.blendingEnabled : i.enabled;
            if (f(e, e.BLEND, r), r) {
                var o = i.color, a = i.equationRgb, s = i.equationAlpha, u = i.functionSourceRgb, l = i.functionDestinationRgb, c = i.functionSourceAlpha, d = i.functionDestinationAlpha;
                e.blendColor(o.red, o.green, o.blue, o.alpha), e.blendEquationSeparate(a, s), e.blendFuncSeparate(u, l, c, d)
            }
        }

        function b(e, t) {
            var n = t.stencilTest, i = n.enabled;
            if (f(e, e.STENCIL_TEST, i), i) {
                var r = n.frontFunction, o = n.backFunction, a = n.reference, s = n.mask;
                e.stencilFunc(n.frontFunction, n.reference, n.mask), e.stencilFuncSeparate(e.BACK, o, a, s), e.stencilFuncSeparate(e.FRONT, r, a, s);
                var u = n.frontOperation, l = u.fail, c = u.zFail, d = u.zPass;
                e.stencilOpSeparate(e.FRONT, l, c, d);
                var h = n.backOperation, p = h.fail, m = h.zFail, y = h.zPass;
                e.stencilOpSeparate(e.BACK, p, m, y)
            }
        }

        function T(e, t) {
            var n = t.sampleCoverage, i = n.enabled;
            f(e, e.SAMPLE_COVERAGE, i), i && e.sampleCoverage(n.value, n.invert)
        }

        function E(e, t) {
            f(e, e.DITHER, t.dither)
        }

        function A(e, t, n) {
            var i = t.viewport;
            if ("undefined" == typeof i) {
                var r = n.context.getCanvas();
                i = I, i.width = r.clientWidth, i.height = r.clientHeight
            }
            n.context.getUniformState().setViewport(i), e.viewport(i.x, i.y, i.width, i.height)
        }

        function M(e, t) {
            var n = [];
            return e.frontFace !== t.frontFace && n.push(h), (e.cull.enabled !== t.cull.enabled || e.cull.face !== t.cull.face) && n.push(p), e.lineWidth !== t.lineWidth && n.push(m), (e.polygonOffset.enabled !== t.polygonOffset.enabled || e.polygonOffset.factor !== t.polygonOffset.factor || e.polygonOffset.units !== t.polygonOffset.units) && n.push(y), n.push(v), (e.depthRange.near !== t.depthRange.near || e.depthRange.far !== t.depthRange.far) && n.push(g), (e.depthTest.enabled !== t.depthTest.enabled || e.depthTest.func !== t.depthTest.func) && n.push(_), (e.colorMask.red !== t.colorMask.red || e.colorMask.green !== t.colorMask.green || e.colorMask.blue !== t.colorMask.blue || e.colorMask.alpha !== t.colorMask.alpha) && n.push(w), e.depthMask !== t.depthMask && n.push(C), n.push(S), e.stencilMask !== t.stencilMask && n.push(x), (e.stencilTest.enabled !== t.stencilTest.enabled || e.stencilTest.frontFunction !== t.stencilTest.frontFunction || e.stencilTest.backFunction !== t.stencilTest.backFunction || e.stencilTest.reference !== t.stencilTest.reference || e.stencilTest.mask !== t.stencilTest.mask || e.stencilTest.frontOperation.fail !== t.stencilTest.frontOperation.fail || e.stencilTest.frontOperation.zFail !== t.stencilTest.frontOperation.zFail || e.stencilTest.backOperation.fail !== t.stencilTest.backOperation.fail || e.stencilTest.backOperation.zFail !== t.stencilTest.backOperation.zFail || e.stencilTest.backOperation.zPass !== t.stencilTest.backOperation.zPass) && n.push(b), (e.sampleCoverage.enabled !== t.sampleCoverage.enabled || e.sampleCoverage.value !== t.sampleCoverage.value || e.sampleCoverage.invert !== t.sampleCoverage.invert) && n.push(T), e.dither !== t.dither && n.push(E), n.push(A), n
        }

        var D = function (f, h) {
            var p = t(h, {}), m = t(p.cull, {}), y = t(p.polygonOffset, {}), v = t(p.scissorTest, {}), g = t(v.rectangle, {}), _ = t(p.depthRange, {}), w = t(p.depthTest, {}), C = t(p.colorMask, {}), x = t(p.blending, {}), S = t(x.color, {}), b = t(p.stencilTest, {}), T = t(b.frontOperation, {}), E = t(b.backOperation, {}), A = t(p.sampleCoverage, {}), M = p.viewport;
            if (this.frontFace = t(p.frontFace, o.COUNTER_CLOCKWISE), this.cull = {enabled: t(m.enabled, !1), face: t(m.face, a.BACK)}, this.lineWidth = t(p.lineWidth, 1), this.polygonOffset = {enabled: t(y.enabled, !1), factor: t(y.factor, 0), units: t(y.units, 0)}, this.scissorTest = {enabled: t(v.enabled, !1), rectangle: i.clone(g)}, this.depthRange = {near: t(_.near, 0), far: t(_.far, 1)}, this.depthTest = {enabled: t(w.enabled, !1), func: t(w.func, s.LESS)}, this.colorMask = {red: t(C.red, !0), green: t(C.green, !0), blue: t(C.blue, !0), alpha: t(C.alpha, !0)}, this.depthMask = t(p.depthMask, !0), this.stencilMask = t(p.stencilMask, -1), this.blending = {enabled: t(x.enabled, !1), color: new e(t(S.red, 0), t(S.green, 0), t(S.blue, 0), t(S.alpha, 0)), equationRgb: t(x.equationRgb, u.ADD), equationAlpha: t(x.equationAlpha, u.ADD), functionSourceRgb: t(x.functionSourceRgb, l.ONE), functionSourceAlpha: t(x.functionSourceAlpha, l.ONE), functionDestinationRgb: t(x.functionDestinationRgb, l.ZERO), functionDestinationAlpha: t(x.functionDestinationAlpha, l.ZERO)}, this.stencilTest = {enabled: t(b.enabled, !1), frontFunction: t(b.frontFunction, c.ALWAYS), backFunction: t(b.backFunction, c.ALWAYS), reference: t(b.reference, 0), mask: t(b.mask, -1), frontOperation: {fail: t(T.fail, d.KEEP), zFail: t(T.zFail, d.KEEP), zPass: t(T.zPass, d.KEEP)}, backOperation: {fail: t(E.fail, d.KEEP), zFail: t(E.zFail, d.KEEP), zPass: t(E.zPass, d.KEEP)}}, this.sampleCoverage = {enabled: t(A.enabled, !1), value: t(A.value, 1), invert: t(A.invert, !1)}, this.dither = t(p.dither, !0), this.viewport = "undefined" != typeof M ? new i(M.x, M.y, "undefined" == typeof M.width ? f.getCanvas().clientWidth : M.width, "undefined" == typeof M.height ? f.getCanvas().clientHeight : M.height) : void 0, !o.validate(this.frontFace))throw new n("Invalid renderState.frontFace.");
            if (!a.validate(this.cull.face))throw new n("Invalid renderState.cull.face.");
            if (this.lineWidth < f.getMinimumAliasedLineWidth() || this.lineWidth > f.getMaximumAliasedLineWidth())throw new r("renderState.lineWidth is out of range.  Check getMinimumAliasedLineWidth() and getMaximumAliasedLineWidth().");
            if (this.scissorTest.rectangle.width < 0 || this.scissorTest.rectangle.height < 0)throw new n("renderState.scissorTest.rectangle.width and renderState.scissorTest.rectangle.height must be greater than or equal to zero.");
            if (this.depthRange.near > this.depthRange.far)throw new n("renderState.depthRange.near can not be greater than renderState.depthRange.far.");
            if (this.depthRange.near < 0)throw new n("renderState.depthRange.near must be greater than or equal to zero.");
            if (this.depthRange.far > 1)throw new n("renderState.depthRange.far must be less than or equal to one.");
            if (!s.validate(this.depthTest.func))throw new n("Invalid renderState.depthTest.func.");
            if (this.blending.color.red < 0 || this.blending.color.red > 1 || this.blending.color.green < 0 || this.blending.color.green > 1 || this.blending.color.blue < 0 || this.blending.color.blue > 1 || this.blending.color.alpha < 0 || this.blending.color.alpha > 1)throw new n("renderState.blending.color components must be greater than or equal to zero and less than or equal to one.");
            if (!u.validate(this.blending.equationRgb))throw new n("Invalid renderState.blending.equationRgb.");
            if (!u.validate(this.blending.equationAlpha))throw new n("Invalid renderState.blending.equationAlpha.");
            if (!l.validate(this.blending.functionSourceRgb))throw new n("Invalid renderState.blending.functionSourceRgb.");
            if (!l.validate(this.blending.functionSourceAlpha))throw new n("Invalid renderState.blending.functionSourceAlpha.");
            if (!l.validate(this.blending.functionDestinationRgb))throw new n("Invalid renderState.blending.functionDestinationRgb.");
            if (!l.validate(this.blending.functionDestinationAlpha))throw new n("Invalid renderState.blending.functionDestinationAlpha.");
            if (!c.validate(this.stencilTest.frontFunction))throw new n("Invalid renderState.stencilTest.frontFunction.");
            if (!c.validate(this.stencilTest.backFunction))throw new n("Invalid renderState.stencilTest.backFunction.");
            if (!d.validate(this.stencilTest.frontOperation.fail))throw new n("Invalid renderState.stencilTest.frontOperation.fail.");
            if (!d.validate(this.stencilTest.frontOperation.zFail))throw new n("Invalid renderState.stencilTest.frontOperation.zFail.");
            if (!d.validate(this.stencilTest.frontOperation.zPass))throw new n("Invalid renderState.stencilTest.frontOperation.zPass.");
            if (!d.validate(this.stencilTest.backOperation.fail))throw new n("Invalid renderState.stencilTest.backOperation.fail.");
            if (!d.validate(this.stencilTest.backOperation.zFail))throw new n("Invalid renderState.stencilTest.backOperation.zFail.");
            if (!d.validate(this.stencilTest.backOperation.zPass))throw new n("Invalid renderState.stencilTest.backOperation.zPass.");
            if ("undefined" != typeof this.viewport) {
                if (this.viewport.width < 0)throw new n("renderState.viewport.width must be greater than or equal to zero.");
                if (this.viewport.width > f.getMaximumViewportWidth())throw new r("renderState.viewport.width must be less than or equal to the maximum viewport width (" + this.getMaximumViewportWidth().toString() + ").  Check getMaximumViewportWidth().");
                if (this.viewport.height < 0)throw new n("renderState.viewport.height must be greater than or equal to zero.");
                if (this.viewport.height > f.getMaximumViewportHeight())throw new r("renderState.viewport.height must be less than or equal to the maximum viewport height (" + this.getMaximumViewportHeight().toString() + ").  Check getMaximumViewportHeight().")
            }
            this.id = 0, this._applyFunctions = []
        }, I = new i;
        return D.apply = function (e, t, n) {
            h(e, t), p(e, t), m(e, t), y(e, t), v(e, t, n), g(e, t), _(e, t), w(e, t), C(e, t), x(e, t), S(e, t, n), b(e, t), T(e, t), E(e, t), A(e, t, n)
        }, D.partialApply = function (e, t, n, i) {
            var r = n._applyFunctions[t.id];
            "undefined" == typeof r && (r = M(t, n), n._applyFunctions[t.id] = r);
            for (var o = r.length, a = 0; o > a; ++a)r[a](e, n, i)
        }, D
    }), n("Renderer/ShaderCache", ["../Core/destroyObject"], function (e) {
        "use strict";
        var t = function (e) {
            this._context = e, this._shaders = {}, this._shadersToRelease = {}
        };
        return t.prototype.replaceShaderProgram = function (e, t, n, i) {
            return"undefined" != typeof e && e.release(), this.getShaderProgram(t, n, i)
        }, t.prototype.getShaderProgram = function (e, t, n) {
            var i, r = e + t + JSON.stringify(n);
            if (this._shaders[r])i = this._shaders[r]; else {
                var o = this._context.createShaderProgram(e, t, n);
                i = {cache: this, shaderProgram: o, keyword: r, count: 0}, o._cachedShader = i, this._shaders[r] = i
            }
            return++i.count, i.shaderProgram
        }, t.prototype.destroyReleasedShaderPrograms = function () {
            var e = this._shadersToRelease;
            for (var t in e)if (e.hasOwnProperty(t)) {
                var n = e[t];
                0 === n.count && (delete this._shaders[n.keyword], n.shaderProgram.destroy())
            }
            this._shadersToRelease = {}
        }, t.prototype.releaseShaderProgram = function (e) {
            if (e) {
                var t = e._cachedShader;
                t && 0 === --t.count && (this._shadersToRelease[t.keyword] = t)
            }
            return void 0
        }, t.prototype.isDestroyed = function () {
            return!1
        }, t.prototype.destroy = function () {
            var t = this._shaders;
            for (var n in t)t.hasOwnProperty(n) && t[n].shaderProgram.destroy();
            return e(this)
        }, t
    }), n("Renderer/UniformDatatype", ["../Core/Enumeration"], function (e) {
        "use strict";
        var t = {FLOAT: new e(5126, "FLOAT", {getGLSL: function () {
            return"float"
        }}), FLOAT_VECTOR2: new e(35664, "FLOAT_VECTOR2", {getGLSL: function () {
            return"vec2"
        }}), FLOAT_VECTOR3: new e(35665, "FLOAT_VECTOR3", {getGLSL: function () {
            return"vec3"
        }}), FLOAT_VECTOR4: new e(35666, "FLOAT_VECTOR4", {getGLSL: function () {
            return"vec4"
        }}), INT: new e(5124, "INT", {getGLSL: function () {
            return"int"
        }}), INT_VECTOR2: new e(35667, "INT_VECTOR2", {getGLSL: function () {
            return"ivec2"
        }}), INT_VECTOR3: new e(35668, "INT_VECTOR3", {getGLSL: function () {
            return"ivec3"
        }}), INT_VECTOR4: new e(35669, "INT_VECTOR4", {getGLSL: function () {
            return"ivec4"
        }}), BOOL: new e(35670, "BOOL", {getGLSL: function () {
            return"bool"
        }}), BOOL_VECTOR2: new e(35671, "BOOL_VECTOR2", {getGLSL: function () {
            return"bvec2"
        }}), BOOL_VECTOR3: new e(35672, "BOOL_VECTOR3", {getGLSL: function () {
            return"bvec3"
        }}), BOOL_VECTOR4: new e(35673, "BOOL_VECTOR4", {getGLSL: function () {
            return"bvec4"
        }}), FLOAT_MATRIX2: new e(35674, "FLOAT_MATRIX2", {getGLSL: function () {
            return"mat2"
        }}), FLOAT_MATRIX3: new e(35675, "FLOAT_MATRIX3", {getGLSL: function () {
            return"mat3"
        }}), FLOAT_MATRIX4: new e(35676, "FLOAT_MATRIX4", {getGLSL: function () {
            return"mat4"
        }}), SAMPLER_2D: new e(35678, "SAMPLER_2D", {getGLSL: function () {
            return"sampler2D"
        }}), SAMPLER_CUBE: new e(35680, "SAMPLER_CUBE", {getGLSL: function () {
            return"samplerCube"
        }})};
        return t
    }), n("Shaders/BuiltinFunctions", [], function () {
        "use strict";
        return"const float czm_infinity = 5906376272000.0;\nconst float czm_epsilon1 = 0.1;\nconst float czm_epsilon2 = 0.01;\nconst float czm_epsilon3 = 0.001;\nconst float czm_epsilon4 = 0.0001;\nconst float czm_epsilon5 = 0.00001;\nconst float czm_epsilon6 = 0.000001;\nconst float czm_epsilon7 = 0.0000001;\nbool czm_equalsEpsilon(vec4 left, vec4 right, float epsilon) {\nreturn all(lessThanEqual(abs(left - right), vec4(epsilon)));\n}\nbool czm_equalsEpsilon(vec3 left, vec3 right, float epsilon) {\nreturn all(lessThanEqual(abs(left - right), vec3(epsilon)));\n}\nbool czm_equalsEpsilon(vec2 left, vec2 right, float epsilon) {\nreturn all(lessThanEqual(abs(left - right), vec2(epsilon)));\n}\nbool czm_equalsEpsilon(float left, float right, float epsilon) {\nreturn (abs(left - right) <= epsilon);\n}\nbool czm_equalsEpsilon(float left, float right) {\nreturn (abs(left - right) <= czm_epsilon7);\n}\nmat2 czm_transpose(mat2 matrix)\n{\nreturn mat2(\nmatrix[0][0], matrix[1][0],\nmatrix[0][1], matrix[1][1]);\n}\nmat3 czm_transpose(mat3 matrix)\n{\nreturn mat3(\nmatrix[0][0], matrix[1][0], matrix[2][0],\nmatrix[0][1], matrix[1][1], matrix[2][1],\nmatrix[0][2], matrix[1][2], matrix[2][2]);\n}\nmat4 czm_transpose(mat4 matrix)\n{\nreturn mat4(\nmatrix[0][0], matrix[1][0], matrix[2][0], matrix[3][0],\nmatrix[0][1], matrix[1][1], matrix[2][1], matrix[3][1],\nmatrix[0][2], matrix[1][2], matrix[2][2], matrix[3][2],\nmatrix[0][3], matrix[1][3], matrix[2][3], matrix[3][3]);\n}\nvec4 czm_modelToWindowCoordinates(vec4 position)\n{\nvec4 q = czm_modelViewProjection * position;\nq.xyz /= q.w;\nq.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz;\nreturn q;\n}\nvec4 czm_eyeToWindowCoordinates(vec4 positionEC)\n{\nvec4 q = czm_projection * positionEC;\nq.xyz /= q.w;\nq.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz;\nreturn q;\n}\nvec4 czm_windowToEyeCoordinates(vec4 fragmentCoordinate)\n{\nfloat x = 2.0 * (fragmentCoordinate.x - czm_viewport.x) / czm_viewport.z - 1.0;\nfloat y = 2.0 * (fragmentCoordinate.y - czm_viewport.y) / czm_viewport.w - 1.0;\nfloat z = (fragmentCoordinate.z - czm_viewportTransformation[3][2]) / czm_viewportTransformation[2][2];\nvec4 q = vec4(x, y, z, 1.0);\nq /= fragmentCoordinate.w;\nq = czm_inverseProjection * q;\nreturn q;\n}\nmat3 czm_tangentToEyeSpaceMatrix(vec3 normalEC, vec3 tangentEC, vec3 binormalEC)\n{\nvec3 normal = normalize(normalEC);\nvec3 tangent = normalize(tangentEC);\nvec3 binormal = normalize(binormalEC);\nreturn mat3(tangent.x,  tangent.y,  tangent.z,\nbinormal.x, binormal.y, binormal.z,\nnormal.x,   normal.y,   normal.z);\n}\nvec4 czm_eyeOffset(vec4 positionEC, vec3 eyeOffset)\n{\nvec4 p = positionEC;\nvec4 zEyeOffset = normalize(p) * eyeOffset.z;\np.xy += eyeOffset.xy + zEyeOffset.xy;\np.z += zEyeOffset.z;\nreturn p;\n}\nvec3 czm_geodeticSurfaceNormal(vec3 positionOnEllipsoid, vec3 ellipsoidCenter, vec3 oneOverEllipsoidRadiiSquared)\n{\nreturn normalize((positionOnEllipsoid - ellipsoidCenter) * oneOverEllipsoidRadiiSquared);\n}\nvec2 czm_ellipsoidWgs84TextureCoordinates(vec3 normal)\n{\nreturn vec2(atan(normal.y, normal.x) * czm_oneOverTwoPi + 0.5, asin(normal.z) * czm_oneOverPi + 0.5);\n}\nmat3 czm_eastNorthUpToEyeCoordinates(vec3 positionMC, vec3 normalEC)\n{\nvec3 tangentMC = normalize(vec3(-positionMC.y, positionMC.x, 0.0));\nvec3 tangentEC = normalize(czm_normal3D * tangentMC);\nvec3 bitangentEC = normalize(cross(normalEC, tangentEC));\nreturn mat3(\ntangentEC.x,   tangentEC.y,   tangentEC.z,\nbitangentEC.x, bitangentEC.y, bitangentEC.z,\nnormalEC.x,    normalEC.y,    normalEC.z);\n}\nstruct czm_materialInput\n{\nfloat s;\nvec2 st;\nvec3 str;\nvec3 normalEC;\nmat3 tangentToEyeMatrix;\nvec3 positionToEyeEC;\n};\nstruct czm_material\n{\nvec3 diffuse;\nfloat specular;\nfloat shininess;\nvec3 normal;\nvec3 emission;\nfloat alpha;\n};\nczm_material czm_getDefaultMaterial(czm_materialInput materialInput)\n{\nczm_material material;\nmaterial.diffuse = vec3(0.0);\nmaterial.specular = 0.0;\nmaterial.shininess = 1.0;\nmaterial.normal = materialInput.normalEC;\nmaterial.emission = vec3(0.0);\nmaterial.alpha = 1.0;\nreturn material;\n}\nfloat getLambertDiffuse(vec3 lightDirectionEC, vec3 normalEC)\n{\nreturn max(dot(lightDirectionEC, normalEC), 0.0);\n}\nfloat getLambertDiffuseOfMaterial(vec3 lightDirectionEC, czm_material material)\n{\nreturn getLambertDiffuse(lightDirectionEC, material.normal);\n}\nfloat getSpecular(vec3 lightDirectionEC, vec3 toEyeEC, vec3 normalEC, float shininess)\n{\nvec3 toReflectedLight = reflect(-lightDirectionEC, normalEC);\nfloat specular = max(dot(toReflectedLight, toEyeEC), 0.0);\nreturn pow(specular, shininess);\n}\nfloat getSpecularOfMaterial(vec3 lightDirectionEC, vec3 toEyeEC, czm_material material)\n{\nreturn getSpecular(lightDirectionEC, toEyeEC, material.normal, material.shininess);\n}\nvec4 czm_phong(vec3 toEye, czm_material material)\n{\nfloat diffuse = getLambertDiffuseOfMaterial(vec3(0.0, 0.0, 1.0), material) + getLambertDiffuseOfMaterial(vec3(0.0, 1.0, 0.0), material);\nfloat specular = getSpecularOfMaterial(czm_sunDirectionEC, toEye, material) + getSpecularOfMaterial(czm_moonDirectionEC, toEye, material);\nvec3 ambient = vec3(0.0);\nvec3 color = ambient + material.emission;\ncolor += material.diffuse * diffuse;\ncolor += material.specular * specular;\nreturn vec4(color, material.alpha);\n}\nfloat czm_luminance(vec3 rgb)\n{\nconst vec3 W = vec3(0.2125, 0.7154, 0.0721);\nreturn dot(rgb, W);\n}\nvec3 czm_hue(vec3 rgb, float adjustment)\n{\nconst mat3 toYIQ = mat3(0.299,     0.587,     0.114,\n0.595716, -0.274453, -0.321263,\n0.211456, -0.522591,  0.311135);\nconst mat3 toRGB = mat3(1.0,  0.9563,  0.6210,\n1.0, -0.2721, -0.6474,\n1.0, -1.107,   1.7046);\nvec3 yiq = toYIQ * rgb;\nfloat hue = atan(yiq.z, yiq.y) + adjustment;\nfloat chroma = sqrt(yiq.z * yiq.z + yiq.y * yiq.y);\nvec3 color = vec3(yiq.x, chroma * cos(hue), chroma * sin(hue));\nreturn toRGB * color;\n}\nvec3 czm_saturation(vec3 rgb, float adjustment)\n{\nvec3 intensity = vec3(czm_luminance(rgb));\nreturn mix(intensity, rgb, adjustment);\n}\nvec3 czm_multiplyWithColorBalance(vec3 left, vec3 right)\n{\nconst vec3 W = vec3(0.2125, 0.7154, 0.0721);\nvec3 target = left * right;\nfloat leftLuminance = dot(left, W);\nfloat rightLuminance = dot(right, W);\nfloat targetLuminance = dot(target, W);\nreturn ((leftLuminance + rightLuminance) / (2.0 * targetLuminance)) * target;\n}\nvec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist, float fuzzFactor)\n{\nfloat val1 = clamp(dist / fuzzFactor, 0.0, 1.0);\nfloat val2 = clamp((dist - 0.5) / fuzzFactor, 0.0, 1.0);\nval1 = val1 * (1.0 - val2);\nval1 = val1 * val1 * (3.0 - (2.0 * val1));\nval1 = pow(val1, 0.5);\nvec4 midColor = (color1 + color2) * 0.5;\nreturn mix(midColor, currentColor, val1);\n}\nvec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist)\n{\nreturn czm_antialias(color1, color2, currentColor, dist, 0.1);\n}\nvec3 czm_RGBToXYZ(vec3 rgb)\n{\nconst mat3 RGB2XYZ = mat3(0.4124, 0.2126, 0.0193,\n0.3576, 0.7152, 0.1192,\n0.1805, 0.0722, 0.9505);\nvec3 xyz = RGB2XYZ * rgb;\nvec3 Yxy;\nYxy.r = xyz.g;\nfloat temp = dot(vec3(1.0), xyz);\nYxy.gb = xyz.rg / temp;\nreturn Yxy;\n}\nvec3 czm_XYZToRGB(vec3 Yxy)\n{\nconst mat3 XYZ2RGB = mat3( 3.2405, -0.9693,  0.0556,\n-1.5371,  1.8760, -0.2040,\n-0.4985,  0.0416,  1.0572);\nvec3 xyz;\nxyz.r = Yxy.r * Yxy.g / Yxy.b;\nxyz.g = Yxy.r;\nxyz.b = Yxy.r * (1.0 - Yxy.g - Yxy.b) / Yxy.b;\nreturn XYZ2RGB * xyz;\n}\nconst float czm_webMercatorMaxLatitude = 1.4844222297453323669610967939;\nconst int czm_scene2D = 0;\nconst int czm_columbusView = 1;\nconst int czm_scene3D = 2;\nconst int czm_morphing = 3;\nvec4 czm_columbusViewMorph(vec4 position2D, vec4 position3D, float time)\n{\nvec3 p = mix(position2D.xyz, position3D.xyz, time);\nreturn vec4(p, 1.0);\n}\nvec4 czm_computePosition();\nstruct czm_ray\n{\nvec3 origin;\nvec3 direction;\n};\nvec3 czm_pointAlongRay(czm_ray ray, float time)\n{\nreturn ray.origin + (time * ray.direction);\n}\nstruct czm_raySegment\n{\nfloat start;\nfloat stop;\n};\nconst czm_raySegment czm_emptyRaySegment = czm_raySegment(-czm_infinity, -czm_infinity);\nconst czm_raySegment czm_fullRaySegment = czm_raySegment(0.0, czm_infinity);\nbool czm_isEmpty(czm_raySegment interval)\n{\nreturn (interval.stop < 0.0);\n}\nbool czm_isFull(czm_raySegment interval)\n{\nreturn (interval.start == 0.0 && interval.stop == czm_infinity);\n}\nstruct czm_ellipsoid\n{\nvec3 center;\nvec3 radii;\nvec3 inverseRadii;\nvec3 inverseRadiiSquared;\n};\nczm_ellipsoid czm_ellipsoidNew(vec3 center, vec3 radii)\n{\nvec3 inverseRadii = vec3(1.0 / radii.x, 1.0 / radii.y, 1.0 / radii.z);\nvec3 inverseRadiiSquared = inverseRadii * inverseRadii;\nczm_ellipsoid temp = czm_ellipsoid(center, radii, inverseRadii, inverseRadiiSquared);\nreturn temp;\n}\nbool czm_ellipsoidContainsPoint(czm_ellipsoid ellipsoid, vec3 point)\n{\nvec3 scaled = ellipsoid.inverseRadii * (czm_inverseModelView * vec4(point, 1.0)).xyz;\nreturn (dot(scaled, scaled) <= 1.0);\n}\nczm_raySegment czm_rayEllipsoidIntersectionInterval(czm_ray ray, czm_ellipsoid ellipsoid)\n{\nvec3 q = ellipsoid.inverseRadii * (czm_inverseModelView * vec4(ray.origin, 1.0)).xyz;\nvec3 w = ellipsoid.inverseRadii * (czm_inverseModelView * vec4(ray.direction, 0.0)).xyz;\nq = q - ellipsoid.inverseRadii * (czm_inverseModelView * vec4(ellipsoid.center, 1.0)).xyz;\nfloat q2 = dot(q, q);\nfloat qw = dot(q, w);\nif (q2 > 1.0)\n{\nif (qw >= 0.0)\n{\nreturn czm_emptyRaySegment;\n}\nelse\n{\nfloat qw2 = qw * qw;\nfloat difference = q2 - 1.0;\nfloat w2 = dot(w, w);\nfloat product = w2 * difference;\nif (qw2 < product)\n{\nreturn czm_emptyRaySegment;\n}\nelse if (qw2 > product)\n{\nfloat discriminant = qw * qw - product;\nfloat temp = -qw + sqrt(discriminant);\nfloat root0 = temp / w2;\nfloat root1 = difference / temp;\nif (root0 < root1)\n{\nczm_raySegment i = czm_raySegment(root0, root1);\nreturn i;\n}\nelse\n{\nczm_raySegment i = czm_raySegment(root1, root0);\nreturn i;\n}\n}\nelse\n{\nfloat root = sqrt(difference / w2);\nczm_raySegment i = czm_raySegment(root, root);\nreturn i;\n}\n}\n}\nelse if (q2 < 1.0)\n{\nfloat difference = q2 - 1.0;\nfloat w2 = dot(w, w);\nfloat product = w2 * difference;\nfloat discriminant = qw * qw - product;\nfloat temp = -qw + sqrt(discriminant);\nczm_raySegment i = czm_raySegment(0.0, temp / w2);\nreturn i;\n}\nelse\n{\nif (qw < 0.0)\n{\nfloat w2 = dot(w, w);\nczm_raySegment i = czm_raySegment(0.0, -qw / w2);\nreturn i;\n}\nelse\n{\nreturn czm_emptyRaySegment;\n}\n}\n}\nczm_ellipsoid czm_getWgs84EllipsoidEC()\n{\nreturn czm_ellipsoidNew(\nczm_view[3].xyz,\nvec3(6378137.0, 6378137.0, 6356752.314245));\n}\nfloat czm_latitudeToWebMercatorFraction(float latitude, float southMercatorYLow, float southMercatorYHigh, float oneOverMercatorHeight)\n{\nfloat sinLatitude = sin(latitude);\nfloat mercatorY = 0.5 * log((1.0 + sinLatitude) / (1.0 - sinLatitude));\nfloat t1 = 0.0 - southMercatorYLow;\nfloat e = t1 - 0.0;\nfloat t2 = ((-southMercatorYLow - e) + (0.0 - (t1 - e))) + mercatorY - southMercatorYHigh;\nfloat highDifference = t1 + t2;\nfloat lowDifference = t2 - (highDifference - t1);\nreturn highDifference * oneOverMercatorHeight + lowDifference * oneOverMercatorHeight;\n}\nvec4 czm_translateRelativeToEye(vec3 high, vec3 low)\n{\nvec3 highDifference = high - czm_encodedCameraPositionMCHigh;\nvec3 lowDifference = low - czm_encodedCameraPositionMCLow;\nreturn vec4(highDifference + lowDifference, 1.0);\n}\nvec4 czm_getWaterNoise(sampler2D normalMap, vec2 uv, float time, float angleInRadians)\n{\nfloat cosAngle = cos(angleInRadians);\nfloat sinAngle = sin(angleInRadians);\nvec2 s0 = vec2(1.0/17.0, 0.0);\nvec2 s1 = vec2(-1.0/29.0, 0.0);\nvec2 s2 = vec2(1.0/101.0, 1.0/59.0);\nvec2 s3 = vec2(-1.0/109.0, -1.0/57.0);\ns0 = vec2((cosAngle * s0.x) - (sinAngle * s0.y), (sinAngle * s0.x) + (cosAngle * s0.y));\ns1 = vec2((cosAngle * s1.x) - (sinAngle * s1.y), (sinAngle * s1.x) + (cosAngle * s1.y));\ns2 = vec2((cosAngle * s2.x) - (sinAngle * s2.y), (sinAngle * s2.x) + (cosAngle * s2.y));\ns3 = vec2((cosAngle * s3.x) - (sinAngle * s3.y), (sinAngle * s3.x) + (cosAngle * s3.y));\nvec2 uv0 = (uv/103.0) + (time * s0);\nvec2 uv1 = uv/107.0 + (time * s1) + vec2(0.23);\nvec2 uv2 = uv/vec2(897.0, 983.0) + (time * s2) + vec2(0.51);\nvec2 uv3 = uv/vec2(991.0, 877.0) + (time * s3) + vec2(0.71);\nuv0 = fract(uv0);\nuv1 = fract(uv1);\nuv2 = fract(uv2);\nuv3 = fract(uv3);\nvec4 noise = (texture2D(normalMap, uv0)) +\n(texture2D(normalMap, uv1)) +\n(texture2D(normalMap, uv2)) +\n(texture2D(normalMap, uv3));\nreturn ((noise / 4.0) - 0.5) * 2.0;\n}\nvec4 _czm_mod289(vec4 x)\n{\nreturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec3 _czm_mod289(vec3 x)\n{\nreturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec2 _czm_mod289(vec2 x)\n{\nreturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nfloat _czm_mod289(float x)\n{\nreturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 _czm_permute(vec4 x)\n{\nreturn _czm_mod289(((x*34.0)+1.0)*x);\n}\nvec3 _czm_permute(vec3 x)\n{\nreturn _czm_mod289(((x*34.0)+1.0)*x);\n}\nfloat _czm_permute(float x)\n{\nreturn _czm_mod289(((x*34.0)+1.0)*x);\n}\nvec4 _czm_taylorInvSqrt(vec4 r)\n{\nreturn 1.79284291400159 - 0.85373472095314 * r;\n}\nfloat _czm_taylorInvSqrt(float r)\n{\nreturn 1.79284291400159 - 0.85373472095314 * r;\n}\nvec4 _czm_grad4(float j, vec4 ip)\n{\nconst vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\nvec4 p,s;\np.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\np.w = 1.5 - dot(abs(p.xyz), ones.xyz);\ns = vec4(lessThan(p, vec4(0.0)));\np.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\nreturn p;\n}\nfloat czm_snoise(vec2 v)\n{\nconst vec4 C = vec4(0.211324865405187,\n0.366025403784439,\n-0.577350269189626,\n0.024390243902439);\nvec2 i  = floor(v + dot(v, C.yy) );\nvec2 x0 = v -   i + dot(i, C.xx);\nvec2 i1;\ni1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\nvec4 x12 = x0.xyxy + C.xxzz;\nx12.xy -= i1;\ni = _czm_mod289(i);\nvec3 p = _czm_permute( _czm_permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));\nvec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\nm = m*m ;\nm = m*m ;\nvec3 x = 2.0 * fract(p * C.www) - 1.0;\nvec3 h = abs(x) - 0.5;\nvec3 ox = floor(x + 0.5);\nvec3 a0 = x - ox;\nm *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\nvec3 g;\ng.x  = a0.x  * x0.x  + h.x  * x0.y;\ng.yz = a0.yz * x12.xz + h.yz * x12.yw;\nreturn 130.0 * dot(m, g);\n}\nfloat czm_snoise(vec3 v)\n{\nconst vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\nconst vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\nvec3 i  = floor(v + dot(v, C.yyy) );\nvec3 x0 =   v - i + dot(i, C.xxx) ;\nvec3 g = step(x0.yzx, x0.xyz);\nvec3 l = 1.0 - g;\nvec3 i1 = min( g.xyz, l.zxy );\nvec3 i2 = max( g.xyz, l.zxy );\nvec3 x1 = x0 - i1 + C.xxx;\nvec3 x2 = x0 - i2 + C.yyy;\nvec3 x3 = x0 - D.yyy;\ni = _czm_mod289(i);\nvec4 p = _czm_permute( _czm_permute( _czm_permute(\ni.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n+ i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\nfloat n_ = 0.142857142857;\nvec3  ns = n_ * D.wyz - D.xzx;\nvec4 j = p - 49.0 * floor(p * ns.z * ns.z);\nvec4 x_ = floor(j * ns.z);\nvec4 y_ = floor(j - 7.0 * x_ );\nvec4 x = x_ *ns.x + ns.yyyy;\nvec4 y = y_ *ns.x + ns.yyyy;\nvec4 h = 1.0 - abs(x) - abs(y);\nvec4 b0 = vec4( x.xy, y.xy );\nvec4 b1 = vec4( x.zw, y.zw );\nvec4 s0 = floor(b0)*2.0 + 1.0;\nvec4 s1 = floor(b1)*2.0 + 1.0;\nvec4 sh = -step(h, vec4(0.0));\nvec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\nvec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\nvec3 p0 = vec3(a0.xy,h.x);\nvec3 p1 = vec3(a0.zw,h.y);\nvec3 p2 = vec3(a1.xy,h.z);\nvec3 p3 = vec3(a1.zw,h.w);\nvec4 norm = _czm_taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\np0 *= norm.x;\np1 *= norm.y;\np2 *= norm.z;\np3 *= norm.w;\nvec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\nm = m * m;\nreturn 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\ndot(p2,x2), dot(p3,x3) ) );\n}\nfloat czm_snoise(vec4 v)\n{\nconst vec4  C = vec4( 0.138196601125011,\n0.276393202250021,\n0.414589803375032,\n-0.447213595499958);\n#define F4 0.309016994374947451\nvec4 i  = floor(v + dot(v, vec4(F4)) );\nvec4 x0 = v -   i + dot(i, C.xxxx);\nvec4 i0;\nvec3 isX = step( x0.yzw, x0.xxx );\nvec3 isYZ = step( x0.zww, x0.yyz );\ni0.x = isX.x + isX.y + isX.z;\ni0.yzw = 1.0 - isX;\ni0.y += isYZ.x + isYZ.y;\ni0.zw += 1.0 - isYZ.xy;\ni0.z += isYZ.z;\ni0.w += 1.0 - isYZ.z;\nvec4 i3 = clamp( i0, 0.0, 1.0 );\nvec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\nvec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\nvec4 x1 = x0 - i1 + C.xxxx;\nvec4 x2 = x0 - i2 + C.yyyy;\nvec4 x3 = x0 - i3 + C.zzzz;\nvec4 x4 = x0 + C.wwww;\ni = _czm_mod289(i);\nfloat j0 = _czm_permute( _czm_permute( _czm_permute( _czm_permute(i.w) + i.z) + i.y) + i.x);\nvec4 j1 = _czm_permute( _czm_permute( _czm_permute( _czm_permute (\ni.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n+ i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n+ i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n+ i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\nvec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\nvec4 p0 = _czm_grad4(j0,   ip);\nvec4 p1 = _czm_grad4(j1.x, ip);\nvec4 p2 = _czm_grad4(j1.y, ip);\nvec4 p3 = _czm_grad4(j1.z, ip);\nvec4 p4 = _czm_grad4(j1.w, ip);\nvec4 norm = _czm_taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\np0 *= norm.x;\np1 *= norm.y;\np2 *= norm.z;\np3 *= norm.w;\np4 *= _czm_taylorInvSqrt(dot(p4,p4));\nvec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\nvec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\nm0 = m0 * m0;\nm1 = m1 * m1;\nreturn 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n+ dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n}\nvec3 _czm_permute289(vec3 x)\n{\nreturn mod((34.0 * x + 1.0) * x, 289.0);\n}\nvec2 czm_cellular(vec2 P)\n{\n#define K 0.142857142857\n#define Ko 0.428571428571\n#define jitter 1.0\nvec2 Pi = mod(floor(P), 289.0);\nvec2 Pf = fract(P);\nvec3 oi = vec3(-1.0, 0.0, 1.0);\nvec3 of = vec3(-0.5, 0.5, 1.5);\nvec3 px = _czm_permute289(Pi.x + oi);\nvec3 p = _czm_permute289(px.x + Pi.y + oi);\nvec3 ox = fract(p*K) - Ko;\nvec3 oy = mod(floor(p*K),7.0)*K - Ko;\nvec3 dx = Pf.x + 0.5 + jitter*ox;\nvec3 dy = Pf.y - of + jitter*oy;\nvec3 d1 = dx * dx + dy * dy;\np = _czm_permute289(px.y + Pi.y + oi);\nox = fract(p*K) - Ko;\noy = mod(floor(p*K),7.0)*K - Ko;\ndx = Pf.x - 0.5 + jitter*ox;\ndy = Pf.y - of + jitter*oy;\nvec3 d2 = dx * dx + dy * dy;\np = _czm_permute289(px.z + Pi.y + oi);\nox = fract(p*K) - Ko;\noy = mod(floor(p*K),7.0)*K - Ko;\ndx = Pf.x - 1.5 + jitter*ox;\ndy = Pf.y - of + jitter*oy;\nvec3 d3 = dx * dx + dy * dy;\nvec3 d1a = min(d1, d2);\nd2 = max(d1, d2);\nd2 = min(d2, d3);\nd1 = min(d1a, d2);\nd2 = max(d1a, d2);\nd1.xy = (d1.x < d1.y) ? d1.xy : d1.yx;\nd1.xz = (d1.x < d1.z) ? d1.xz : d1.zx;\nd1.yz = min(d1.yz, d2.yz);\nd1.y = min(d1.y, d1.z);\nd1.y = min(d1.y, d2.x);\nreturn sqrt(d1.xy);\n}\n"
    }), n("Renderer/ShaderProgram", ["../Core/DeveloperError", "../Core/RuntimeError", "../Core/destroyObject", "../Core/Math", "../Core/Matrix2", "../Core/Matrix3", "../Core/Matrix4", "./UniformDatatype", "../Shaders/BuiltinFunctions"], function (e, t, n, i, r, o, a, s, u) {
        "use strict";
        function l(e, n) {
            switch (n) {
                case e.FLOAT:
                    return function () {
                        return s.FLOAT
                    };
                case e.FLOAT_VEC2:
                    return function () {
                        return s.FLOAT_VECTOR2
                    };
                case e.FLOAT_VEC3:
                    return function () {
                        return s.FLOAT_VECTOR3
                    };
                case e.FLOAT_VEC4:
                    return function () {
                        return s.FLOAT_VECTOR4
                    };
                case e.INT:
                    return function () {
                        return s.INT
                    };
                case e.INT_VEC2:
                    return function () {
                        return s.INT_VECTOR2
                    };
                case e.INT_VEC3:
                    return function () {
                        return s.INT_VECTOR3
                    };
                case e.INT_VEC4:
                    return function () {
                        return s.INT_VECTOR4
                    };
                case e.BOOL:
                    return function () {
                        return s.BOOL
                    };
                case e.BOOL_VEC2:
                    return function () {
                        return s.BOOL_VECTOR2
                    };
                case e.BOOL_VEC3:
                    return function () {
                        return s.BOOL_VECTOR3
                    };
                case e.BOOL_VEC4:
                    return function () {
                        return s.BOOL_VECTOR4
                    };
                case e.FLOAT_MAT2:
                    return function () {
                        return s.FLOAT_MATRIX2
                    };
                case e.FLOAT_MAT3:
                    return function () {
                        return s.FLOAT_MATRIX3
                    };
                case e.FLOAT_MAT4:
                    return function () {
                        return s.FLOAT_MATRIX4
                    };
                case e.SAMPLER_2D:
                    return function () {
                        return s.SAMPLER_2D
                    };
                case e.SAMPLER_CUBE:
                    return function () {
                        return s.SAMPLER_CUBE
                    };
                default:
                    throw new t("Unrecognized uniform type: " + n)
            }
        }

        function c(e) {
            var t = e.indexOf("#version");
            if (-1 !== t) {
                var n = e.indexOf("\n", t);
                if (-1 !== t) {
                    var i = e.substring(t, n + 1), r = e.substring(0, t) + "//" + e.substring(t);
                    return{versionDirective: i, modifiedSource: r}
                }
            }
            return{versionDirective: "", modifiedSource: e}
        }

        function d(e, t) {
            var n = e[t], i = "uniform " + n.getDatatype().getGLSL() + " " + t, r = n.getSize();
            return i += 1 === r ? ";" : "[" + r.toString() + "];"
        }

        function f(e) {
            var t = e, n = S;
            for (var i in n)if (n.hasOwnProperty(i)) {
                var r = d(n, i), o = t.indexOf(r);
                -1 !== o && (t = t.substring(0, o) + "/*" + t.substring(o, r.length) + "*/" + t.substring(o + r.length))
            }
            return t
        }

        function h() {
            return"#ifdef GL_FRAGMENT_PRECISION_HIGH \n  precision highp float; \n#else \n  precision mediump float; \n#endif \n\n"
        }

        function p() {
            var e = {czm_pi: Math.PI.toExponential(), czm_oneOverPi: i.ONE_OVER_PI.toExponential(), czm_piOverTwo: i.PI_OVER_TWO.toExponential(), czm_piOverThree: i.PI_OVER_THREE.toExponential(), czm_piOverFour: i.PI_OVER_FOUR.toExponential(), czm_piOverSix: i.PI_OVER_SIX.toExponential(), czm_threePiOver2: i.THREE_PI_OVER_TWO.toExponential(), czm_twoPi: i.TWO_PI.toExponential(), czm_oneOverTwoPi: i.ONE_OVER_TWO_PI.toExponential(), czm_radiansPerDegree: i.RADIANS_PER_DEGREE.toExponential(), czm_degreesPerRadian: i.DEGREES_PER_RADIAN.toExponential(), czm_solarRadius: i.SOLAR_RADIUS.toExponential()}, t = "";
            for (var n in e)e.hasOwnProperty(n) && (t += "const float " + n + " = " + e[n] + "; \n");
            return t += " \n"
        }

        function m() {
            var e = "", t = S;
            for (var n in t)t.hasOwnProperty(n) && (e += d(t, n) + " \n");
            return e += "\n"
        }

        function y(e, n, i, r, o) {
            var a = c(i), s = c(r), u = a.versionDirective + A() + f(a.modifiedSource), l = s.versionDirective + h() + A() + f(s.modifiedSource), d = e.createShader(e.VERTEX_SHADER);
            e.shaderSource(d, u), e.compileShader(d);
            var p = e.getShaderInfoLog(d);
            if (n && p && p.length && console.log("[GL] Vertex shader compile log: " + p), !e.getShaderParameter(d, e.COMPILE_STATUS))throw e.deleteShader(d), console.error("[GL] Vertex shader compile log: " + p), new t("Vertex shader failed to compile.  Compile log: " + p);
            var m = e.createShader(e.FRAGMENT_SHADER);
            e.shaderSource(m, l), e.compileShader(m);
            var y = e.getShaderInfoLog(m);
            if (n && y && y.length && console.log("[GL] Fragment shader compile log: " + y), !e.getShaderParameter(m, e.COMPILE_STATUS))throw e.deleteShader(d), e.deleteShader(m), console.error("[GL] Fragment shader compile log: " + y), new t("Fragment shader failed to compile.  Compile log: " + y);
            var v = e.createProgram();
            if (e.attachShader(v, d), e.attachShader(v, m), e.deleteShader(d), e.deleteShader(m), "undefined" != typeof o)for (var g in o)o.hasOwnProperty(g) && e.bindAttribLocation(v, o[g], g);
            e.linkProgram(v);
            var _ = e.getProgramInfoLog(v);
            if (n && _ && _.length && console.log("[GL] Shader program link log: " + _), !e.getProgramParameter(v, e.LINK_STATUS))throw e.deleteProgram(v), console.error("[GL] Shader program link log: " + _), new t("Program failed to link.  Link log: " + _);
            return v
        }

        function v(e, t, n) {
            for (var i = {}, r = 0; n > r; ++r) {
                var o = e.getActiveAttrib(t, r), a = e.getAttribLocation(t, o.name);
                i[o.name] = {name: o.name, type: o.type, index: a}
            }
            return i
        }

        function g(e, t) {
            for (var n = {}, i = [], r = [], o = e.getProgramParameter(t, e.ACTIVE_UNIFORMS), a = 0; o > a; ++a) {
                var s = e.getActiveUniform(t, a), u = "[0]", l = -1 !== s.name.indexOf(u, s.name.length - u.length) ? s.name.slice(0, s.name.length - 3) : s.name;
                if (0 !== l.indexOf("gl_"))if (s.name.indexOf("[") < 0) {
                    var c = e.getUniformLocation(t, l), d = e.getUniform(t, c), f = new b(e, s, l, c, d);
                    n[l] = f, f._setSampler ? r.push(f) : i.push(f)
                } else {
                    var h, p, m, y, v = l.indexOf("[");
                    if (v >= 0)h = n[l.slice(0, v)], p = h._getLocations(), p.length <= 1 && (m = h.value, y = e.getUniformLocation(t, l), p.push(y), m.push(e.getUniform(t, y))); else {
                        p = [], m = [];
                        for (var g = 0; g < s.size; ++g)y = e.getUniformLocation(t, l + "[" + g + "]"), p.push(y), m.push(e.getUniform(t, y));
                        h = new T(e, s, l, p, m), n[l] = h, h._setSampler ? r.push(h) : i.push(h)
                    }
                }
            }
            return{allUniforms: n, uniforms: i, samplerUniforms: r}
        }

        function _(e) {
            var t = [], n = {};
            for (var i in e)if (e.hasOwnProperty(i)) {
                var r = S[i];
                r ? t.push({uniform: e[i], automaticUniform: r}) : n[i] = e[i]
            }
            return{automaticUniforms: t, manualUniforms: n}
        }

        var w, C, x, S = {czm_viewport: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_VECTOR4
        }, getValue: function (e) {
            var t = e.getViewport();
            return{x: t.x, y: t.y, z: t.width, w: t.height}
        }}, czm_viewportOrthographic: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_MATRIX4
        }, getValue: function (e) {
            return e.getViewportOrthographic()
        }}, czm_viewportTransformation: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_MATRIX4
        }, getValue: function (e) {
            return e.getViewportTransformation()
        }}, czm_model: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_MATRIX4
        }, getValue: function (e) {
            return e.getModel()
        }}, czm_inverseModel: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_MATRIX4
        }, getValue: function (e) {
            return e.getInverseModel()
        }}, czm_view: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_MATRIX4
        }, getValue: function (e) {
            return e.getView()
        }}, czm_view3D: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_MATRIX4
        }, getValue: function (e) {
            return e.getView3D()
        }}, czm_viewRotation: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_MATRIX3
        }, getValue: function (e) {
            return e.getViewRotation()
        }}, czm_viewRotation3D: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_MATRIX3
        }, getValue: function (e) {
            return e.getViewRotation3D()
        }}, czm_inverseView: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_MATRIX4
        }, getValue: function (e) {
            return e.getInverseView()
        }}, czm_inverseView3D: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_MATRIX4
        }, getValue: function (e) {
            return e.getInverseView3D()
        }}, czm_inverseViewRotation: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_MATRIX3
        }, getValue: function (e) {
            return e.getInverseViewRotation()
        }}, czm_inverseViewRotation3D: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_MATRIX3
        }, getValue: function (e) {
            return e.getInverseViewRotation3D()
        }}, czm_projection: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_MATRIX4
        }, getValue: function (e) {
            return e.getProjection()
        }}, czm_inverseProjection: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_MATRIX4
        }, getValue: function (e) {
            return e.getInverseProjection()
        }}, czm_infiniteProjection: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_MATRIX4
        }, getValue: function (e) {
            return e.getInfiniteProjection()
        }}, czm_modelView: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_MATRIX4
        }, getValue: function (e) {
            return e.getModelView()
        }}, czm_modelView3D: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_MATRIX4
        }, getValue: function (e) {
            return e.getModelView3D()
        }}, czm_modelViewRelativeToEye: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_MATRIX4
        }, getValue: function (e) {
            return e.getModelViewRelativeToEye()
        }}, czm_inverseModelView: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_MATRIX4
        }, getValue: function (e) {
            return e.getInverseModelView()
        }}, czm_inverseModelView3D: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_MATRIX4
        }, getValue: function (e) {
            return e.getInverseModelView3D()
        }}, czm_viewProjection: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_MATRIX4
        }, getValue: function (e) {
            return e.getViewProjection()
        }}, czm_modelViewProjection: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_MATRIX4
        }, getValue: function (e) {
            return e.getModelViewProjection()
        }}, czm_modelViewProjectionRelativeToEye: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_MATRIX4
        }, getValue: function (e) {
            return e.getModelViewProjectionRelativeToEye()
        }}, czm_modelViewInfiniteProjection: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_MATRIX4
        }, getValue: function (e) {
            return e.getModelViewInfiniteProjection()
        }}, czm_normal: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_MATRIX3
        }, getValue: function (e) {
            return e.getNormal()
        }}, czm_normal3D: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_MATRIX3
        }, getValue: function (e) {
            return e.getNormal3D()
        }}, czm_inverseNormal: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_MATRIX3
        }, getValue: function (e) {
            return e.getInverseNormal()
        }}, czm_inverseNormal3D: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_MATRIX3
        }, getValue: function (e) {
            return e.getInverseNormal3D()
        }}, czm_entireFrustum: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_VECTOR2
        }, getValue: function (e) {
            return e.getEntireFrustum()
        }}, czm_currentFrustum: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_VECTOR2
        }, getValue: function (e) {
            return e.getCurrentFrustum()
        }}, czm_pixelSizeInMeters: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT
        }, getValue: function (e) {
            return e.getPixelSize()
        }}, czm_sunPositionWC: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_VECTOR3
        }, getValue: function (e) {
            return e.getSunPositionWC()
        }}, czm_sunPositionColumbusView: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_VECTOR3
        }, getValue: function (e) {
            return e.getSunPositionColumbusView()
        }}, czm_sunDirectionEC: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_VECTOR3
        }, getValue: function (e) {
            return e.getSunDirectionEC()
        }}, czm_sunDirectionWC: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_VECTOR3
        }, getValue: function (e) {
            return e.getSunDirectionWC()
        }}, czm_moonDirectionEC: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_VECTOR3
        }, getValue: function (e) {
            return e.getMoonDirectionEC()
        }}, czm_encodedCameraPositionMCHigh: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_VECTOR3
        }, getValue: function (e) {
            return e.getEncodedCameraPositionMCHigh()
        }}, czm_encodedCameraPositionMCLow: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_VECTOR3
        }, getValue: function (e) {
            return e.getEncodedCameraPositionMCLow()
        }}, czm_viewerPositionWC: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_VECTOR3
        }, getValue: function (e) {
            return e.getInverseView().getTranslation()
        }}, czm_frameNumber: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT
        }, getValue: function (e) {
            return e.getFrameState().frameNumber
        }}, czm_morphTime: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT
        }, getValue: function (e) {
            return e.getFrameState().morphTime
        }}, czm_temeToPseudoFixed: {getSize: function () {
            return 1
        }, getDatatype: function () {
            return s.FLOAT_MATRIX3
        }, getValue: function (e) {
            return e.getTemeToPseudoFixedMatrix()
        }}};
        "undefined" != typeof Float32Array && (w = new Float32Array(4), C = new Float32Array(9), x = new Float32Array(16));
        var b = function (n, i, s, u, c) {
            this.value = c, this.getName = function () {
                return s
            }, this.getDatatype = l(n, i.type), this._getLocation = function () {
                return u
            }, this._set = function () {
                switch (i.type) {
                    case n.FLOAT:
                        return function () {
                            n.uniform1f(u, this.value)
                        };
                    case n.FLOAT_VEC2:
                        return function () {
                            var e = this.value;
                            n.uniform2f(u, e.x, e.y)
                        };
                    case n.FLOAT_VEC3:
                        return function () {
                            var e = this.value;
                            n.uniform3f(u, e.x, e.y, e.z)
                        };
                    case n.FLOAT_VEC4:
                        return function () {
                            var t = this.value;
                            if ("undefined" != typeof t.red)n.uniform4f(u, t.red, t.green, t.blue, t.alpha); else {
                                if ("undefined" == typeof t.x)throw new e('Invalid vec4 value for uniform "' + i.name + '".');
                                n.uniform4f(u, t.x, t.y, t.z, t.w)
                            }
                        };
                    case n.SAMPLER_2D:
                    case n.SAMPLER_CUBE:
                        return void 0;
                    case n.INT:
                    case n.BOOL:
                        return function () {
                            n.uniform1i(u, this.value)
                        };
                    case n.INT_VEC2:
                    case n.BOOL_VEC2:
                        return function () {
                            var e = this.value;
                            n.uniform2i(u, e.x, e.y)
                        };
                    case n.INT_VEC3:
                    case n.BOOL_VEC3:
                        return function () {
                            var e = this.value;
                            n.uniform3i(u, e.x, e.y, e.z)
                        };
                    case n.INT_VEC4:
                    case n.BOOL_VEC4:
                        return function () {
                            var e = this.value;
                            n.uniform4i(u, e.x, e.y, e.z, e.w)
                        };
                    case n.FLOAT_MAT2:
                        return function () {
                            n.uniformMatrix2fv(u, !1, r.toArray(this.value, w))
                        };
                    case n.FLOAT_MAT3:
                        return function () {
                            n.uniformMatrix3fv(u, !1, o.toArray(this.value, C))
                        };
                    case n.FLOAT_MAT4:
                        return function () {
                            n.uniformMatrix4fv(u, !1, a.toArray(this.value, x))
                        };
                    default:
                        throw new t("Unrecognized uniform type: " + i.type + ' for uniform "' + i.name + '".')
                }
            }(), (i.type === n.SAMPLER_2D || i.type === n.SAMPLER_CUBE) && (this._setSampler = function (e) {
                return n.activeTexture(n.TEXTURE0 + e), n.bindTexture(this.value._getTarget(), this.value._getTexture()), n.uniform1i(u, e), e + 1
            }, this._clearSampler = function (e) {
                return n.activeTexture(n.TEXTURE0 + e), n.bindTexture(this.value._getTarget(), null), e + 1
            })
        }, T = function (n, i, s, u, c) {
            this.value = c;
            var d = u;
            this.getName = function () {
                return s
            }, this.getDatatype = l(n, i.type), this._getLocations = function () {
                return d
            }, this._set = function () {
                switch (i.type) {
                    case n.FLOAT:
                        return function () {
                            for (var e = 0; e < d.length; ++e)n.uniform1f(d[e], this.value[e])
                        };
                    case n.FLOAT_VEC2:
                        return function () {
                            for (var e = 0; e < d.length; ++e) {
                                var t = this.value[e];
                                n.uniform2f(d[e], t.x, t.y)
                            }
                        };
                    case n.FLOAT_VEC3:
                        return function () {
                            for (var e = 0; e < d.length; ++e) {
                                var t = this.value[e];
                                n.uniform3f(d[e], t.x, t.y, t.z)
                            }
                        };
                    case n.FLOAT_VEC4:
                        return function () {
                            for (var t = 0; t < d.length; ++t) {
                                var i = this.value[t];
                                if ("undefined" != typeof i.red)n.uniform4f(d[t], i.red, i.green, i.blue, i.alpha); else {
                                    if ("undefined" == typeof i.x)throw new e("Invalid vec4 value.");
                                    n.uniform4f(d[t], i.x, i.y, i.z, i.w)
                                }
                            }
                        };
                    case n.SAMPLER_2D:
                    case n.SAMPLER_CUBE:
                        return void 0;
                    case n.INT:
                    case n.BOOL:
                        return function () {
                            for (var e = 0; e < d.length; ++e)n.uniform1i(d[e], this.value[e])
                        };
                    case n.INT_VEC2:
                    case n.BOOL_VEC2:
                        return function () {
                            for (var e = 0; e < d.length; ++e) {
                                var t = this.value[e];
                                n.uniform2i(d[e], t.x, t.y)
                            }
                        };
                    case n.INT_VEC3:
                    case n.BOOL_VEC3:
                        return function () {
                            for (var e = 0; e < d.length; ++e) {
                                var t = this.value[e];
                                n.uniform3i(d[e], t.x, t.y, t.z)
                            }
                        };
                    case n.INT_VEC4:
                    case n.BOOL_VEC4:
                        return function () {
                            for (var e = 0; e < d.length; ++e) {
                                var t = this.value[e];
                                n.uniform4i(d[e], t.x, t.y, t.z, t.w)
                            }
                        };
                    case n.FLOAT_MAT2:
                        return function () {
                            for (var e = 0; e < d.length; ++e)n.uniformMatrix2fv(d[e], !1, r.toArray(this.value[e], w))
                        };
                    case n.FLOAT_MAT3:
                        return function () {
                            for (var e = 0; e < d.length; ++e)n.uniformMatrix3fv(d[e], !1, o.toArray(this.value[e], C))
                        };
                    case n.FLOAT_MAT4:
                        return function () {
                            for (var e = 0; e < d.length; ++e)n.uniformMatrix4fv(d[e], !1, a.toArray(this.value[e], x))
                        };
                    default:
                        throw new t("Unrecognized uniform type: " + i.type)
                }
            }(), (i.type === n.SAMPLER_2D || i.type === n.SAMPLER_CUBE) && (this._setSampler = function (e) {
                for (var t = 0; t < d.length; ++t) {
                    var i = this.value[t], r = e + t;
                    n.activeTexture(n.TEXTURE0 + r), n.bindTexture(i._getTarget(), i._getTexture()), n.uniform1i(d[t], r)
                }
                return e + d.length
            }, this._clearSampler = function (e) {
                for (var t = 0; t < d.length; ++t)n.activeTexture(n.TEXTURE0 + e + t), n.bindTexture(this.value[t]._getTarget(), null);
                return e + d.length
            })
        }, E = function (e, t, n, i, r) {
            var o = y(e, t, n, i, r), a = e.getProgramParameter(o, e.ACTIVE_ATTRIBUTES), s = g(e, o), u = _(s.allUniforms);
            this._gl = e, this._program = o, this._numberOfVertexAttributes = a, this._vertexAttributes = v(e, o, a), this._allUniforms = s.allUniforms, this._uniforms = s.uniforms, this._samplerUniforms = s.samplerUniforms, this._automaticUniforms = u.automaticUniforms, this._manualUniforms = u.manualUniforms
        }, A = function () {
            var e = p() + m() + u + "\n\n" + "#line 0 \n";
            return A = function () {
                return e
            }, e
        };
        return E.prototype.getVertexAttributes = function () {
            return this._vertexAttributes
        }, E.prototype.getNumberOfVertexAttributes = function () {
            return this._numberOfVertexAttributes
        }, E.prototype.getAllUniforms = function () {
            return this._allUniforms
        }, E.prototype.getManualUniforms = function () {
            return this._manualUniforms
        }, E.prototype._bind = function () {
            this._gl.useProgram(this._program)
        }, E.prototype._unBind = function () {
            this._gl.useProgram(null);
            for (var e = this._samplerUniforms, t = 0, n = e.length, i = 0; n > i; ++i)t = e[i]._clearSampler(t)
        }, E.prototype._setUniforms = function (t, n, i) {
            var r, o, a = this._uniforms, s = this._samplerUniforms, u = this._manualUniforms, l = this._automaticUniforms;
            if (t)for (var c in u)u.hasOwnProperty(c) && (u[c].value = t[c]());
            for (r = l.length, o = 0; r > o; ++o)l[o].uniform.value = l[o].automaticUniform.getValue(n);
            for (r = a.length, o = 0; r > o; ++o)a[o]._set();
            var d = 0;
            for (r = s.length, o = 0; r > o; ++o)d = s[o]._setSampler(d);
            if (i) {
                var f = this._gl, h = this._program;
                if (f.validateProgram(h), !f.getProgramParameter(h, f.VALIDATE_STATUS))throw new e("Program validation failed.  Link log: " + f.getProgramInfoLog(h))
            }
        }, E.prototype.isDestroyed = function () {
            return!1
        }, E.prototype.destroy = function () {
            return this._gl.deleteProgram(this._program), n(this)
        }, E.prototype.release = function () {
            return this._cachedShader ? this._cachedShader.cache.releaseShaderProgram(this) : this.destroy()
        }, E
    }), n("Renderer/TextureAtlas", ["../Core/BoundingRectangle", "../Core/Cartesian2", "../Core/createGuid", "../Core/defaultValue", "../Core/destroyObject", "../Core/DeveloperError", "./PixelFormat"], function (e, t, n, i, r, o, a) {
        "use strict";
        function s(e, n, r, o, a) {
            this.bottomLeft = i(e, t.ZERO), this.topRight = i(n, t.ZERO), this.childNode1 = r, this.childNode2 = o, this.imageIndex = a
        }

        function u(e, n) {
            var i = e.getNumberOfImages(), r = 2;
            if (i > 0) {
                var o = e._texture.getWidth(), a = e._texture.getHeight(), u = r * (o + n.width + e._borderWidthInPixels), l = r * (a + n.height + e._borderWidthInPixels), c = o / u, d = a / l, f = new s(new t(o + e._borderWidthInPixels, 0), new t(u, a)), h = new s(new t, new t(u, a), e._root, f), p = new s(new t(0, a + e._borderWidthInPixels), new t(u, l)), m = new s(new t, new t(u, l), h, p);
                e._root = m;
                for (var y = 0; y < e._textureCoordinates.length; y++) {
                    var v = e._textureCoordinates[y];
                    "undefined" != typeof v && (v.x *= c, v.y *= d, v.width *= c, v.height *= d)
                }
                var g = e._context.createTexture2D({width: u, height: l, pixelFormat: e._pixelFormat}), _ = e._context.createFramebuffer({colorTexture: e._texture});
                _._bind(), g.copyFromFramebuffer(0, 0, 0, 0, o, a), _._unBind(), _.destroy(), e._texture = g
            } else {
                var w = r * (n.width + e._borderWidthInPixels), C = r * (n.height + e._borderWidthInPixels);
                e._texture = e._texture && e._texture.destroy(), e._texture = e._context.createTexture2D({width: w, height: C, pixelFormat: e._pixelFormat}), e._root = new s(new t, new t(w, C))
            }
        }

        function l(e, n, i) {
            if ("undefined" == typeof n)return void 0;
            if ("undefined" == typeof n.childNode1 && "undefined" == typeof n.childNode2) {
                if ("undefined" != typeof n.imageIndex)return void 0;
                var r = n.topRight.x - n.bottomLeft.x, o = n.topRight.y - n.bottomLeft.y, a = r - i.width, u = o - i.height;
                if (0 > a || 0 > u)return void 0;
                if (0 === a && 0 === u)return n;
                if (a > u) {
                    n.childNode1 = new s(new t(n.bottomLeft.x, n.bottomLeft.y), new t(n.bottomLeft.x + i.width, n.topRight.y));
                    var c = n.bottomLeft.x + i.width + e._borderWidthInPixels;
                    c < n.topRight.x && (n.childNode2 = new s(new t(c, n.bottomLeft.y), new t(n.topRight.x, n.topRight.y)))
                } else {
                    n.childNode1 = new s(new t(n.bottomLeft.x, n.bottomLeft.y), new t(n.topRight.x, n.bottomLeft.y + i.height));
                    var d = n.bottomLeft.y + i.height + e._borderWidthInPixels;
                    d < n.topRight.y && (n.childNode2 = new s(new t(n.bottomLeft.x, d), new t(n.topRight.x, n.topRight.y)))
                }
                return l(e, n.childNode1, i)
            }
            return l(e, n.childNode1, i) || l(e, n.childNode2, i)
        }

        function c(t, n, i) {
            if ("undefined" == typeof n)throw new o("image is required.");
            var r = l(t, t._root, n);
            if ("undefined" != typeof r) {
                r.imageIndex = i;
                var a = t._texture.getWidth(), s = t._texture.getHeight(), d = r.topRight.x - r.bottomLeft.x, f = r.topRight.y - r.bottomLeft.y;
                t._textureCoordinates[i] = new e(r.bottomLeft.x / a, r.bottomLeft.y / s, d / a, f / s), t._texture.copyFrom(n, r.bottomLeft.x, r.bottomLeft.y)
            } else u(t, n), c(t, n, i)
        }

        var d = new t(16, 16), f = function (e) {
            e = i(e, i.EMPTY_OBJECT);
            var r = e.context;
            if ("undefined" == typeof r)throw new o("context is required.");
            var u = i(e.borderWidthInPixels, 1);
            if (0 > u)throw new o("borderWidthInPixels must be greater than or equal to zero.");
            var l = i(e.initialSize, d);
            if (l.x < 1 || l.y < 1)throw new o("initialSize must be greater than zero.");
            this._context = r, this._pixelFormat = i(e.pixelFormat, a.RGBA), this._borderWidthInPixels = u, this._textureCoordinates = [], this._guid = n(), this._texture = this._context.createTexture2D({width: l.x, height: l.y, pixelFormat: this._pixelFormat}), this._root = new s(new t, new t(l.x, l.y));
            var c = e.images;
            "undefined" != typeof c && c.length > 0 && this.addImages(c);
            var f = e.image;
            "undefined" != typeof f && this.addImage(f)
        };
        return f.prototype.addImage = function (e) {
            var t = this.getNumberOfImages();
            return c(this, e, t), this._guid = n(), t
        }, f.prototype.addImages = function (e) {
            if ("undefined" == typeof e || e.length < 1)throw new o("images is required and must have length greater than zero.");
            var t, i = [], r = e.length, a = this.getNumberOfImages();
            for (t = 0; r > t; ++t)i.push({image: e[t], index: t + a});
            for (i.sort(function (e, t) {
                return Math.max(t.image.height, t.image.width) - Math.max(e.image.height, e.image.width)
            }), t = 0; r > t; ++t) {
                var s = i[t];
                c(this, s.image, s.index)
            }
            return this._guid = n(), a
        }, f.prototype.addSubRegions = function (t, i) {
            for (var r = this.addImage(t), o = this._texture.getWidth(), a = this._texture.getHeight(), s = this.getNumberOfImages(), u = i.length, l = this._textureCoordinates[r], c = 0; u > c; ++c) {
                var d = i[c];
                this._textureCoordinates.push(new e(l.x + d.x / o, l.y + d.y / a, d.width / o, d.height / a))
            }
            return this._guid = n(), s
        }, f.prototype.getBorderWidthInPixels = function () {
            return this._borderWidthInPixels
        }, f.prototype.getTextureCoordinates = function () {
            return this._textureCoordinates
        }, f.prototype.getTexture = function () {
            return this._texture
        }, f.prototype.getNumberOfImages = function () {
            return this._textureCoordinates.length
        }, f.prototype.getGUID = function () {
            return this._guid
        }, f.prototype.isDestroyed = function () {
            return!1
        }, f.prototype.destroy = function () {
            return this._texture = this._texture && this._texture.destroy(), r(this)
        }, f
    }), n("Renderer/UniformState", ["../Core/Matrix3", "../Core/Matrix4", "../Core/Cartesian2", "../Core/Cartesian3", "../Core/Cartesian4", "../Core/Cartographic", "../Core/Math", "../Core/EncodedCartesian3", "../Core/BoundingRectangle", "../Core/Transforms", "../Core/Simon1994PlanetaryPositions", "../Scene/SceneMode"], function (e, t, n, i, r, o, a, s, u, l, c, d) {
        "use strict";
        function f(e, n) {
            t.clone(n, e._view), t.getRotation(n, e._viewRotation), e._view3DDirty = !0, e._inverseView3DDirty = !0, e._modelViewDirty = !0, e._modelView3DDirty = !0, e._modelViewRelativeToEyeDirty = !0, e._inverseModelViewDirty = !0, e._inverseModelView3DDirty = !0, e._viewProjectionDirty = !0, e._modelViewProjectionDirty = !0, e._modelViewProjectionRelativeToEyeDirty = !0, e._modelViewInfiniteProjectionDirty = !0, e._normalDirty = !0, e._inverseNormalDirty = !0, e._normal3DDirty = !0, e._inverseNormal3DDirty = !0
        }

        function h(e, n) {
            t.clone(n, e._inverseView), t.getRotation(n, e._inverseViewRotation)
        }

        function p(e, n) {
            t.clone(n, e._projection), e._inverseProjectionDirty = !0, e._viewProjectionDirty = !0, e._modelViewProjectionDirty = !0, e._modelViewProjectionRelativeToEyeDirty = !0
        }

        function m(e, n) {
            t.clone(n, e._infiniteProjection), e._modelViewInfiniteProjectionDirty = !0
        }

        function y(e, t) {
            i.clone(t.getPositionWC(), e._cameraPosition), i.clone(t.getDirectionWC(), e._cameraDirection), i.clone(t.getRightWC(), e._cameraRight), i.clone(t.getUpWC(), e._cameraUp), e._encodedCameraPositionMCDirty = !0
        }

        function v(t, n) {
            "undefined" == typeof l.computeIcrfToFixedMatrix(n.time, N) && (N = l.computeTemeToPseudoFixedMatrix(n.time, N));
            var r = c.ComputeSunPositionInEarthInertialFrame(n.time, t._sunPositionWC);
            e.multiplyByVector(N, r, r), i.normalize(r, t._sunDirectionWC), r = e.multiplyByVector(t.getViewRotation3D(), r, t._sunDirectionEC), i.normalize(r, r), r = c.ComputeMoonPositionInEarthInertialFrame(n.time, t._moonDirectionEC), e.multiplyByVector(N, r, r), e.multiplyByVector(t.getViewRotation3D(), r, r), i.normalize(r, r);
            var o = n.scene2D.projection, a = o.getEllipsoid(), s = a.cartesianToCartographic(t._sunPositionWC, F);
            o.project(s, t._sunPositionColumbusView)
        }

        function g(e) {
            if (e._viewportDirty) {
                var n = e._viewport;
                t.computeOrthographicOffCenter(n.x, n.x + n.width, n.y, n.y + n.height, 0, 1, e._viewportOrthographicMatrix), t.computeViewportTransformation(n, 0, 1, e._viewportTransformation), e._viewportDirty = !1
            }
        }

        function _(e) {
            e._inverseProjectionDirty && (e._inverseProjectionDirty = !1, t.inverse(e._projection, e._inverseProjection))
        }

        function w(e) {
            e._modelViewDirty && (e._modelViewDirty = !1, t.multiply(e._view, e._model, e._modelView))
        }

        function C(e) {
            e._modelView3DDirty && (e._modelView3DDirty = !1, t.multiply(e.getView3D(), e._model, e._modelView3D))
        }

        function x(e) {
            if (e._modelViewRelativeToEyeDirty) {
                e._modelViewRelativeToEyeDirty = !1;
                var t = e.getModelView(), n = e._modelViewRelativeToEye;
                n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4], n[5] = t[5], n[6] = t[6], n[7] = t[7], n[8] = t[8], n[9] = t[9], n[10] = t[10], n[11] = t[11], n[12] = 0, n[13] = 0, n[14] = 0, n[15] = t[15]
            }
        }

        function S(e) {
            e._inverseModelViewDirty && (e._inverseModelViewDirty = !1, t.inverse(e.getModelView(), e._inverseModelView))
        }

        function b(e) {
            e._inverseModelView3DDirty && (e._inverseModelView3DDirty = !1, t.inverse(e.getModelView3D(), e._inverseModelView3D))
        }

        function T(e) {
            e._viewProjectionDirty && (e._viewProjectionDirty = !1, t.multiply(e._projection, e._view, e._viewProjection))
        }

        function E(e) {
            e._modelViewProjectionDirty && (e._modelViewProjectionDirty = !1, t.multiply(e._projection, e.getModelView(), e._modelViewProjection))
        }

        function A(e) {
            e._modelViewProjectionRelativeToEyeDirty && (e._modelViewProjectionRelativeToEyeDirty = !1, t.multiply(e._projection, e.getModelViewRelativeToEye(), e._modelViewProjectionRelativeToEye))
        }

        function M(e) {
            e._modelViewInfiniteProjectionDirty && (e._modelViewInfiniteProjectionDirty = !1, t.multiply(e._infiniteProjection, e.getModelView(), e._modelViewInfiniteProjection))
        }

        function D(e) {
            e._normalDirty && (e._normalDirty = !1, t.transpose(e.getInverseModelView(), V), t.getRotation(V, e._normal))
        }

        function I(e) {
            e._normal3DDirty && (e._normal3DDirty = !1, t.transpose(e.getInverseModelView3D(), V), t.getRotation(V, e._normal3D))
        }

        function P(e) {
            e._inverseNormalDirty && (e._inverseNormalDirty = !1, t.getRotation(e.getInverseModelView(), e._inverseNormal))
        }

        function O(e) {
            e._inverseNormal3DDirty && (e._inverseNormal3DDirty = !1, t.getRotation(e.getInverseModelView3D(), e._inverseNormal3D))
        }

        function R(e) {
            e._encodedCameraPositionMCDirty && (e._encodedCameraPositionMCDirty = !1, e.getInverseModel().multiplyByPoint(e._cameraPosition, B), s.fromCartesian(B, e._encodedCameraPositionMC))
        }

        function z(e, n, r, o, s, u, c, f) {
            var h = k;
            h.x = e.y, h.y = e.z, h.z = e.x;
            var p = U;
            p.x = r.y, p.y = r.z, p.z = r.x;
            var m = q;
            m.x = o.y, m.y = o.z, m.z = o.x;
            var y = W;
            y.x = n.y, y.y = n.z, y.z = n.x, u === d.SCENE2D && (h.z = .5 * s);
            var v = c.unproject(h, H);
            v.longitude = a.clamp(v.longitude, -Math.PI, Math.PI), v.latitude = a.clamp(v.latitude, -a.PI_OVER_TWO, a.PI_OVER_TWO);
            var g = c.getEllipsoid(), _ = g.cartographicToCartesian(v, G), w = l.eastNorthUpToFixedFrame(_, g, j);
            return w.multiplyByVector(p, p), w.multiplyByVector(m, m), w.multiplyByVector(y, y), "undefined" == typeof f && (f = new t), f[0] = p.x, f[1] = m.x, f[2] = -y.x, f[3] = 0, f[4] = p.y, f[5] = m.y, f[6] = -y.y, f[7] = 0, f[8] = p.z, f[9] = m.z, f[10] = -y.z, f[11] = 0, f[12] = -i.dot(p, _), f[13] = -i.dot(m, _), f[14] = i.dot(y, _), f[15] = 1, f
        }

        var L = function () {
            this._viewport = new u, this._viewportDirty = !1, this._viewportOrthographicMatrix = t.IDENTITY.clone(), this._viewportTransformation = t.IDENTITY.clone(), this._model = t.IDENTITY.clone(), this._view = t.IDENTITY.clone(), this._inverseView = t.IDENTITY.clone(), this._projection = t.IDENTITY.clone(), this._infiniteProjection = t.IDENTITY.clone(), this._entireFrustum = new n, this._currentFrustum = new n, this._pixelSize = 0, this._frameState = void 0, this._temeToPseudoFixed = e.IDENTITY.clone(), this._view3DDirty = !0, this._view3D = new t, this._inverseView3DDirty = !0, this._inverseView3D = new t, this._inverseModelDirty = !0, this._inverseModel = new t, this._viewRotation = new e, this._inverseViewRotation = new e, this._viewRotation3D = new e, this._inverseViewRotation3D = new e, this._inverseProjectionDirty = !0, this._inverseProjection = new t, this._modelViewDirty = !0, this._modelView = new t, this._modelView3DDirty = !0, this._modelView3D = new t, this._modelViewRelativeToEyeDirty = !0, this._modelViewRelativeToEye = new t, this._inverseModelViewDirty = !0, this._inverseModelView = new t, this._inverseModelView3DDirty = !0, this._inverseModelView3D = new t, this._viewProjectionDirty = !0, this._viewProjection = new t, this._modelViewProjectionDirty = !0, this._modelViewProjection = new t, this._modelViewProjectionRelativeToEyeDirty = !0, this._modelViewProjectionRelativeToEye = new t, this._modelViewInfiniteProjectionDirty = !0, this._modelViewInfiniteProjection = new t, this._normalDirty = !0, this._normal = new e, this._normal3DDirty = !0, this._normal3D = new e, this._inverseNormalDirty = !0, this._inverseNormal = new e, this._inverseNormal3DDirty = !0, this._inverseNormal3D = new e, this._encodedCameraPositionMCDirty = !0, this._encodedCameraPositionMC = new s, this._cameraPosition = new i, this._sunPositionWC = new i, this._sunPositionColumbusView = new i, this._sunDirectionWC = new i, this._sunDirectionEC = new i, this._moonDirectionEC = new i, this._mode = void 0, this._mapProjection = void 0, this._cameraDirection = new i, this._cameraRight = new i, this._cameraUp = new i, this._frustum2DWidth = 0
        }, N = new e, F = new o;
        L.prototype.updateFrustum = function (e) {
            p(this, e.getProjectionMatrix()), "undefined" != typeof e.getInfiniteProjectionMatrix && m(this, e.getInfiniteProjectionMatrix()), this._currentFrustum.x = e.near, this._currentFrustum.y = e.far
        }, L.prototype.update = function (e) {
            this._mode = e.mode, this._mapProjection = e.scene2D.projection;
            var t = e.camera;
            f(this, t.getViewMatrix()), h(this, t.getInverseViewMatrix()), y(this, t), this._frustum2DWidth = e.mode === d.SCENE2D ? t.frustum.right - t.frustum.left : 0, v(this, e);
            var n = t.frustum.getPixelSize(e.canvasDimensions);
            this._pixelSize = Math.max(n.x, n.y), this._entireFrustum.x = t.frustum.near, this._entireFrustum.y = t.frustum.far, this.updateFrustum(t.frustum), this._frameState = e, this._temeToPseudoFixed = l.computeTemeToPseudoFixedMatrix(e.time)
        }, L.prototype.setViewport = function (e) {
            u.equals(e, this._viewport) || (u.clone(e, this._viewport), this._viewportDirty = !0)
        }, L.prototype.getViewport = function () {
            return this._viewport
        }, L.prototype.getViewportOrthographic = function () {
            return g(this), this._viewportOrthographicMatrix
        }, L.prototype.getViewportTransformation = function () {
            return g(this), this._viewportTransformation
        }, L.prototype.setModel = function (e) {
            t.clone(e, this._model), this._modelView3DDirty = !0, this._inverseModelView3DDirty = !0, this._inverseModelDirty = !0, this._modelViewDirty = !0, this._modelViewRelativeToEyeDirty = !0, this._inverseModelViewDirty = !0, this._modelViewProjectionDirty = !0, this._modelViewProjectionRelativeToEyeDirty = !0, this._modelViewInfiniteProjectionDirty = !0, this._normalDirty = !0, this._inverseNormalDirty = !0, this._normal3DDirty = !0, this._inverseNormal3DDirty = !0, this._encodedCameraPositionMCDirty = !0
        }, L.prototype.getModel = function () {
            return this._model
        }, L.prototype.getInverseModel = function () {
            return this._inverseModelDirty && (this._inverseModelDirty = !1, this._model.inverse(this._inverseModel)), this._inverseModel
        }, L.prototype.getView = function () {
            return this._view
        }, L.prototype.getView3D = function () {
            return this._view3DDirty && (this._mode === d.SCENE3D ? t.clone(this._view, this._view3D) : z(this._cameraPosition, this._cameraDirection, this._cameraRight, this._cameraUp, this._frustum2DWidth, this._mode, this._mapProjection, this._view3D), t.getRotation(this._view3D, this._viewRotation3D), this._view3DDirty = !1), this._view3D
        }, L.prototype.getViewRotation = function () {
            return this._viewRotation
        }, L.prototype.getViewRotation3D = function () {
            return this.getView3D(), this._viewRotation3D
        }, L.prototype.getInverseView = function () {
            return this._inverseView
        }, L.prototype.getInverseView3D = function () {
            return this._inverseView3DDirty && (t.inverseTransformation(this.getView3D(), this._inverseView3D), t.getRotation(this._inverseView3D, this._inverseViewRotation3D), this._inverseView3DDirty = !1), this._inverseView3D
        }, L.prototype.getInverseViewRotation = function () {
            return this._inverseViewRotation
        }, L.prototype.getInverseViewRotation3D = function () {
            return this.getInverseView3D(), this._inverseViewRotation3D
        }, L.prototype.getProjection = function () {
            return this._projection
        }, L.prototype.getInverseProjection = function () {
            return _(this), this._inverseProjection
        }, L.prototype.getInfiniteProjection = function () {
            return this._infiniteProjection
        }, L.prototype.getModelView = function () {
            return w(this), this._modelView
        }, L.prototype.getModelView3D = function () {
            return C(this), this._modelView3D
        }, L.prototype.getModelViewRelativeToEye = function () {
            return x(this), this._modelViewRelativeToEye
        }, L.prototype.getInverseModelView = function () {
            return S(this), this._inverseModelView
        }, L.prototype.getInverseModelView3D = function () {
            return b(this), this._inverseModelView3D
        }, L.prototype.getViewProjection = function () {
            return T(this), this._viewProjection
        }, L.prototype.getModelViewProjection = function () {
            return E(this), this._modelViewProjection
        }, L.prototype.getModelViewProjectionRelativeToEye = function () {
            return A(this), this._modelViewProjectionRelativeToEye
        }, L.prototype.getModelViewInfiniteProjection = function () {
            return M(this), this._modelViewInfiniteProjection
        };
        var V = new t;
        L.prototype.getNormal = function () {
            return D(this), this._normal
        }, L.prototype.getNormal3D = function () {
            return I(this), this._normal3D
        }, L.prototype.getInverseNormal = function () {
            return P(this), this._inverseNormal
        }, L.prototype.getInverseNormal3D = function () {
            return O(this), this._inverseNormal3D
        }, L.prototype.getEntireFrustum = function () {
            return this._entireFrustum
        }, L.prototype.getCurrentFrustum = function () {
            return this._currentFrustum
        }, L.prototype.getPixelSize = function () {
            return this._pixelSize
        }, L.prototype.getSunPositionWC = function () {
            return this._sunPositionWC
        }, L.prototype.getSunPositionColumbusView = function () {
            return this._sunPositionColumbusView
        }, L.prototype.getSunDirectionWC = function () {
            return this._sunDirectionWC
        }, L.prototype.getSunDirectionEC = function () {
            return this._sunDirectionEC
        }, L.prototype.getMoonDirectionEC = function () {
            return this._moonDirectionEC
        };
        var B = new i;
        L.prototype.getEncodedCameraPositionMCHigh = function () {
            return R(this), this._encodedCameraPositionMC.high
        }, L.prototype.getEncodedCameraPositionMCLow = function () {
            return R(this), this._encodedCameraPositionMC.low
        }, L.prototype.getFrameState = function () {
            return this._frameState
        }, L.prototype.getTemeToPseudoFixedMatrix = function () {
            return this._temeToPseudoFixed
        }, L.prototype.getHighResolutionSnapScale = function () {
            return 1
        };
        var k = new i, U = new r, q = new r, W = new r, H = new o, G = new i, j = new t;
        return L
    }), n("Renderer/VertexArray", ["../Core/defaultValue", "../Core/destroyObject", "../Core/DeveloperError", "../Core/ComponentDatatype"], function (e, t, n, i) {
        "use strict";
        function r(t, r, o) {
            if (!r.vertexBuffer && !r.value)throw new n("attribute must have a vertexBuffer or a value.");
            if (r.vertexBuffer && r.value)throw new n("attribute cannot have both a vertexBuffer and a value.  It must have either a vertexBuffer property defining per-vertex data or a value property defining data for all vertices.");
            var a = r.value ? r.value.length : r.componentsPerAttribute;
            if (1 !== a && 2 !== a && 3 !== a && 4 !== a) {
                if (r.value)throw new n("attribute.value.length must be in the range [1, 4].");
                throw new n("attribute.componentsPerAttribute must be in the range [1, 4].")
            }
            if (r.componentDatatype) {
                var s = r.componentDatatype;
                if (!i.validate(s))throw new n("attribute must have a valid componentDatatype or not specify it.")
            }
            if (r.strideInBytes && r.strideInBytes > 255)throw new n("attribute must have a strideInBytes less than or equal to 255 or not specify it.");
            var u = {index: e(r.index, o), enabled: e(r.enabled, !0), vertexBuffer: r.vertexBuffer, value: r.value ? r.value.slice(0) : void 0, componentsPerAttribute: a, componentDatatype: r.componentDatatype || i.FLOAT, normalize: r.normalize || !1, offsetInBytes: r.offsetInBytes || 0, strideInBytes: r.strideInBytes || 0};
            if (u.vertexBuffer)u.vertexAttrib = function (e) {
                e.bindBuffer(e.ARRAY_BUFFER, this.vertexBuffer._getBuffer()), e.vertexAttribPointer(this.index, this.componentsPerAttribute, this.componentDatatype, this.normalize, this.strideInBytes, this.offsetInBytes), e.enableVertexAttribArray(this.index)
            }, u.disableVertexAttribArray = function (e) {
                e.disableVertexAttribArray(this.index)
            }; else {
                switch (u.componentsPerAttribute) {
                    case 1:
                        u.vertexAttrib = function (e) {
                            e.vertexAttrib1fv(this.index, this.value)
                        };
                        break;
                    case 2:
                        u.vertexAttrib = function (e) {
                            e.vertexAttrib2fv(this.index, this.value)
                        };
                        break;
                    case 3:
                        u.vertexAttrib = function (e) {
                            e.vertexAttrib3fv(this.index, this.value)
                        };
                        break;
                    case 4:
                        u.vertexAttrib = function (e) {
                            e.vertexAttrib4fv(this.index, this.value)
                        }
                }
                u.disableVertexAttribArray = function () {
                }
            }
            t.push(u)
        }

        function o(e, t, n) {
            for (var i = 0; i < t.length; ++i) {
                var r = t[i];
                r.enabled && r.vertexAttrib(e)
            }
            "undefined" != typeof n && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, n._getBuffer())
        }

        var a = function (e, t, i, a) {
            var s = [];
            if ("undefined" != typeof i)for (var u = 0; u < i.length; ++u)r(s, i[u], u);
            for (var l = {}, c = 0; c < s.length; ++c) {
                var d = s[c].index;
                if (l[d])throw new n("Index " + d + " is used by more than one attribute.");
                l[d] = !0
            }
            var f;
            null !== t && (f = t.createVertexArrayOES(), t.bindVertexArrayOES(f), o(e, s, a), t.bindVertexArrayOES(null)), this._gl = e, this._vaoExtension = t, this._vao = f, this._attributes = s, this._indexBuffer = a
        };
        return a.prototype.getAttribute = function (e) {
            if ("undefined" == typeof e)throw new n("index is required.");
            return this._attributes[e]
        }, a.prototype.getNumberOfAttributes = function () {
            return this._attributes.length
        }, a.prototype.getIndexBuffer = function () {
            return this._indexBuffer
        }, a.prototype._bind = function () {
            "undefined" != typeof this._vao ? this._vaoExtension.bindVertexArrayOES(this._vao) : o(this._gl, this._attributes, this._indexBuffer)
        }, a.prototype._unBind = function () {
            if ("undefined" != typeof this._vao)this._vaoExtension.bindVertexArrayOES(null); else {
                for (var e = this._attributes, t = this._gl, n = 0; n < e.length; ++n) {
                    var i = e[n];
                    i.enabled && i.disableVertexAttribArray(t)
                }
                this._indexBuffer && t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, null)
            }
        }, a.prototype._getNumberOfVertices = function () {
            if (this._attributes.length > 0) {
                var e = this._attributes[0], t = e.strideInBytes || e.componentsPerAttribute * e.componentDatatype.sizeInBytes;
                return e.vertexBuffer.getSizeInBytes() / t
            }
            return 0
        }, a.prototype.isDestroyed = function () {
            return!1
        }, a.prototype.destroy = function () {
            for (var e = this._attributes, n = 0; n < e.length; ++n) {
                var i = e[n].vertexBuffer;
                i && !i.isDestroyed() && i.getVertexArrayDestroyable() && i.destroy()
            }
            var r = this._indexBuffer;
            return r && !r.isDestroyed() && r.getVertexArrayDestroyable() && r.destroy(), "undefined" != typeof this._vao && this._vaoExtension.deleteVertexArrayOES(this._vao), t(this)
        }, a
    }), n("Renderer/Context", ["../Core/defaultValue", "../Core/DeveloperError", "../Core/destroyObject", "../Core/Color", "../Core/ComponentDatatype", "../Core/IndexDatatype", "../Core/RuntimeError", "../Core/PrimitiveType", "../Core/Geometry", "../Core/createGuid", "../Core/Matrix4", "../Core/Math", "./Buffer", "./BufferUsage", "./CubeMap", "./Framebuffer", "./PixelDatatype", "./PixelFormat", "./PickFramebuffer", "./Renderbuffer", "./RenderbufferFormat", "./RenderState", "./ShaderCache", "./ShaderProgram", "./Texture", "./TextureAtlas", "./TextureMagnificationFilter", "./TextureMinificationFilter", "./TextureWrap", "./UniformState", "./VertexArray", "./VertexLayout", "./ClearCommand", "./PassState"], function (e, t, n, i, r, o, a, s, u, l, c, d, f, h, p, m, y, v, g, _, w, C, x, S, b, T, E, A, M, D, I, P, O, R) {
        "use strict";
        function z(e, t) {
            var n = "OpenGL Error:  ";
            switch (t) {
                case e.INVALID_ENUM:
                    n += "Invalid enumeration";
                    break;
                case e.INVALID_VALUE:
                    n += "Invalid value";
                    break;
                case e.INVALID_OPERATION:
                    n += "Invalid operation";
                    break;
                case e.OUT_OF_MEMORY:
                    n += "Out of memory";
                    break;
                case e.CONTEXT_LOST_WEBGL:
                    n += "Context lost";
                    break;
                default:
                    n += "Unknown"
            }
            return n
        }

        function L(e, t, n, i) {
            for (var r = z(e, i) + ": " + t.name + "(", o = 0; o < n.length; ++o)0 !== o && (r += ", "), r += n[o];
            return r += ");"
        }

        function N(e, t, n) {
            var i = e.getError();
            if (i !== e.NO_ERROR)throw new a(L(e, t, n, i))
        }

        function F(e, t) {
            function n(n) {
                return function () {
                    var i = n.apply(e, arguments);
                    return t(e, n, arguments), i
                }
            }

            if (!t)return e;
            var i = {};
            for (var r in e) {
                var o = e[r];
                i[r] = "function" == typeof o ? n(o) : o
            }
            return i
        }

        function V(e, n, i, r) {
            var o;
            if ("number" == typeof i)o = i; else {
                if ("object" != typeof i || "undefined" == typeof i.byteLength)throw new t("typedArrayOrSizeInBytes must be either a typed array or a number.");
                o = i.byteLength
            }
            if (0 >= o)throw new t("typedArrayOrSizeInBytes must be greater than zero.");
            if (!h.validate(r))throw new t("usage is invalid.");
            var a = e.createBuffer();
            return e.bindBuffer(n, a), e.bufferData(n, i, r), e.bindBuffer(n, null), new f(e, n, o, r, a)
        }

        function B(e, t, n) {
            var i = e._currentRenderState;
            i !== t && (e._currentRenderState = t, C.partialApply(e._gl, i, t, n))
        }

        function k(e) {
            return e.values.length / e.componentsPerAttribute
        }

        function U(e) {
            return e.componentDatatype.sizeInBytes * e.componentsPerAttribute
        }

        function q(e) {
            var t, n, i, o = [];
            for (n in e)e.hasOwnProperty(n) && "undefined" != typeof e[n] && "undefined" != typeof e[n].values && (o.push(n), e[n].componentDatatype === r.DOUBLE && (e[n].componentDatatype = r.FLOAT, e[n].values = r.FLOAT.createTypedArray(e[n].values)));
            var s, u = o.length;
            if (u > 0)for (s = k(e[o[0]]), t = 1; u > t; ++t) {
                var l = k(e[o[t]]);
                if (l !== s)throw new a("Each attribute list must have the same number of vertices.  Attribute " + o[t] + " has a different number of vertices " + "(" + l.toString() + ")" + " than attribute " + o[0] + " (" + s.toString() + ").")
            }
            o.sort(function (t, n) {
                return e[n].componentDatatype.sizeInBytes - e[t].componentDatatype.sizeInBytes
            });
            var c = 0, d = {};
            for (t = 0; u > t; ++t)n = o[t], i = e[n], d[n] = c, c += U(i);
            if (c > 0) {
                var f = e[o[0]].componentDatatype.sizeInBytes, h = c % f;
                0 !== h && (c += f - h);
                var p = s * c, m = new ArrayBuffer(p), y = {};
                for (t = 0; u > t; ++t) {
                    n = o[t];
                    var v = e[n].componentDatatype.sizeInBytes;
                    y[n] = {pointer: e[n].componentDatatype.createTypedArray(m), index: d[n] / v, strideInComponentType: c / v}
                }
                for (t = 0; s > t; ++t)for (var g = 0; u > g; ++g) {
                    n = o[g], i = e[n];
                    for (var _ = i.values, w = y[n], C = w.pointer, x = i.componentsPerAttribute, S = 0; x > S; ++S)C[w.index + S] = _[t * x + S];
                    w.index += w.strideInComponentType
                }
                return{buffer: m, offsetsInBytes: d, vertexSizeInBytes: c}
            }
            return void 0
        }

        function W(e, t, n) {
            this._pickObjects = e, this.key = t, this.color = n
        }

        var H = function (e, n) {
            if (!window.WebGLRenderingContext)throw new a("The browser does not support WebGL.  Visit http://get.webgl.org.");
            if ("undefined" == typeof e)throw new t("canvas is required.");
            if (this._canvas = e, "undefined" == typeof n && (n = {}), "undefined" == typeof n.alpha && (n.alpha = !1), this._originalGLContext = e.getContext("webgl", n) || e.getContext("experimental-webgl", n), !this._originalGLContext)throw new a("The browser supports WebGL, but initialization failed.");
            this._id = l(), this._validateFB = !1, this._validateSP = !1, this._logShaderCompilation = !1, this._throwOnWebGLError = !1, this._shaderCache = new x(this);
            var r = this._gl = this._originalGLContext;
            this._version = r.getParameter(r.VERSION), this._shadingLanguageVersion = r.getParameter(r.SHADING_LANGUAGE_VERSION), this._vendor = r.getParameter(r.VENDOR), this._renderer = r.getParameter(r.RENDERER), this._redBits = r.getParameter(r.RED_BITS), this._greenBits = r.getParameter(r.GREEN_BITS), this._blueBits = r.getParameter(r.BLUE_BITS), this._alphaBits = r.getParameter(r.ALPHA_BITS), this._depthBits = r.getParameter(r.DEPTH_BITS), this._stencilBits = r.getParameter(r.STENCIL_BITS), this._maximumCombinedTextureImageUnits = r.getParameter(r.MAX_COMBINED_TEXTURE_IMAGE_UNITS), this._maximumCubeMapSize = r.getParameter(r.MAX_CUBE_MAP_TEXTURE_SIZE), this._maximumFragmentUniformVectors = r.getParameter(r.MAX_FRAGMENT_UNIFORM_VECTORS), this._maximumTextureImageUnits = r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS), this._maximumRenderbufferSize = r.getParameter(r.MAX_RENDERBUFFER_SIZE), this._maximumTextureSize = r.getParameter(r.MAX_TEXTURE_SIZE), this._maximumVaryingVectors = r.getParameter(r.MAX_VARYING_VECTORS), this._maximumVertexAttributes = r.getParameter(r.MAX_VERTEX_ATTRIBS), this._maximumVertexTextureImageUnits = r.getParameter(r.MAX_VERTEX_TEXTURE_IMAGE_UNITS), this._maximumVertexUniformVectors = r.getParameter(r.MAX_VERTEX_UNIFORM_VECTORS), this._aliasedLineWidthRange = r.getParameter(r.ALIASED_LINE_WIDTH_RANGE), this._aliasedPointSizeRange = r.getParameter(r.ALIASED_POINT_SIZE_RANGE), this._maximumViewportDimensions = r.getParameter(r.MAX_VIEWPORT_DIMS), this._antialias = r.getContextAttributes().antialias, this._standardDerivatives = r.getExtension("OES_standard_derivatives"), this._elementIndexUint = r.getExtension("OES_element_index_uint"), this._depthTexture = r.getExtension("WEBKIT_WEBGL_depth_texture") || r.getExtension("MOZ_WEBGL_depth_texture"), this._textureFloat = r.getExtension("OES_texture_float");
            var o = r.getExtension("EXT_texture_filter_anisotropic") || r.getExtension("WEBKIT_EXT_texture_filter_anisotropic") || r.getExtension("MOZ_EXT_texture_filter_anisotropic");
            this._textureFilterAnisotropic = o, this._maximumTextureFilterAnisotropy = o ? r.getParameter(o.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1, this._vertexArrayObject = r.getExtension("OES_vertex_array_object");
            var s = r.getParameter(r.COLOR_CLEAR_VALUE);
            this._clearColor = new i(s[0], s[1], s[2], s[3]), this._clearDepth = r.getParameter(r.DEPTH_CLEAR_VALUE), this._clearStencil = r.getParameter(r.STENCIL_CLEAR_VALUE);
            var u = new D, c = new R(this), d = this.createRenderState();
            this._defaultPassState = c, this._defaultRenderState = d, this._defaultTexture = void 0, this._defaultCubeMap = void 0, this._us = u, this._currentFramebuffer = void 0, this._currentSp = void 0, this._currentRenderState = d, this._pickObjects = {}, this._nextPickColor = new Uint32Array(1), this.cache = {}, C.apply(r, d, c)
        };
        H.prototype.getId = function () {
            return this._id
        }, H.prototype.getCanvas = function () {
            return this._canvas
        }, H.prototype.getShaderCache = function () {
            return this._shaderCache
        }, H.prototype.getUniformState = function () {
            return this._us
        }, H.prototype.getVersion = function () {
            return this._version
        }, H.prototype.getShadingLanguageVersion = function () {
            return this._shadingLanguageVersion
        }, H.prototype.getVendor = function () {
            return this._vendor
        }, H.prototype.getRenderer = function () {
            return this._renderer
        }, H.prototype.getRedBits = function () {
            return this._redBits
        }, H.prototype.getGreenBits = function () {
            return this._greenBits
        }, H.prototype.getBlueBits = function () {
            return this._blueBits
        }, H.prototype.getAlphaBits = function () {
            return this._alphaBits
        }, H.prototype.getDepthBits = function () {
            return this._depthBits
        }, H.prototype.getStencilBits = function () {
            return this._stencilBits
        }, H.prototype.getMaximumCombinedTextureImageUnits = function () {
            return this._maximumCombinedTextureImageUnits
        }, H.prototype.getMaximumCubeMapSize = function () {
            return this._maximumCubeMapSize
        }, H.prototype.getMaximumFragmentUniformVectors = function () {
            return this._maximumFragmentUniformVectors
        }, H.prototype.getMaximumTextureImageUnits = function () {
            return this._maximumTextureImageUnits
        }, H.prototype.getMaximumRenderbufferSize = function () {
            return this._maximumRenderbufferSize
        }, H.prototype.getMaximumTextureSize = function () {
            return this._maximumTextureSize
        }, H.prototype.getMaximumVaryingVectors = function () {
            return this._maximumVaryingVectors
        }, H.prototype.getMaximumVertexAttributes = function () {
            return this._maximumVertexAttributes
        }, H.prototype.getMaximumVertexTextureImageUnits = function () {
            return this._maximumVertexTextureImageUnits
        }, H.prototype.getMaximumVertexUniformVectors = function () {
            return this._maximumVertexUniformVectors
        }, H.prototype.getMinimumAliasedLineWidth = function () {
            return this._aliasedLineWidthRange[0]
        }, H.prototype.getMaximumAliasedLineWidth = function () {
            return this._aliasedLineWidthRange[1]
        }, H.prototype.getMinimumAliasedPointSize = function () {
            return this._aliasedPointSizeRange[0]
        }, H.prototype.getMaximumAliasedPointSize = function () {
            return this._aliasedPointSizeRange[1]
        }, H.prototype.getMaximumViewportWidth = function () {
            return this._maximumViewportDimensions[0]
        }, H.prototype.getMaximumViewportHeight = function () {
            return this._maximumViewportDimensions[1]
        }, H.prototype.getAntialias = function () {
            return this._antialias
        }, H.prototype.getStandardDerivatives = function () {
            return!!this._standardDerivatives
        }, H.prototype.getElementIndexUint = function () {
            return!!this._elementIndexUint
        }, H.prototype.getDepthTexture = function () {
            return!!this._depthTexture
        }, H.prototype.getFloatingPointTexture = function () {
            return!!this._textureFloat
        }, H.prototype.getTextureFilterAnisotropic = function () {
            return!!this._textureFilterAnisotropic
        }, H.prototype.getMaximumTextureFilterAnisotropy = function () {
            return this._maximumTextureFilterAnisotropy
        }, H.prototype.getVertexArrayObject = function () {
            return!!this._vertexArrayObject
        }, H.prototype.getValidateFramebuffer = function () {
            return this._validateFB
        }, H.prototype.setValidateFramebuffer = function (e) {
            this._validateFB = e
        }, H.prototype.getValidateShaderProgram = function () {
            return this._validateSP
        }, H.prototype.setValidateShaderProgram = function (e) {
            this._validateSP = e
        }, H.prototype.getThrowOnWebGLError = function () {
            return this._throwOnWebGLError
        }, H.prototype.setThrowOnWebGLError = function (e) {
            this._throwOnWebGLError = e, this._gl = F(this._originalGLContext, e ? N : null)
        }, H.prototype.getLogShaderCompilation = function () {
            return this._logShaderCompilation
        }, H.prototype.setLogShaderCompilation = function (e) {
            this._logShaderCompilation = e
        }, H.prototype.getDefaultTexture = function () {
            return void 0 === this._defaultTexture && (this._defaultTexture = this.createTexture2D({source: {width: 1, height: 1, arrayBufferView: new Uint8Array([255, 255, 255, 255])}})), this._defaultTexture
        }, H.prototype.getDefaultCubeMap = function () {
            if (void 0 === this._defaultCubeMap) {
                var e = {width: 1, height: 1, arrayBufferView: new Uint8Array([255, 255, 255, 255])};
                this._defaultCubeMap = this.createCubeMap({source: {positiveX: e, negativeX: e, positiveY: e, negativeY: e, positiveZ: e, negativeZ: e}})
            }
            return this._defaultCubeMap
        }, H.prototype.createShaderProgram = function (e, t, n) {
            return new S(this._gl, this._logShaderCompilation, e, t, n)
        }, H.prototype.createVertexBuffer = function (e, t) {
            return V(this._gl, this._gl.ARRAY_BUFFER, e, t)
        }, H.prototype.createIndexBuffer = function (e, n, i) {
            if (!o.validate(i))throw new t("Invalid indexDatatype.");
            if (i === o.UNSIGNED_INT && !this.getElementIndexUint())throw new a("IndexDatatype.UNSIGNED_INT requires OES_element_index_uint, which is not supported on this system.");
            var r = i.sizeInBytes, s = this._gl, u = V(s, s.ELEMENT_ARRAY_BUFFER, e, n), l = u.getSizeInBytes() / r;
            return u.getIndexDatatype = function () {
                return i
            }, u.getBytesPerIndex = function () {
                return r
            }, u.getNumberOfIndices = function () {
                return l
            }, u
        }, H.prototype.createVertexArray = function (e, t) {
            return new I(this._gl, this._vertexArrayObject, e, t)
        }, H.prototype.createTexture2D = function (n) {
            if (!n)throw new t("description is required.");
            var i = n.source, r = "undefined" != typeof i ? i.width : n.width, o = "undefined" != typeof i ? i.height : n.height;
            if ("undefined" == typeof r || "undefined" == typeof o)throw new t("description requires a source field to create an initialized texture or width and height fields to create a blank texture.");
            if (0 >= r)throw new t("Width must be greater than zero.");
            if (r > this._maximumTextureSize)throw new t("Width must be less than or equal to the maximum texture size (" + this._maximumTextureSize + ").  Check getMaximumTextureSize().");
            if (0 >= o)throw new t("Height must be greater than zero.");
            if (o > this._maximumTextureSize)throw new t("Height must be less than or equal to the maximum texture size (" + this._maximumTextureSize + ").  Check getMaximumTextureSize().");
            var s = e(n.pixelFormat, v.RGBA);
            if (!v.validate(s))throw new t("Invalid description.pixelFormat.");
            var u = e(n.pixelDatatype, y.UNSIGNED_BYTE);
            if (!y.validate(u))throw new t("Invalid description.pixelDatatype.");
            if (u === y.FLOAT && !this.getFloatingPointTexture())throw new a("When description.pixelDatatype is FLOAT, this WebGL implementation must support the OES_texture_float extension.");
            if (s === v.DEPTH_COMPONENT && u !== y.UNSIGNED_SHORT && u !== y.UNSIGNED_INT)throw new t("When description.pixelFormat is DEPTH_COMPONENT, description.pixelDatatype must be UNSIGNED_SHORT or UNSIGNED_INT.");
            if (s === v.DEPTH_STENCIL && u !== y.UNSIGNED_INT_24_8_WEBGL)throw new t("When description.pixelFormat is DEPTH_STENCIL, description.pixelDatatype must be UNSIGNED_INT_24_8_WEBGL.");
            if (v.isDepthFormat(s)) {
                if (i)throw new t("When description.pixelFormat is DEPTH_COMPONENT or DEPTH_STENCIL, source cannot be provided.");
                if (!this.getDepthTexture())throw new a("When description.pixelFormat is DEPTH_COMPONENT or DEPTH_STENCIL, this WebGL implementation must support WEBGL_depth_texture.  Check getDepthTexture().")
            }
            var l = n.preMultiplyAlpha || s === v.RGB || s === v.LUMINANCE, c = e(n.flipY, !0), d = this._gl, f = d.TEXTURE_2D, h = d.createTexture();
            return d.activeTexture(d.TEXTURE0), d.bindTexture(f, h), i ? (d.pixelStorei(d.UNPACK_PREMULTIPLY_ALPHA_WEBGL, l), d.pixelStorei(d.UNPACK_FLIP_Y_WEBGL, c), i.arrayBufferView ? d.texImage2D(f, 0, s, r, o, 0, s, u, i.arrayBufferView) : d.texImage2D(f, 0, s, s, u, i)) : d.texImage2D(f, 0, s, r, o, 0, s, u, null), d.bindTexture(f, null), new b(d, this._textureFilterAnisotropic, f, h, s, u, r, o, l, c)
        }, H.prototype.createTexture2DFromFramebuffer = function (n, i, r, o, a) {
            if (n = e(n, v.RGB), i = e(i, 0), r = e(r, 0), o = e(o, this._canvas.clientWidth), a = e(a, this._canvas.clientHeight), !v.validate(n))throw new t("Invalid pixelFormat.");
            if (v.isDepthFormat(n))throw new t("pixelFormat cannot be DEPTH_COMPONENT or DEPTH_STENCIL.");
            if (0 > i)throw new t("framebufferXOffset must be greater than or equal to zero.");
            if (0 > r)throw new t("framebufferYOffset must be greater than or equal to zero.");
            if (i + o > this._canvas.clientWidth)throw new t("framebufferXOffset + width must be less than or equal to getCanvas().clientWidth");
            if (r + a > this._canvas.clientHeight)throw new t("framebufferYOffset + height must be less than or equal to getCanvas().clientHeight.");
            var s = this._gl, u = s.TEXTURE_2D, l = s.createTexture();
            return s.activeTexture(s.TEXTURE0), s.bindTexture(u, l), s.copyTexImage2D(u, 0, n, i, r, o, a, 0), s.bindTexture(u, null), new b(s, this._textureFilterAnisotropic, u, l, n, void 0, o, a)
        }, H.prototype.createTextureAtlas = function (e) {
            return e = e || {}, e.context = this, new T(e)
        }, H.prototype.createCubeMap = function (n) {
            function i(e, t) {
                t.arrayBufferView ? g.texImage2D(e, 0, d, c, c, 0, d, f, t.arrayBufferView) : g.texImage2D(e, 0, d, d, f, t)
            }

            if (!n)throw new t("description is required.");
            var r, o, s = n.source;
            if (s) {
                var u = [s.positiveX, s.negativeX, s.positiveY, s.negativeY, s.positiveZ, s.negativeZ];
                if (!(u[0] && u[1] && u[2] && u[3] && u[4] && u[5]))throw new t("description.source requires positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ faces.");
                r = u[0].width, o = u[0].height;
                for (var l = 1; 6 > l; ++l)if (Number(u[l].width) !== r || Number(u[l].height) !== o)throw new t("Each face in description.source must have the same width and height.")
            } else r = n.width, o = n.height;
            if ("undefined" == typeof r || "undefined" == typeof o)throw new t("description requires a source field to create an initialized cube map or width and height fields to create a blank cube map.");
            if (r !== o)throw new t("Width must equal height.");
            var c = r;
            if (0 >= c)throw new t("Width and height must be greater than zero.");
            if (c > this._maximumCubeMapSize)throw new t("Width and height must be less than or equal to the maximum cube map size (" + this._maximumCubeMapSize + ").  Check getMaximumCubeMapSize().");
            var d = e(n.pixelFormat, v.RGBA);
            if (!v.validate(d))throw new t("Invalid description.pixelFormat.");
            if (v.isDepthFormat(d))throw new t("description.pixelFormat cannot be DEPTH_COMPONENT or DEPTH_STENCIL.");
            var f = e(n.pixelDatatype, y.UNSIGNED_BYTE);
            if (!y.validate(f))throw new t("Invalid description.pixelDatatype.");
            if (f === y.FLOAT && !this.getFloatingPointTexture())throw new a("When description.pixelDatatype is FLOAT, this WebGL implementation must support the OES_texture_float extension.");
            var h = n.preMultiplyAlpha || d === v.RGB || d === v.LUMINANCE, m = e(n.flipY, !0), g = this._gl, _ = g.TEXTURE_CUBE_MAP, w = g.createTexture();
            return g.activeTexture(g.TEXTURE0), g.bindTexture(_, w), s ? (g.pixelStorei(g.UNPACK_PREMULTIPLY_ALPHA_WEBGL, h), g.pixelStorei(g.UNPACK_FLIP_Y_WEBGL, m), i(g.TEXTURE_CUBE_MAP_POSITIVE_X, s.positiveX), i(g.TEXTURE_CUBE_MAP_NEGATIVE_X, s.negativeX), i(g.TEXTURE_CUBE_MAP_POSITIVE_Y, s.positiveY), i(g.TEXTURE_CUBE_MAP_NEGATIVE_Y, s.negativeY), i(g.TEXTURE_CUBE_MAP_POSITIVE_Z, s.positiveZ), i(g.TEXTURE_CUBE_MAP_NEGATIVE_Z, s.negativeZ)) : (g.texImage2D(g.TEXTURE_CUBE_MAP_POSITIVE_X, 0, d, c, c, 0, d, f, null), g.texImage2D(g.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, d, c, c, 0, d, f, null), g.texImage2D(g.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, d, c, c, 0, d, f, null), g.texImage2D(g.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, d, c, c, 0, d, f, null), g.texImage2D(g.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, d, c, c, 0, d, f, null), g.texImage2D(g.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, d, c, c, 0, d, f, null)), g.bindTexture(_, null), new p(g, this._textureFilterAnisotropic, _, w, d, f, c, h, m)
        }, H.prototype.createFramebuffer = function (e) {
            return new m(this._gl, e)
        }, H.prototype.createRenderbuffer = function (n) {
            n = e(n, e.EMPTY_OBJECT);
            var i = e(n.format, w.RGBA4), r = "undefined" != typeof n.width ? n.width : this._canvas.clientWidth, o = "undefined" != typeof n.height ? n.height : this._canvas.clientHeight, a = this._gl;
            if (!w.validate(i))throw new t("Invalid format.");
            if (0 >= r)throw new t("Width must be greater than zero.");
            if (r > this.getMaximumRenderbufferSize())throw new t("Width must be less than or equal to the maximum renderbuffer size (" + this.getMaximumRenderbufferSize() + ").  Check getMaximumRenderbufferSize().");
            if (0 >= o)throw new t("Height must be greater than zero.");
            if (o > this.getMaximumRenderbufferSize())throw new t("Height must be less than or equal to the maximum renderbuffer size (" + this.getMaximumRenderbufferSize() + ").  Check getMaximumRenderbufferSize().");
            return new _(a, i, r, o)
        };
        var G = 0, j = {};
        H.prototype.createRenderState = function (e) {
            var t = JSON.stringify(e), n = j[t];
            if ("undefined" != typeof n)return n;
            var i = new C(this, e), r = JSON.stringify(i);
            return n = j[r], "undefined" == typeof n && (i.id = G++, n = i, j[r] = n), j[t] = n, n
        }, H.prototype.createSampler = function (e) {
            var n = {wrapS: e.wrapS || M.CLAMP, wrapT: e.wrapT || M.CLAMP, minificationFilter: e.minificationFilter || A.LINEAR, magnificationFilter: e.magnificationFilter || E.LINEAR, maximumAnisotropy: "undefined" != typeof e.maximumAnisotropy ? e.maximumAnisotropy : 1};
            if (!M.validate(n.wrapS))throw new t("Invalid sampler.wrapS.");
            if (!M.validate(n.wrapT))throw new t("Invalid sampler.wrapT.");
            if (!A.validate(n.minificationFilter))throw new t("Invalid sampler.minificationFilter.");
            if (!E.validate(n.magnificationFilter))throw new t("Invalid sampler.magnificationFilter.");
            if (n.maximumAnisotropy < 1)throw new t("sampler.maximumAnisotropy must be greater than or equal to one.");
            return n
        }, H.prototype._validateFramebuffer = function () {
            if (this._validateFB) {
                var e = this._gl, n = e.checkFramebufferStatus(e.FRAMEBUFFER);
                if (n !== e.FRAMEBUFFER_COMPLETE) {
                    var i;
                    switch (n) {
                        case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                            i = "Framebuffer is not complete.  Incomplete attachment: at least one attachment point with a renderbuffer or texture attached has its attached object no longer in existence or has an attached image with a width or height of zero, or the color attachment point has a non-color-renderable image attached, or the depth attachment point has a non-depth-renderable image attached, or the stencil attachment point has a non-stencil-renderable image attached.  Color-renderable formats include GL_RGBA4, GL_RGB5_A1, and GL_RGB565. GL_DEPTH_COMPONENT16 is the only depth-renderable format. GL_STENCIL_INDEX8 is the only stencil-renderable format.";
                            break;
                        case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                            i = "Framebuffer is not complete.  Incomplete dimensions: not all attached images have the same width and height.";
                            break;
                        case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                            i = "Framebuffer is not complete.  Missing attachment: no images are attached to the framebuffer.";
                            break;
                        case e.FRAMEBUFFER_UNSUPPORTED:
                            i = "Framebuffer is not complete.  Unsupported: the combination of internal formats of the attached images violates an implementation-dependent set of restrictions."
                    }
                    throw new t(i)
                }
            }
        };
        var Y = new O;
        return H.prototype.clear = function (t, n) {
            t = e(t, Y), n = e(n, this._defaultPassState);
            var r = this._gl, o = 0, a = t.color, s = t.depth, u = t.stencil;
            "undefined" != typeof a && (i.equals(this._clearColor, a) || (i.clone(a, this._clearColor), r.clearColor(a.red, a.green, a.blue, a.alpha)), o |= r.COLOR_BUFFER_BIT), "undefined" != typeof s && (s !== this._clearDepth && (this._clearDepth = s, r.clearDepth(s)), o |= r.DEPTH_BUFFER_BIT), "undefined" != typeof u && (u !== this._clearStencil && (this._clearStencil = u, r.clearStencil(u)), o |= r.STENCIL_BUFFER_BIT);
            var l = e(t.renderState, this._defaultRenderState);
            B(this, l, n);
            var c = e(t.framebuffer, n.framebuffer);
            "undefined" != typeof c && (c._bind(), this._validateFramebuffer(c)), r.clear(o), "undefined" != typeof c && c._unBind()
        }, H.prototype.draw = function (t, n) {
            n = e(n, this._defaultPassState), this.beginDraw(t, n), this.continueDraw(t), this.endDraw()
        }, H.prototype.beginDraw = function (n, i) {
            if ("undefined" == typeof n)throw new t("command is required.");
            if ("undefined" == typeof n.shaderProgram)throw new t("command.shaderProgram is required.");
            var r = e(n.framebuffer, i.framebuffer), o = n.shaderProgram, a = "undefined" != typeof n.renderState ? n.renderState : this._defaultRenderState;
            if ("undefined" != typeof r && a.depthTest && a.depthTest.enabled && !r.hasDepthAttachment())throw new t("The depth test can not be enabled (command.renderState.depthTest.enabled) because the framebuffer (command.framebuffer) does not have a depth or depth-stencil renderbuffer.");
            B(this, a, i), "undefined" != typeof r && (r._bind(), this._validateFramebuffer(r)), o._bind(), this._currentFramebuffer = r, this._currentSp = o
        }, H.prototype.continueDraw = function (n) {
            var i = this._currentSp;
            if ("undefined" == typeof i)throw new t("beginDraw must be called before continueDraw.");
            if ("undefined" == typeof n)throw new t("command is required.");
            var r = n.primitiveType;
            if (!s.validate(r))throw new t("command.primitiveType is required and must be valid.");
            if ("undefined" == typeof n.vertexArray)throw new t("command.vertexArray is required.");
            var o = n.vertexArray, a = o.getIndexBuffer(), u = n.offset, l = n.count, d = "undefined" != typeof a;
            if (d ? (u = (u || 0) * a.getBytesPerIndex(), l = l || a.getNumberOfIndices()) : (u = u || 0, l = l || o._getNumberOfVertices()), 0 > u)throw new t("command.offset must be omitted or greater than or equal to zero.");
            l > 0 && (this._us.setModel(e(n.modelMatrix, c.IDENTITY)), i._setUniforms(n.uniformMap, this._us, this._validateSP), o._bind(), d ? this._gl.drawElements(r, l, a.getIndexDatatype().value, u) : this._gl.drawArrays(r, u, l), o._unBind())
        }, H.prototype.endDraw = function () {
            "undefined" != typeof this._currentFramebuffer && (this._currentFramebuffer._unBind(), this._currentFramebuffer = void 0), this._currentSp._unBind(), this._currentSp = void 0
        }, H.prototype.readPixels = function (e) {
            e = e || {};
            var n = Math.max(e.x || 0, 0), i = Math.max(e.y || 0, 0), r = e.width || this._canvas.clientWidth, o = e.height || this._canvas.clientHeight, a = e.framebuffer || null;
            if (0 >= r)throw new t("readState.width must be greater than zero.");
            if (0 >= o)throw new t("readState.height must be greater than zero.");
            var s = new Uint8Array(4 * r * o);
            a && (a._bind(), this._validateFramebuffer(a));
            var u = this._gl;
            return u.readPixels(n, i, r, o, u.RGBA, u.UNSIGNED_BYTE, s), a && a._unBind(), s
        }, H.prototype.createVertexArrayFromGeometry = function (t) {
            var n, i, a, s = e(t, e.EMPTY_OBJECT), l = e(s.geometry, e.EMPTY_OBJECT), c = e(s.bufferUsage, h.DYNAMIC_DRAW), f = e(s.attributeIndices, e.EMPTY_OBJECT), p = "undefined" != typeof s.vertexLayout && s.vertexLayout === P.INTERLEAVED, m = s.vertexArrayAttributes, y = "undefined" != typeof m ? m : [], v = l.attributes;
            if (p) {
                var g = q(v);
                if ("undefined" != typeof g) {
                    a = this.createVertexBuffer(g.buffer, c);
                    var _ = g.offsetsInBytes, w = g.vertexSizeInBytes;
                    for (n in v)v.hasOwnProperty(n) && "undefined" != typeof v[n] && (i = v[n], "undefined" != typeof i.values ? y.push({index: f[n], vertexBuffer: a, componentDatatype: i.componentDatatype, componentsPerAttribute: i.componentsPerAttribute, normalize: i.normalize, offsetInBytes: _[n], strideInBytes: w}) : y.push({index: f[n], value: i.value, componentDatatype: i.componentDatatype, normalize: i.normalize}))
                }
            } else for (n in v)if (v.hasOwnProperty(n) && "undefined" != typeof v[n]) {
                i = v[n];
                var C = i.componentDatatype;
                C === r.DOUBLE && (C = r.FLOAT), a = void 0, "undefined" != typeof i.values && (a = this.createVertexBuffer(C.createTypedArray(i.values), c)), y.push({index: f[n], vertexBuffer: a, value: i.value, componentDatatype: C, componentsPerAttribute: i.componentsPerAttribute, normalize: i.normalize})
            }
            var x, S = l.indices;
            return"undefined" != typeof S && (x = u.computeNumberOfVertices(l) > d.SIXTY_FOUR_KILOBYTES && this.getElementIndexUint() ? this.createIndexBuffer(new Uint32Array(S), c, o.UNSIGNED_INT) : this.createIndexBuffer(new Uint16Array(S), c, o.UNSIGNED_SHORT)), this.createVertexArray(y, x)
        }, H.prototype.createPickFramebuffer = function () {
            return new g(this)
        }, H.prototype.getObjectByPickColor = function (e) {
            if ("undefined" == typeof e)throw new t("pickColor is required.");
            return this._pickObjects[e.toRgba()]
        }, W.prototype.destroy = function () {
            return delete this._pickObjects[this.key], void 0
        }, H.prototype.createPickId = function (e) {
            if ("undefined" == typeof e)throw new t("object is required.");
            ++this._nextPickColor[0];
            var n = this._nextPickColor[0];
            if (0 === n)throw new a("Out of unique Pick IDs.");
            return this._pickObjects[n] = e, new W(this._pickObjects, n, i.fromRgba(n))
        }, H.prototype.isDestroyed = function () {
            return!1
        }, H.prototype.destroy = function () {
            var e = this.cache;
            for (var t in e)if (e.hasOwnProperty(t)) {
                var i = e[t];
                "undefined" != typeof i.destroy && i.destroy()
            }
            return this._shaderCache = this._shaderCache.destroy(), this._defaultTexture = this._defaultTexture && this._defaultTexture.destroy(), this._defaultCubeMap = this._defaultCubeMap && this._defaultCubeMap.destroy(), n(this)
        }, H
    }), n("Renderer/loadCubeMap", ["../Core/DeveloperError", "../Core/loadImage", "../ThirdParty/when"], function (e, t, n) {
        "use strict";
        var i = function (i, r, o) {
            if ("undefined" == typeof i)throw new e("context is required.");
            if ("undefined" == typeof r || "undefined" == typeof r.positiveX || "undefined" == typeof r.negativeX || "undefined" == typeof r.positiveY || "undefined" == typeof r.negativeY || "undefined" == typeof r.positiveZ || "undefined" == typeof r.negativeZ)throw new e("urls is required and must have positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ properties.");
            var a = [t(r.positiveX, o), t(r.negativeX, o), t(r.positiveY, o), t(r.negativeY, o), t(r.positiveZ, o), t(r.negativeZ, o)];
            return n.all(a, function (e) {
                return i.createCubeMap({source: {positiveX: e[0], negativeX: e[1], positiveY: e[2], negativeY: e[3], positiveZ: e[4], negativeZ: e[5]}})
            })
        };
        return i
    }), n("ThirdParty/Tween", [], function () {
        var e = e || function () {
            var e = [];
            return{REVISION: "7", getAll: function () {
                return e
            }, removeAll: function () {
                e = []
            }, add: function (t) {
                e.push(t)
            }, remove: function (t) {
                var n = e.indexOf(t);
                -1 !== n && e.splice(n, 1)
            }, update: function (t) {
                if (0 === e.length)return!1;
                var n = 0, i = e.length;
                for (t = void 0 !== t ? t : Date.now(); i > n;)e[n].update(t) ? n++ : (e.splice(n, 1), i--);
                return!0
            }}
        }();
        return e.Tween = function (t) {
            var n = t, i = {}, r = {}, o = 1e3, a = 0, s = null, u = e.Easing.Linear.None, l = e.Interpolation.Linear, c = [], d = null, f = !1, h = null, p = null;
            this.to = function (e, t) {
                return void 0 !== t && (o = t), r = e, this
            }, this.start = function (t) {
                e.add(this), f = !1, s = void 0 !== t ? t : Date.now(), s += a;
                for (var o in r)if (null !== n[o]) {
                    if (r[o]instanceof Array) {
                        if (0 === r[o].length)continue;
                        r[o] = [n[o]].concat(r[o])
                    }
                    i[o] = n[o]
                }
                return this
            }, this.stop = function () {
                return e.remove(this), this
            }, this.delay = function (e) {
                return a = e, this
            }, this.easing = function (e) {
                return u = e, this
            }, this.interpolation = function (e) {
                return l = e, this
            }, this.chain = function () {
                return c = arguments, this
            }, this.onStart = function (e) {
                return d = e, this
            }, this.onUpdate = function (e) {
                return h = e, this
            }, this.onComplete = function (e) {
                return p = e, this
            }, this.update = function (e) {
                if (s > e)return!0;
                f === !1 && (null !== d && d.call(n), f = !0);
                var t = (e - s) / o;
                t = t > 1 ? 1 : t;
                var a = u(t);
                for (var m in i) {
                    var y = i[m], v = r[m];
                    n[m] = v instanceof Array ? l(v, a) : y + (v - y) * a
                }
                if (null !== h && h.call(n, a), 1 == t) {
                    null !== p && p.call(n);
                    for (var g = 0, _ = c.length; _ > g; g++)c[g].start(e);
                    return!1
                }
                return!0
            }
        }, e.Easing = {Linear: {None: function (e) {
            return e
        }}, Quadratic: {In: function (e) {
            return e * e
        }, Out: function (e) {
            return e * (2 - e)
        }, InOut: function (e) {
            return(e *= 2) < 1 ? .5 * e * e : -.5 * (--e * (e - 2) - 1)
        }}, Cubic: {In: function (e) {
            return e * e * e
        }, Out: function (e) {
            return--e * e * e + 1
        }, InOut: function (e) {
            return(e *= 2) < 1 ? .5 * e * e * e : .5 * ((e -= 2) * e * e + 2)
        }}, Quartic: {In: function (e) {
            return e * e * e * e
        }, Out: function (e) {
            return 1 - --e * e * e * e
        }, InOut: function (e) {
            return(e *= 2) < 1 ? .5 * e * e * e * e : -.5 * ((e -= 2) * e * e * e - 2)
        }}, Quintic: {In: function (e) {
            return e * e * e * e * e
        }, Out: function (e) {
            return--e * e * e * e * e + 1
        }, InOut: function (e) {
            return(e *= 2) < 1 ? .5 * e * e * e * e * e : .5 * ((e -= 2) * e * e * e * e + 2)
        }}, Sinusoidal: {In: function (e) {
            return 1 - Math.cos(e * Math.PI / 2)
        }, Out: function (e) {
            return Math.sin(e * Math.PI / 2)
        }, InOut: function (e) {
            return.5 * (1 - Math.cos(Math.PI * e))
        }}, Exponential: {In: function (e) {
            return 0 === e ? 0 : Math.pow(1024, e - 1)
        }, Out: function (e) {
            return 1 === e ? 1 : 1 - Math.pow(2, -10 * e)
        }, InOut: function (e) {
            return 0 === e ? 0 : 1 === e ? 1 : (e *= 2) < 1 ? .5 * Math.pow(1024, e - 1) : .5 * (-Math.pow(2, -10 * (e - 1)) + 2)
        }}, Circular: {In: function (e) {
            return 1 - Math.sqrt(1 - e * e)
        }, Out: function (e) {
            return Math.sqrt(1 - --e * e)
        }, InOut: function (e) {
            return(e *= 2) < 1 ? -.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1)
        }}, Elastic: {In: function (e) {
            var t, n = .1, i = .4;
            return 0 === e ? 0 : 1 === e ? 1 : (!n || 1 > n ? (n = 1, t = i / 4) : t = i * Math.asin(1 / n) / (2 * Math.PI), -(n * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * 2 * Math.PI / i)))
        }, Out: function (e) {
            var t, n = .1, i = .4;
            return 0 === e ? 0 : 1 === e ? 1 : (!n || 1 > n ? (n = 1, t = i / 4) : t = i * Math.asin(1 / n) / (2 * Math.PI), n * Math.pow(2, -10 * e) * Math.sin((e - t) * 2 * Math.PI / i) + 1)
        }, InOut: function (e) {
            var t, n = .1, i = .4;
            return 0 === e ? 0 : 1 === e ? 1 : (!n || 1 > n ? (n = 1, t = i / 4) : t = i * Math.asin(1 / n) / (2 * Math.PI), (e *= 2) < 1 ? -.5 * n * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * 2 * Math.PI / i) : .5 * n * Math.pow(2, -10 * (e -= 1)) * Math.sin((e - t) * 2 * Math.PI / i) + 1)
        }}, Back: {In: function (e) {
            var t = 1.70158;
            return e * e * ((t + 1) * e - t)
        }, Out: function (e) {
            var t = 1.70158;
            return--e * e * ((t + 1) * e + t) + 1
        }, InOut: function (e) {
            var t = 2.5949095;
            return(e *= 2) < 1 ? .5 * e * e * ((t + 1) * e - t) : .5 * ((e -= 2) * e * ((t + 1) * e + t) + 2)
        }}, Bounce: {In: function (t) {
            return 1 - e.Easing.Bounce.Out(1 - t)
        }, Out: function (e) {
            return 1 / 2.75 > e ? 7.5625 * e * e : 2 / 2.75 > e ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : 2.5 / 2.75 > e ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375
        }, InOut: function (t) {
            return.5 > t ? .5 * e.Easing.Bounce.In(2 * t) : .5 * e.Easing.Bounce.Out(2 * t - 1) + .5
        }}}, e.Interpolation = {Linear: function (t, n) {
            var i = t.length - 1, r = i * n, o = Math.floor(r), a = e.Interpolation.Utils.Linear;
            return 0 > n ? a(t[0], t[1], r) : n > 1 ? a(t[i], t[i - 1], i - r) : a(t[o], t[o + 1 > i ? i : o + 1], r - o)
        }, Bezier: function (t, n) {
            var i, r = 0, o = t.length - 1, a = Math.pow, s = e.Interpolation.Utils.Bernstein;
            for (i = 0; o >= i; i++)r += a(1 - n, o - i) * a(n, i) * t[i] * s(o, i);
            return r
        }, CatmullRom: function (t, n) {
            var i = t.length - 1, r = i * n, o = Math.floor(r), a = e.Interpolation.Utils.CatmullRom;
            return t[0] === t[i] ? (0 > n && (o = Math.floor(r = i * (1 + n))), a(t[(o - 1 + i) % i], t[o], t[(o + 1) % i], t[(o + 2) % i], r - o)) : 0 > n ? t[0] - (a(t[0], t[0], t[1], t[1], -r) - t[0]) : n > 1 ? t[i] - (a(t[i], t[i], t[i - 1], t[i - 1], r - i) - t[i]) : a(t[o ? o - 1 : 0], t[o], t[o + 1 > i ? i : o + 1], t[o + 2 > i ? i : o + 2], r - o)
        }, Utils: {Linear: function (e, t, n) {
            return(t - e) * n + e
        }, Bernstein: function (t, n) {
            var i = e.Interpolation.Utils.Factorial;
            return i(t) / i(n) / i(t - n)
        }, Factorial: function () {
            var e = [1];
            return function (t) {
                var n, i = 1;
                if (e[t])return e[t];
                for (n = t; n > 1; n--)i *= n;
                return e[t] = i
            }
        }(), CatmullRom: function (e, t, n, i, r) {
            var o = .5 * (n - e), a = .5 * (i - t), s = r * r, u = r * s;
            return(2 * t - 2 * n + o + a) * u + (-3 * t + 3 * n - 2 * o - a) * s + o * r + t
        }}}, e
    }), n("Scene/AnimationCollection", ["../Core/DeveloperError", "../Core/clone", "../ThirdParty/Tween", "../Core/defaultValue"], function (e, t, n, i) {
        "use strict";
        var r = function () {
        };
        return r.prototype.add = function (r) {
            if (r = i(r, i.EMPTY_OBJECT), "undefined" == typeof r.duration)throw new e("duration is required.");
            if (r.duration > 0) {
                var o = i(r.delayDuration, 0), a = i(r.easingFunction, n.Easing.Linear.None), s = t(r.startValue), u = new n.Tween(s);
                return u.to(r.stopValue, r.duration), u.delay(o), u.easing(a), "function" == typeof r.onUpdate && u.onUpdate(function () {
                    r.onUpdate(s)
                }), u.onComplete(i(r.onComplete, null)), u.start(), {_tween: u}
            }
            "function" == typeof r.onComplete && r.onComplete()
        }, r.prototype.addAlpha = function (t, r, o, a) {
            if ("undefined" == typeof t)throw new e("material is required.");
            var s = [];
            for (var u in t.uniforms)t.uniforms.hasOwnProperty(u) && "undefined" != typeof t.uniforms[u] && "undefined" != typeof t.uniforms[u].alpha && s.push(u);
            if (0 === s.length)throw new e("material has no properties with alpha components.");
            r = i(r, 0), o = i(o, 1), a = i(a, i.EMPTY_OBJECT);
            var l = i(a.duration, 3e3), c = i(a.delayDuration, 0), d = i(a.easingFunction, n.Easing.Linear.None), f = {alpha: r}, h = new n.Tween(f);
            return h.to({alpha: o}, l), h.delay(c), h.easing(d), h.onUpdate(function () {
                for (var e = s.length, n = 0; e > n; ++n)t.uniforms[s[n]].alpha = f.alpha
            }), h.onComplete(i(a.onComplete, null)), h.start(), {_tween: h}
        }, r.prototype.addProperty = function (t, r, o, a, s) {
            if ("undefined" == typeof t)throw new e("object is required.");
            if ("undefined" == typeof r)throw new e("property is required.");
            if ("undefined" == typeof t[r])throw new e("object must have the specified property.");
            s = i(s, i.EMPTY_OBJECT);
            var u = i(s.duration, 3e3), l = i(s.delayDuration, 0), c = i(s.easingFunction, n.Easing.Linear.None), d = {value: o}, f = new n.Tween(d);
            return f.to({value: a}, u), f.delay(l), f.easing(c), f.onUpdate(function () {
                t[r] = d.value
            }), f.onComplete(i(s.onComplete, null)), f.start(), {_tween: f}
        }, r.prototype.addOffsetIncrement = function (t, r) {
            if ("undefined" == typeof t)throw new e("material is required.");
            if ("undefined" == typeof t.uniforms.offset)throw new e("material must have an offset property.");
            r = i(r, i.EMPTY_OBJECT);
            var o = i(r.duration, 3e3), a = i(r.delayDuration, 0), s = i(r.easingFunction, n.Easing.Linear.None), u = {offset: t.uniforms.offset}, l = new n.Tween(u);
            return l.to({offset: t.uniforms.offset + 1}, o), l.delay(a), l.easing(s), l.onUpdate(function () {
                t.uniforms.offset = u.offset
            }), l.onComplete(function () {
                l.to({offset: t.uniforms.offset + 1}, o), l.start()
            }), l.start(), {_tween: l}
        }, r.prototype.remove = function (e) {
            if ("undefined" != typeof e) {
                var t = n.getAll().length;
                return n.remove(e._tween), n.getAll().length === t - 1
            }
            return!1
        }, r.prototype.removeAll = function () {
            n.removeAll()
        }, r.prototype.contains = function (e) {
            return"undefined" != typeof e ? -1 !== n.getAll().indexOf(e._tween) : !1
        }, r.prototype.update = function () {
            n.update()
        }, r
    }), n("Scene/Credit", ["../Core/DeveloperError"], function (e) {
        "use strict";
        var t = function (t, n, i) {
            var r = "undefined" != typeof i, o = "undefined" != typeof n, a = "undefined" != typeof t;
            if (!a && !o && !r)throw new e("text, imageUrl or link is required");
            a || o || (t = i), this._text = t, this._imageUrl = n, this._link = i, this._hasLink = r, this._hasImage = o
        };
        return t.prototype.hasImage = function () {
            return this._hasImage
        }, t.prototype.hasLink = function () {
            return this._hasLink
        }, t.prototype.getText = function () {
            return this._text
        }, t.prototype.getImageUrl = function () {
            return this._imageUrl
        }, t.prototype.getLink = function () {
            return this._link
        }, t.equals = function (e, t) {
            var n = "undefined" == typeof e, i = "undefined" == typeof t;
            return e === t || (n && i || !n && !i) && e._text === t._text && e._imageUrl === t._imageUrl && e._link === t._link
        }, t.prototype.equals = function (e) {
            return t.equals(this, e)
        }, t
    }), n("Scene/TerrainProvider", ["../Core/DeveloperError", "../Core/ComponentDatatype", "../Renderer/BufferUsage", "../Core/IndexDatatype"], function (e, t, n, i) {
        "use strict";
        function r(e, t, n, i, r) {
            return e[t++] = n, e[t++] = i, e[t++] = i, e[t++] = r, e[t++] = r, e[t++] = n, t
        }

        function o(e) {
            for (var t = e.length, n = new Uint16Array(2 * t), i = 0, o = 0; t > o; o += 3)i = r(n, i, e[o], e[o + 1], e[o + 2]);
            return n
        }

        var a = function () {
            throw new e("This type should not be instantiated directly.")
        };
        a.attributeIndices = {position3DAndHeight: 0, textureCoordinates: 1}, a.wireframe = !1;
        var s = [];
        return a.getRegularGridIndices = function (e, t) {
            var n = s[e];
            "undefined" == typeof n && (s[e] = n = []);
            var i = n[t];
            if ("undefined" == typeof i) {
                i = n[t] = new Uint16Array(6 * (e - 1) * (t - 1));
                for (var r = 0, o = 0, a = 0; t - 1 > a; ++a) {
                    for (var u = 0; e - 1 > u; ++u) {
                        var l = r, c = l + e, d = c + 1, f = l + 1;
                        i[o++] = l, i[o++] = c, i[o++] = f, i[o++] = f, i[o++] = c, i[o++] = d, ++r
                    }
                    ++r
                }
            }
            return i
        }, a.createTileEllipsoidGeometryFromBuffers = function (e, r, s, u) {
            var l = t.FLOAT, c = r.vertices, d = e.createVertexBuffer(c, n.STATIC_DRAW), f = 5 * l.sizeInBytes, h = 3;
            u && (f += l.sizeInBytes, ++h);
            var p = [
                {index: a.attributeIndices.position3DAndHeight, vertexBuffer: d, componentDatatype: l, componentsPerAttribute: h, offsetInBytes: 0, strideInBytes: f},
                {index: a.attributeIndices.textureCoordinates, vertexBuffer: d, componentDatatype: l, componentsPerAttribute: 2, offsetInBytes: h * l.sizeInBytes, strideInBytes: f}
            ], m = r.indices.indexBuffers || {}, y = m[e.getId()];
            if ("undefined" == typeof y || y.isDestroyed()) {
                var v = r.indices;
                a.wireframe && (v = o(r.indices)), y = e.createIndexBuffer(v, n.STATIC_DRAW, i.UNSIGNED_SHORT), y.setVertexArrayDestroyable(!1), y.referenceCount = 1, m[e.getId()] = y, r.indices.indexBuffers = m
            } else++y.referenceCount;
            s.vertexArray = e.createVertexArray(p, y)
        }, a.heightmapTerrainQuality = .25, a.getEstimatedLevelZeroGeometricErrorForAHeightmap = function (e, t, n) {
            return 2 * e.getMaximumRadius() * Math.PI * a.heightmapTerrainQuality / (t * n)
        }, a.prototype.requestTileGeometry = function () {
            throw new e("This type should not be instantiated directly.")
        }, a.prototype.getErrorEvent = function () {
            throw new e("This type should not be instantiated directly.")
        }, a.prototype.getLevelMaximumGeometricError = function () {
            throw new e("This type should not be instantiated directly.")
        }, a.prototype.getCredit = function () {
            throw new e("This type should not be instantiated directly.")
        }, a.prototype.getTilingScheme = function () {
            throw new e("This type should not be instantiated directly.")
        }, a.prototype.hasWaterMask = function () {
            throw new e("This type should not be instantiated directly.")
        }, a.prototype.isReady = function () {
            throw new e("This type should not be instantiated directly.")
        }, a
    }), n("Scene/ImageryState", ["../Core/Enumeration"], function (e) {
        "use strict";
        var t = {UNLOADED: new e(0, "UNLOADED"), TRANSITIONING: new e(1, "TRANSITIONING"), RECEIVED: new e(2, "RECEIVED"), TEXTURE_LOADED: new e(3, "TEXTURE_LOADED"), READY: new e(4, "READY"), FAILED: new e(5, "FAILED"), INVALID: new e(6, "INVALID"), PLACEHOLDER: new e(7, "PLACEHOLDER")};
        return t
    }), n("Scene/TerrainState", ["../Core/Enumeration"], function (e) {
        "use strict";
        var t = {FAILED: new e(0, "FAILED"), UNLOADED: new e(1, "UNLOADED"), RECEIVING: new e(2, "RECEIVING"), RECEIVED: new e(3, "RECEIVED"), TRANSFORMING: new e(4, "TRANSFORMING"), TRANSFORMED: new e(5, "TRANSFORMED"), READY: new e(6, "READY")};
        return t
    }), n("Scene/TileState", ["../Core/Enumeration"], function (e) {
        "use strict";
        var t = {START: new e(0, "START"), LOADING: new e(1, "LOADING"), READY: new e(2, "READY")};
        return t
    }), n("Scene/TileProviderError", ["../Core/defaultValue"], function (e) {
        "use strict";
        var t = function (t, n, i, r, o, a) {
            this.provider = t, this.message = n, this.x = i, this.y = r, this.level = o, this.timesRetried = e(a, 0), this.retry = !1
        };
        return t.handleError = function (e, n, i, r, o, a, s, u) {
            var l = e;
            return"undefined" == typeof e ? l = new t(n, r, o, a, s, 0) : (l.provider = n, l.message = r, l.x = o, l.y = a, l.level = s, l.retry = !1, ++l.timesRetried), i.getNumberOfListeners() > 0 ? i.raiseEvent(l) : (console.log('An error occurred in "' + n.constructor.name + '":'), console.log(r)), l.retry && "undefined" != typeof u && u(), l
        }, t.handleSuccess = function (e) {
            "undefined" != typeof e && (e.timesRetried = -1)
        }, t
    }), n("Scene/TileTerrain", ["../Core/BoundingSphere", "../Core/Cartesian3", "../Core/DeveloperError", "./TerrainProvider", "./TerrainState", "./TileProviderError", "../ThirdParty/when"], function (e, t, n, i, r, o, a) {
        "use strict";
        function s(e, t, n, i, s) {
            function u(t) {
                e.data = t, e.state = r.RECEIVED
            }

            function l() {
                e.state = r.FAILED;
                var a = "Failed to obtain terrain tile X: " + n + " Y: " + i + " Level: " + s + ".";
                t._requestError = o.handleError(t._requestError, t, t.getErrorEvent(), a, n, i, s, c)
            }

            function c() {
                e.data = t.requestTileGeometry(n, i, s), "undefined" != typeof e.data ? (e.state = r.RECEIVING, a(e.data, u, l)) : e.state = r.UNLOADED
            }

            c()
        }

        function u(e, t, n, i, o, s) {
            var u = n.getTilingScheme(), l = e.data, c = l.createMesh(u, i, o, s);
            "undefined" != typeof c && (e.state = r.TRANSFORMING, a(c, function (t) {
                e.mesh = t, e.state = r.TRANSFORMED
            }, function () {
                e.state = r.FAILED
            }))
        }

        function l(e, t) {
            i.createTileEllipsoidGeometryFromBuffers(t, e.mesh, e, !0), e.state = r.READY
        }

        var c = function (e) {
            this.state = r.UNLOADED, this.data = void 0, this.mesh = void 0, this.vertexArray = void 0, this.upsampleDetails = e
        };
        return c.prototype.freeResources = function () {
            if (this.state = r.UNLOADED, this.data = void 0, this.mesh = void 0, "undefined" != typeof this.vertexArray) {
                var e = this.vertexArray.getIndexBuffer();
                this.vertexArray.destroy(), this.vertexArray = void 0, e.isDestroyed() || "undefined" == typeof e.referenceCount || (--e.referenceCount, 0 === e.referenceCount && e.destroy())
            }
        }, c.prototype.publishToTile = function (n) {
            var i = this.mesh;
            t.clone(i.center, n.center), n.minimumHeight = i.minimumHeight, n.maximumHeight = i.maximumHeight, e.clone(i.boundingSphere3D, n.boundingSphere3D), t.clone(i.occludeePointInScaledSpace, n.occludeePointInScaledSpace), n.freeVertexArray(), n.vertexArray = this.vertexArray, this.vertexArray = void 0
        }, c.prototype.processLoadStateMachine = function (e, t, n, i, o) {
            this.state === r.UNLOADED && s(this, t, n, i, o), this.state === r.RECEIVED && u(this, e, t, n, i, o), this.state === r.TRANSFORMED && l(this, e, t, n, i, o)
        }, c.prototype.processUpsampleStateMachine = function (e, t, i, o, s) {
            if (this.state === r.UNLOADED) {
                var c = this.upsampleDetails;
                if ("undefined" == typeof c)throw new n("TileTerrain cannot upsample unless provided upsampleDetails.");
                var d = c.data, f = c.x, h = c.y, p = c.level;
                if (this.data = d.upsample(t.getTilingScheme(), f, h, p, i, o, s), "undefined" == typeof this.data)return;
                this.state = r.RECEIVING;
                var m = this;
                a(this.data, function (e) {
                    m.data = e, m.state = r.RECEIVED
                }, function () {
                    m.state = r.FAILED
                })
            }
            this.state === r.RECEIVED && u(this, e, t, i, o, s), this.state === r.TRANSFORMED && l(this, e, t, i, o, s)
        }, c
    }), n("Scene/Tile", ["../Core/BoundingSphere", "../Core/Cartesian3", "../Core/Cartesian4", "../Core/DeveloperError", "./ImageryState", "./TerrainState", "./TileState", "./TileTerrain", "../Renderer/PixelDatatype", "../Renderer/PixelFormat", "../Renderer/TextureMagnificationFilter", "../Renderer/TextureMinificationFilter", "../Renderer/TextureWrap"], function (e, t, n, i, r, o, a, s, u, l, c, d, f) {
        "use strict";
        function h(e, n, i) {
            var r = m(e);
            "undefined" != typeof r && (e.upsampledTerrain = new s(r)), g(e) && (e.loadedTerrain = new s);
            for (var o = 0, a = i.getLength(); a > o; ++o) {
                var u = i.get(o);
                u.show && u._createTileImagerySkeletons(e, n)
            }
            var l = e.tilingScheme.getEllipsoid(), c = e.extent;
            l.cartographicToCartesian(c.getSouthwest(), e.southwestCornerCartesian);
            var d = l.cartographicToCartesian(c.getSoutheast(), b);
            l.cartographicToCartesian(c.getNortheast(), e.northeastCornerCartesian);
            var f = l.cartographicToCartesian(c.getNorthwest(), T);
            t.UNIT_Z.cross(e.southwestCornerCartesian.negate(x), x).normalize(e.westNormal), e.northeastCornerCartesian.negate(x).cross(t.UNIT_Z, x).normalize(e.eastNormal), l.geodeticSurfaceNormal(d, x).cross(e.southwestCornerCartesian.subtract(d, S), x).normalize(e.southNormal), l.geodeticSurfaceNormal(f, x).cross(e.northeastCornerCartesian.subtract(f, S), x).normalize(e.northNormal)
        }

        function p(e, t, n) {
            var i = e.loadedTerrain, r = e.upsampledTerrain, a = !1;
            if ("undefined" != typeof i) {
                if (i.processLoadStateMachine(t, n, e.x, e.y, e.level), i.state.value >= o.RECEIVED.value) {
                    if (e.terrainData !== i.data) {
                        e.terrainData = i.data;
                        var s = e.terrainData.getWaterMask();
                        "undefined" != typeof s && ("undefined" != typeof e.waterMaskTexture && (--e.waterMaskTexture.referenceCount, 0 === e.waterMaskTexture.referenceCount && e.waterMaskTexture.destroy()), e.waterMaskTexture = _(t, s), e.waterMaskTranslationAndScale.x = 0, e.waterMaskTranslationAndScale.y = 0, e.waterMaskTranslationAndScale.z = 1, e.waterMaskTranslationAndScale.w = 1), v(e)
                    }
                    a = !0
                }
                i.state === o.READY ? (i.publishToTile(e), e.loadedTerrain = void 0, e.upsampledTerrain = void 0) : i.state === o.FAILED && (e.loadedTerrain = void 0)
            }
            a || "undefined" == typeof r || (r.processUpsampleStateMachine(t, n, e.x, e.y, e.level), r.state.value >= o.RECEIVED.value && e.terrainData !== r.data && (e.terrainData = r.data, n.hasWaterMask() && w(e, t), y(e)), r.state === o.READY ? (r.publishToTile(e), e.upsampledTerrain = void 0) : r.state === o.FAILED && (e.upsampledTerrain = void 0))
        }

        function m(e) {
            for (var t = e.parent; "undefined" != typeof t && "undefined" == typeof t.terrainData;)t = t.parent;
            return"undefined" == typeof t ? void 0 : {data: t.terrainData, x: t.x, y: t.y, level: t.level}
        }

        function y(e) {
            if ("undefined" != typeof e.children)for (var t = 0; 4 > t; ++t) {
                var n = e.children[t];
                if (n.state !== a.START) {
                    if ("undefined" != typeof n.terrainData && !n.terrainData.wasCreatedByUpsampling())continue;
                    "undefined" != typeof n.upsampledTerrain && n.upsampledTerrain.freeResources(), n.upsampledTerrain = new s({data: e.terrainData, x: e.x, y: e.y, level: e.level}), n.state = a.LOADING
                }
            }
        }

        function v(e) {
            if ("undefined" != typeof e.children)for (var t = 0; 4 > t; ++t) {
                var n = e.children[t];
                if (n.state !== a.START) {
                    if ("undefined" != typeof n.terrainData && !n.terrainData.wasCreatedByUpsampling())continue;
                    "undefined" != typeof n.upsampledTerrain && n.upsampledTerrain.freeResources(), n.upsampledTerrain = new s({data: e.terrainData, x: e.x, y: e.y, level: e.level}), e.terrainData.isChildAvailable(e.x, e.y, n.x, n.y) && "undefined" == typeof n.loadedTerrain && (n.loadedTerrain = new s), n.state = a.LOADING
                }
            }
        }

        function g(e) {
            var t = e.parent;
            return"undefined" == typeof t ? !0 : "undefined" == typeof t.terrainData ? !1 : t.terrainData.isChildAvailable(t.x, t.y, e.x, e.y)
        }

        function _(e, t) {
            var n, i = e.cache.tile_waterMaskData;
            "undefined" == typeof i && (i = e.cache.tile_waterMaskData = {allWaterTexture: void 0, allLandTexture: void 0, sampler: void 0, destroy: function () {
                "undefined" != typeof this.allWaterTexture && this.allWaterTexture.destroy(), "undefined" != typeof this.allLandTexture && this.allLandTexture.destroy()
            }});
            var r = Math.sqrt(t.length);
            return 1 !== r || 0 !== t[0] && 255 !== t[0] ? (n = e.createTexture2D({pixelFormat: l.LUMINANCE, pixelDatatype: u.UNSIGNED_BYTE, source: {width: r, height: r, arrayBufferView: t}}), n.referenceCount = 0, "undefined" == typeof i.sampler && (i.sampler = e.createSampler({wrapS: f.CLAMP, wrapT: f.CLAMP, minificationFilter: d.LINEAR, magnificationFilter: c.LINEAR})), n.setSampler(i.sampler)) : ("undefined" == typeof i.allWaterTexture && (i.allWaterTexture = e.createTexture2D({pixelFormat: l.LUMINANCE, pixelDatatype: u.UNSIGNED_BYTE, source: {arrayBufferView: new Uint8Array([255]), width: 1, height: 1}}), i.allWaterTexture.referenceCount = 1, i.allLandTexture = e.createTexture2D({pixelFormat: l.LUMINANCE, pixelDatatype: u.UNSIGNED_BYTE, source: {arrayBufferView: new Uint8Array([0]), width: 1, height: 1}}), i.allLandTexture.referenceCount = 1), n = 0 === t[0] ? i.allLandTexture : i.allWaterTexture), ++n.referenceCount, n
        }

        function w(e) {
            for (var t = e.parent; "undefined" != typeof t && ("undefined" == typeof t.terrainData || t.terrainData.wasCreatedByUpsampling());)t = t.parent;
            if ("undefined" != typeof t && "undefined" != typeof t.waterMaskTexture) {
                e.waterMaskTexture = t.waterMaskTexture, ++e.waterMaskTexture.referenceCount;
                var n = t.extent, i = e.extent, r = i.east - i.west, o = i.north - i.south, a = r / (n.east - n.west), s = o / (n.north - n.south);
                e.waterMaskTranslationAndScale.x = a * (i.west - n.west) / r, e.waterMaskTranslationAndScale.y = s * (i.south - n.south) / o, e.waterMaskTranslationAndScale.z = a, e.waterMaskTranslationAndScale.w = s
            }
        }

        var C = function (r) {
            if ("undefined" == typeof r)throw new i("description is required.");
            if ("undefined" == typeof r.x || "undefined" == typeof r.y) {
                if ("undefined" == typeof r.extent)throw new i("Either description.extent is required or description.x and description.y are required.")
            } else if (r.x < 0 || r.y < 0)throw new i("description.x and description.y must be greater than or equal to zero.");
            if ("undefined" == typeof r.level || r.zoom < 0)throw new i("description.level is required and must be greater than or equal to zero.");
            if ("undefined" == typeof r.tilingScheme)throw new i("description.tilingScheme is required.");
            this.tilingScheme = r.tilingScheme, this.x = r.x, this.y = r.y, this.level = r.level, this.parent = r.parent, this.children = void 0, this.extent = this.tilingScheme.tileXYToExtent(this.x, this.y, this.level), this.state = a.START, this.replacementPrevious = void 0, this.replacementNext = void 0, this.imagery = [], this.distance = 0, this.southwestCornerCartesian = new t, this.northeastCornerCartesian = new t, this.westNormal = new t, this.southNormal = new t, this.eastNormal = new t, this.northNormal = new t, this.waterMaskTexture = void 0, this.waterMaskTranslationAndScale = new n(0, 0, 1, 1), this.terrainData = void 0, this.center = new t, this.vertexArray = void 0, this.minimumHeight = 0, this.maximumHeight = 0, this.boundingSphere3D = new e, this.boundingSphere2D = new e, this.occludeePointInScaledSpace = new t, this.isRenderable = !1, this.loadedTerrain = void 0, this.upsampledTerrain = void 0
        };
        C.prototype.getChildren = function () {
            if ("undefined" == typeof this.children) {
                var e = this.tilingScheme, t = this.level + 1, n = 2 * this.x, i = 2 * this.y;
                this.children = [new C({tilingScheme: e, x: n, y: i, level: t, parent: this}), new C({tilingScheme: e, x: n + 1, y: i, level: t, parent: this}), new C({tilingScheme: e, x: n, y: i + 1, level: t, parent: this}), new C({tilingScheme: e, x: n + 1, y: i + 1, level: t, parent: this})]
            }
            return this.children
        }, C.prototype.freeResources = function () {
            "undefined" != typeof this.waterMaskTexture && (--this.waterMaskTexture.referenceCount, 0 === this.waterMaskTexture.referenceCount && this.waterMaskTexture.destroy(), this.waterMaskTexture = void 0), this.state = a.START, this.isRenderable = !1, this.terrainData = void 0, "undefined" != typeof this.loadedTerrain && (this.loadedTerrain.freeResources(), this.loadedTerrain = void 0), "undefined" != typeof this.upsampledTerrain && (this.upsampledTerrain.freeResources(), this.upsampledTerrain = void 0);
            var e, t, n = this.imagery;
            for (e = 0, t = n.length; t > e; ++e)n[e].freeResources();
            if (this.imagery.length = 0, "undefined" != typeof this.children) {
                for (e = 0, t = this.children.length; t > e; ++e)this.children[e].freeResources();
                this.children = void 0
            }
            this.freeVertexArray()
        }, C.prototype.freeVertexArray = function () {
            if ("undefined" != typeof this.vertexArray) {
                var e = this.vertexArray.getIndexBuffer();
                this.vertexArray.destroy(), this.vertexArray = void 0, e.isDestroyed() || "undefined" == typeof e.referenceCount || (--e.referenceCount, 0 === e.referenceCount && e.destroy())
            }
        }, C.prototype.processStateMachine = function (e, t, n) {
            this.state === a.START && (h(this, t, n), this.state = a.LOADING), this.state === a.LOADING && p(this, e, t);
            for (var i = "undefined" != typeof this.vertexArray, o = "undefined" == typeof this.loadedTerrain && "undefined" == typeof this.upsampledTerrain, s = this.imagery, u = 0, l = s.length; l > u; ++u) {
                var c = s[u];
                if ("undefined" != typeof c.loadingImagery) {
                    if (c.loadingImagery.state === r.PLACEHOLDER) {
                        var d = c.loadingImagery.imageryLayer;
                        if (d.getImageryProvider().isReady()) {
                            c.freeResources(), s.splice(u, 1), d._createTileImagerySkeletons(this, t, u), --u, l = s.length;
                            continue
                        }
                    }
                    var f = c.processStateMachine(this, e);
                    o = o && f, i = i && (f || "undefined" != typeof c.readyImagery)
                }
            }
            u === l && (i && (this.isRenderable = !0), o && (this.state = a.READY))
        };
        var x = new t, S = new t, b = new t, T = new t;
        return C
    }), n("Scene/TilingScheme", ["../Core/DeveloperError", "./Tile"], function (e, t) {
        "use strict";
        var n = function () {
            throw new e("This type should not be instantiated directly.  Instead, use WebMercatorTilingScheme or GeographicTilingScheme.")
        };
        return n.prototype.getEllipsoid = function () {
            throw new e("This type should not be instantiated directly.")
        }, n.prototype.getExtent = function () {
            throw new e("This type should not be instantiated directly.")
        }, n.prototype.getProjection = function () {
            throw new e("This type should not be instantiated directly.")
        }, n.prototype.getNumberOfXTilesAtLevel = function () {
            throw new e("This type should not be instantiated directly.")
        }, n.prototype.getNumberOfYTilesAtLevel = function () {
            throw new e("This type should not be instantiated directly.")
        }, n.prototype.createLevelZeroTiles = function () {
            throw new e("This type should not be instantiated directly.")
        }, n.prototype.extentToNativeExtent = function () {
            throw new e("This type should not be instantiated directly.")
        }, n.prototype.tileXYToNativeExtent = function () {
            throw new e("This type should not be instantiated directly.")
        }, n.prototype.tileXYToExtent = function () {
            throw new e("This type should not be instantiated directly.")
        }, n.prototype.positionToTileXY = function () {
            throw new e("This type should not be instantiated directly.")
        }, n.createRectangleOfLevelZeroTiles = function (n, i, r) {
            if ("undefined" == typeof n)throw new e("tilingScheme is required.");
            if ("undefined" == typeof i)throw new e("numberOfLevelZeroTilesX is required.");
            if ("undefined" == typeof r)throw new e("numberOfLevelZeroTilesY is required.");
            for (var o = new Array(i * r), a = 0, s = 0; r > s; ++s)for (var u = 0; i > u; ++u)o[a++] = new t({tilingScheme: n, x: u, y: s, level: 0});
            return o
        }, n
    }), n("Scene/GeographicTilingScheme", ["../Core/defaultValue", "../Core/DeveloperError", "../Core/Math", "../Core/Cartesian2", "../Core/Ellipsoid", "../Core/Extent", "../Core/GeographicProjection", "./TilingScheme"], function (e, t, n, i, r, o, a, s) {
        "use strict";
        var u = function (t) {
            t = e(t, {}), this._ellipsoid = e(t.ellipsoid, r.WGS84), this._extent = e(t.extent, o.MAX_VALUE), this._projection = new a(this._ellipsoid), this._numberOfLevelZeroTilesX = e(t.numberOfLevelZeroTilesX, 2), this._numberOfLevelZeroTilesY = e(t.numberOfLevelZeroTilesY, 1)
        };
        return u.prototype.getEllipsoid = function () {
            return this._ellipsoid
        }, u.prototype.getExtent = function () {
            return this._extent
        }, u.prototype.getProjection = function () {
            return this._projection
        }, u.prototype.getNumberOfXTilesAtLevel = function (e) {
            return this._numberOfLevelZeroTilesX << e
        }, u.prototype.getNumberOfYTilesAtLevel = function (e) {
            return this._numberOfLevelZeroTilesY << e
        }, u.prototype.createLevelZeroTiles = function () {
            return s.createRectangleOfLevelZeroTiles(this, this._numberOfLevelZeroTilesX, this._numberOfLevelZeroTilesY)
        }, u.prototype.extentToNativeExtent = function (e, i) {
            if ("undefined" == typeof e)throw new t("extent is required.");
            var r = n.toDegrees(e.west), a = n.toDegrees(e.south), s = n.toDegrees(e.east), u = n.toDegrees(e.north);
            return"undefined" == typeof i ? new o(r, a, s, u) : (i.west = r, i.south = a, i.east = s, i.north = u, i)
        }, u.prototype.tileXYToNativeExtent = function (e, t, i, r) {
            var o = this.tileXYToExtent(e, t, i, r);
            return o.west = n.toDegrees(o.west), o.south = n.toDegrees(o.south), o.east = n.toDegrees(o.east), o.north = n.toDegrees(o.north), o
        }, u.prototype.tileXYToExtent = function (e, t, n, i) {
            var r = this._extent, a = this.getNumberOfXTilesAtLevel(n), s = this.getNumberOfYTilesAtLevel(n), u = (r.east - r.west) / a, l = e * u + r.west, c = (e + 1) * u + r.west, d = (r.north - r.south) / s, f = r.north - t * d, h = r.north - (t + 1) * d;
            return"undefined" == typeof i && (i = new o(l, h, c, f)), i.west = l, i.south = h, i.east = c, i.north = f, i
        }, u.prototype.positionToTileXY = function (e, t, n) {
            var r = this._extent;
            if (e.latitude > r.north || e.latitude < r.south || e.longitude < r.west || e.longitude > r.east)return void 0;
            var o = this.getNumberOfXTilesAtLevel(t), a = this.getNumberOfYTilesAtLevel(t), s = (r.east - r.west) / o, u = (r.north - r.south) / a, l = 0 | (e.longitude - r.west) / s;
            l >= o && (l = o - 1);
            var c = 0 | (r.north - e.latitude) / u;
            return c >= a && (c = a - 1), "undefined" == typeof n ? new i(l, c) : (n.x = l, n.y = c, n)
        }, u
    }), n("Scene/TerrainMesh", [], function () {
        "use strict";
        var e = function (e, t, n, i, r, o, a) {
            this.center = e, this.vertices = t, this.indices = n, this.minimumHeight = i, this.maximumHeight = r, this.boundingSphere3D = o, this.occludeePointInScaledSpace = a
        };
        return e
    }), n("Scene/HeightmapTerrainData", ["../Core/defaultValue", "../Core/DeveloperError", "../Core/HeightmapTessellator", "../Core/Math", "../Core/TaskProcessor", "./GeographicTilingScheme", "./TerrainMesh", "./TerrainProvider", "../ThirdParty/when"], function (e, t, n, i, r, o, a, s, u) {
        "use strict";
        function l(e, t, n, i, r, o, a) {
            var s = 1, u = e._width, l = e._height, c = o * (u - 1), d = c + u - 1, f = a * (l - 1), h = f + l - 1, p = 1 << s;
            c /= p, d /= p, f /= p, h /= p;
            var m = n * (u - 1), v = i * (l - 1);
            c -= m, d -= m, f -= v, h -= v;
            var g, _, w = 0 | c, C = 0 | d, x = 0 | f, S = 0 | h, b = C - w + 1, T = S - x + 1, E = e._buffer, A = e._structure, M = b * T, D = M * A.stride, I = new E.constructor(D), P = 0, O = A.stride;
            if (O > 1)for (_ = x; S >= _; ++_)for (g = w; C >= g; ++g)for (var R = (_ * u + g) * O, z = 0; O > z; ++z)I[P++] = E[R + z]; else for (_ = x; S >= _; ++_)for (g = w; C >= g; ++g)I[P++] = E[_ * u + g];
            return new y({buffer: I, width: b, height: T, childTileMask: 0, structure: e._structure, createdByUpsampling: !0})
        }

        function c(e, t, n, r, o, a, s, u) {
            var l, c, h, p, v = e._width, g = e._height, _ = e._structure, w = _.stride, C = e._buffer, x = new C.constructor(v * g * w), S = t.tileXYToExtent(n, r, o), b = t.tileXYToExtent(a, s, u);
            if (w > 1) {
                var T = _.elementsPerHeight, E = _.elementMultiplier, A = _.isBigEndian, M = Math.pow(E, T - 1);
                for (c = 0; g > c; ++c)for (h = i.lerp(b.north, b.south, c / (g - 1)), l = 0; v > l; ++l) {
                    p = i.lerp(b.west, b.east, l / (v - 1));
                    var D = f(C, T, E, w, A, S, v, g, p, h);
                    m(x, T, E, M, w, A, c * v + l, D)
                }
            } else for (c = 0; g > c; ++c)for (h = i.lerp(b.north, b.south, c / (g - 1)), l = 0; v > l; ++l)p = i.lerp(b.west, b.east, l / (v - 1)), x[c * v + l] = d(C, S, v, g, p, h);
            return new y({buffer: x, width: v, height: g, childTileMask: 0, structure: e._structure, createdByUpsampling: !0})
        }

        function d(e, t, n, i, r, o) {
            var a = (r - t.west) * (n - 1) / (t.east - t.west), s = (o - t.south) * (i - 1) / (t.north - t.south), u = 0 | a, l = u + 1;
            l >= n && (l = n - 1, u = n - 2);
            var c = 0 | s, d = c + 1;
            d >= i && (d = i - 1, c = i - 2);
            var f = a - u, p = s - c;
            c = i - 1 - c, d = i - 1 - d;
            var m = e[c * n + u], y = e[c * n + l], v = e[d * n + u], g = e[d * n + l];
            return h(f, p, m, y, v, g)
        }

        function f(e, t, n, i, r, o, a, s, u, l) {
            var c = (u - o.west) * (a - 1) / (o.east - o.west), d = (l - o.south) * (s - 1) / (o.north - o.south), f = 0 | c, m = f + 1;
            m >= a && (m = a - 1, f = a - 2);
            var y = 0 | d, v = y + 1;
            v >= s && (v = s - 1, y = s - 2);
            var g = c - f, _ = d - y;
            y = s - 1 - y, v = s - 1 - v;
            var w = p(e, t, n, i, r, y * a + f), C = p(e, t, n, i, r, y * a + m), x = p(e, t, n, i, r, v * a + f), S = p(e, t, n, i, r, v * a + m);
            return h(g, _, w, C, x, S)
        }

        function h(e, t, n, i, r, o) {
            return e > t ? n + e * (i - n) + t * (o - i) : n + e * (o - r) + t * (r - n)
        }

        function p(e, t, n, i, r, o) {
            o *= i;
            var a, s = 0;
            if (r)for (a = 0; t > a; ++a)s = s * n + e[o + a]; else for (a = t - 1; a >= 0; --a)s = s * n + e[o + a];
            return s
        }

        function m(e, t, n, i, r, o, a, s) {
            a *= r;
            var u;
            if (o)for (u = 0; t > u; ++u)e[a + u] = 0 | s / i, s -= e[a + u] * i, i /= n; else for (u = t - 1; u >= 0; --u)e[a + u] = 0 | s / i, s -= e[a + u] * i, i /= n
        }

        var y = function (i) {
            if ("undefined" == typeof i || "undefined" == typeof i.buffer)throw new t("description.buffer is required.");
            if ("undefined" == typeof i.width)throw new t("description.width is required.");
            if ("undefined" == typeof i.height)throw new t("description.height is required.");
            this._buffer = i.buffer, this._width = i.width, this._height = i.height, this._childTileMask = e(i.childTileMask, 15);
            var r = n.DEFAULT_STRUCTURE, o = i.structure;
            "undefined" == typeof o ? o = r : o !== r && (o.heightScale = e(o.heightScale, r.heightScale), o.heightOffset = e(o.heightOffset, r.heightOffset), o.elementsPerHeight = e(o.elementsPerHeight, r.elementsPerHeight), o.stride = e(o.stride, r.stride), o.elementMultiplier = e(o.elementMultiplier, r.elementMultiplier), o.isBigEndian = e(o.isBigEndian, r.isBigEndian)), this._structure = o, this._createdByUpsampling = e(i.createdByUpsampling, !1), this._waterMask = i.waterMask
        }, v = new r("createVerticesFromHeightmap");
        return y.prototype.createMesh = function (e, n, i, r) {
            if ("undefined" == typeof e)throw new t("tilingScheme is required.");
            if ("undefined" == typeof n)throw new t("x is required.");
            if ("undefined" == typeof i)throw new t("y is required.");
            if ("undefined" == typeof r)throw new t("level is required.");
            var l = e.getEllipsoid(), c = e.tileXYToNativeExtent(n, i, r), d = e.tileXYToExtent(n, i, r), f = l.cartographicToCartesian(d.getCenter()), h = this._structure, p = s.getEstimatedLevelZeroGeometricErrorForAHeightmap(l, this._width, e.getNumberOfXTilesAtLevel(0)), m = p / (1 << r), y = v.scheduleTask({heightmap: this._buffer, structure: h, width: this._width, height: this._height, nativeExtent: c, extent: d, relativeToCenter: f, ellipsoid: l, skirtHeight: Math.min(4 * m, 1e3), isGeographic: e instanceof o});
            return"undefined" == typeof y ? void 0 : u(y, function (e) {
                return new a(f, new Float32Array(e.vertices), s.getRegularGridIndices(e.gridWidth, e.gridHeight), e.minimumHeight, e.maximumHeight, e.boundingSphere3D, e.occludeePointInScaledSpace)
            })
        }, y.prototype.interpolateHeight = function (e, t, n) {
            var i, r = this._width, o = this._height, a = this._structure, s = a.stride;
            if (s > 1) {
                var u = a.elementsPerHeight, l = a.elementMultiplier, c = a.isBigEndian;
                i = f(this._buffer, u, l, s, c, e, r, o, t, n)
            } else i = d(this._buffer, e, r, o, t, n);
            return i * a.heightScale + a.heightOffset
        }, y.prototype.upsample = function (e, n, i, r, o, a, s) {
            if ("undefined" == typeof e)throw new t("tilingScheme is required.");
            if ("undefined" == typeof n)throw new t("thisX is required.");
            if ("undefined" == typeof i)throw new t("thisY is required.");
            if ("undefined" == typeof r)throw new t("thisLevel is required.");
            if ("undefined" == typeof o)throw new t("descendantX is required.");
            if ("undefined" == typeof a)throw new t("descendantY is required.");
            if ("undefined" == typeof s)throw new t("descendantLevel is required.");
            var u = s - r;
            if (u > 1)throw new t("Upsampling through more than one level at a time is not currently supported.");
            var d;
            return d = 1 === this._width % 2 && 1 === this._height % 2 ? l(this, e, n, i, r, o, a, s) : c(this, e, n, i, r, o, a, s)
        }, y.prototype.isChildAvailable = function (e, n, i, r) {
            if ("undefined" == typeof e)throw new t("thisX is required.");
            if ("undefined" == typeof n)throw new t("thisY is required.");
            if ("undefined" == typeof i)throw new t("childX is required.");
            if ("undefined" == typeof r)throw new t("childY is required.");
            var o = 2;
            return i !== 2 * e && ++o, r !== 2 * n && (o -= 2), 0 !== (this._childTileMask & 1 << o)
        }, y.prototype.getWaterMask = function () {
            return this._waterMask
        }, y.prototype.wasCreatedByUpsampling = function () {
            return this._createdByUpsampling
        }, y
    }), n("Scene/ArcGisImageServerTerrainProvider", ["../Core/defaultValue", "../Core/loadImage", "../Core/getImagePixels", "../Core/throttleRequestByServer", "../Core/writeTextToCanvas", "../Core/DeveloperError", "../Core/Math", "../Core/Ellipsoid", "../Core/Event", "./Credit", "./TerrainProvider", "./GeographicTilingScheme", "./HeightmapTerrainData", "../ThirdParty/when"], function (e, t, n, i, r, o, a, s, u, l, c, d, f, h) {
        "use strict";
        var p = function (t) {
            if ("undefined" == typeof t || "undefined" == typeof t.url)throw new o("description.url is required.");
            this._url = t.url, this._token = t.token, this._tilingScheme = t.tilingScheme, "undefined" == typeof this._tilingScheme && (this._tilingScheme = new d({ellipsoid: e(t.ellipsoid, s.WGS84)})), this._heightmapWidth = 65, this._levelZeroMaximumGeometricError = c.getEstimatedLevelZeroGeometricErrorForAHeightmap(this._tilingScheme.getEllipsoid(), this._heightmapWidth, this._tilingScheme.getNumberOfXTilesAtLevel(0)), this._proxy = t.proxy, this._terrainDataStructure = {heightScale: .001, heightOffset: -1e3, elementsPerHeight: 3, stride: 4, elementMultiplier: 256, isBigEndian: !0}, this._errorEvent = new u;
            var n = t.credit;
            "string" == typeof n && (n = new l(n)), this._credit = n
        };
        return p.prototype.requestTileGeometry = function (e, r, o) {
            var s = this._tilingScheme.tileXYToExtent(e, r, o), u = (s.east - s.west) / (this._heightmapWidth - 1), l = (s.north - s.south) / (this._heightmapWidth - 1);
            s.west -= .5 * u, s.east += .5 * u, s.south -= .5 * l, s.north += .5 * l;
            var c = a.toDegrees(s.west) + "%2C" + a.toDegrees(s.south) + "%2C" + a.toDegrees(s.east) + "%2C" + a.toDegrees(s.north), d = this._url + "/exportImage?interpolation=RSP_BilinearInterpolation&format=tiff&f=image&size=" + this._heightmapWidth + "%2C" + this._heightmapWidth + "&bboxSR=4326&imageSR=4326&bbox=" + c;
            this._token && (d += "&token=" + this._token);
            var p = this._proxy;
            "undefined" != typeof p && (d = p.getURL(d));
            var m = i(d, t);
            if ("undefined" == typeof m)return void 0;
            var y = this;
            return h(m, function (e) {
                return new f({buffer: n(e), width: y._heightmapWidth, height: y._heightmapWidth, childTileMask: 15, structure: y._terrainDataStructure})
            })
        }, p.prototype.getErrorEvent = function () {
            return this._errorEvent
        }, p.prototype.getLevelMaximumGeometricError = function (e) {
            return this._levelZeroMaximumGeometricError / (1 << e)
        }, p.prototype.getCredit = function () {
            return this._credit
        }, p.prototype.getTilingScheme = function () {
            return this._tilingScheme
        }, p.prototype.hasWaterMask = function () {
            return!1
        }, p.prototype.isReady = function () {
            return!0
        }, p
    }), n("Scene/DiscardMissingTileImagePolicy", ["../Core/defaultValue", "../Core/loadImageViaBlob", "../Core/getImagePixels", "../Core/DeveloperError", "../ThirdParty/when"], function (e, t, n, i, r) {
        "use strict";
        var o = function (o) {
            function a(e) {
                "undefined" != typeof e.blob && (u._missingImageByteLength = e.blob.size);
                var t = n(e);
                if (o.disableCheckIfAllPixelsAreTransparent) {
                    for (var i = !0, r = e.width, a = o.pixelsToCheck, s = 0, l = a.length; i && l > s; ++s) {
                        var c = a[s], d = 4 * c.x + c.y * r, f = t[d + 3];
                        f > 0 && (i = !1)
                    }
                    i && (t = void 0)
                }
                u._missingImagePixels = t, u._isReady = !0
            }

            function s() {
                u._missingImagePixels = void 0, u._isReady = !0
            }

            if (o = e(o, {}), "undefined" == typeof o.missingImageUrl)throw new i("description.missingImageUrl is required.");
            if ("undefined" == typeof o.pixelsToCheck)throw new i("description.pixelsToCheck is required.");
            this._pixelsToCheck = o.pixelsToCheck, this._missingImagePixels = void 0, this._missingImageByteLength = void 0, this._isReady = !1;
            var u = this;
            r(t(o.missingImageUrl), a, s)
        };
        return o.prototype.isReady = function () {
            return this._isReady
        }, o.prototype.shouldDiscardImage = function (e) {
            if (!this._isReady)throw new i("shouldDiscardImage must not be called before the discard policy is ready.");
            var t = this._pixelsToCheck, r = this._missingImagePixels;
            if ("undefined" == typeof r)return!1;
            if ("undefined" != typeof e.blob && e.blob.size !== this._missingImageByteLength)return!1;
            for (var o = n(e), a = e.width, s = 0, u = t.length; u > s; ++s)for (var l = t[s], c = 4 * l.x + l.y * a, d = 0; 4 > d; ++d) {
                var f = c + d;
                if (o[f] !== r[f])return!1
            }
            return!0
        }, o
    }), n("Scene/ImageryProvider", ["../Core/loadImage", "../Core/loadImageViaBlob", "../Core/DeveloperError", "../Core/throttleRequestByServer"], function (e, t, n, i) {
        "use strict";
        var r = function () {
            throw this.defaultAlpha = void 0, this.defaultBrightness = void 0, this.defaultContrast = void 0, this.defaultHue = void 0, this.defaultSaturation = void 0, this.defaultGamma = void 0, new n("This type should not be instantiated directly.")
        };
        return r.prototype.isReady = function () {
            throw new n("This type should not be instantiated directly.")
        }, r.prototype.getExtent = function () {
            throw new n("This type should not be instantiated directly.")
        }, r.prototype.getTileWidth = function () {
            throw new n("This type should not be instantiated directly.")
        }, r.prototype.getTileHeight = function () {
            throw new n("This type should not be instantiated directly.")
        }, r.prototype.getMaximumLevel = function () {
            throw new n("This type should not be instantiated directly.")
        }, r.prototype.getMinimumLevel = function () {
            throw new n("This type should not be instantiated directly.")
        }, r.prototype.getTilingScheme = function () {
            throw new n("This type should not be instantiated directly.")
        }, r.prototype.getTileDiscardPolicy = function () {
            throw new n("This type should not be instantiated directly.")
        }, r.prototype.getErrorEvent = function () {
            throw new n("This type should not be instantiated directly.")
        }, r.prototype.getCredit = function () {
            throw new n("This type should not be instantiated directly.")
        }, r.prototype.getProxy = function () {
            throw new n("This type should not be instantiated directly.")
        }, r.prototype.requestImage = function () {
            throw new n("This type should not be instantiated directly.")
        }, r.loadImage = function (n, r) {
            return"undefined" != typeof n.getTileDiscardPolicy() ? i(r, t) : i(r, e)
        }, r
    }), n("Scene/WebMercatorTilingScheme", ["../Core/defaultValue", "../Core/Ellipsoid", "../Core/Extent", "../Core/Cartesian2", "../Core/WebMercatorProjection", "./TilingScheme"], function (e, t, n, i, r, o) {
        "use strict";
        var a = function (o) {
            if (o = e(o, {}), this._ellipsoid = e(o.ellipsoid, t.WGS84), this._numberOfLevelZeroTilesX = e(o.numberOfLevelZeroTilesX, 1), this._numberOfLevelZeroTilesY = e(o.numberOfLevelZeroTilesY, 1), this._projection = new r(this._ellipsoid), "undefined" != typeof o.extentSouthwestInMeters && "undefined" != typeof o.extentNortheastInMeters)this._extentSouthwestInMeters = o.extentSouthwestInMeters, this._extentNortheastInMeters = o.extentNortheastInMeters; else {
                var a = this._ellipsoid.getMaximumRadius() * Math.PI;
                this._extentSouthwestInMeters = new i(-a, -a), this._extentNortheastInMeters = new i(a, a)
            }
            var s = this._projection.unproject(this._extentSouthwestInMeters), u = this._projection.unproject(this._extentNortheastInMeters);
            this._extent = new n(s.longitude, s.latitude, u.longitude, u.latitude)
        };
        return a.prototype.getEllipsoid = function () {
            return this._ellipsoid
        }, a.prototype.getExtent = function () {
            return this._extent
        }, a.prototype.getProjection = function () {
            return this._projection
        }, a.prototype.getNumberOfXTilesAtLevel = function (e) {
            return this._numberOfLevelZeroTilesX << e
        }, a.prototype.getNumberOfYTilesAtLevel = function (e) {
            return this._numberOfLevelZeroTilesY << e
        }, a.prototype.createLevelZeroTiles = function () {
            return o.createRectangleOfLevelZeroTiles(this, this._numberOfLevelZeroTilesX, this._numberOfLevelZeroTilesY)
        }, a.prototype.extentToNativeExtent = function (e, t) {
            var i = this._projection, r = i.project(e.getSouthwest()), o = i.project(e.getNortheast());
            return"undefined" == typeof t ? new n(r.x, r.y, o.x, o.y) : (t.west = r.x, t.south = r.y, t.east = o.x, t.north = o.y, t)
        }, a.prototype.tileXYToNativeExtent = function (e, t, i, r) {
            var o = this.getNumberOfXTilesAtLevel(i), a = this.getNumberOfYTilesAtLevel(i), s = (this._extentNortheastInMeters.x - this._extentSouthwestInMeters.x) / o, u = this._extentSouthwestInMeters.x + e * s, l = this._extentSouthwestInMeters.x + (e + 1) * s, c = (this._extentNortheastInMeters.y - this._extentSouthwestInMeters.y) / a, d = this._extentNortheastInMeters.y - t * c, f = this._extentNortheastInMeters.y - (t + 1) * c;
            return"undefined" == typeof r ? new n(u, f, l, d) : (r.west = u, r.south = f, r.east = l, r.north = d, r)
        }, a.prototype.tileXYToExtent = function (e, t, n, r) {
            var o = this.tileXYToNativeExtent(e, t, n, r), a = this._projection, s = a.unproject(new i(o.west, o.south)), u = a.unproject(new i(o.east, o.north));
            return o.west = s.longitude, o.south = s.latitude, o.east = u.longitude, o.north = u.latitude, o
        }, a.prototype.positionToTileXY = function (e, t, n) {
            var r = this._extent;
            if (e.latitude > r.north || e.latitude < r.south || e.longitude < r.west || e.longitude > r.east)return void 0;
            var o = this.getNumberOfXTilesAtLevel(t), a = this.getNumberOfYTilesAtLevel(t), s = this._extentNortheastInMeters.x - this._extentSouthwestInMeters.x, u = s / o, l = this._extentNortheastInMeters.y - this._extentSouthwestInMeters.y, c = l / a, d = this._projection, f = d.project(e), h = f.x - this._extentSouthwestInMeters.x, p = this._extentNortheastInMeters.y - f.y, m = 0 | h / u;
            m >= o && (m = o - 1);
            var y = 0 | p / c;
            return y >= a && (y = a - 1), "undefined" == typeof n ? new i(m, y) : (n.x = m, n.y = y, n)
        }, a
    }), n("Scene/ArcGisMapServerImageryProvider", ["../Core/defaultValue", "../Core/jsonp", "../Core/writeTextToCanvas", "../Core/Cartesian2", "../Core/DeveloperError", "../Core/Event", "./DiscardMissingTileImagePolicy", "./GeographicTilingScheme", "./ImageryProvider", "./TileProviderError", "./WebMercatorTilingScheme", "./Credit", "../ThirdParty/when"], function (e, t, n, i, r, o, a, s, u, l, c, d, f) {
        "use strict";
        function h(e, t, n, i) {
            var r;
            if (e._useTiles)r = e._url + "/tile/" + i + "/" + n + "/" + t; else {
                var o = e._tilingScheme.tileXYToNativeExtent(t, n, i), a = o.west + "%2C" + o.south + "%2C" + o.east + "%2C" + o.north;
                r = e._url + "/export?", r += "bbox=" + a, r += "&bboxSR=4326&size=256%2C256&imageSR=4326&format=png&transparent=true&f=image"
            }
            var s = e._proxy;
            return"undefined" != typeof s && (r = s.getURL(r)), r
        }

        var p = function (n) {
            function u(e) {
                var t = e.tileInfo;
                if (v._useTiles && "undefined" != typeof t) {
                    if (v._tileWidth = t.rows, v._tileHeight = t.cols, 102100 === t.spatialReference.wkid)v._tilingScheme = new c; else {
                        if (4326 !== e.tileInfo.spatialReference.wkid) {
                            var n = "Tile spatial reference WKID " + e.tileInfo.spatialReference.wkid + " is not supported.";
                            return y = l.handleError(y, v, v._errorEvent, n, void 0, void 0, void 0, m), void 0
                        }
                        v._tilingScheme = new s
                    }
                    v._maximumLevel = e.tileInfo.lods.length - 1, "undefined" == typeof v._tileDiscardPolicy && (v._tileDiscardPolicy = new a({missingImageUrl: h(v, 0, 0, v._maximumLevel), pixelsToCheck: [new i(0, 0), new i(200, 20), new i(20, 200), new i(80, 110), new i(160, 130)], disableCheckIfAllPixelsAreTransparent: !0})), v._useTiles = !0
                } else v._tileWidth = 256, v._tileHeight = 256, v._tilingScheme = new s, v._useTiles = !1;
                "undefined" != typeof e.copyrightText && e.copyrightText.length > 0 && (v._credit = new d(e.copyrightText)), v._ready = !0, l.handleSuccess(y)
            }

            function p() {
                var e = "An error occurred while accessing " + v._url + ".";
                y = l.handleError(y, v, v._errorEvent, e, void 0, void 0, void 0, m)
            }

            function m() {
                var e = t(v._url, {parameters: {f: "json"}, proxy: v._proxy});
                f(e, u, p)
            }

            if (n = e(n, {}), "undefined" == typeof n.url)throw new r("description.url is required.");
            this._url = n.url, this._tileDiscardPolicy = n.tileDiscardPolicy, this._proxy = n.proxy, this._tileWidth = void 0, this._tileHeight = void 0, this._maximumLevel = void 0, this._tilingScheme = void 0, this._credit = void 0, this._useTiles = e(n.usePreCachedTilesIfAvailable, !0), this._errorEvent = new o, this._ready = !1;
            var y, v = this;
            m()
        };
        return p.prototype.isUsingPrecachedTiles = function () {
            return this._useTiles
        }, p.prototype.getUrl = function () {
            return this._url
        }, p.prototype.getProxy = function () {
            return this._proxy
        }, p.prototype.getTileWidth = function () {
            if (!this._ready)throw new r("getTileWidth must not be called before the imagery provider is ready.");
            return this._tileWidth
        }, p.prototype.getTileHeight = function () {
            if (!this._ready)throw new r("getTileHeight must not be called before the imagery provider is ready.");
            return this._tileHeight
        }, p.prototype.getMaximumLevel = function () {
            if (!this._ready)throw new r("getMaximumLevel must not be called before the imagery provider is ready.");
            return this._maximumLevel
        }, p.prototype.getMinimumLevel = function () {
            if (!this._ready)throw new r("getMinimumLevel must not be called before the imagery provider is ready.");
            return 0
        }, p.prototype.getTilingScheme = function () {
            if (!this._ready)throw new r("getTilingScheme must not be called before the imagery provider is ready.");
            return this._tilingScheme
        }, p.prototype.getExtent = function () {
            if (!this._ready)throw new r("getExtent must not be called before the imagery provider is ready.");
            return this._tilingScheme.getExtent()
        }, p.prototype.getTileDiscardPolicy = function () {
            if (!this._ready)throw new r("getTileDiscardPolicy must not be called before the imagery provider is ready.");
            return this._tileDiscardPolicy
        }, p.prototype.getErrorEvent = function () {
            return this._errorEvent
        }, p.prototype.isReady = function () {
            return this._ready
        }, p.prototype.requestImage = function (e, t, n) {
            if (!this._ready)throw new r("requestImage must not be called before the imagery provider is ready.");
            var i = h(this, e, t, n);
            return u.loadImage(this, i)
        }, p.prototype.getCredit = function () {
            return this._credit
        }, p
    }), n("Scene/BingMapsStyle", ["../Core/Enumeration"], function (e) {
        "use strict";
        var t = {AERIAL: new e(0, "AERIAL", {imagerySetName: "Aerial"}), AERIAL_WITH_LABELS: new e(1, "AERIAL_WITH_LABELS", {imagerySetName: "AerialWithLabels"}), ROAD: new e(2, "ROAD", {imagerySetName: "Road"}), ORDNANCE_SURVEY: new e(3, "ORDNANCE_SURVEY", {imagerySetName: "OrdnanceSurvey"}), COLLINS_BART: new e(4, "COLLINS_BART", {imagerySetName: "CollinsBart"})};
        return t
    }), n("Scene/BingMapsImageryProvider", ["../Core/defaultValue", "../Core/jsonp", "../Core/Cartesian2", "../Core/DeveloperError", "../Core/Event", "./BingMapsStyle", "./DiscardMissingTileImagePolicy", "./ImageryProvider", "./TileProviderError", "./WebMercatorTilingScheme", "./Credit", "../ThirdParty/when"], function (e, t, n, i, r, o, a, s, u, l, c, d) {
        "use strict";
        function f(e, t, n, i) {
            var r = e._imageUrlTemplate, o = h.tileXYToQuadKey(t, n, i);
            r = r.replace("{quadkey}", o);
            var a = e._imageUrlSubdomains, s = (t + n + i) % a.length;
            r = r.replace("{subdomain}", a[s]);
            var u = e._proxy;
            return"undefined" != typeof u && (r = u.getURL(r)), r
        }

        var h = function p(s) {
            function h(e) {
                var t = e.resourceSets[0].resources[0];
                _._tileWidth = t.imageWidth, _._tileHeight = t.imageHeight, _._maximumLevel = t.zoomMax - 1, _._imageUrlSubdomains = t.imageUrlSubdomains, _._imageUrlTemplate = t.imageUrl.replace("{culture}", ""), "undefined" == typeof _._tileDiscardPolicy && (_._tileDiscardPolicy = new a({missingImageUrl: f(_, 0, 0, _._maximumLevel), pixelsToCheck: [new n(0, 0), new n(120, 140), new n(130, 160), new n(200, 50), new n(200, 200)], disableCheckIfAllPixelsAreTransparent: !0})), _._ready = !0, u.handleSuccess(v)
            }

            function m() {
                var e = "An error occurred while accessing " + g + ".";
                v = u.handleError(v, _, _._errorEvent, e, void 0, void 0, void 0, y)
            }

            function y() {
                var e = t(g, {callbackParameterName: "jsonp", proxy: _._proxy});
                d(e, h, m)
            }

            if (s = e(s, {}), "undefined" == typeof s.url)throw new i("description.url is required.");
            this._url = s.url, this._key = e(s.key, "Auc5O1omLRY_ub2safz0m2vJbzhYhSfTkO9eRDtLOauonIVoAiy6BV8c-L4jl1MT"), this._mapStyle = e(s.mapStyle, o.AERIAL), this._tileDiscardPolicy = s.tileDiscardPolicy, this._proxy = s.proxy, this._credit = new c("Bing Imagery", p._logoData, "http://www.bing.com"), this.defaultGamma = 1, (this._mapStyle === o.AERIAL || this._mapStyle === o.AERIAL_WITH_LABELS) && (this.defaultGamma = 1.3), this._tilingScheme = new l({numberOfLevelZeroTilesX: 2, numberOfLevelZeroTilesY: 2}), this._tileWidth = void 0, this._tileHeight = void 0, this._maximumLevel = void 0, this._imageUrlTemplate = void 0, this._imageUrlSubdomains = void 0, this._errorEvent = new r, this._ready = !1;
            var v, g = this._url + "/REST/v1/Imagery/Metadata/" + this._mapStyle.imagerySetName + "?key=" + this._key, _ = this;
            y()
        };
        return h.prototype.getUrl = function () {
            return this._url
        }, h.prototype.getProxy = function () {
            return this._proxy
        }, h.prototype.getKey = function () {
            return this._key
        }, h.prototype.getMapStyle = function () {
            return this._mapStyle
        }, h.prototype.getTileWidth = function () {
            if (!this._ready)throw new i("getTileWidth must not be called before the imagery provider is ready.");
            return this._tileWidth
        }, h.prototype.getTileHeight = function () {
            if (!this._ready)throw new i("getTileHeight must not be called before the imagery provider is ready.");
            return this._tileHeight
        }, h.prototype.getMaximumLevel = function () {
            if (!this._ready)throw new i("getMaximumLevel must not be called before the imagery provider is ready.");
            return this._maximumLevel
        }, h.prototype.getMinimumLevel = function () {
            if (!this._ready)throw new i("getMinimumLevel must not be called before the imagery provider is ready.");
            return 0
        }, h.prototype.getTilingScheme = function () {
            if (!this._ready)throw new i("getTilingScheme must not be called before the imagery provider is ready.");
            return this._tilingScheme
        }, h.prototype.getExtent = function () {
            if (!this._ready)throw new i("getExtent must not be called before the imagery provider is ready.");
            return this._tilingScheme.getExtent()
        }, h.prototype.getTileDiscardPolicy = function () {
            if (!this._ready)throw new i("getTileDiscardPolicy must not be called before the imagery provider is ready.");
            return this._tileDiscardPolicy
        }, h.prototype.getErrorEvent = function () {
            return this._errorEvent
        }, h.prototype.isReady = function () {
            return this._ready
        }, h.prototype.requestImage = function (e, t, n) {
            if (!this._ready)throw new i("requestImage must not be called before the imagery provider is ready.");
            var r = f(this, e, t, n);
            return s.loadImage(this, r)
        }, h.prototype.getCredit = function () {
            return this._credit
        }, h._logoData = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAAWCAYAAACcy/8iAAAABGdBTUEAAK/INwWK6QAAAAlwSFlzAAAOwgAADsIBFShKgAAAABp0RVh0U29mdHdhcmUAUGFpbnQuTkVUIHYzLjUuMTAw9HKhAAAL+UlEQVRYR9WYeVSXZRbHFZB9kX0H2UQBWUQFFJcKl9GOVIBLWDNKc7JSUxwVbFxGBBcUaVGSpCI7ogKOWohWipKC4oqaC4KyCIoCssiOznzuD36NecypM/8095zn/F7e57n3ud/7fO997ksvpLeamppq37591U1NTbXNzc31LCwsdE1MTDQMDQ2ZUlORRb8m6urqKkZGRn0Y2mZmZgaMvujqoaulo6PThyW9e8YfQ8RhAwMDDSsrK4MBAwbYeHh4OLi5udnZ29sb47g282osUzr9iyG6AFOXADk6OloNGjTIZfDgwQMRB1tbW9RNtAGt+izdp8bz5Fnr5RAUQ19fX/VZA0yqHIIqvsk60ekWTU1NVU5F19XV1TY2bk3Y7t2ZK1K/+jrSy8vLldM2RVFHV1dXw9jYWFMGADT09PTUed9HhHfa/fr1M5sW/OKI/RuC4wqSX965bWXIHG9vb1dLS0sjdNXZQw2dPqIrwRU7BEpD5sQObkhQlI79DEjmZC/REx3R1dbW1tDS0tJEV4s5Hd7rKQcM1ZXgc3h61tbWOvxqE3jRVWNObPbqhXIfABtxsh5nz57PevTocVdjY2PD0KFDx6IwEND2DGuebWTwbMUwx4AJTgt9TVxcXJyz4kas79ph3fl4h/mj+lSHW2sXTA5nMztSxZANjdjDFGeIgaXCFs/W8jemTDgJfcBoAUZdgghATd7pYdpI9kKs0LORwbM1e8uvPfadnJ2dOSvX/vjg6ODgYEPwrWGbYvC3OcOQd5rsr0rge8sJq4sz0NC3oODM4X8hjY1Nzb6+vtOdnJyCoOmoYcOGjfLz8xstg+dAHx8fP2jvaWNj44SubOS5dfGoFRUpHsV1X7vXXdzsczQibEwYUXbDSXFqIIwZQhADsaGwhZ2R7BFAnH1wyBkAloA0IoiGADLDtj0+DSJF/GRtj85odEbh02hPT8+gxYuXRKSnZ6zOzNyz6tOtye9GRkaOPnPmzPtnz559X35zc3NnJCYmeuCfHimqTvBVBLAGkTQnSsNOnjx1tBtwY3NwcPD8zz//YvPFi5e+v3PnToFyVFZW5l+9eu27AweyP8WBsYAZjnMjJk4Y++aWtQu2bouL+DIhdkkC9iba2dmNIDgvxcdvjCwoOJ1ZXl6ep7RTVVV16saN4qOHDx9Jff318FCA+3FiAwDugk0vgvPinj17E69du/4De55S6pWVleWfOlWQfeFCYc7du9UlDx8+bHz4sLnxVMGZb8PDw8devnw5/vjx44uqq6v31tfXHzl06NB4Trsvvkg6dQOGchZQwj8/vxtwa2tr+4MHD+o6OzvbeW5B8XZV1Z3rbHxVnltaWpuY67h3v6Z8x460LSNHjgxftGjxUhyo7OjoaL18+adTnED4zFmz5ty8eesK71oY7U1NTfeQ4h47FS0tLY1ip6Gh8f7Ro7np06dPf8PL23vSpsQPl1dU3L7a2dnV0dbW3sraqtu3K69WV98rbmxqqu1CHiM9vrY0Nzc3pKSkrOjfv79vRkbGlJiYmFFFRUWrCwsL56elpQ2Dqfpywr8KWKSr61EXm17bu3d/Skho6BQiHjRkyJCg114LCUtL27mpuLjkgmza2trW9sMPh//5wQd/j6mpqa0RXRhwYd68ectu3Sq9Jn/j8P38kyezoeB7sGKC1IdJkyaFpKZ+FX/lytV8QAuGrry8/O8XLly4jJMsEzwNDQ21Bw8e2hkePuMvUFn0Xl62fEU09gvQ6RTbly79dDEx8aNE/HoFhrjANsljK0DKsIAthoDVIr3UqN6KHFYAJjq/AFxWXlG0YEHkfN6PwYY7BcZJhjwTnMCIiL/OLi6+eUXWcgrtO9J27rp/v0YJuHD//m8y2ts7hCHNe/ft3xEYODIUhwaT0/2x44wdN5wZMXly8J+vF924LHowpy07++C3ytPD5hcEKAQ9P6g+EL1BUHPUjBlvzC0puVkoa+rq6u4uW7Y8CpBDyX0LhgFFUXJWj7W6vNdCrw/FubtKS9Eih80kh58EvGHDpniS/SXmXKGCCcOACOlzFZhSW5xl448//iS+DbSy/tr1ohLw1sozp3bpxIkT38mznO7q2LjlOO1PPbJGv6+YYhjjnCOOBW7btu0jWSty/nyhAogILHgXvSAOxIP19hQdJ/wZTAGciv0sCQx0biLW68hTd+bFTQ2CowZoNYKqxjtVDQ0N5XWnuJakwzKl6fCFUod69vpXWFjYHBRG4qQD14UBTYYWwdHi/sNG336cVMBKpL6+oV7W375dVf0k4Ly8vO/lGcD3YmPXRGFrkIDFjjrbihMaBM4MQD5JSUlrZa0IutceIfK8Oz3jK39//zAJFreBsMyLAI15++3ZkRUVFUWypra2rnz58pURvHcErLbYZigB/geoUgChRgQN4btbRmZmonKzrKzs3QRhItHyxDEbQJoBXobcgR5QfXxW1oF0Uk+xPv9kwWko/UzAa9asW4zTAwmWHlsqHCKI0rQYw5RBycnJcbJWZN/+b7JuV1aWCqspUA+OHcvdN2tWxFvk8ERy+JX18RtiqO7nZF/k8YHsg9vd3d0DCYg1BNTA9i87q6eFQKsCQroT26ioqBlE7gqbPaJy1lGBk4KDXwkjZ/2gjA8U9+b+DZg06eXXtmz5NEHyU2gFUECtTVAWracBr18f/zdOwJUT1mVLBWDAS/cjBcUdSq+WtSLJyZ+lRC9duhJQhdSAlvb29jZoW3Pnzt0S8rWCPRtlTzKp48SJvNwxY8ZIg+NN7MywL+zpztXniIosJDcMyWMPnJtzq7T0nFRBrpJONr6UmZn50a5du9bt2rV7LcUoiaJ0WhyRNVLJY2JW/yM6eukKAN8Xp3sAK3KYSludkJD4PsFy6qGc4gTopgSwAUWlf2pq6kpZK7J1a/Jm2BNMnk5OSfkylvv2m9LSslzu8BOlpaX55eUVl9txTECXlZWXUFgjsT0E/y2kBe2x/1zpLacMaKlmFtDYY8mS6HC6lFSagxIpSkIfACoEjF1cRe3cy2U5OTlfREdHvw0DgqKiot8jj29xt7aeO3f+JHP75fnevfslmzZ9OBOnbGGSFvspAFM7VDkVqaL227dvj2Qpy1takpK2xvBuODXCmzTzpasKkO6K8QJNzISQkNCZOUeP7ZPrUAJEcI+PGz9+AteOHZTW7LH/X0VFVVVVjRPQkTYTmjkEBgb6E70pcXFx75Bjy47k5Oz48ccTGVBueWxsLG3cwmkBAQH+5KBcF84vvPDi0BUrVk5Zs2bNW7NnvzN95syZU6H5W+iHkhae0M4Yh5SUE0rLZ6Um+qZ0SP4bNya8uXbtulmkSxD7+wDYjVrRHxY4MRwYjvgmrerwiRMnRtDc5AlgusKa5ORtUQTH+QkG/SbpTd8un1byHawnwCWvEWcp+Zy8F72tF89u8o45O5wwpZgZMgxwzphKbMmcHb/9+O0HGDtOy5K1hsxrsU5ZQUUUeQwAbQCass6WX5dx48YPj176wdSoqKXTaSYEvAd0dURXPkSc8WsIpz0tPz8/W2jd3NzSmJ6euZo73eX3AhYRZ1Sgm3Ql0nvqsIk+GxqBzZjNeDSRBt+A09GVnKHKy6Xeh7VyzWgzJzq6Mi/FENpqMacu4HrsK6U3e6hILrNWi3UGxMf6k082v07Tc76yquoneub0qVOnSdH0J4hezA+lzoxbtSpmFalSISdMu1kE26YSGPsnUuZ3S28orgIYFa5NVQGkHHKN9bwTwwp69qyXQqTCdSMB+3nIO2qEct3TotDFpnywa+Kzydy5814qKrpxkLohRbPt5s2bF/iI2fjqq6+Gz5+/YC4fG3sePKivliuJktLG3CquJW8YZPpEyvxPonDqGeN58lvWPCkKeuO0HmnjGBoWFpSTcyyltra2hDr2kMuiU+jbXTw7Ovh8raFyn05M/HARYH04fSspgNh5MmX+0CKNiPy7SIMCaERF78fXli83TjgfL+tpPj7j+/br/PyTXx45krOVU42G6n8iOPJNbglYLhnFHfx/AVYpiusR0PLvH32Am0NxR3LWnWbHh+tpCN/Mvjx7U6BcAWoLI6TH1xEqSwqKjW5Tvya9ev0bEj8/qn9c7kYAAAAASUVORK5CYII=", h.tileXYToQuadKey = function (e, t, n) {
            for (var i = "", r = n; r >= 0; --r) {
                var o = 1 << r, a = 0;
                0 !== (e & o) && (a |= 1), 0 !== (t & o) && (a |= 2), i += a
            }
            return i
        }, h.quadKeyToTileXY = function (e) {
            for (var t = 0, n = 0, i = e.length - 1, r = i; r >= 0; --r) {
                var o = 1 << r, a = +e[i - r];
                0 !== (1 & a) && (t |= o), 0 !== (2 & a) && (n |= o)
            }
            return{x: t, y: n, level: i}
        }, h
    }), n("Scene/CameraController", ["../Core/defaultValue", "../Core/Cartesian2", "../Core/Cartesian3", "../Core/Cartesian4", "../Core/Cartographic", "../Core/DeveloperError", "../Core/Ellipsoid", "../Core/GeographicProjection", "../Core/IntersectionTests", "../Core/Math", "../Core/Matrix3", "../Core/Matrix4", "../Core/Quaternion", "../Core/Ray", "./SceneMode", "../ThirdParty/Tween"], function (e, t, n, i, r, o, a, s, u, l, c, d, f, h, p, m) {
        "use strict";
        function y(e, t) {
            var n = e._maxCoord.x * e.maximumTranslateFactor;
            t.x > n && (t.x = n), t.x < -n && (t.x = -n);
            var i = e._maxCoord.y * e.maximumTranslateFactor;
            t.y > i && (t.y = i), t.y < -i && (t.y = -i)
        }

        function v(e, t) {
            var i, r = e._camera;
            if ("undefined" != typeof t) {
                var o = n.clone(r.getPositionWC(), q), a = n.clone(r.getUpWC(), W), s = n.clone(r.getRightWC(), H), u = n.clone(r.getDirectionWC(), G);
                i = r.transform, r.transform = t.multiply(i);
                var l = r.getInverseTransform();
                n.clone(d.multiplyByVector(l, o, o), r.position), n.clone(d.multiplyByVector(l, a, a), r.up), n.clone(d.multiplyByVector(l, s, s), r.right), n.clone(d.multiplyByVector(l, u, u), r.direction)
            }
            return i
        }

        function g(e, t) {
            if ("undefined" != typeof t) {
                var i = e._camera, r = n.clone(i.getPositionWC(), j), o = n.clone(i.getUpWC(), Y), a = n.clone(i.getRightWC(), X), s = n.clone(i.getDirectionWC(), Z);
                i.transform = t, t = i.getInverseTransform(), r = n.clone(d.multiplyByVector(t, r, r), i.position), o = n.clone(d.multiplyByVector(t, o, o), i.up), a = n.clone(d.multiplyByVector(t, a, a), i.right), s = n.clone(d.multiplyByVector(t, s, s), i.direction)
            }
        }

        function _(e, t, i) {
            var r = e._camera, o = v(e, i), a = r.position, s = n.normalize(a, Q);
            if ("undefined" != typeof e.constrainedAxis) {
                var u = s.equalsEpsilon(e.constrainedAxis, l.EPSILON2), c = s.equalsEpsilon(e.constrainedAxis.negate(), l.EPSILON2);
                if (u || c)(u && 0 > t || c && t > 0) && e.rotate(r.right, t); else {
                    var d = n.normalize(e.constrainedAxis, $), f = s.dot(d), h = Math.acos(f);
                    t > 0 && t > h && (t = h), f = s.dot(d.negate()), h = Math.acos(f), 0 > t && -t > h && (t = -h);
                    var p = n.cross(d, s, et);
                    e.rotate(p, t)
                }
            } else e.rotate(r.right, t);
            g(e, o)
        }

        function w(e, t, n) {
            "undefined" != typeof e.constrainedAxis ? e.rotate(e.constrainedAxis, t, n) : e.rotate(e._camera.up, t, n)
        }

        function C(e, t) {
            var n = e._camera.frustum;
            if ("undefined" == typeof n.left || "undefined" == typeof n.right || "undefined" == typeof n.top || "undefined" == typeof n.bottom)throw new o("The camera frustum is expected to be orthographic for 2D camera control.");
            t = .5 * t;
            var i = n.right - t, r = n.left + t, a = e._maxCoord.x * e.maximumZoomFactor;
            i > a && (i = a, r = -a);
            var s = n.top / n.right;
            n.right = i, n.left = r, n.top = n.right * s, n.bottom = -n.top
        }

        function x(e, t) {
            var n = e._camera;
            e.move(n.direction, t)
        }

        function S(e, i) {
            var r = e._camera, o = .5 * -i.height, a = -o, s = r.frustum;
            if (a > o) {
                var u = s.top / s.right;
                s.right = a, s.left = o, s.top = s.right * u, s.bottom = -s.top
            }
            t.clone(e._projection.project(i), r.position), n.negate(n.UNIT_Z, r.direction), n.clone(n.UNIT_Y, r.up), n.clone(n.UNIT_X, r.right)
        }

        function b(e, t) {
            var i = e._camera, r = e._projection;
            i.position = r.project(t), n.negate(n.UNIT_Z, i.direction), n.clone(n.UNIT_Y, i.up), n.clone(n.UNIT_X, i.right)
        }

        function T(e, t) {
            var i = e._camera, r = e._projection.getEllipsoid();
            r.cartographicToCartesian(t, i.position), n.negate(i.position, i.direction), n.normalize(i.direction, i.direction), n.cross(i.direction, n.UNIT_Z, i.right), n.cross(i.right, i.direction, i.up), n.cross(i.direction, i.up, i.right)
        }

        function E(e, t, i, r, o) {
            var a = e;
            o && (a = st);
            var s = t.north, u = t.south, c = t.east, d = t.west;
            d > c && (c += l.TWO_PI);
            var f = tt;
            f.longitude = c, f.latitude = s;
            var h = i.cartographicToCartesian(f, nt);
            f.latitude = u;
            var p = i.cartographicToCartesian(f, ot);
            f.longitude = d;
            var m = i.cartographicToCartesian(f, it);
            f.latitude = s;
            var y = i.cartographicToCartesian(f, rt), v = n.subtract(h, m, at);
            n.multiplyByScalar(v, .5, v), n.add(m, v, v), n.subtract(y, v, y), n.subtract(p, v, p), n.subtract(h, v, h), n.subtract(m, v, m);
            var g = i.geodeticSurfaceNormal(v, a.direction);
            n.negate(g, g), n.normalize(g, g);
            var _ = n.cross(g, n.UNIT_Z, a.right);
            n.normalize(_, _);
            var w = n.cross(_, g, a.up), C = Math.max(Math.abs(w.dot(y)), Math.abs(w.dot(p)), Math.abs(w.dot(h)), Math.abs(w.dot(m))), x = Math.max(Math.abs(_.dot(y)), Math.abs(_.dot(p)), Math.abs(_.dot(h)), Math.abs(_.dot(m))), S = Math.tan(.5 * e.frustum.fovy), b = e.frustum.aspectRatio * S, T = Math.max(x / b, C / S), E = v.magnitude() + T;
            return n.normalize(v, v), n.multiplyByScalar(v, E, r)
        }

        function A(e, t, r, o, a) {
            var s = t.north, u = t.south, l = t.east, c = t.west, f = d.clone(e.transform, dt);
            f.setColumn(3, i.UNIT_W);
            var h = e.getInverseTransform(), p = ut;
            p.longitude = l, p.latitude = s;
            var m = r.project(p), y = n.clone(m, lt);
            d.multiplyByVector(f, y, y), d.multiplyByVector(h, y, y), p.longitude = c, p.latitude = u, m = r.project(p);
            var v = n.clone(m, ct);
            d.multiplyByVector(f, v, v), d.multiplyByVector(h, v, v);
            var g = Math.tan(.5 * e.frustum.fovy), _ = e.frustum.aspectRatio * g;
            if ("undefined" == typeof o && (o = new n), o.x = .5 * (y.x - v.x) + v.x, o.y = .5 * (y.y - v.y) + v.y, o.z = .5 * Math.max((y.x - v.x) / _, (y.y - v.y) / g), !a) {
                var w = n.clone(n.UNIT_Z, e.direction);
                n.negate(w, w), n.clone(n.UNIT_X, e.right), n.clone(n.UNIT_Y, e.up)
            }
            return o
        }

        function M(e, t, i, r, o) {
            var a = t.north, s = t.south, u = t.east, l = t.west, c = ft;
            c.longitude = u, c.latitude = a;
            var d = i.project(c, ht);
            c.longitude = l, c.latitude = s;
            var f, h, p = i.project(c, pt), m = .5 * Math.abs(d.x - p.x), y = .5 * Math.abs(d.y - p.y), v = e.frustum.right / e.frustum.top, g = y * v;
            if (m > g ? (f = m, h = f / v) : (h = y, f = g), y = Math.max(2 * f, 2 * h), "undefined" == typeof r && (r = new n), r.x = .5 * (d.x - p.x) + p.x, r.y = .5 * (d.y - p.y) + p.y, o)c = i.unproject(r, c), c.height = y, r = i.project(c, r); else {
                var _ = e.frustum;
                _.right = f, _.left = -f, _.top = h, _.bottom = -h;
                var w = n.clone(n.UNIT_Z, e.direction);
                n.negate(w, w), n.clone(n.UNIT_X, e.right), n.clone(n.UNIT_Y, e.up)
            }
            return r
        }

        function D(t, n, i, r) {
            i = e(i, a.WGS84);
            var o = t.getPickRay(n, mt), s = u.rayEllipsoid(o, i);
            return s ? o.getPoint(s.start, r) : void 0
        }

        function I(e, t, n, i) {
            var r = e.getPickRay(t, yt), o = r.origin;
            o.z = 0;
            var a = n.unproject(o);
            return a.latitude < -l.PI_OVER_TWO || a.latitude > l.PI_OVER_TWO || a.longitude < -Math.PI || a.longitude > Math.PI ? void 0 : n.getEllipsoid().cartographicToCartesian(a, i)
        }

        function P(e, t, i, r) {
            var o = e.getPickRay(t, vt), a = -o.origin.x / o.direction.x;
            o.getPoint(a, r);
            var s = i.unproject(new n(r.y, r.z, 0));
            return s.latitude < -l.PI_OVER_TWO || s.latitude > l.PI_OVER_TWO || s.longitude < -Math.PI || s.longitude > Math.PI ? void 0 : i.getEllipsoid().cartographicToCartesian(s, r)
        }

        function O(e, t, i) {
            var r = e._canvas.clientWidth, o = e._canvas.clientHeight, a = Math.tan(.5 * e.frustum.fovy), s = e.frustum.aspectRatio * a, u = e.frustum.near, l = 2 / r * t.x - 1, c = 2 / o * (o - t.y) - 1, d = e.getPositionWC();
            n.clone(d, i.origin);
            var f = n.multiplyByScalar(e.getDirectionWC(), u, gt);
            n.add(d, f, f);
            var h = n.multiplyByScalar(e.getRightWC(), l * u * s, _t), p = n.multiplyByScalar(e.getUpWC(), c * u * a, wt), m = n.add(f, h, i.direction);
            return n.add(m, p, m), n.subtract(m, d, m), n.normalize(m, m), i
        }

        function R(e, t, i) {
            var r = e._canvas.clientWidth, o = e._canvas.clientHeight, a = 2 / r * t.x - 1;
            a *= .5 * (e.frustum.right - e.frustum.left);
            var s = 2 / o * (o - t.y) - 1;
            s *= .5 * (e.frustum.top - e.frustum.bottom);
            var u = i.origin;
            return n.clone(e.position, u), u.x += a, u.y += s, n.clone(e.getDirectionWC(), i.direction), i
        }

        function z(e, t) {
            var n = e._camera, i = n.position, r = i.x < -e._maxCoord.x || i.x > e._maxCoord.x, o = i.y < -e._maxCoord.y || i.y > e._maxCoord.y, a = r || o, s = n.frustum, u = s.top, c = s.bottom, d = s.right, f = s.left, h = e._frustum, p = d > e._frustum.right;
            if (a || p) {
                var y = i.clone();
                y.x > e._maxCoord.x ? y.x = e._maxCoord.x : y.x < -e._maxCoord.x && (y.x = -e._maxCoord.x), y.y > e._maxCoord.y ? y.y = e._maxCoord.y : y.y < -e._maxCoord.y && (y.y = -e._maxCoord.y);
                var v = function (e) {
                    a && (n.position = i.lerp(y, e.time)), p && (n.frustum.top = l.lerp(u, h.top, e.time), n.frustum.bottom = l.lerp(c, h.bottom, e.time), n.frustum.right = l.lerp(d, h.right, e.time), n.frustum.left = l.lerp(f, h.left, e.time))
                };
                return{easingFunction: m.Easing.Exponential.Out, startValue: {time: 0}, stopValue: {time: 1}, duration: t, onUpdate: v}
            }
            return void 0
        }

        function L(e, t, r, o, a, s) {
            var u = t.clone();
            r.y > o ? u.y -= r.y - o : r.y < -o && (u.y += -o - r.y), r.z > a ? u.z -= r.z - a : r.z < -a && (u.z += -a - r.z);
            var l = e._camera, c = function (e) {
                var r = t.lerp(u, e.time), o = new i(r.x, r.y, r.z, 1);
                l.position = n.fromCartesian4(l.getInverseTransform().multiplyByVector(o))
            };
            return{easingFunction: m.Easing.Exponential.Out, startValue: {time: 0}, stopValue: {time: 1}, duration: s, onUpdate: c}
        }

        function N(e, t) {
            var r = e._camera, o = r.position, a = r.direction, s = n.fromCartesian4(r.getInverseTransform().multiplyByVector(i.UNIT_X)), u = -s.dot(o) / s.dot(a), l = o.add(a.multiplyByScalar(u));
            l = new i(l.x, l.y, l.z, 1);
            var c = r.transform.multiplyByVector(l), d = new i(r.position.x, r.position.y, r.position.z, 1), f = r.transform.multiplyByVector(d), h = Math.tan(.5 * e._camera.frustum.fovy), p = e._camera.frustum.aspectRatio * h, m = f.subtract(c).magnitude(), y = p * m, v = h * m, g = e._maxCoord.x, _ = e._maxCoord.y, w = Math.max(y - g, g), C = Math.max(v - _, _);
            if (f.z < -w || f.z > w || f.y < -C || f.y > C) {
                var x = c.y < -w || c.y > w, S = c.z < -C || c.z > C;
                if (x || S)return L(e, n.fromCartesian4(f), n.fromCartesian4(c), w, C, t)
            }
            return void 0
        }

        var F = function (e) {
            if ("undefined" == typeof e)throw new o("camera is required.");
            this._camera = e, this._mode = p.SCENE3D, this._projection = new s, this.defaultMoveAmount = 1e5, this.defaultLookAmount = Math.PI / 60, this.defaultRotateAmount = Math.PI / 3600, this.defaultZoomAmount = 1e5, this.constrainedAxis = void 0, this.maximumTranslateFactor = 1.5, this.maximumZoomFactor = 2.5, this._maxCoord = new n, this._frustum = void 0
        }, V = new r(Math.PI, l.PI_OVER_TWO);
        F.prototype.update = function (e, t) {
            var n = !1;
            e !== this._mode && (this._mode = e, n = this._mode === p.SCENE2D);
            var i = t.projection;
            if ("undefined" != typeof i && i !== this._projection && (this._projection = i, this._maxCoord = i.project(V, this._maxCoord)), n) {
                var r = this._frustum = this._camera.frustum.clone();
                if ("undefined" == typeof r.left || "undefined" == typeof r.right || "undefined" == typeof r.top || "undefined" == typeof r.bottom)throw new o("The camera frustum is expected to be orthographic for 2D camera control.");
                var a = 2, s = r.top / r.right;
                r.right = this._maxCoord.x * a, r.left = -r.right, r.top = s * r.right, r.bottom = -r.top
            }
        };
        var B = new n;
        F.prototype.move = function (e, t) {
            if ("undefined" == typeof e)throw new o("direction is required.");
            var i = this._camera.position;
            n.multiplyByScalar(e, t, B), n.add(i, B, i), this._mode === p.SCENE2D && y(this, i)
        }, F.prototype.moveForward = function (t) {
            t = e(t, this.defaultMoveAmount), this.move(this._camera.direction, t)
        }, F.prototype.moveBackward = function (t) {
            t = e(t, this.defaultMoveAmount), this.move(this._camera.direction, -t)
        }, F.prototype.moveUp = function (t) {
            t = e(t, this.defaultMoveAmount), this.move(this._camera.up, t)
        }, F.prototype.moveDown = function (t) {
            t = e(t, this.defaultMoveAmount), this.move(this._camera.up, -t)
        }, F.prototype.moveRight = function (t) {
            t = e(t, this.defaultMoveAmount), this.move(this._camera.right, t)
        }, F.prototype.moveLeft = function (t) {
            t = e(t, this.defaultMoveAmount), this.move(this._camera.right, -t)
        }, F.prototype.lookLeft = function (t) {
            t = e(t, this.defaultLookAmount), this.look(this._camera.up, -t)
        }, F.prototype.lookRight = function (t) {
            t = e(t, this.defaultLookAmount), this.look(this._camera.up, t)
        }, F.prototype.lookUp = function (t) {
            t = e(t, this.defaultLookAmount), this.look(this._camera.right, -t)
        }, F.prototype.lookDown = function (t) {
            t = e(t, this.defaultLookAmount), this.look(this._camera.right, t)
        };
        var k = new f, U = new c;
        F.prototype.look = function (t, n) {
            if ("undefined" == typeof t)throw new o("axis is required.");
            var i = e(n, this.defaultLookAmount), r = c.fromQuaternion(f.fromAxisAngle(t, i, k), U), a = this._camera.direction, s = this._camera.up, u = this._camera.right;
            c.multiplyByVector(r, a, a), c.multiplyByVector(r, s, s), c.multiplyByVector(r, u, u)
        }, F.prototype.twistLeft = function (t) {
            t = e(t, this.defaultLookAmount), this.look(this._camera.direction, t)
        }, F.prototype.twistRight = function (t) {
            t = e(t, this.defaultLookAmount), this.look(this._camera.direction, -t)
        };
        var q = i.UNIT_W.clone(), W = i.ZERO.clone(), H = i.ZERO.clone(), G = i.ZERO.clone(), j = i.UNIT_W.clone(), Y = i.ZERO.clone(), X = i.ZERO.clone(), Z = i.ZERO.clone(), K = new f, J = new c;
        F.prototype.rotate = function (t, i, r) {
            if ("undefined" == typeof t)throw new o("axis is required.");
            var a = this._camera, s = e(i, this.defaultRotateAmount), u = c.fromQuaternion(f.fromAxisAngle(t, s, K), J), l = v(this, r);
            c.multiplyByVector(u, a.position, a.position), c.multiplyByVector(u, a.direction, a.direction), c.multiplyByVector(u, a.up, a.up), n.cross(a.direction, a.up, a.right), n.cross(a.right, a.direction, a.up), g(this, l)
        }, F.prototype.rotateDown = function (t, n) {
            t = e(t, this.defaultRotateAmount), _(this, t, n)
        }, F.prototype.rotateUp = function (t, n) {
            t = e(t, this.defaultRotateAmount), _(this, -t, n)
        };
        var Q = new n, $ = new n, et = new n;
        F.prototype.rotateRight = function (t, n) {
            t = e(t, this.defaultRotateAmount), w(this, -t, n)
        }, F.prototype.rotateLeft = function (t, n) {
            t = e(t, this.defaultRotateAmount), w(this, t, n)
        }, F.prototype.zoomIn = function (t) {
            t = e(t, this.defaultZoomAmount), this._mode === p.SCENE2D ? C(this, t) : x(this, t)
        }, F.prototype.zoomOut = function (t) {
            t = e(t, this.defaultZoomAmount), this._mode === p.SCENE2D ? C(this, -t) : x(this, -t)
        }, F.prototype.getMagnitude = function () {
            var e = this._camera;
            return this._mode === p.SCENE3D ? e.position.magnitude() : this._mode === p.COLUMBUS_VIEW ? Math.abs(e.position.z) : this._mode === p.SCENE2D ? Math.max(e.frustum.right - e.frustum.left, e.frustum.top - e.frustum.bottom) : void 0
        }, F.prototype.setPositionCartographic = function (e) {
            if ("undefined" == typeof e)throw new o("cartographic is required.");
            this._mode === p.SCENE2D ? S(this, e) : this._mode === p.COLUMBUS_VIEW ? b(this, e) : this._mode === p.SCENE3D && T(this, e)
        }, F.prototype.lookAt = function (e, t, i) {
            if ("undefined" == typeof e)throw new o("eye is required");
            if ("undefined" == typeof t)throw new o("target is required");
            if ("undefined" == typeof i)throw new o("up is required");
            if (this._mode === p.SCENE2D)throw new o("lookAt is not supported in 2D mode because there is only one direction to look.");
            if (this._mode === p.MORPHING)throw new o("lookAt is not supported while morphing.");
            var r = this._camera;
            r.position = n.clone(e, r.position), r.direction = n.subtract(t, e, r.direction).normalize(r.direction), r.right = n.cross(r.direction, i, r.right).normalize(r.right), r.up = n.cross(r.right, r.direction, r.up)
        };
        var tt = new r, nt = new n, it = new n, rt = new n, ot = new n, at = new n, st = {direction: new n, right: new n, up: new n}, ut = new r, lt = i.UNIT_W.clone(), ct = i.UNIT_W.clone(), dt = new d, ft = new r, ht = new n, pt = new n;
        F.prototype.getExtentCameraCoordinates = function (e, t) {
            if ("undefined" == typeof e)throw new o("extent is required");
            return this._mode === p.SCENE3D ? E(this._camera, e, this._projection.getEllipsoid(), t, !0) : this._mode === p.COLUMBUS_VIEW ? A(this._camera, e, this._projection, t, !0) : this._mode === p.SCENE2D ? M(this._camera, e, this._projection, t, !0) : void 0
        }, F.prototype.viewExtent = function (t, n) {
            if ("undefined" == typeof t)throw new o("extent is required.");
            n = e(n, a.WGS84), this._mode === p.SCENE3D ? E(this._camera, t, n, this._camera.position) : this._mode === p.COLUMBUS_VIEW ? A(this._camera, t, this._projection, this._camera.position) : this._mode === p.SCENE2D && M(this._camera, t, this._projection, this._camera.position)
        };
        var mt = new h, yt = new h, vt = new h;
        F.prototype.pickEllipsoid = function (t, i, r) {
            if ("undefined" == typeof t)throw new o("windowPosition is required.");
            return"undefined" == typeof r && (r = new n), i = e(i, a.WGS84), this._mode === p.SCENE3D ? r = D(this, t, i, r) : this._mode === p.SCENE2D ? r = I(this, t, this._projection, r) : this._mode === p.COLUMBUS_VIEW && (r = P(this, t, this._projection, r)), r
        };
        var gt = new n, _t = new n, wt = new n;
        return F.prototype.getPickRay = function (e, t) {
            if ("undefined" == typeof e)throw new o("windowPosition is required.");
            "undefined" == typeof t && (t = new h);
            var n = this._camera, i = n.frustum;
            return"undefined" != typeof i.aspectRatio && "undefined" != typeof i.fovy && "undefined" != typeof i.near ? O(n, e, t) : R(n, e, t)
        }, F.prototype.createCorrectPositionAnimation = function (e) {
            if ("undefined" == typeof e)throw new o("duration is required.");
            return this._mode === p.SCENE2D ? z(this, e) : this._mode === p.COLUMBUS_VIEW ? N(this, e) : void 0
        }, F
    }), n("Scene/CullingVolume", ["../Core/defaultValue", "../Core/DeveloperError", "../Core/Intersect"], function (e, t, n) {
        "use strict";
        var i = function (t) {
            this.planes = e(t, [])
        };
        return i.prototype.getVisibility = function (e) {
            if ("undefined" == typeof e)throw new t("boundingVolume is required.");
            for (var i = this.planes, r = !1, o = 0, a = i.length; a > o; ++o) {
                var s = e.intersect(i[o]);
                if (s === n.OUTSIDE)return n.OUTSIDE;
                s === n.INTERSECTING && (r = !0)
            }
            return r ? n.INTERSECTING : n.INSIDE
        }, i
    }), n("Scene/PerspectiveOffCenterFrustum", ["../Core/DeveloperError", "../Core/defaultValue", "../Core/destroyObject", "../Core/Cartesian2", "../Core/Cartesian3", "../Core/Cartesian4", "../Core/Matrix4", "../Scene/CullingVolume"], function (e, t, n, i, r, o, a, s) {
        "use strict";
        function u(t) {
            if ("undefined" == typeof t.right || "undefined" == typeof t.left || "undefined" == typeof t.top || "undefined" == typeof t.bottom || " undefined" == typeof t.near || "undefined" == typeof t.far)throw new e("right, left, top, bottom, near, or far parameters are not set.");
            var n = t.top, i = t.bottom, r = t.right, o = t.left, s = t.near, u = t.far;
            if (n !== t._top || i !== t._bottom || o !== t._left || r !== t._right || s !== t._near || u !== t._far) {
                if (t.near <= 0 || t.near > t.far)throw new e("near must be greater than zero and less than far.");
                t._left = o, t._right = r, t._top = n, t._bottom = i, t._near = s, t._far = u, t._perspectiveMatrix = a.computePerspectiveOffCenter(o, r, i, n, s, u), t._infinitePerspective = a.computeInfinitePerspectiveOffCenter(o, r, i, n, s)
            }
        }

        var l = function () {
            this.left = void 0, this._left = void 0, this.right = void 0, this._right = void 0, this.top = void 0, this._top = void 0, this.bottom = void 0, this._bottom = void 0, this.near = 1, this._near = this.near, this.far = 5e8, this._far = this.far, this._cullingVolume = new s, this._perspectiveMatrix = void 0, this._infinitePerspective = void 0
        };
        l.prototype.getProjectionMatrix = function () {
            return u(this), this._perspectiveMatrix
        }, l.prototype.getInfiniteProjectionMatrix = function () {
            return u(this), this._infinitePerspective
        };
        var c = new r, d = new r, f = new r, h = new r;
        return l.prototype.computeCullingVolume = function (t, n, i) {
            if ("undefined" == typeof t)throw new e("position is required.");
            if ("undefined" == typeof n)throw new e("direction is required.");
            if ("undefined" == typeof i)throw new e("up is required.");
            var a = this._cullingVolume.planes, s = this.top, u = this.bottom, l = this.right, p = this.left, m = this.near, y = this.far, v = r.cross(n, i, c), g = d;
            r.multiplyByScalar(n, m, g), r.add(t, g, g);
            var _ = f;
            r.multiplyByScalar(n, y, _), r.add(t, _, _);
            var w = h;
            r.multiplyByScalar(v, p, w), r.add(g, w, w), r.subtract(w, t, w), r.normalize(w, w), r.cross(w, i, w);
            var C = a[0];
            return"undefined" == typeof C && (C = a[0] = new o), C.x = w.x, C.y = w.y, C.z = w.z, C.w = -r.dot(w, t), r.multiplyByScalar(v, l, w), r.add(g, w, w), r.subtract(w, t, w), r.normalize(w, w), r.cross(i, w, w), C = a[1], "undefined" == typeof C && (C = a[1] = new o), C.x = w.x, C.y = w.y, C.z = w.z, C.w = -r.dot(w, t), r.multiplyByScalar(i, u, w), r.add(g, w, w), r.subtract(w, t, w), r.normalize(w, w), r.cross(v, w, w), C = a[2], "undefined" == typeof C && (C = a[2] = new o), C.x = w.x, C.y = w.y, C.z = w.z, C.w = -r.dot(w, t), r.multiplyByScalar(i, s, w), r.add(g, w, w), r.subtract(w, t, w), r.normalize(w, w), r.cross(w, v, w), C = a[3], "undefined" == typeof C && (C = a[3] = new o), C.x = w.x, C.y = w.y, C.z = w.z, C.w = -r.dot(w, t), C = a[4], "undefined" == typeof C && (C = a[4] = new o), C.x = n.x, C.y = n.y, C.z = n.z, C.w = -r.dot(n, g), r.negate(n, w), C = a[5], "undefined" == typeof C && (C = a[5] = new o), C.x = w.x, C.y = w.y, C.z = w.z, C.w = -r.dot(w, _), this._cullingVolume
        }, l.prototype.getPixelSize = function (n, r) {
            if (u(this), "undefined" == typeof n)throw new e("canvasDimensions is required.");
            var o = n.x, a = n.y;
            if (0 >= o)throw new e("canvasDimensions.x must be greater than zero.");
            if (0 >= a)throw new e("canvasDimensions.y must be greater than zero.");
            r = t(r, this.near);
            var s = 1 / this.near, l = this.top * s, c = 2 * r * l / a;
            l = this.right * s;
            var d = 2 * r * l / o;
            return new i(d, c)
        }, l.prototype.clone = function () {
            var e = new l;
            return e.right = this.right, e.left = this.left, e.top = this.top, e.bottom = this.bottom, e.near = this.near, e.far = this.far, e
        }, l.prototype.equals = function (e) {
            return"undefined" != typeof e && this.right === e.right && this.left === e.left && this.top === e.top && this.bottom === e.bottom && this.near === e.near && this.far === e.far
        }, l
    }), n("Scene/PerspectiveFrustum", ["../Core/DeveloperError", "../Scene/PerspectiveOffCenterFrustum"], function (e, t) {
        "use strict";
        function n(t) {
            if ("undefined" == typeof t.fovy || "undefined" == typeof t.aspectRatio || "undefined" == typeof t.near || "undefined" == typeof t.far)throw new e("fovy, aspectRatio, near, or far parameters are not set.");
            var n = t._offCenterFrustum;
            if (t.fovy !== t._fovy || t.aspectRatio !== t._aspectRatio || t.near !== t._near || t.far !== t._far) {
                if (t.fovy < 0 || t.fovy >= Math.PI)throw new e("fovy must be in the range [0, PI).");
                if (t.aspectRatio < 0)throw new e("aspectRatio must be positive.");
                if (t.near < 0 || t.near > t.far)throw new e("near must be greater than zero and less than far.");
                t._fovy = t.fovy, t._aspectRatio = t.aspectRatio, t._near = t.near, t._far = t.far, n.top = t.near * Math.tan(.5 * t.fovy), n.bottom = -n.top, n.right = t.aspectRatio * n.top, n.left = -n.right, n.near = t.near, n.far = t.far
            }
        }

        var i = function () {
            this._offCenterFrustum = new t, this.fovy = void 0, this._fovy = void 0, this.aspectRatio = void 0, this._aspectRatio = void 0, this.near = 1, this._near = this.near, this.far = 5e8, this._far = this.far
        };
        return i.prototype.getProjectionMatrix = function () {
            return n(this), this._offCenterFrustum.getProjectionMatrix()
        }, i.prototype.getInfiniteProjectionMatrix = function () {
            return n(this), this._offCenterFrustum.getInfiniteProjectionMatrix()
        }, i.prototype.computeCullingVolume = function (e, t, i) {
            return n(this), this._offCenterFrustum.computeCullingVolume(e, t, i)
        }, i.prototype.getPixelSize = function (e, t) {
            return n(this), this._offCenterFrustum.getPixelSize(e, t)
        }, i.prototype.clone = function () {
            var e = new i;
            return e.fovy = this.fovy, e.aspectRatio = this.aspectRatio, e.near = this.near, e.far = this.far, e._offCenterFrustum = this._offCenterFrustum.clone(), e
        }, i.prototype.equals = function (e) {
            return"undefined" == typeof e ? !1 : (n(this), n(e), this.fovy === e.fovy && this.aspectRatio === e.aspectRatio && this.near === e.near && this.far === e.far && this._offCenterFrustum.equals(e._offCenterFrustum))
        }, i
    }), n("Scene/Camera", ["../Core/DeveloperError", "../Core/Math", "../Core/Ellipsoid", "../Core/Cartesian3", "../Core/Cartesian4", "../Core/Matrix4", "./CameraController", "./PerspectiveFrustum"], function (e, t, n, i, r, o, a, s) {
        "use strict";
        function u(e) {
            var t = e._right, n = e._up, i = e._direction, r = e._position, a = new o(t.x, t.y, t.z, -t.dot(r), n.x, n.y, n.z, -n.dot(r), -i.x, -i.y, -i.z, i.dot(r), 0, 0, 0, 1);
            e._viewMatrix = a.multiply(e._invTransform), e._invViewMatrix = e._viewMatrix.inverseTransformation()
        }

        function l(e) {
            var n = e._position, o = !n.equals(e.position);
            o && (n = e._position = e.position.clone());
            var a = e._direction, s = !a.equals(e.direction);
            s && (a = e._direction = e.direction.clone());
            var l = e._up, c = !l.equals(e.up);
            c && (l = e._up = e.up.clone());
            var d = e._right, f = !d.equals(e.right);
            f && (d = e._right = e.right.clone());
            var h = e._transform, p = !h.equals(e.transform);
            if (p && (h = e._transform = e.transform.clone(), e._invTransform = e._transform.inverseTransformation()), (o || p) && (e._positionWC = i.fromCartesian4(h.multiplyByPoint(n))), s || c || f) {
                var m = a.dot(l.cross(d));
                if (Math.abs(1 - m) > t.EPSILON2) {
                    a = e._direction = a.normalize(), e.direction = a.clone();
                    var y = 1 / l.magnitudeSquared(), v = l.dot(a) * y, g = a.multiplyByScalar(v);
                    l = e._up = l.subtract(g).normalize(), e.up = l.clone(), d = e._right = a.cross(l), e.right = d.clone()
                }
            }
            (s || p) && (e._directionWC = i.fromCartesian4(h.multiplyByVector(new r(a.x, a.y, a.z, 0)))), (c || p) && (e._upWC = i.fromCartesian4(h.multiplyByVector(new r(l.x, l.y, l.z, 0)))), (f || p) && (e._rightWC = i.fromCartesian4(h.multiplyByVector(new r(d.x, d.y, d.z, 0)))), (o || s || c || f || p) && u(e)
        }

        var c = function (r) {
            if ("undefined" == typeof r)throw new e("canvas is required.");
            this.transform = o.IDENTITY.clone(), this._transform = this.transform.clone(), this._invTransform = o.IDENTITY.clone();
            var l = n.WGS84.getMaximumRadius(), c = new i(0, -2, 1).normalize().multiplyByScalar(2.5 * l);
            this.position = c.clone(), this._position = c, this._positionWC = c;
            var d = i.ZERO.subtract(c).normalize();
            this.direction = d.clone(), this._direction = d, this._directionWC = d;
            var f = d.cross(i.UNIT_Z).normalize(), h = f.cross(d);
            this.up = h.clone(), this._up = h, this._upWC = h, f = d.cross(h), this.right = f.clone(), this._right = f, this._rightWC = f, this.frustum = new s, this.frustum.fovy = t.toRadians(60), this.frustum.aspectRatio = r.clientWidth / r.clientHeight, this.controller = new a(this), this._viewMatrix = void 0, this._invViewMatrix = void 0, u(this), this._canvas = r
        };
        return c.prototype.getInverseTransform = function () {
            return l(this), this._invTransform
        }, c.prototype.getViewMatrix = function () {
            return l(this), this._viewMatrix
        }, c.prototype.getInverseViewMatrix = function () {
            return l(this), this._invViewMatrix
        }, c.prototype.getPositionWC = function () {
            return l(this), this._positionWC
        }, c.prototype.getDirectionWC = function () {
            return l(this), this._directionWC
        }, c.prototype.getUpWC = function () {
            return l(this), this._upWC
        }, c.prototype.getRightWC = function () {
            return l(this), this._rightWC
        }, c.prototype.clone = function () {
            var e = new c(this._canvas);
            return e.position = this.position.clone(), e.direction = this.direction.clone(), e.up = this.up.clone(), e.right = this.right.clone(), e.transform = this.transform.clone(), e.frustum = this.frustum.clone(), e
        }, c.prototype.worldToCameraCoordinates = function (t, n) {
            if ("undefined" == typeof t)throw new e("cartesian is required.");
            return o.multiplyByVector(this.getInverseTransform(), t, n)
        }, c.prototype.cameraToWorldCoordinates = function (t, n) {
            if ("undefined" == typeof t)throw new e("cartesian is required.");
            return o.multiplyByVector(this.transform, t, n)
        }, c
    }), n("Scene/CameraEventType", ["../Core/Enumeration"], function (e) {
        "use strict";
        var t = {LEFT_DRAG: new e(0, "LEFT_DRAG"), RIGHT_DRAG: new e(1, "RIGHT_DRAG"), MIDDLE_DRAG: new e(2, "MIDDLE_DRAG"), WHEEL: new e(3, "WHEEL"), PINCH: new e(4, "PINCH")};
        return t
    }), n("Scene/CameraEventAggregator", ["../Core/DeveloperError", "../Core/destroyObject", "../Core/Math", "../Core/ScreenSpaceEventHandler", "../Core/ScreenSpaceEventType", "../Core/Cartesian2", "./CameraEventType"], function (e, t, n, i, r, o, a) {
        "use strict";
        var s = function (t, s, u) {
            if ("undefined" == typeof t)throw new e("description.canvas is required.");
            if ("undefined" == typeof s)throw new e("moveType is required.");
            this._eventHandler = new i(t), this._update = !0, this._movement = void 0, this._lastMovement = void 0, this._isDown = !1, this._pressTime = void 0, this._releaseTime = void 0;
            var l = this;
            if (s === a.PINCH)this._eventHandler.setInputAction(function () {
                l._isDown = !0, l._pressTime = new Date
            }, r.PINCH_START, u), this._eventHandler.setInputAction(function () {
                l._isDown = !1, l._releaseTime = new Date
            }, r.PINCH_END, u), this._eventHandler.setInputAction(function (e) {
                if (l._isDown) {
                    l._update ? (l._movement = e, l._update = !1, l._movement.prevAngle = l._movement.angleAndHeight.startPosition.x) : (l._movement.distance.endPosition = e.distance.endPosition.clone(), l._movement.angleAndHeight.endPosition = e.angleAndHeight.endPosition.clone());
                    for (var n = l._movement.angleAndHeight.endPosition.x, i = l._movement.prevAngle, r = 2 * Math.PI; n >= i + Math.PI;)n -= r;
                    for (; n < i - Math.PI;)n += r;
                    l._movement.angleAndHeight.endPosition.x = -n * t.clientWidth / 12, l._movement.angleAndHeight.startPosition.x = -i * t.clientWidth / 12
                }
            }, r.PINCH_MOVE, u); else if (s === a.WHEEL)this._eventHandler.setInputAction(function (e) {
                var t = 2 * n.toRadians(e);
                l._update ? (l._movement = {startPosition: new o, endPosition: new o(0, t), motion: new o}, l._lastMovement = l._movement, l._update = !1) : l._movement.endPosition.y = l._movement.endPosition.y + t, l._pressTime = new Date, l._releaseTime = new Date(l._pressTime.getTime() + 5 * Math.abs(t))
            }, r.WHEEL, u); else {
                var c, d;
                if (s === a.LEFT_DRAG)c = r.LEFT_DOWN, d = r.LEFT_UP; else if (s === a.RIGHT_DRAG)c = r.RIGHT_DOWN, d = r.RIGHT_UP; else {
                    if (s !== a.MIDDLE_DRAG)throw this._eventHandler = this._eventHandler && this._eventHandler.destroy(), new e("moveType must be of type CameraEventType.");
                    c = r.MIDDLE_DOWN, d = r.MIDDLE_UP
                }
                this._eventHandler.setInputAction(function () {
                    l._lastMovement = null, l._isDown = !0, l._pressTime = new Date
                }, c, u), this._eventHandler.setInputAction(function () {
                    l._isDown = !1, l._releaseTime = new Date
                }, d, u), this._eventHandler.setInputAction(function (e) {
                    l._isDown && (l._update ? (l._lastMovement = l._movement, l._movement = e, l._update = !1) : l._movement.endPosition = e.endPosition.clone())
                }, r.MOUSE_MOVE, u)
            }
        };
        return s.prototype.isMoving = function () {
            return!this._update
        }, s.prototype.getMovement = function () {
            var e = this._movement;
            return this._update = !0, e
        }, s.prototype.getLastMovement = function () {
            return this._lastMovement
        }, s.prototype.isButtonDown = function () {
            return this._isDown
        }, s.prototype.getButtonPressTime = function () {
            return this._pressTime
        }, s.prototype.getButtonReleaseTime = function () {
            return this._releaseTime
        }, s.prototype.isDestroyed = function () {
            return!1
        }, s.prototype.destroy = function () {
            return this._eventHandler = this._eventHandler && this._eventHandler.destroy(), t(this)
        }, s
    }), n("Scene/CameraFlightPath", ["../Core/Cartesian2", "../Core/Cartesian3", "../Core/clone", "../Core/defaultValue", "../Core/DeveloperError", "../Core/HermiteSpline", "../Core/Math", "../Core/Matrix3", "../Core/OrientationInterpolator", "../Core/Quaternion", "../Scene/PerspectiveFrustum", "../Scene/PerspectiveOffCenterFrustum", "../Scene/SceneMode", "../ThirdParty/Tween"], function (e, t, n, i, r, o, a, s, u, l, c, d, f, h) {
        "use strict";
        function p(e, t, n) {
            return e.cross(t, M), M.cross(e, D), A[0] = M.x, A[1] = D.x, A[2] = -e.x, A[3] = M.y, A[4] = D.y, A[5] = -e.y, A[6] = M.z, A[7] = D.z, A[8] = -e.z, l.fromRotationMatrix(A, n)
        }

        function m(e, t, n) {
            var i, r, o;
            if (e instanceof c) {
                var a = Math.tan(.5 * e.fovy);
                return i = e.near, r = e.near * a, o = e.aspectRatio * r, Math.max(t * i / o, n * i / r)
            }
            return e instanceof d ? (i = e.near, r = e.top, o = e.right, Math.max(t * i / o, n * i / r)) : Math.max(t, n)
        }

        function y(e) {
            if (e.length > 2)return new o(e);
            var n = e[0], i = e[1];
            return{getControlPoints: function () {
                return e
            }, evaluate: function (e, r) {
                e = a.clamp(e, n.time, i.time);
                var o = (e - n.time) / (i.time - n.time);
                return t.lerp(n.point, i.point, o, r)
            }}
        }

        function v(e, n, i, r, o) {
            var u, c, d, f = n.getMaximumRadius(), h = e.frustum, p = m(h, f, f), v = i.normalize().dot(r.normalize());
            if (i.magnitude() > p)c = f + .6 * (p - f), d = .35; else {
                var g = i.subtract(r);
                c = g.multiplyByScalar(.5).add(r).magnitude();
                var _ = e.up.multiplyByScalar(g.dot(e.up)).magnitude(), w = e.right.multiplyByScalar(g.dot(e.right)).magnitude();
                c += m(h, _, w), d = a.clamp(v + 1, .25, .5)
            }
            var C, x, S, b, T = r.normalize().multiplyByScalar(c), E = i.normalize().multiplyByScalar(c);
            if (r.magnitude() > p && v > .75)b = i.subtract(r).multiplyByScalar(.5).add(r), u = [
                {point: i},
                {point: b},
                {point: r}
            ]; else if (i.magnitude() > p && v > 0)b = i.subtract(T).multiplyByScalar(.5).add(T), u = [
                {point: i},
                {point: b},
                {point: r}
            ]; else {
                u = [
                    {point: i}
                ], x = Math.acos(E.normalize().dot(T.normalize())), C = E.cross(T), C.equalsEpsilon(t.ZERO, a.EPSILON6) && (C = t.UNIT_Z);
                for (var A = d * x, M = x - A, D = M; D > 0; D -= A)S = s.fromQuaternion(l.fromAxisAngle(C, D)), u.push({point: S.multiplyByVector(T)});
                u.push({point: r})
            }
            for (var I = o / (u.length - 1), P = 0; P < u.length; ++P)u[P].time = P * I;
            return y(u)
        }

        function g(e, n, i, r) {
            n[0].orientation = p(e.direction, e.up);
            for (var o, a = n.length - 1, s = 1; a > s; ++s)o = n[s], o.point.negate(I).normalize(I), I.cross(t.UNIT_Z, P).normalize(P), P.cross(I, O), o.orientation = p(I, O, R);
            return o = n[a], "undefined" != typeof i && "undefined" != typeof r ? o.orientation = p(i, r) : (o.point.negate(I).normalize(I), I.cross(t.UNIT_Z, P).normalize(P), P.cross(I, O), o.orientation = p(I, O, R)), new u(n)
        }

        function _(e, t, n, i, r) {
            var o = e.camera, a = e.scene2D.projection.getEllipsoid(), u = v(o, a, o.position, t, n), l = g(o, u.getControlPoints(), i, r), c = function (e) {
                var t = e.time, n = l.evaluate(t);
                s.fromQuaternion(n, E), o.position = u.evaluate(t, o.position), o.right = E.getRow(0, o.right), o.up = E.getRow(1, o.up), o.direction = E.getRow(2, o.direction).negate(o.direction)
            };
            return c
        }

        function w(e, n, i, r, o) {
            var s, u, l = n.getMaximumRadius(), c = e.frustum, d = m(c, Math.PI * l, a.PI_OVER_TWO * l), f = .5;
            if (i.z > d)u = .6 * d; else {
                var h = i.subtract(r);
                u = m(c, Math.abs(h.y), Math.abs(h.x))
            }
            var p = r.clone();
            p.z = u;
            var v = i.clone();
            v.z = u;
            var g;
            if (r.z > d)g = i.subtract(r).multiplyByScalar(.5).add(r), s = [
                {point: i},
                {point: g},
                {point: r}
            ]; else if (i.z > d)g = i.subtract(p).multiplyByScalar(.5).add(p), s = [
                {point: i},
                {point: g},
                {point: r}
            ]; else {
                s = [
                    {point: i}
                ];
                var _ = v.subtract(p), w = _.magnitude();
                t.normalize(_, _);
                for (var C = f * w, x = w - C, S = x; S > 0; S -= C)s.push({point: _.multiplyByScalar(S).add(p)});
                s.push({point: r})
            }
            for (var b = o / (s.length - 1), T = 0; T < s.length; ++T)s[T].time = T * b;
            return y(s)
        }

        function C(e, t, n, i) {
            t[0].orientation = p(e.direction, e.up);
            for (var r, o = t.length - 1, a = 1; o > a; ++a)r = t[a], r.orientation = F;
            return r = t[o], r.orientation = "undefined" != typeof n && "undefined" != typeof i ? p(n, i) : F, new u(t)
        }

        function x(e, t, n, i, r) {
            var o = e.camera, a = e.scene2D.projection.getEllipsoid(), u = w(o, a, o.position.clone(), t, n), l = C(o, u.getControlPoints(), i, r), c = function (e) {
                var t = e.time, n = l.evaluate(t);
                s.fromQuaternion(n, E), o.position = u.evaluate(t, o.position), o.right = E.getRow(0, o.right), o.up = E.getRow(1, o.up), o.direction = E.getRow(2, o.direction).negate(o.direction)
            };
            return c
        }

        function S(e, n, i, r, o) {
            var a = e.camera, u = e.scene2D.projection.getEllipsoid(), l = a.position.clone();
            l.z = a.frustum.right - a.frustum.left;
            var c = w(a, u, l, n, i), d = c.getControlPoints(), f = C(a, d, t.UNIT_Z.negate(), o), h = a.position.z, p = function (e) {
                var t = e.time, n = f.evaluate(t);
                s.fromQuaternion(n, E), a.position = c.evaluate(t, a.position);
                var i = a.position.z;
                a.position.z = h, a.right = E.getRow(0, a.right), a.up = E.getRow(1, a.up), a.direction = E.getRow(2, a.direction).negate(a.direction);
                var r = a.frustum, o = r.top / r.right, u = .5 * (i - (r.right - r.left));
                r.right += u, r.left -= u, r.top = o * r.right, r.bottom = -r.top
            };
            return p
        }

        var b = {}, T = new t, E = new s, A = new s, M = new t, D = new t, I = new t, P = new t, O = new t, R = new l, z = t.UNIT_Z.negate(), L = z.cross(t.UNIT_Y).normalize(), N = L.cross(z), F = p(z, N), V = new t, B = new t, k = new t;
        return b.createAnimation = function (n, o) {
            o = i(o, i.EMPTY_OBJECT);
            var s = o.destination;
            if ("undefined" == typeof n)throw new r("frameState is required.");
            if ("undefined" == typeof s)throw new r("destination is required.");
            if (n.mode === f.MORPHING)throw new r("frameState.mode cannot be SceneMode.MORPHING");
            var u = o.direction, l = o.up, c = i(o.duration, 3e3), d = o.onComplete, p = n.camera.frustum;
            if (n.mode === f.SCENE2D) {
                if (e.equalsEpsilon(n.camera.position, s, a.EPSILON6) && a.equalsEpsilon(Math.max(p.right - p.left, p.top - p.bottom), s.z, a.EPSILON6))return{duration: 0, onComplete: d}
            } else if (t.equalsEpsilon(s, n.camera.position, a.EPSILON6))return{duration: 0, onComplete: d};
            if (0 >= c) {
                var m = function () {
                    var e = s;
                    if (n.mode === f.SCENE3D ? ("undefined" == typeof o.direction && "undefined" == typeof o.up ? (V = e.negate(V).normalize(V), B = V.cross(t.UNIT_Z, B).normalize(B)) : (V = o.direction, B = V.cross(o.up, B).normalize(B)), k = i(o.up, B.cross(V, k))) : ("undefined" == typeof o.direction && "undefined" == typeof o.up ? (V = t.UNIT_Z.negate(V), B = V.cross(t.UNIT_Y, B).normalize(B)) : (V = o.direction, B = V.cross(o.up, B).normalize(B)), k = i(o.up, B.cross(V, k))), t.clone(e, n.camera.position), t.clone(V, n.camera.direction), t.clone(k, n.camera.up), t.clone(B, n.camera.right), n.mode === f.SCENE2D) {
                        var r = n.camera.position.z, a = p.top / p.right, u = .5 * (r - (p.right - p.left));
                        p.right += u, p.left -= u, p.top = a * p.right, p.bottom = -p.top
                    }
                    "function" == typeof d && d()
                };
                return{duration: 0, onComplete: m}
            }
            var y;
            return y = n.mode === f.SCENE3D ? _(n, s, c, u, l) : n.mode === f.SCENE2D ? S(n, s, c, u, l) : x(n, s, c, u, l), {duration: c, easingFunction: h.Easing.Sinusoidal.InOut, startValue: {time: 0}, stopValue: {time: c}, onUpdate: y, onComplete: d}
        }, b.createAnimationCartographic = function (e, t) {
            t = i(t, i.EMPTY_OBJECT);
            var o = t.destination;
            if ("undefined" == typeof e)throw new r("frameState is required.");
            if ("undefined" == typeof o)throw new r("description.destination is required.");
            var a = e.scene2D.projection;
            if (e.mode === f.SCENE3D) {
                var s = a.getEllipsoid();
                s.cartographicToCartesian(o, T)
            } else {
                if (e.mode !== f.COLUMBUS_VIEW && e.mode !== f.SCENE2D)throw new r("frameState.mode cannot be SceneMode.MORPHING");
                a.project(o, T)
            }
            var u = n(t);
            return u.destination = T, this.createAnimation(e, u)
        }, b.createAnimationExtent = function (e, t) {
            t = i(t, i.EMPTY_OBJECT);
            var o = t.destination;
            if ("undefined" == typeof e)throw new r("frameState is required.");
            if ("undefined" == typeof o)throw new r("description.destination is required.");
            if (e.mode === f.MORPHING)throw new r("frameState.mode cannot be SceneMode.MORPHING");
            var a = n(t), s = e.camera;
            return s.controller.getExtentCameraCoordinates(o, T), a.destination = T, this.createAnimation(e, a)
        }, b
    }), n("Scene/Imagery", ["../Core/destroyObject", "./ImageryState"], function (e, t) {
        "use strict";
        var n = function (e, n, i, r, o) {
            if (this.imageryLayer = e, this.x = n, this.y = i, this.level = r, 0 !== r) {
                var a = 0 | n / 2, s = 0 | i / 2, u = r - 1;
                this.parent = e.getImageryFromCache(a, s, u)
            }
            if (this.state = t.UNLOADED, this.imageUrl = void 0, this.image = void 0, this.texture = void 0, this.referenceCount = 0, "undefined" == typeof o && e.getImageryProvider().isReady()) {
                var l = e.getImageryProvider().getTilingScheme();
                o = l.tileXYToExtent(n, i, r)
            }
            this.extent = o
        };
        return n.createPlaceholder = function (e) {
            var i = new n(e, 0, 0, 0);
            return i.addReference(), i.state = t.PLACEHOLDER, i
        }, n.prototype.addReference = function () {
            ++this.referenceCount
        }, n.prototype.releaseReference = function () {
            return--this.referenceCount, 0 === this.referenceCount ? (this.imageryLayer.removeImageryFromCache(this), "undefined" != typeof this.parent && this.parent.releaseReference(), "undefined" != typeof this.image && "undefined" != typeof this.image.destroy && this.image.destroy(), "undefined" != typeof this.texture && "undefined" != typeof this.texture.destroy && this.texture.destroy(), e(this), 0) : this.referenceCount
        }, n
    }), n("Scene/TileImagery", ["./ImageryState"], function (e) {
        "use strict";
        var t = function (e, t) {
            this.readyImagery = void 0, this.loadingImagery = e, this.textureCoordinateExtent = t, this.textureTranslationAndScale = void 0
        };
        return t.prototype.freeResources = function () {
            "undefined" != typeof this.readyImagery && this.readyImagery.releaseReference(), "undefined" != typeof this.loadingImagery && this.loadingImagery.releaseReference()
        }, t.prototype.processStateMachine = function (t, n) {
            var i = this.loadingImagery, r = i.imageryLayer;
            if (i.state === e.UNLOADED && (i.state = e.TRANSITIONING, r._requestImagery(i)), i.state === e.RECEIVED && (i.state = e.TRANSITIONING, r._createTexture(n, i)), i.state === e.TEXTURE_LOADED && (i.state = e.TRANSITIONING, r._reprojectTexture(n, i)), i.state === e.READY)return"undefined" != typeof this.readyImagery && this.readyImagery.releaseReference(), this.readyImagery = this.loadingImagery, this.loadingImagery = void 0, this.textureTranslationAndScale = r._calculateTextureTranslationAndScale(t, this), !0;
            for (var o = i.parent, a = !1; "undefined" != typeof o && o.state !== e.READY;)a = a || o.state !== e.FAILED && o.state !== e.INVALID, o = o.parent;
            return this.readyImagery !== o && ("undefined" != typeof this.readyImagery && this.readyImagery.releaseReference(), this.readyImagery = o, "undefined" != typeof o && (o.addReference(), this.textureTranslationAndScale = r._calculateTextureTranslationAndScale(t, this))), a || i.state !== e.FAILED && i.state !== e.INVALID ? !1 : !0
        }, t
    }), n("Scene/TexturePool", ["../Core/destroyObject", "../Core/DeveloperError", "../Renderer/PixelDatatype", "../Renderer/PixelFormat", "../Renderer/Texture"], function (e, t, n, i, r) {
        "use strict";
        function o(e, t, n) {
            return"undefined" == typeof a && (a = function (e, t, n) {
                this._texture = e, this._textureTypeKey = t, this._pool = n
            }, Object.keys(r.prototype).forEach(function (e) {
                a.prototype[e] = function () {
                    var t = this._texture;
                    return t[e].apply(t, arguments)
                }
            }), a.prototype.destroy = function () {
                var e = this._pool._free[this._textureTypeKey];
                "undefined" == typeof e && (e = this._pool._free[this._textureTypeKey] = []), e.length >= 8 ? this._texture.destroy() : e.push(this)
            }), new a(e, t, n)
        }

        var a, s = function () {
            this._free = {}
        };
        return s.prototype.createTexture2D = function (e, r) {
            if (!r)throw new t("description is required.");
            var a = r.source, s = "undefined" != typeof a ? a.width : r.width, u = "undefined" != typeof a ? a.height : r.height, l = +(r.pixelFormat || i.RGBA), c = +(r.pixelDatatype || n.UNSIGNED_BYTE), d = +(r.preMultiplyAlpha || l === i.RGB || l === i.LUMINANCE), f = JSON.stringify([s, u, l, c, d]), h = this._free[f];
            if ("undefined" != typeof h && h.length > 0) {
                var p = h.pop();
                return"undefined" != typeof a && p.copyFrom(a), p
            }
            return o(e.createTexture2D(r), f, this)
        }, s.prototype.isDestroyed = function () {
            return!1
        }, s.prototype.destroy = function () {
            var t = this._free;
            return Object.keys(t).forEach(function (e) {
                t[e].forEach(function (e) {
                    e._texture.destroy()
                })
            }), e(this)
        }, s
    }), n("Shaders/ReprojectWebMercatorFS", [], function () {
        "use strict";
        return"uniform sampler2D u_texture;\nvarying vec2 v_textureCoordinates;\nvoid main()\n{\ngl_FragColor = texture2D(u_texture, v_textureCoordinates);\n}\n"
    }), n("Shaders/ReprojectWebMercatorVS", [], function () {
        "use strict";
        return"attribute vec4 position;\nuniform vec2 u_textureDimensions;\nuniform float u_northLatitude;\nuniform float u_southLatitude;\nuniform float u_southMercatorYHigh;\nuniform float u_southMercatorYLow;\nuniform float u_oneOverMercatorHeight;\nvarying vec2 v_textureCoordinates;\nvoid main()\n{\nfloat currentLatitude = mix(u_southLatitude, u_northLatitude, position.y);\nfloat fraction = czm_latitudeToWebMercatorFraction(currentLatitude, u_southMercatorYLow, u_southMercatorYHigh, u_oneOverMercatorHeight);\nv_textureCoordinates = vec2(position.x, fraction);\ngl_Position = czm_viewportOrthographic * (position * vec4(u_textureDimensions, 1.0, 1.0));\n}\n"
    }), n("Scene/ImageryLayer", ["../Core/defaultValue", "../Core/destroyObject", "../Core/BoundingRectangle", "../Core/ComponentDatatype", "../Core/Cartesian2", "../Core/Cartesian4", "../Core/Color", "../Core/Extent", "../Core/Math", "../Core/PrimitiveType", "../Core/Geometry", "../Core/GeometryAttribute", "../Renderer/BufferUsage", "../Renderer/MipmapHint", "../Renderer/TextureMagnificationFilter", "../Renderer/TextureMinificationFilter", "../Renderer/TextureWrap", "../Renderer/ClearCommand", "./GeographicTilingScheme", "./Imagery", "./TileProviderError", "./ImageryState", "./TileImagery", "./TerrainProvider", "./TexturePool", "../ThirdParty/when", "../Shaders/ReprojectWebMercatorFS", "../Shaders/ReprojectWebMercatorVS"], function (e, t, n, i, r, o, a, s, u, l, c, d, f, h, p, m, y, v, g, _, w, C, x, S, b, T, E, A) {
        "use strict";
        function M(e, t, n) {
            return JSON.stringify([e, t, n])
        }

        function D(t, r, o, s) {
            var u = r.cache.imageryLayer_reproject;
            if ("undefined" == typeof u) {
                u = r.cache.imageryLayer_reproject = {framebuffer: void 0, vertexArray: void 0, shaderProgram: void 0, renderState: void 0, sampler: void 0, destroy: function () {
                    "undefined" != typeof this.framebuffer && this.framebuffer.destroy(), "undefined" != typeof this.vertexArray && this.vertexArray.destroy(), "undefined" != typeof this.shaderProgram && this.shaderProgram.release()
                }}, u.framebuffer = r.createFramebuffer(), u.framebuffer.destroyAttachments = !1;
                for (var g = new Array(131072), _ = 0, w = 0; 256 > w; ++w)for (var C = w / 255, x = 0; 256 > x; ++x) {
                    var b = x / 255;
                    g[_++] = b, g[_++] = C
                }
                var T = new c({attributes: {position: new d({componentDatatype: i.FLOAT, componentsPerAttribute: 2, values: g})}, indices: S.getRegularGridIndices(256, 256), primitiveType: l.TRIANGLES}), M = {position: 0};
                u.vertexArray = r.createVertexArrayFromGeometry({geometry: T, attributeIndices: M, bufferUsage: f.STATIC_DRAW}), u.shaderProgram = r.getShaderCache().getShaderProgram(A, E, M);
                var D = r.getMaximumTextureFilterAnisotropy();
                u.sampler = r.createSampler({wrapS: y.CLAMP, wrapT: y.CLAMP, minificationFilter: m.LINEAR, magnificationFilter: p.LINEAR, maximumAnisotropy: Math.min(D, e(t._maximumAnisotropy, D))})
            }
            o.setSampler(u.sampler);
            var I = o.getWidth(), P = o.getHeight();
            O.textureDimensions.x = I, O.textureDimensions.y = P, O.texture = o, O.northLatitude = s.north, O.southLatitude = s.south;
            var z = Math.sin(s.south), L = .5 * Math.log((1 + z) / (1 - z));
            R[0] = L, O.southMercatorYHigh = R[0], O.southMercatorYLow = L - R[0], z = Math.sin(s.north);
            var N = .5 * Math.log((1 + z) / (1 - z));
            O.oneOverMercatorHeight = 1 / (N - L);
            var F = t._texturePool.createTexture2D(r, {width: I, height: P, pixelFormat: o.getPixelFormat(), pixelDatatype: o.getPixelDatatype(), preMultiplyAlpha: o.getPreMultiplyAlpha()});
            F.generateMipmap(h.NICEST), u.framebuffer.setColorTexture(F);
            var V = new v;
            return V.color = a.BLACK, V.framebuffer = u.framebuffer, V.execute(r), ("undefined" == typeof u.renderState || u.renderState.viewport.width !== I || u.renderState.viewport.height !== P) && (u.renderState = r.createRenderState({viewport: new n(0, 0, I, P)})), r.draw({framebuffer: u.framebuffer, shaderProgram: u.shaderProgram, renderState: u.renderState, primitiveType: l.TRIANGLES, vertexArray: u.vertexArray, uniformMap: O}), F
        }

        function I(e, t, n) {
            var i = e._imageryProvider, r = i.getTilingScheme(), o = r.getEllipsoid(), a = Math.cos(n), s = r.getExtent(), u = o.getMaximumRadius() * (s.east - s.west) * a / (i.getTileWidth() * r.getNumberOfXTilesAtLevel(0)), l = u / t, c = Math.log(l) / Math.log(2), d = Math.round(c);
            return 0 | d
        }

        var P = function z(t, n) {
            this._imageryProvider = t, n = e(n, {}), this.alpha = e(n.alpha, e(t.defaultAlpha, 1)), this.brightness = e(n.brightness, e(t.defaultBrightness, z.DEFAULT_BRIGHTNESS)), this.contrast = e(n.contrast, e(t.defaultContrast, z.DEFAULT_CONTRAST)), this.hue = e(n.hue, e(t.defaultHue, z.DEFAULT_HUE)), this.saturation = e(n.saturation, e(t.defaultSaturation, z.DEFAULT_SATURATION)), this.gamma = e(n.gamma, e(t.defaultGamma, z.DEFAULT_GAMMA)), this.show = e(n.show, !0), this._extent = e(n.extent, s.MAX_VALUE), this._maximumAnisotropy = n.maximumAnisotropy, this._imageryCache = {}, this._texturePool = new b, this._skeletonPlaceholder = new x(_.createPlaceholder(this)), this._show = !1, this._layerIndex = -1, this._isBaseLayer = !1, this._requestImageError = void 0
        };
        P.DEFAULT_BRIGHTNESS = 1, P.DEFAULT_CONTRAST = 1, P.DEFAULT_HUE = 0, P.DEFAULT_SATURATION = 1, P.DEFAULT_GAMMA = 1, P.prototype.getImageryProvider = function () {
            return this._imageryProvider
        }, P.prototype.getExtent = function () {
            return this._extent
        }, P.prototype.isBaseLayer = function () {
            return this._isBaseLayer
        }, P.prototype.isDestroyed = function () {
            return!1
        }, P.prototype.destroy = function () {
            return this._texturePool = this._texturePool && this._texturePool.destroy(), t(this)
        }, P.prototype._createTileImagerySkeletons = function (e, t, n) {
            var i = this._imageryProvider;
            if ("undefined" == typeof n && (n = e.imagery.length), !i.isReady())return this._skeletonPlaceholder.loadingImagery.addReference(), e.imagery.splice(n, 0, this._skeletonPlaceholder), !0;
            var r = e.extent.intersectWith(i.getExtent());
            if (r = r.intersectWith(this._extent), r.east <= r.west || r.north <= r.south) {
                if (!this.isBaseLayer())return!1;
                var a = i.getExtent().intersectWith(this._extent), s = e.extent;
                s.south >= a.north ? r.north = r.south = a.north : s.north <= a.south && (r.north = r.south = a.south), s.west >= a.east ? r.west = r.east = a.east : s.east <= a.west && (r.west = r.east = a.west)
            }
            var u = 0;
            r.south > 0 ? u = r.south : r.north < 0 && (u = r.north);
            var l = 1, c = l * t.getLevelMaximumGeometricError(e.level), d = I(this, c, u);
            d = Math.max(0, d);
            var f = i.getMaximumLevel();
            if (d > f && (d = f), "undefined" != typeof i.getMinimumLevel) {
                var h = i.getMinimumLevel();
                h > d && (d = h)
            }
            var p = i.getTilingScheme(), m = p.positionToTileXY(r.getNorthwest(), d), y = p.positionToTileXY(r.getSoutheast(), d), v = (e.extent.north - e.extent.south) / 512, g = (e.extent.east - e.extent.west) / 512, _ = p.tileXYToExtent(m.x, m.y, d);
            Math.abs(_.south - e.extent.north) < g && m.y < y.y && ++m.y, Math.abs(_.east - e.extent.west) < v && m.x < y.x && ++m.x;
            var w = p.tileXYToExtent(y.x, y.y, d);
            Math.abs(w.north - e.extent.south) < g && y.y > m.y && --y.y, Math.abs(w.west - e.extent.east) < v && y.x > m.x && --y.x;
            var C, S, b = e.extent, T = p.tileXYToExtent(m.x, m.y, d), E = 0, A = 1;
            !this.isBaseLayer() && Math.abs(T.west - e.extent.west) >= v && (E = Math.min(1, (T.west - b.west) / (b.east - b.west))), !this.isBaseLayer() && Math.abs(T.north - e.extent.north) >= g && (A = Math.max(0, (T.north - b.south) / (b.north - b.south)));
            for (var M = A, D = m.x; D <= y.x; D++) {
                C = E, T = p.tileXYToExtent(D, m.y, d), E = Math.min(1, (T.east - b.west) / (b.east - b.west)), D === y.x && (this.isBaseLayer() || Math.abs(T.east - e.extent.east) < v) && (E = 1), A = M;
                for (var P = m.y; P <= y.y; P++) {
                    S = A, T = p.tileXYToExtent(D, P, d), A = Math.max(0, (T.south - b.south) / (b.north - b.south)), P === y.y && (this.isBaseLayer() || Math.abs(T.south - e.extent.south) < g) && (A = 0);
                    var O = new o(C, A, E, S), R = this.getImageryFromCache(D, P, d, T);
                    e.imagery.splice(n, 0, new x(R, O)), ++n
                }
            }
            return!0
        }, P.prototype._calculateTextureTranslationAndScale = function (e, t) {
            var n = t.readyImagery.extent, i = e.extent, r = i.east - i.west, a = i.north - i.south, s = r / (n.east - n.west), u = a / (n.north - n.south);
            return new o(s * (i.west - n.west) / r, u * (i.south - n.south) / a, s, u)
        }, P.prototype._requestImagery = function (e) {
            function t(t) {
                return"undefined" == typeof t ? n() : (e.image = t, e.state = C.RECEIVED, w.handleSuccess(o._requestImageError), void 0)
            }

            function n() {
                e.state = C.FAILED;
                var t = "Failed to obtain image tile X: " + e.x + " Y: " + e.y + " Level: " + e.level + ".";
                o._requestImageError = w.handleError(o._requestImageError, r, r.getErrorEvent(), t, e.x, e.y, e.level, i)
            }

            function i() {
                e.state = C.TRANSITIONING;
                var i = r.requestImage(e.x, e.y, e.level);
                return"undefined" == typeof i ? (e.state = C.UNLOADED, void 0) : (T(i, t, n), void 0)
            }

            var r = this._imageryProvider, o = this;
            i()
        }, P.prototype._createTexture = function (e, t) {
            var n = this._imageryProvider;
            if ("undefined" != typeof n.getTileDiscardPolicy) {
                var i = n.getTileDiscardPolicy();
                if ("undefined" != typeof i) {
                    if (!i.isReady())return t.state = C.RECEIVED, void 0;
                    if (i.shouldDiscardImage(t.image))return t.state = C.INVALID, void 0
                }
            }
            var r = this._texturePool.createTexture2D(e, {source: t.image});
            t.texture = r, t.image = void 0, t.state = C.TEXTURE_LOADED
        }, P.prototype._reprojectTexture = function (t, n) {
            var i = n.texture, r = n.extent;
            if (!(this._imageryProvider.getTilingScheme()instanceof g) && (r.east - r.west) / i.getWidth() > 1e-5) {
                var o = D(this, t, i, n.extent);
                i.destroy(), n.texture = i = o
            }
            if (u.isPowerOfTwo(i.getWidth()) && u.isPowerOfTwo(i.getHeight())) {
                var a = t.cache.imageryLayer_mipmapSampler;
                if ("undefined" == typeof a) {
                    var s = t.getMaximumTextureFilterAnisotropy();
                    a = t.cache.imageryLayer_mipmapSampler = t.createSampler({wrapS: y.CLAMP, wrapT: y.CLAMP, minificationFilter: m.LINEAR_MIPMAP_LINEAR, magnificationFilter: p.LINEAR, maximumAnisotropy: Math.min(s, e(this._maximumAnisotropy, s))})
                }
                i.generateMipmap(h.NICEST), i.setSampler(a)
            } else {
                var l = t.cache.imageryLayer_nonMipmapSampler;
                "undefined" == typeof l && (l = t.cache.imageryLayer_nonMipmapSampler = t.createSampler({wrapS: y.CLAMP, wrapT: y.CLAMP, minificationFilter: m.LINEAR, magnificationFilter: p.LINEAR})), i.setSampler(l)
            }
            n.state = C.READY
        }, P.prototype.getImageryFromCache = function (e, t, n, i) {
            var r = M(e, t, n), o = this._imageryCache[r];
            return"undefined" == typeof o && (o = new _(this, e, t, n, i), this._imageryCache[r] = o), o.addReference(), o
        }, P.prototype.removeImageryFromCache = function (e) {
            var t = M(e.x, e.y, e.level);
            delete this._imageryCache[t]
        };
        var O = {u_textureDimensions: function () {
            return this.textureDimensions
        }, u_texture: function () {
            return this.texture
        }, u_northLatitude: function () {
            return this.northLatitude
        }, u_southLatitude: function () {
            return this.southLatitude
        }, u_southMercatorYLow: function () {
            return this.southMercatorYLow
        }, u_southMercatorYHigh: function () {
            return this.southMercatorYHigh
        }, u_oneOverMercatorHeight: function () {
            return this.oneOverMercatorHeight
        }, textureDimensions: new r, texture: void 0, northLatitude: 0, southLatitude: 0, southMercatorYHigh: 0, southMercatorYLow: 0, oneOverMercatorHeight: 0}, R = "undefined" != typeof Float32Array ? new Float32Array(1) : void 0;
        return P
    }), n("Scene/TileReplacementQueue", ["./ImageryState", "./TerrainState"], function (e, t) {
        "use strict";
        function n(e, t) {
            var n = t.replacementPrevious, i = t.replacementNext;
            t === e._lastBeforeStartOfFrame && (e._lastBeforeStartOfFrame = i), t === e.head ? e.head = i : n.replacementNext = i, t === e.tail ? e.tail = n : i.replacementPrevious = n, t.replacementPrevious = void 0, t.replacementNext = void 0, --e.count
        }

        var i = function () {
            this.head = void 0, this.tail = void 0, this.count = 0, this._lastBeforeStartOfFrame = void 0
        };
        return i.prototype.markStartOfRenderFrame = function () {
            this._lastBeforeStartOfFrame = this.head
        }, i.prototype.trimTiles = function (i) {
            for (var r = this.tail, o = !0; o && "undefined" != typeof this._lastBeforeStartOfFrame && this.count > i && "undefined" != typeof r;) {
                o = r !== this._lastBeforeStartOfFrame;
                for (var a = r.replacementPrevious, s = r.loadedTerrain, u = "undefined" != typeof s && (s.state === t.RECEIVING || s.state === t.TRANSFORMING), l = r.upsampledTerrain, c = "undefined" != typeof l && (l.state === t.RECEIVING || l.state === t.TRANSFORMING), d = !u && !c, f = r.imagery, h = 0, p = f.length; d && p > h; ++h) {
                    var m = f[h];
                    d = "undefined" == typeof m.loadingImagery || m.loadingImagery.state !== e.TRANSITIONING
                }
                d && (r.freeResources(), n(this, r)), r = a
            }
        }, i.prototype.markTileRendered = function (e) {
            var t = this.head;
            return t === e ? (e === this._lastBeforeStartOfFrame && (this._lastBeforeStartOfFrame = e.replacementNext), void 0) : (++this.count, "undefined" == typeof t ? (e.replacementPrevious = void 0, e.replacementNext = void 0, this.head = e, this.tail = e, void 0) : (("undefined" != typeof e.replacementPrevious || "undefined" != typeof e.replacementNext) && n(this, e), e.replacementPrevious = void 0, e.replacementNext = t, t.replacementPrevious = e, this.head = e, void 0))
        }, i
    }), n("Scene/CentralBodySurface", ["../Core/defaultValue", "../Core/destroyObject", "../Core/BoundingSphere", "../Core/Cartesian2", "../Core/Cartesian3", "../Core/Cartesian4", "../Core/EllipsoidGeometry", "../Core/DeveloperError", "../Core/Ellipsoid", "../Core/EllipsoidalOccluder", "../Core/Intersect", "../Core/Matrix4", "../Core/PrimitiveType", "../Core/Queue", "../Core/WebMercatorProjection", "../Renderer/DrawCommand", "./ImageryLayer", "./ImageryState", "./SceneMode", "./TerrainProvider", "./TileReplacementQueue", "./TileState"], function (e, t, n, i, r, o, a, s, u, l, c, d, f, h, p, m, y, v, g, _, w, C) {
        "use strict";
        function x(e, t) {
            var n = e.loadingImagery;
            "undefined" == typeof n && (n = e.readyImagery);
            var i = t.loadingImagery;
            return"undefined" == typeof i && (i = t.readyImagery), n.imageryLayer._layerIndex - i.imageryLayer._layerIndex
        }

        function S(e) {
            if (e._imageryLayerCollection._update(), e._layerOrderChanged) {
                e._layerOrderChanged = !1;
                for (var t = e._tileReplacementQueue.head; "undefined" != typeof t;)t.imagery.sort(x), t = t.replacementNext
            }
        }

        function b(e, t, n) {
            var i = e._debug;
            if (!i.suspendLodUpdate) {
                var r, o, a = e._tilesToRenderByTextureCount;
                for (r = 0, o = a.length; o > r; ++r) {
                    var s = a[r];
                    "undefined" != typeof s && (s.length = 0)
                }
                var u = e._tileTraversalQueue;
                if (u.clear(), i.maxDepth = 0, i.tilesVisited = 0, i.tilesCulled = 0, i.tilesRendered = 0, i.texturesRendered = 0, i.tilesWaitingForChildren = 0, e._tileLoadQueue.length = 0, e._tileReplacementQueue.markStartOfRenderFrame(), "undefined" == typeof e._levelZeroTiles) {
                    if (!e._terrainProvider.isReady())return;
                    var l = e._terrainProvider.getTilingScheme();
                    e._levelZeroTiles = l.createLevelZeroTiles()
                }
                var c = n.camera.getPositionWC(), d = e._terrainProvider.getTilingScheme().getEllipsoid(), f = d.cartesianToCartographic(c);
                e._ellipsoidalOccluder.setCameraPosition(c);
                var h, p = e._levelZeroTiles;
                for (r = 0, o = p.length; o > r; ++r)h = p[r], e._tileReplacementQueue.markTileRendered(h), h.state !== C.READY && P(e, h), h.isRenderable && M(e, n, h) ? u.enqueue(h) : (++i.tilesCulled, h.isRenderable || ++i.tilesWaitingForChildren);
                for (; "undefined" != typeof(h = u.dequeue());)if (++i.tilesVisited, e._tileReplacementQueue.markTileRendered(h), h.level > i.maxDepth && (i.maxDepth = h.level), T(e, t, n, c, f, h) < e._maxScreenSpaceError)A(e, h); else if (I(e, n, h)) {
                    var m = h.children;
                    for (r = 0, o = m.length; o > r; ++r)M(e, n, m[r]) ? u.enqueue(m[r]) : ++i.tilesCulled
                } else++i.tilesWaitingForChildren, A(e, h);
                i.enableDebugOutput && (i.tilesVisited !== i.lastTilesVisited || i.tilesRendered !== i.lastTilesRendered || i.texturesRendered !== i.lastTexturesRendered || i.tilesCulled !== i.lastTilesCulled || i.maxDepth !== i.lastMaxDepth || i.tilesWaitingForChildren !== i.lastTilesWaitingForChildren) && (console.log("Visited " + i.tilesVisited + ", Rendered: " + i.tilesRendered + ", Textures: " + i.texturesRendered + ", Culled: " + i.tilesCulled + ", Max Depth: " + i.maxDepth + ", Waiting for children: " + i.tilesWaitingForChildren), i.lastTilesVisited = i.tilesVisited, i.lastTilesRendered = i.tilesRendered, i.lastTexturesRendered = i.texturesRendered, i.lastTilesCulled = i.tilesCulled, i.lastMaxDepth = i.maxDepth, i.lastTilesWaitingForChildren = i.tilesWaitingForChildren)
            }
        }

        function T(e, t, n, i, r, o) {
            if (n.mode === g.SCENE2D)return E(e, t, n, i, r, o);
            var a = o.extent, s = 1;
            if (n.mode === g.SCENE3D) {
                var u = 0;
                a.south > 0 ? u = a.south : a.north < 0 && (u = a.north), s = Math.cos(u)
            }
            var l = s * e._terrainProvider.getLevelMaximumGeometricError(o.level), c = Math.sqrt(D(n, i, r, o));
            o.distance = c;
            var d = t.getCanvas(), f = d.clientHeight, h = n.camera, p = h.frustum, m = p.fovy;
            return l * f / (2 * c * Math.tan(.5 * m))
        }

        function E(e, t, n, i, r, o) {
            var a = n.camera, s = a.frustum, u = t.getCanvas(), l = u.clientWidth, c = u.clientHeight, d = e._terrainProvider.getLevelMaximumGeometricError(o.level), f = Math.max(s.top - s.bottom, s.right - s.left) / Math.max(l, c);
            return d / f
        }

        function A(e, t) {
            for (var n = 0, i = t.imagery, r = 0, o = i.length; o > r; ++r) {
                var a = i[r];
                "undefined" != typeof a.readyImagery && 0 !== a.readyImagery.imageryLayer.alpha && ++n
            }
            var s = e._tilesToRenderByTextureCount[n];
            "undefined" == typeof s && (s = [], e._tilesToRenderByTextureCount[n] = s), s.push(t);
            var u = e._debug;
            ++u.tilesRendered, u.texturesRendered += n
        }

        function M(e, t, i) {
            var o = t.cullingVolume, a = i.boundingSphere3D;
            if (t.mode !== g.SCENE3D && (a = V, n.fromExtentWithHeights2D(i.extent, t.scene2D.projection, i.minimumHeight, i.maximumHeight, a), a.center = new r(a.center.z, a.center.x, a.center.y), t.mode === g.MORPHING && (a = n.union(i.boundingSphere3D, a, a))), o.getVisibility(a) === c.OUTSIDE)return!1;
            if (t.mode === g.SCENE3D) {
                var s = i.occludeePointInScaledSpace;
                return"undefined" == typeof s ? !0 : e._ellipsoidalOccluder.isScaledSpacePointVisible(s)
            }
            return!0
        }

        function D(e, t, n, i) {
            var o = i.southwestCornerCartesian, a = i.northeastCornerCartesian, s = i.westNormal, u = i.southNormal, l = i.eastNormal, c = i.northNormal, d = i.maximumHeight;
            e.mode !== g.SCENE3D && (o = e.scene2D.projection.project(i.extent.getSouthwest(), B), o.z = o.y, o.y = o.x, o.x = 0, a = e.scene2D.projection.project(i.extent.getNortheast(), k), a.z = a.y, a.y = a.x, a.x = 0, s = U, l = r.UNIT_Y, u = q, c = r.UNIT_Z, d = 0);
            var f, h = t.subtract(o, W), p = h.dot(s), m = h.dot(u), y = t.subtract(a, W), v = y.dot(l), _ = y.dot(c);
            f = e.mode === g.SCENE3D ? n.height : t.x;
            var w = f - d, C = 0;
            return p > 0 ? C += p * p : v > 0 && (C += v * v), m > 0 ? C += m * m : _ > 0 && (C += _ * _), w > 0 && (C += w * w), C
        }

        function I(e, t, n) {
            for (var i = !0, r = n.getChildren(), o = 0, a = r.length; a > o; ++o) {
                var s = r[o];
                e._tileReplacementQueue.markTileRendered(s), s.state !== C.READY && P(e, s), s.isRenderable || (i = !1)
            }
            return i
        }

        function P(e, t) {
            e._tileLoadQueue.push(t)
        }

        function O(e, t) {
            var n = e._tileLoadQueue, i = e._terrainProvider, r = e._imageryLayerCollection;
            if (0 !== n.length) {
                e._tileReplacementQueue.trimTiles(e._tileCacheSize);
                for (var o = Date.now(), a = e._loadQueueTimeSlice, s = o + a, u = n.length - 1, l = u; l >= 0; --l) {
                    var c = n[l];
                    if (e._tileReplacementQueue.markTileRendered(c), c.processStateMachine(t, i, r), Date.now() >= s)break
                }
            }
        }

        function R(e, t) {
            return e.distance - t.distance
        }

        function z() {
            return{u_center3D: function () {
                return this.center3D
            }, u_tileExtent: function () {
                return this.tileExtent
            }, u_modifiedModelView: function () {
                return this.modifiedModelView
            }, u_dayTextures: function () {
                return this.dayTextures
            }, u_dayTextureTranslationAndScale: function () {
                return this.dayTextureTranslationAndScale
            }, u_dayTextureTexCoordsExtent: function () {
                return this.dayTextureTexCoordsExtent
            }, u_dayTextureAlpha: function () {
                return this.dayTextureAlpha
            }, u_dayTextureBrightness: function () {
                return this.dayTextureBrightness
            }, u_dayTextureContrast: function () {
                return this.dayTextureContrast
            }, u_dayTextureHue: function () {
                return this.dayTextureHue
            }, u_dayTextureSaturation: function () {
                return this.dayTextureSaturation
            }, u_dayTextureOneOverGamma: function () {
                return this.dayTextureOneOverGamma
            }, u_dayIntensity: function () {
                return this.dayIntensity
            }, u_southAndNorthLatitude: function () {
                return this.southAndNorthLatitude
            }, u_southMercatorYLowAndHighAndOneOverHeight: function () {
                return this.southMercatorYLowAndHighAndOneOverHeight
            }, u_waterMask: function () {
                return this.waterMask
            }, u_waterMaskTranslationAndScale: function () {
                return this.waterMaskTranslationAndScale
            }, center3D: void 0, modifiedModelView: new d, tileExtent: new o, dayTextures: [], dayTextureTranslationAndScale: [], dayTextureTexCoordsExtent: [], dayTextureAlpha: [], dayTextureBrightness: [], dayTextureContrast: [], dayTextureHue: [], dayTextureSaturation: [], dayTextureOneOverGamma: [], dayIntensity: 0, southAndNorthLatitude: new i, southMercatorYLowAndHighAndOneOverHeight: new r, waterMask: void 0, waterMaskTranslationAndScale: new o}
        }

        function L(e, t) {
            for (var n in t)t.hasOwnProperty(n) && (e[n] = t[n])
        }

        function N(e, t, i, a, s, u, l, c) {
            for (var h = i.camera.getViewMatrix(), w = t.getMaximumTextureImageUnits(), C = e._tileCommands, x = e._tileCommandUniformMaps, S = -1, b = e._tilesToRenderByTextureCount, T = 0, E = b.length; E > T; ++T) {
                var A = b[T];
                if ("undefined" != typeof A && 0 !== A.length) {
                    A.sort(R);
                    for (var M = 0, D = A.length; D > M; M++) {
                        var I = A[M], P = I.center, O = j, N = 0, F = 0, V = 0, B = 0, k = 0;
                        if (i.mode !== g.SCENE3D) {
                            var U = s.project(I.extent.getSouthwest()), q = s.project(I.extent.getNortheast());
                            if (O.x = U.x, O.y = U.y, O.z = q.x, O.w = q.y, i.mode !== g.MORPHING && (P = Y, P.x = 0, P.y = .5 * (O.z + O.x), P.z = .5 * (O.w + O.y), O.x -= P.y, O.y -= P.z, O.z -= P.y, O.w -= P.z), s instanceof p) {
                                N = I.extent.south, F = I.extent.north;
                                var W = p.geodeticLatitudeToMercatorAngle(N), Z = p.geodeticLatitudeToMercatorAngle(F);
                                H[0] = W, V = H[0], B = W - H[0], k = 1 / (Z - W)
                            }
                        }
                        var K = X;
                        K.x = P.x, K.y = P.y, K.z = P.z, K.w = 1, d.multiplyByVector(h, K, K), h.setColumn(3, K, G);
                        var J = I.imagery, Q = 0, $ = J.length;
                        do {
                            var et = 0;
                            ++S;
                            var tt = C[S];
                            "undefined" == typeof tt && (tt = new m, tt.owner = I, tt.cull = !1, C[S] = tt, x[S] = z()), tt.owner = I, tt.debugShowBoundingVolume = I === e._debug.boundingSphereTile;
                            var nt = x[S];
                            L(nt, u), nt.center3D = I.center, o.clone(O, nt.tileExtent), nt.southAndNorthLatitude.x = N, nt.southAndNorthLatitude.y = F, nt.southMercatorYLowAndHighAndOneOverHeight.x = B, nt.southMercatorYLowAndHighAndOneOverHeight.y = V, nt.southMercatorYLowAndHighAndOneOverHeight.z = k, d.clone(G, nt.modifiedModelView);
                            for (var it = !1, rt = !1, ot = !1, at = !1, st = !1, ut = !1; w > et && $ > Q;) {
                                var lt = J[Q], ct = lt.readyImagery;
                                if (++Q, "undefined" != typeof ct && ct.state === v.READY && 0 !== ct.imageryLayer.alpha) {
                                    var dt = ct.imageryLayer;
                                    "undefined" == typeof lt.textureTranslationAndScale && (lt.textureTranslationAndScale = dt._calculateTextureTranslationAndScale(I, lt)), nt.dayTextures[et] = ct.texture, nt.dayTextureTranslationAndScale[et] = lt.textureTranslationAndScale, nt.dayTextureTexCoordsExtent[et] = lt.textureCoordinateExtent, nt.dayTextureAlpha[et] = "function" == typeof dt.alpha ? dt.alpha(i, dt, ct.x, ct.y, ct.level) : dt.alpha, ut = ut || 1 !== nt.dayTextureAlpha[et], nt.dayTextureBrightness[et] = "function" == typeof dt.brightness ? dt.brightness(i, dt, ct.x, ct.y, ct.level) : dt.brightness, it = it || nt.dayTextureBrightness[et] !== y.DEFAULT_BRIGHTNESS, nt.dayTextureContrast[et] = "function" == typeof dt.contrast ? dt.contrast(i, dt, ct.x, ct.y, ct.level) : dt.contrast, rt = rt || nt.dayTextureContrast[et] !== y.DEFAULT_CONTRAST, nt.dayTextureHue[et] = "function" == typeof dt.hue ? dt.hue(i, dt, ct.x, ct.y, ct.level) : dt.hue, ot = ot || nt.dayTextureHue[et] !== y.DEFAULT_HUE, nt.dayTextureSaturation[et] = "function" == typeof dt.saturation ? dt.saturation(i, dt, ct.x, ct.y, ct.level) : dt.saturation, at = at || nt.dayTextureSaturation[et] !== y.DEFAULT_SATURATION, nt.dayTextureOneOverGamma[et] = "function" == typeof dt.gamma ? 1 / dt.gamma(i, dt, ct.x, ct.y, ct.level) : 1 / dt.gamma, st = st || nt.dayTextureOneOverGamma[et] !== 1 / y.DEFAULT_GAMMA, ++et
                                }
                            }
                            nt.dayTextures.length = et, nt.waterMask = I.waterMaskTexture, o.clone(I.waterMaskTranslationAndScale, nt.waterMaskTranslationAndScale), l.push(tt), tt.shaderProgram = a.getShaderProgram(t, T, it, rt, ot, at, st, ut), tt.renderState = c, tt.primitiveType = _.wireframe ? f.LINES : f.TRIANGLES, tt.vertexArray = I.vertexArray, tt.uniformMap = nt;
                            var ft = I.boundingSphere3D;
                            i.mode !== g.SCENE3D && (ft = n.fromExtentWithHeights2D(I.extent, i.scene2D.projection, I.minimumHeight, I.maximumHeight), ft.center = new r(ft.center.z, ft.center.x, ft.center.y), i.mode === g.MORPHING && (ft = n.union(I.boundingSphere3D, ft, ft))), tt.boundingVolume = ft
                        } while ($ > Q)
                    }
                }
            }
            C.length = Math.max(0, S + 1)
        }

        var F = function (t) {
            if ("undefined" == typeof t.terrainProvider)throw new s("description.terrainProvider is required.");
            if ("undefined" == typeof t.imageryLayerCollection)throw new s("description.imageryLayerCollection is required.");
            this._terrainProvider = t.terrainProvider, this._imageryLayerCollection = t.imageryLayerCollection, this._maxScreenSpaceError = e(t.maxScreenSpaceError, 2), this._imageryLayerCollection.layerAdded.addEventListener(F.prototype._onLayerAdded, this), this._imageryLayerCollection.layerRemoved.addEventListener(F.prototype._onLayerRemoved, this), this._imageryLayerCollection.layerMoved.addEventListener(F.prototype._onLayerMoved, this), this._imageryLayerCollection.layerShownOrHidden.addEventListener(F.prototype._onLayerShownOrHidden, this), this._layerOrderChanged = !1;
            var n = this._terrainProvider.getTilingScheme();
            this._levelZeroTiles = void 0, this._tilesToRenderByTextureCount = [], this._tileCommands = [], this._tileCommandUniformMaps = [], this._tileTraversalQueue = new h, this._tileLoadQueue = [], this._tileReplacementQueue = new w, this._tileCacheSize = 100, this._loadQueueTimeSlice = 5;
            var i = n.getEllipsoid();
            this._ellipsoidalOccluder = new l(i, r.ZERO), this._debug = {enableDebugOutput: !1, boundingSphereTile: void 0, maxDepth: 0, tilesVisited: 0, tilesCulled: 0, tilesRendered: 0, texturesRendered: 0, tilesWaitingForChildren: 0, lastMaxDepth: -1, lastTilesVisited: -1, lastTilesCulled: -1, lastTilesRendered: -1, lastTexturesRendered: -1, lastTilesWaitingForChildren: -1, suspendLodUpdate: !1}
        };
        F.prototype.update = function (e, t, n, i, r, o, a) {
            S(this), b(this, e, t), O(this, e, t), N(this, e, t, r, a, i, n, o)
        }, F.prototype.getTerrainProvider = function () {
            return this._terrainProvider
        }, F.prototype.setTerrainProvider = function (e) {
            if (this._terrainProvider !== e) {
                if ("undefined" == typeof e)throw new s("terrainProvider is required.");
                this._terrainProvider = e;
                var t = this._tileReplacementQueue;
                t.head = void 0, t.tail = void 0, t.count = 0;
                var n = this._levelZeroTiles;
                if ("undefined" != typeof n)for (var i = 0; i < n.length; ++i)n[i].freeResources();
                this._levelZeroTiles = void 0
            }
        }, F.prototype._onLayerAdded = function (e) {
            if ("undefined" != typeof this._levelZeroTiles && e.show) {
                for (var t = this._tileReplacementQueue.head; "undefined" != typeof t;)e._createTileImagerySkeletons(t, this._terrainProvider) && (t.state = C.LOADING), t = t.replacementNext;
                this._layerOrderChanged = !0
            }
        }, F.prototype._onLayerRemoved = function (e) {
            if ("undefined" != typeof this._levelZeroTiles)for (var t = this._tileReplacementQueue.head; "undefined" != typeof t;) {
                for (var n = t.imagery, i = -1, r = 0, o = 0, a = n.length; a > o; ++o) {
                    var s = n[o], u = s.loadingImagery;
                    if ("undefined" == typeof u && (u = s.readyImagery), u.imageryLayer === e)-1 === i && (i = o), s.freeResources(), ++r; else if (-1 !== i)break
                }
                -1 !== i && n.splice(i, r), e.isBaseLayer() && (t.isRenderable = !1), t = t.replacementNext
            }
        }, F.prototype._onLayerMoved = function () {
            "undefined" != typeof this._levelZeroTiles && (this._layerOrderChanged = !0)
        }, F.prototype._onLayerShownOrHidden = function (e, t, n) {
            "undefined" != typeof this._levelZeroTiles && (n ? this._onLayerAdded(e, t) : this._onLayerRemoved(e, t))
        }, F.prototype.isDestroyed = function () {
            return!1
        }, F.prototype.destroy = function () {
            var e = this._levelZeroTiles;
            if ("undefined" != typeof e)for (var n = 0; n < e.length; ++n)e[n].freeResources();
            return this._imageryLayerCollection.destroy(), t(this)
        };
        var V = new n, B = new r, k = new r, U = r.UNIT_Y.negate(), q = r.UNIT_Z.negate(), W = new r;
        F.prototype.debugShowBoundingSphereOfTileAt = function (e) {
            for (var t, n, i = this._tilesToRenderByTextureCount, r = 0; r < i.length && "undefined" == typeof t; ++r) {
                var o = i[r];
                if ("undefined" != typeof o)for (var a = 0; a < o.length; ++a)if (n = o[a], n.extent.contains(e)) {
                    t = n;
                    break
                }
            }
            "undefined" != typeof t && console.log("x: " + t.x + " y: " + t.y + " level: " + t.level + " radius: " + t.boundingSphere3D.radius + " center magnitude: " + t.boundingSphere3D.center.magnitude()), this._debug.boundingSphereTile = t
        }, F.prototype.debugToggleLodUpdate = function () {
            this._debug.suspendLodUpdate = !this._debug.suspendLodUpdate
        };
        var H = "undefined" != typeof Float32Array ? new Float32Array(1) : void 0, G = new d, j = new o, Y = new r, X = new o;
        return F
    }), n("Scene/CentralBodySurfaceShaderSet", ["../Core/destroyObject", "../Core/defaultValue"], function (e) {
        "use strict";
        function t(e) {
            this.baseVertexShaderString = void 0, this.baseFragmentShaderString = void 0, this._attributeIndices = e, this._shaders = {}
        }

        function n(e, t, n, i, r, o, a) {
            var s = "";
            return s += e, s += t ? "_brightness" : "", s += n ? "_contrast" : "", s += i ? "_hue" : "", s += r ? "_saturation" : "", s += o ? "_gamma" : "", s += a ? "_alpha" : ""
        }

        return t.prototype.invalidateShaders = function () {
            var e = this._shaders;
            for (var t in e)e.hasOwnProperty(t) && e[t].release();
            this._shaders = {}
        }, t.prototype.getShaderProgram = function (e, t, i, r, o, a, s, u) {
            var l = n(t, i, r, o, a, s, u), c = this._shaders[l];
            if ("undefined" == typeof c) {
                for (var d = this.baseVertexShaderString, f = (i ? "#define APPLY_BRIGHTNESS\n" : "") + (r ? "#define APPLY_CONTRAST\n" : "") + (o ? "#define APPLY_HUE\n" : "") + (a ? "#define APPLY_SATURATION\n" : "") + (s ? "#define APPLY_GAMMA\n" : "") + (u ? "#define APPLY_ALPHA\n" : "") + "#define TEXTURE_UNITS " + t + "\n" + this.baseFragmentShaderString + "\n" + "vec3 computeDayColor(vec3 initialColor, vec2 textureCoordinates)\n" + "{\n" + "    vec3 color = initialColor;\n", h = 0; t > h; ++h)f += "color = sampleAndBlend(\n   color,\n   u_dayTextures[" + h + "],\n" + "   textureCoordinates,\n" + "   u_dayTextureTexCoordsExtent[" + h + "],\n" + "   u_dayTextureTranslationAndScale[" + h + "],\n" + "   u_dayTextureAlpha[" + h + "],\n" + "   u_dayTextureBrightness[" + h + "],\n" + "   u_dayTextureContrast[" + h + "],\n" + "   u_dayTextureHue[" + h + "],\n" + "   u_dayTextureSaturation[" + h + "],\n" + "   u_dayTextureOneOverGamma[" + h + "]);\n";
                f += "    return color;\n}", c = e.getShaderCache().getShaderProgram(d, f, this._attributeIndices), this._shaders[l] = c
            }
            return c
        }, t.prototype.destroy = function () {
            return this.invalidateShaders(), e(this)
        }, t
    }), n("Scene/CreditDisplay", ["../Core/defaultValue", "../Core/destroyObject", "../Core/DeveloperError", "./Credit"], function (e, t, n, i) {
        "use strict";
        function r(e, t, n) {
            if ("undefined" == typeof e.element) {
                var i = e.getText(), r = e.getLink(), o = document.createElement("span");
                if (e.hasLink()) {
                    var a = document.createElement("a");
                    a.textContent = i, a.href = r, a.target = "_blank", o.appendChild(a)
                } else o.textContent = i;
                o.className = "cesium-credit-text", e.element = o
            }
            if (t.hasChildNodes()) {
                var s = document.createElement("span");
                s.textContent = n, s.className = "cesium-credit-delimiter", t.appendChild(s)
            }
            t.appendChild(e.element)
        }

        function o(e, t) {
            if ("undefined" == typeof e.element) {
                var n = e.getText(), i = e.getLink(), r = document.createElement("span"), o = document.createElement("img");
                if (o.src = e.getImageUrl(), o.style["vertical-align"] = "bottom", "undefined" != typeof n && (o.alt = n, o.title = n), e.hasLink()) {
                    var a = document.createElement("a");
                    a.appendChild(o), a.href = i, a.target = "_blank", r.appendChild(a)
                } else r.appendChild(o);
                r.className = "cesium-credit-image", e.element = r
            }
            t.appendChild(e.element)
        }

        function a(e, t) {
            for (var n = e.length, r = 0; n > r; r++) {
                var o = e[r];
                if (i.equals(o, t))return!0
            }
            return!1
        }

        function s(e) {
            var t = e.element;
            if ("undefined" != typeof t) {
                var n = t.parentNode;
                if (!e.hasImage()) {
                    var i = t.previousSibling;
                    null === i && (i = t.nextSibling), null !== i && n.removeChild(i)
                }
                n.removeChild(t)
            }
        }

        function u(e, t) {
            var n, i, o, a = e._displayedCredits.textCredits;
            for (n = 0; n < t.length; n++)o = t[n], i = a.indexOf(o), -1 === i ? r(o, e._textContainer, e._delimiter) : a.splice(i, 1);
            for (n = 0; n < a.length; n++)o = a[n], s(o)
        }

        function l(e, t) {
            var n, i, r, a = e._displayedCredits.imageCredits;
            for (n = 0; n < t.length; n++)r = t[n], i = a.indexOf(r), -1 === i ? o(r, e._imageContainer) : a.splice(i, 1);
            for (n = 0; n < a.length; n++)r = a[n], s(r)
        }

        var c = function (t, i) {
            if ("undefined" == typeof t)throw new n("credit container is required");
            var r = document.createElement("span");
            r.className = "cesium-credit-imageContainer";
            var o = document.createElement("span");
            o.className = "cesium-credit-textContainer", t.appendChild(r), t.appendChild(o), this._delimiter = e(i, " • "), this._container = t, this._textContainer = o, this._imageContainer = r, this._defaultImageCredits = [], this._defaultTextCredits = [], this._displayedCredits = {imageCredits: [], textCredits: []}, this._currentFrameCredits = {imageCredits: [], textCredits: []}
        };
        return c.prototype.addCredit = function (e) {
            if ("undefined" == typeof e)throw new n("credit must be defined");
            if (e.hasImage()) {
                var t = this._currentFrameCredits.imageCredits;
                a(t, e) || a(this._defaultImageCredits, e) || t.push(e)
            } else {
                var i = this._currentFrameCredits.textCredits;
                a(i, e) || a(this._defaultTextCredits, e) || i.push(e)
            }
        }, c.prototype.addDefaultCredit = function (e) {
            if ("undefined" == typeof e)throw new n("credit must be defined");
            if (e.hasImage()) {
                var t = this._defaultImageCredits;
                a(t, e) || t.push(e)
            } else {
                var i = this._defaultTextCredits;
                a(i, e) || i.push(e)
            }
        }, c.prototype.removeDefaultCredit = function (e) {
            if ("undefined" == typeof e)throw new n("credit must be defined");
            var t;
            e.hasImage() ? (t = this._defaultImageCredits.indexOf(e), -1 !== t && this._defaultImageCredits.splice(t, 1)) : (t = this._defaultTextCredits.indexOf(e), -1 !== t && this._defaultTextCredits.splice(t, 1))
        }, c.prototype.beginFrame = function () {
            this._currentFrameCredits.imageCredits.length = 0, this._currentFrameCredits.textCredits.length = 0
        }, c.prototype.endFrame = function () {
            var e = this._defaultTextCredits.concat(this._currentFrameCredits.textCredits), t = this._defaultImageCredits.concat(this._currentFrameCredits.imageCredits);
            u(this, e), l(this, t), this._displayedCredits.textCredits = e, this._displayedCredits.imageCredits = t
        }, c.prototype.destroy = function () {
            return this._container.removeChild(this._textContainer), this._container.removeChild(this._imageContainer), t(this)
        }, c.prototype.isDestroyed = function () {
            return!1
        }, c
    }), n("Scene/EllipsoidTerrainProvider", ["../Core/defaultValue", "../Core/Ellipsoid", "../Core/Event", "./HeightmapTerrainData", "./TerrainProvider", "./GeographicTilingScheme"], function (e, t, n, i, r, o) {
        "use strict";
        var a = function (a) {
            a = e(a, {}), this._tilingScheme = a.tilingScheme, "undefined" == typeof this._tilingScheme && (this._tilingScheme = new o({ellipsoid: e(a.ellipsoid, t.WGS84)})), this._levelZeroMaximumGeometricError = r.getEstimatedLevelZeroGeometricErrorForAHeightmap(this._tilingScheme.getEllipsoid(), 64, this._tilingScheme.getNumberOfXTilesAtLevel(0));
            var s = 16, u = 16;
            this._terrainData = new i({buffer: new Uint8Array(s * u), width: 16, height: 16}), this._errorEvent = new n
        };
        return a.prototype.requestTileGeometry = function () {
            return this._terrainData
        }, a.prototype.getErrorEvent = function () {
            return this._errorEvent
        }, a.prototype.getLevelMaximumGeometricError = function (e) {
            return this._levelZeroMaximumGeometricError / (1 << e)
        }, a.prototype.getCredit = function () {
            return void 0
        }, a.prototype.getTilingScheme = function () {
            return this._tilingScheme
        }, a.prototype.hasWaterMask = function () {
            return!1
        }, a.prototype.isReady = function () {
            return!0
        }, a
    }), n("Scene/ImageryLayerCollection", ["../Core/DeveloperError", "../Core/defaultValue", "../Core/destroyObject", "../Core/Event", "../Core/Math", "./ImageryLayer"], function (e, t, n, i, r, o) {
        "use strict";
        function a(t, n) {
            if ("undefined" == typeof n)throw new e("layer is required.");
            var i = t.indexOf(n);
            if (-1 === i)throw new e("layer is not in this collection.");
            return i
        }

        function s(e, t, n) {
            var i = e._layers;
            if (t = r.clamp(t, 0, i.length - 1), n = r.clamp(n, 0, i.length - 1), t !== n) {
                var o = i[t];
                i[t] = i[n], i[n] = o, e._update(), e.layerMoved.raiseEvent(o, n, t)
            }
        }

        var u = function () {
            this._layers = [], this.layerAdded = new i, this.layerRemoved = new i, this.layerMoved = new i, this.layerShownOrHidden = new i
        };
        return u.prototype.add = function (t, n) {
            if ("undefined" == typeof t)throw new e("layer is required.");
            if ("undefined" == typeof n)n = this._layers.length, this._layers.push(t); else {
                if (0 > n)throw new e("index must be greater than or equal to zero.");
                if (n > this._layers.length)throw new e("index must be less than or equal to the number of layers.");
                this._layers.splice(n, 0, t)
            }
            this._update(), this.layerAdded.raiseEvent(t, n)
        }, u.prototype.addImageryProvider = function (t, n) {
            if ("undefined" == typeof t)throw new e("imageryProvider is required.");
            var i = new o(t);
            return this.add(i, n), i
        }, u.prototype.remove = function (e, n) {
            n = t(n, !0);
            var i = this._layers.indexOf(e);
            return-1 !== i ? (this._layers.splice(i, 1), this._update(), this.layerRemoved.raiseEvent(e, i), n && e.destroy(), !0) : !1
        }, u.prototype.removeAll = function (e) {
            e = t(e, !0);
            for (var n = this._layers, i = 0, r = n.length; r > i; i++) {
                var o = n[i];
                this.layerRemoved.raiseEvent(o, i), e && o.destroy()
            }
            this._layers = []
        }, u.prototype.contains = function (e) {
            return-1 !== this.indexOf(e)
        }, u.prototype.indexOf = function (e) {
            return this._layers.indexOf(e)
        }, u.prototype.get = function (t) {
            if ("undefined" == typeof t)throw new e("index is required.", "index");
            return this._layers[t]
        }, u.prototype.getLength = function () {
            return this._layers.length
        }, u.prototype.raise = function (e) {
            var t = a(this._layers, e);
            s(this, t, t + 1)
        }, u.prototype.lower = function (e) {
            var t = a(this._layers, e);
            s(this, t, t - 1)
        }, u.prototype.raiseToTop = function (e) {
            var t = a(this._layers, e);
            t !== this._layers.length - 1 && (this._layers.splice(t, 1), this._layers.push(e), this._update(), this.layerMoved.raiseEvent(e, this._layers.length - 1, t))
        }, u.prototype.lowerToBottom = function (e) {
            var t = a(this._layers, e);
            0 !== t && (this._layers.splice(t, 1), this._layers.splice(0, 0, e), this._update(), this.layerMoved.raiseEvent(e, 0, t))
        }, u.prototype.isDestroyed = function () {
            return!1
        }, u.prototype.destroy = function () {
            return this.removeAll(!0), n(this)
        }, u.prototype._update = function () {
            for (var e, t, n = !0, i = this._layers, r = 0, o = i.length; o > r; ++r)t = i[r], t._layerIndex = r, t.show ? (t._isBaseLayer = n, n = !1) : t._isBaseLayer = !1, t.show !== t._show && ("undefined" != typeof t._show && ("undefined" == typeof e && (e = []), e.push(t)), t._show = t.show);
            if ("undefined" != typeof e)for (r = 0, o = e.length; o > r; ++r)t = e[r], this.layerShownOrHidden.raiseEvent(t, t._layerIndex, t.show)
        }, u
    }), n("Shaders/ViewportQuadVS", [], function () {
        "use strict";
        return"attribute vec4 position;\nattribute vec2 textureCoordinates;\nvarying vec2 v_textureCoordinates;\nvoid main()\n{\ngl_Position = position;\nv_textureCoordinates = textureCoordinates;\n}\n"
    }), n("Shaders/ViewportQuadFS", [], function () {
        "use strict";
        return"varying vec2 v_textureCoordinates;\nvoid main()\n{\nczm_materialInput materialInput;\nmaterialInput.s = v_textureCoordinates.s;\nmaterialInput.st = v_textureCoordinates;\nmaterialInput.str = vec3(v_textureCoordinates, 0.0);\nmaterialInput.normalEC = vec3(0.0, 0.0, -1.0);\nczm_material material = czm_getMaterial(materialInput);\ngl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n}\n"
    }), n("Scene/ViewportQuad", ["../Core/Color", "../Core/combine", "../Core/destroyObject", "../Core/defaultValue", "../Core/DeveloperError", "../Core/BoundingRectangle", "../Core/ComponentDatatype", "../Core/PrimitiveType", "../Core/Geometry", "../Core/GeometryAttribute", "./Material", "../Renderer/BufferUsage", "../Renderer/BlendingState", "../Renderer/CommandLists", "../Renderer/DrawCommand", "../Shaders/ViewportQuadVS", "../Shaders/ViewportQuadFS"], function (e, t, n, i, r, o, a, s, u, l, c, d, f, h, p, m, y) {
        "use strict";
        function v(e) {
            var t = e.cache.viewportQuad_vertexArray;
            if ("undefined" != typeof t)return t;
            var n = new u({attributes: {position: new l({componentDatatype: a.FLOAT, componentsPerAttribute: 2, values: [-1, -1, 1, -1, 1, 1, -1, 1]}), textureCoordinates: new l({componentDatatype: a.FLOAT, componentsPerAttribute: 2, values: [0, 0, 1, 0, 1, 1, 0, 1]})}, primitiveType: s.TRIANGLES});
            return t = e.createVertexArrayFromGeometry({geometry: n, attributeIndices: _, bufferUsage: d.STATIC_DRAW}), e.cache.viewportQuad_vertexArray = t, t
        }

        var g = function (t, n) {
            this._va = void 0, this._overlayCommand = new p, this._overlayCommand.primitiveType = s.TRIANGLE_FAN, this._overlayCommand.owner = this, this._commandLists = new h, this._commandLists.overlayList.push(this._overlayCommand), this.show = !0, "undefined" == typeof t && (t = new o), this.rectangle = o.clone(t), "undefined" == typeof n && (n = c.fromType(void 0, c.ColorType), n.uniforms.color = new e(1, 1, 1, 1)), this.material = n, this._material = void 0
        }, _ = {position: 0, textureCoordinates: 1};
        return g.prototype.update = function (e, t, n) {
            if (this.show) {
                if ("undefined" == typeof this.material)throw new r("this.material must be defined.");
                if ("undefined" == typeof this.rectangle)throw new r("this.rectangle must be defined.");
                "undefined" == typeof this._va && (this._va = v(e), this._overlayCommand.vertexArray = this._va);
                var i = this._overlayCommand.renderState;
                "undefined" != typeof i && o.equals(i.viewport, this.rectangle) || (this._overlayCommand.renderState = e.createRenderState({blending: f.ALPHA_BLEND, viewport: this.rectangle}));
                var a = t.passes;
                if (a.overlay) {
                    if (this._material !== this.material) {
                        this._material = this.material;
                        var s = "#line 0\n" + this._material.shaderSource + "#line 0\n" + y;
                        this._overlayCommand.shaderProgram = e.getShaderCache().replaceShaderProgram(this._overlayCommand.shaderProgram, m, s, _)
                    }
                    this._overlayCommand.uniformMap = this._material._uniforms, n.push(this._commandLists)
                }
            }
        }, g.prototype.isDestroyed = function () {
            return!1
        }, g.prototype.destroy = function () {
            return this._overlayCommand.shaderProgram = this._overlayCommand.shaderProgram && this._overlayCommand.shaderProgram.release(), n(this)
        }, g
    }), n("Shaders/CentralBodyFS", [], function () {
        "use strict";
        return"#if TEXTURE_UNITS > 0\nuniform sampler2D u_dayTextures[TEXTURE_UNITS];\nuniform vec4 u_dayTextureTranslationAndScale[TEXTURE_UNITS];\nuniform float u_dayTextureAlpha[TEXTURE_UNITS];\nuniform float u_dayTextureBrightness[TEXTURE_UNITS];\nuniform float u_dayTextureContrast[TEXTURE_UNITS];\nuniform float u_dayTextureHue[TEXTURE_UNITS];\nuniform float u_dayTextureSaturation[TEXTURE_UNITS];\nuniform float u_dayTextureOneOverGamma[TEXTURE_UNITS];\nuniform vec4 u_dayTextureTexCoordsExtent[TEXTURE_UNITS];\n#endif\n#ifdef SHOW_REFLECTIVE_OCEAN\nuniform sampler2D u_waterMask;\nuniform vec4 u_waterMaskTranslationAndScale;\nuniform float u_zoomedOutOceanSpecularIntensity;\n#endif\n#ifdef SHOW_OCEAN_WAVES\nuniform sampler2D u_oceanNormalMap;\n#endif\nvarying vec3 v_positionMC;\nvarying vec3 v_positionEC;\nvarying vec2 v_textureCoordinates;\nvec3 sampleAndBlend(\nvec3 previousColor,\nsampler2D texture,\nvec2 tileTextureCoordinates,\nvec4 textureCoordinateExtent,\nvec4 textureCoordinateTranslationAndScale,\nfloat textureAlpha,\nfloat textureBrightness,\nfloat textureContrast,\nfloat textureHue,\nfloat textureSaturation,\nfloat textureOneOverGamma)\n{\nvec2 alphaMultiplier = step(textureCoordinateExtent.st, tileTextureCoordinates);\ntextureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\nalphaMultiplier = step(vec2(0.0), textureCoordinateExtent.pq - tileTextureCoordinates);\ntextureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\nvec2 translation = textureCoordinateTranslationAndScale.xy;\nvec2 scale = textureCoordinateTranslationAndScale.zw;\nvec2 textureCoordinates = tileTextureCoordinates * scale + translation;\nvec4 sample = texture2D(texture, textureCoordinates);\nvec3 color = sample.rgb;\nfloat alpha = sample.a;\n#ifdef APPLY_BRIGHTNESS\ncolor = mix(vec3(0.0), color, textureBrightness);\n#endif\n#ifdef APPLY_CONTRAST\ncolor = mix(vec3(0.5), color, textureContrast);\n#endif\n#ifdef APPLY_HUE\ncolor = czm_hue(color, textureHue);\n#endif\n#ifdef APPLY_SATURATION\ncolor = czm_saturation(color, textureSaturation);\n#endif\n#ifdef APPLY_GAMMA\ncolor = pow(color, vec3(textureOneOverGamma));\n#endif\nreturn mix(previousColor, color, alpha * textureAlpha);\n}\nvec3 computeDayColor(vec3 initialColor, vec2 textureCoordinates);\nvec4 computeWaterColor(vec3 positionEyeCoordinates, vec2 textureCoordinates, mat3 enuToEye, vec3 imageryColor, float specularMapValue);\nvoid main()\n{\nvec3 initialColor = vec3(0.0, 0.0, 0.5);\nvec3 startDayColor = computeDayColor(initialColor, clamp(v_textureCoordinates, 0.0, 1.0));\n#ifdef SHOW_TILE_BOUNDARIES\nif (v_textureCoordinates.x < (1.0/256.0) || v_textureCoordinates.x > (255.0/256.0) ||\nv_textureCoordinates.y < (1.0/256.0) || v_textureCoordinates.y > (255.0/256.0))\n{\nstartDayColor = vec3(1.0, 0.0, 0.0);\n}\n#endif\nvec4 color = vec4(startDayColor, 1.0);\n#ifdef SHOW_REFLECTIVE_OCEAN\nvec2 waterMaskTranslation = u_waterMaskTranslationAndScale.xy;\nvec2 waterMaskScale = u_waterMaskTranslationAndScale.zw;\nvec2 waterMaskTextureCoordinates = v_textureCoordinates * waterMaskScale + waterMaskTranslation;\nfloat mask = texture2D(u_waterMask, waterMaskTextureCoordinates).r;\nif (mask > 0.0)\n{\nvec3 normalMC = normalize(czm_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0)));\nvec3 normalEC = normalize(czm_normal3D * normalMC);\nmat3 enuToEye = czm_eastNorthUpToEyeCoordinates(v_positionMC, normalEC);\nvec2 ellipsoidTextureCoordinates = czm_ellipsoidWgs84TextureCoordinates(normalMC);\nvec2 ellipsoidFlippedTextureCoordinates = czm_ellipsoidWgs84TextureCoordinates(normalMC.zyx);\nvec2 textureCoordinates = mix(ellipsoidTextureCoordinates, ellipsoidFlippedTextureCoordinates, czm_morphTime * smoothstep(0.9, 0.95, normalMC.z));\ncolor = computeWaterColor(v_positionEC, textureCoordinates, enuToEye, startDayColor, mask);\n}\n#endif\ngl_FragColor = color;\n}\n#ifdef SHOW_REFLECTIVE_OCEAN\nfloat waveFade(float edge0, float edge1, float x)\n{\nfloat y = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\nreturn pow(1.0 - y, 5.0);\n}\nconst float oceanFrequency = 125000.0;\nconst float oceanAnimationSpeed = 0.006;\nconst float oceanAmplitude = 2.0;\nconst float oceanSpecularIntensity = 0.5;\nvec4 computeWaterColor(vec3 positionEyeCoordinates, vec2 textureCoordinates, mat3 enuToEye, vec3 imageryColor, float specularMapValue)\n{\nfloat time = czm_frameNumber * oceanAnimationSpeed;\nvec3 positionToEyeEC = -positionEyeCoordinates;\nfloat positionToEyeECLength = length(positionToEyeEC);\nvec3 normalizedpositionToEyeEC = normalize(normalize(positionToEyeEC));\nfloat waveIntensity = waveFade(70000.0, 1000000.0, positionToEyeECLength);\n#ifdef SHOW_OCEAN_WAVES\nvec4 noise = czm_getWaterNoise(u_oceanNormalMap, textureCoordinates * oceanFrequency, time, 0.0);\nvec3 normalTangentSpace = noise.xyz * vec3(1.0, 1.0, (1.0 / oceanAmplitude));\nnormalTangentSpace.xy *= waveIntensity;\nnormalTangentSpace = normalize(normalTangentSpace);\n#else\nvec3 normalTangentSpace = vec3(0.0, 0.0, 1.0);\n#endif\nvec3 normalEC = enuToEye * normalTangentSpace;\nconst vec3 waveHighlightColor = vec3(0.3, 0.45, 0.6);\nfloat diffuseIntensity = getLambertDiffuse(czm_sunDirectionEC, normalEC);\nvec3 diffuseHighlight = waveHighlightColor * diffuseIntensity;\n#ifdef SHOW_OCEAN_WAVES\nfloat tsPerturbationRatio = normalTangentSpace.z;\nvec3 nonDiffuseHighlight = mix(waveHighlightColor * 5.0 * (1.0 - tsPerturbationRatio), vec3(0.0), diffuseIntensity);\n#else\nvec3 nonDiffuseHighlight = vec3(0.0);\n#endif\nfloat specularIntensity = getSpecular(czm_sunDirectionEC, normalizedpositionToEyeEC, normalEC, 10.0) + 0.25 * getSpecular(czm_moonDirectionEC, normalizedpositionToEyeEC, normalEC, 10.0);\nfloat surfaceReflectance = mix(0.0, mix(u_zoomedOutOceanSpecularIntensity, oceanSpecularIntensity, waveIntensity), specularMapValue);\nfloat specular = specularIntensity * surfaceReflectance;\nreturn vec4(imageryColor + diffuseHighlight + nonDiffuseHighlight + specular, 1.0);\n}\n#endif\n"
    }), n("Shaders/CentralBodyFSDepth", [], function () {
        "use strict";
        return"varying vec4 positionEC;\nvoid main()\n{\nczm_ellipsoid ellipsoid = czm_getWgs84EllipsoidEC();\nvec3 direction = normalize(positionEC.xyz);\nczm_ray ray = czm_ray(vec3(0.0), direction);\nczm_raySegment intersection = czm_rayEllipsoidIntersectionInterval(ray, ellipsoid);\nif (!czm_isEmpty(intersection))\n{\ngl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);\n}\nelse\n{\ndiscard;\n}\n}\n"
    }), n("Shaders/CentralBodyFSPole", [], function () {
        "use strict";
        return"uniform vec3 u_color;\nvarying vec2 v_textureCoordinates;\nvoid main()\n{\nczm_ellipsoid ellipsoid = czm_getWgs84EllipsoidEC();\nvec3 direction = normalize(czm_windowToEyeCoordinates(gl_FragCoord).xyz);\nczm_ray ray = czm_ray(vec3(0.0), direction);\nczm_raySegment intersection = czm_rayEllipsoidIntersectionInterval(ray, ellipsoid);\nif (!czm_isEmpty(intersection))\n{\nvec3 positionEC = czm_pointAlongRay(ray, intersection.start);\nvec3 positionMC = (czm_inverseModelView * vec4(positionEC, 1.0)).xyz;\nvec3 normalMC = normalize(czm_geodeticSurfaceNormal(positionMC, vec3(0.0), vec3(1.0)));\nvec3 normalEC = normalize(czm_normal * normalMC);\nvec3 startDayColor = u_color;\ngl_FragColor = vec4(startDayColor, 1.0);\n}\nelse\n{\ndiscard;\n}\n}\n"
    }), n("Shaders/CentralBodyVS", [], function () {
        "use strict";
        return"attribute vec4 position3DAndHeight;\nattribute vec2 textureCoordinates;\nuniform vec3 u_center3D;\nuniform mat4 u_modifiedModelView;\nuniform vec4 u_tileExtent;\nuniform vec2 u_southAndNorthLatitude;\nuniform vec3 u_southMercatorYLowAndHighAndOneOverHeight;\nvarying vec3 v_positionMC;\nvarying vec3 v_positionEC;\nvarying vec2 v_textureCoordinates;\nvec4 getPosition(vec3 position3DWC);\nfloat get2DYPositionFraction();\nvec4 getPosition3DMode(vec3 position3DWC)\n{\nreturn czm_projection * (u_modifiedModelView * vec4(position3DAndHeight.xyz, 1.0));\n}\nfloat get2DMercatorYPositionFraction()\n{\nconst float maxTileWidth = 0.003068;\nfloat positionFraction = textureCoordinates.y;\nfloat southLatitude = u_southAndNorthLatitude.x;\nfloat northLatitude = u_southAndNorthLatitude.y;\nif (northLatitude - southLatitude > maxTileWidth)\n{\nfloat southMercatorYLow = u_southMercatorYLowAndHighAndOneOverHeight.x;\nfloat southMercatorYHigh = u_southMercatorYLowAndHighAndOneOverHeight.y;\nfloat oneOverMercatorHeight = u_southMercatorYLowAndHighAndOneOverHeight.z;\nfloat currentLatitude = mix(southLatitude, northLatitude, textureCoordinates.y);\ncurrentLatitude = clamp(currentLatitude, -czm_webMercatorMaxLatitude, czm_webMercatorMaxLatitude);\npositionFraction = czm_latitudeToWebMercatorFraction(currentLatitude, southMercatorYLow, southMercatorYHigh, oneOverMercatorHeight);\n}\nreturn positionFraction;\n}\nfloat get2DGeographicYPositionFraction()\n{\nreturn textureCoordinates.y;\n}\nvec4 getPositionPlanarEarth(vec3 position3DWC, float height2D)\n{\nfloat yPositionFraction = get2DYPositionFraction();\nvec4 rtcPosition2D = vec4(height2D, mix(u_tileExtent.st, u_tileExtent.pq, vec2(textureCoordinates.x, yPositionFraction)), 1.0);\nreturn czm_projection * (u_modifiedModelView * rtcPosition2D);\n}\nvec4 getPosition2DMode(vec3 position3DWC)\n{\nreturn getPositionPlanarEarth(position3DWC, 0.0);\n}\nvec4 getPositionColumbusViewMode(vec3 position3DWC)\n{\nreturn getPositionPlanarEarth(position3DWC, position3DAndHeight.w);\n}\nvec4 getPositionMorphingMode(vec3 position3DWC)\n{\nfloat yPositionFraction = get2DYPositionFraction();\nvec4 position2DWC = vec4(0.0, mix(u_tileExtent.st, u_tileExtent.pq, vec2(textureCoordinates.x, yPositionFraction)), 1.0);\nvec4 morphPosition = czm_columbusViewMorph(position2DWC, vec4(position3DWC, 1.0), czm_morphTime);\nreturn czm_modelViewProjection * morphPosition;\n}\nvoid main()\n{\nvec3 position3DWC = position3DAndHeight.xyz + u_center3D;\ngl_Position = getPosition(position3DWC);\n#ifdef SHOW_REFLECTIVE_OCEAN\nv_positionEC = (czm_modelView3D * vec4(position3DWC, 1.0)).xyz;\nv_positionMC = position3DWC;\n#endif\nv_textureCoordinates = textureCoordinates;\n}\n"
    }), n("Shaders/CentralBodyVSDepth", [], function () {
        "use strict";
        return"attribute vec4 position;\nvarying vec4 positionEC;\nvoid main()\n{\npositionEC = czm_modelView * position;\ngl_Position = czm_projection * positionEC;\n}\n"
    }), n("Shaders/CentralBodyVSPole", [], function () {
        "use strict";
        return"attribute vec4 position;\nvarying vec2 v_textureCoordinates;\nvoid main()\n{\nfloat x = (position.x - czm_viewport.x) / czm_viewport.z;\nfloat y = (position.y - czm_viewport.y) / czm_viewport.w;\nv_textureCoordinates = vec2(x, y);\ngl_Position = czm_viewportOrthographic * position;\n}\n"
    }), n("Scene/CentralBody", ["../Core/buildModuleUrl", "../Core/combine", "../Core/loadImage", "../Core/defaultValue", "../Core/destroyObject", "../Core/BoundingRectangle", "../Core/BoundingSphere", "../Core/Cartesian2", "../Core/Cartesian3", "../Core/Cartographic", "../Core/ComponentDatatype", "../Core/Ellipsoid", "../Core/Extent", "../Core/GeographicProjection", "../Core/Geometry", "../Core/GeometryAttribute", "../Core/Intersect", "../Core/Math", "../Core/Matrix4", "../Core/Occluder", "../Core/PrimitiveType", "../Core/Transforms", "../Renderer/BufferUsage", "../Renderer/ClearCommand", "../Renderer/CommandLists", "../Renderer/DepthFunction", "../Renderer/DrawCommand", "./CentralBodySurface", "./CentralBodySurfaceShaderSet", "./CreditDisplay", "./EllipsoidTerrainProvider", "./ImageryLayerCollection", "./Material", "./SceneMode", "./TerrainProvider", "./ViewportQuad", "../Shaders/CentralBodyFS", "../Shaders/CentralBodyFSDepth", "../Shaders/CentralBodyFSPole", "../Shaders/CentralBodyVS", "../Shaders/CentralBodyVSDepth", "../Shaders/CentralBodyVSPole", "../ThirdParty/when"], function (e, t, n, i, r, o, a, s, u, l, c, d, f, h, p, m, y, v, g, _, w, C, x, S, b, T, E, A, M, D, I, P, O, R, z, L, N, F, V, B, k, U, q) {
        "use strict";
        function W(e, t) {
            var n = e._ellipsoid.getRadii(), i = t.camera.getPositionWC(), r = e._ellipsoid.getOneOverRadii().multiplyComponents(i), o = r.magnitude(), a = r.normalize(), s = u.UNIT_Z.cross(r).normalize(), l = a.cross(s).normalize(), c = Math.sqrt(r.magnitudeSquared() - 1), d = a.multiplyByScalar(1 / o), f = c / o, h = s.multiplyByScalar(f), p = l.multiplyByScalar(f), m = n.multiplyComponents(d.add(p).subtract(h)), y = n.multiplyComponents(d.add(p).add(h)), v = n.multiplyComponents(d.subtract(p).subtract(h)), g = n.multiplyComponents(d.subtract(p).add(h));
            return[m.x, m.y, m.z, v.x, v.y, v.z, y.x, y.y, y.z, g.x, g.y, g.z]
        }

        function H(e, t, n, i, r, a) {
            var s, c = e._ellipsoid.cartographicToCartesian(new l(0, i)), d = e._ellipsoid.cartographicToCartesian(new l(Math.PI, i)), f = .5 * c.subtract(d).magnitude(), h = e._ellipsoid.cartographicToCartesian(new l(0, n)), p = t.camera.direction;
            s = 1 - u.UNIT_Z.negate().dot(p) < v.EPSILON6 ? u.UNIT_X : p.cross(u.UNIT_Z).normalize();
            var m = h.add(s.multiplyByScalar(f)), y = h.add(u.UNIT_Z.cross(s).normalize().multiplyByScalar(f));
            C.pointToWindowCoordinates(r, a, h, h), C.pointToWindowCoordinates(r, a, m, m), C.pointToWindowCoordinates(r, a, y, y);
            var g = Math.floor(Math.max(y.subtract(h).magnitude(), m.subtract(h).magnitude())), _ = g;
            return new o(Math.floor(h.x) - g, Math.floor(h.y) - _, 2 * g, 2 * _)
        }

        function G(e, n, i) {
            var r = e._surface._terrainProvider;
            if (i.mode === R.SCENE3D && r.isReady()) {
                var o = r.getTilingScheme().getExtent(), s = n.getUniformState().getViewProjection(), u = X;
                u.width = n.getCanvas().clientWidth, u.height = n.getCanvas().clientHeight;
                var l, d, h, w, C, S, b, T, E, A = g.computeViewportTransformation(u, 0, 1, Z), M = .05, D = e._occluder;
                o.north < v.PI_OVER_TWO && (l = new f(-Math.PI, o.north, Math.PI, v.PI_OVER_TWO), d = a.fromExtent3D(l, e._ellipsoid), h = i.cullingVolume.getVisibility(d) === y.OUTSIDE, w = _.computeOccludeePointFromExtent(l, e._ellipsoid), C = w && !D.isPointVisible(w, 0) || !D.isBoundingSphereVisible(d), e._drawNorthPole = !h && !C, e._drawNorthPole && (T = H(e, i, l.north, l.south - M, s, A), E = [T.x, T.y, T.x + T.width, T.y, T.x + T.width, T.y + T.height, T.x, T.y + T.height], "undefined" == typeof e._northPoleCommand.vertexArray ? (e._northPoleCommand.boundingVolume = a.fromExtent3D(l, e._ellipsoid), b = new p({attributes: {position: new m({componentDatatype: c.FLOAT, componentsPerAttribute: 2, values: E})}}), e._northPoleCommand.vertexArray = n.createVertexArrayFromGeometry({geometry: b, attributeIndices: {position: 0}, bufferUsage: x.STREAM_DRAW})) : (S = c.FLOAT, e._northPoleCommand.vertexArray.getAttribute(0).vertexBuffer.copyFromArrayView(S.createTypedArray(E))))), o.south > -v.PI_OVER_TWO && (l = new f(-Math.PI, -v.PI_OVER_TWO, Math.PI, o.south), d = a.fromExtent3D(l, e._ellipsoid), h = i.cullingVolume.getVisibility(d) === y.OUTSIDE, w = _.computeOccludeePointFromExtent(l, e._ellipsoid), C = w && !D.isPointVisible(w) || !D.isBoundingSphereVisible(d), e._drawSouthPole = !h && !C, e._drawSouthPole && (T = H(e, i, l.south, l.north + M, s, A), E = [T.x, T.y, T.x + T.width, T.y, T.x + T.width, T.y + T.height, T.x, T.y + T.height], "undefined" == typeof e._southPoleCommand.vertexArray ? (e._southPoleCommand.boundingVolume = a.fromExtent3D(l, e._ellipsoid), b = new p({attributes: {position: new m({componentDatatype: c.FLOAT, componentsPerAttribute: 2, values: E})}}), e._southPoleCommand.vertexArray = n.createVertexArrayFromGeometry({geometry: b, attributeIndices: {position: 0}, bufferUsage: x.STREAM_DRAW})) : (S = c.FLOAT, e._southPoleCommand.vertexArray.getAttribute(0).vertexBuffer.copyFromArrayView(S.createTypedArray(E)))));
                var I = 0, P = e._imageryLayerCollection.getLength() > 0 ? e._imageryLayerCollection.get(0) : void 0;
                "undefined" != typeof P && "undefined" != typeof P.getImageryProvider() && "undefined" != typeof P.getImageryProvider().getPoleIntensity && (I = P.getImageryProvider().getPoleIntensity());
                var O = {u_dayIntensity: function () {
                    return I
                }}, z = e;
                if ("undefined" == typeof e._northPoleCommand.uniformMap) {
                    var L = t([O, {u_color: function () {
                        return z.northPoleColor
                    }}], !1, !1);
                    e._northPoleCommand.uniformMap = t([L, e._drawUniforms], !1, !1)
                }
                if ("undefined" == typeof e._southPoleCommand.uniformMap) {
                    var N = t([O, {u_color: function () {
                        return z.southPoleColor
                    }}], !1, !1);
                    e._southPoleCommand.uniformMap = t([N, e._drawUniforms], !1, !1)
                }
            }
        }

        function j(e, t) {
            var n = t.creditDisplay, i = e._surface._terrainProvider.getCredit();
            "undefined" != typeof i && n.addCredit(i);
            for (var r = e._imageryLayerCollection, o = 0, a = r.getLength(); a > o; ++o) {
                var s = r.get(o);
                s.show && (i = s.getImageryProvider().getCredit(), "undefined" != typeof i && n.addCredit(i))
            }
        }

        var Y = function (t) {
            t = i(t, d.WGS84);
            var n = new I({ellipsoid: t}), r = new P;
            this.terrainProvider = n, this._ellipsoid = t, this._imageryLayerCollection = r, this._surface = new A({terrainProvider: n, imageryLayerCollection: r}), this._occluder = new _(new a(u.ZERO, t.getMinimumRadius()), u.ZERO), this._surfaceShaderSet = new M(z.attributeIndices), this._rsColor = void 0, this._rsColorWithoutDepthTest = void 0;
            var o = new S;
            o.depth = 1, o.stencil = 0, o.owner = this, this._clearDepthCommand = o, this._depthCommand = new E, this._depthCommand.primitiveType = w.TRIANGLES, this._depthCommand.boundingVolume = new a(u.ZERO, t.getMaximumRadius()), this._depthCommand.owner = this, this._northPoleCommand = new E, this._northPoleCommand.primitiveType = w.TRIANGLE_FAN, this._northPoleCommand.owner = this, this._southPoleCommand = new E, this._southPoleCommand.primitiveType = w.TRIANGLE_FAN, this._southPoleCommand.owner = this, this._drawNorthPole = !1, this._drawSouthPole = !1, this._commandLists = new b, this.northPoleColor = new u(2 / 255, 6 / 255, 18 / 255), this.southPoleColor = new u(1, 1, 1), this.show = !0, this._mode = R.SCENE3D, this._projection = void 0, this.oceanNormalMapUrl = e("Assets/Textures/waterNormalsSmall.jpg"), this.depthTestAgainstTerrain = !1, this.tileCacheSize = 100, this._lastOceanNormalMapUrl = void 0, this._oceanNormalMap = void 0, this._zoomedOutOceanSpecularIntensity = .5, this._showingPrettyOcean = !1, this._hasWaterMask = !1;
            var s = this;
            this._drawUniforms = {u_zoomedOutOceanSpecularIntensity: function () {
                return s._zoomedOutOceanSpecularIntensity
            }, u_oceanNormalMap: function () {
                return s._oceanNormalMap
            }}
        };
        Y.prototype.getEllipsoid = function () {
            return this._ellipsoid
        }, Y.prototype.getImageryLayers = function () {
            return this._imageryLayerCollection
        };
        var X = new o, Z = new g;
        return Y.prototype.update = function (e, t, i) {
            if (this.show) {
                var r = e.getCanvas().clientWidth, o = e.getCanvas().clientHeight;
                if (0 !== r && 0 !== o) {
                    var a = t.mode, s = t.scene2D.projection, u = !1;
                    (this._mode !== a || "undefined" == typeof this._rsColor) && (u = !0, a !== R.SCENE3D && (a !== R.COLUMBUS_VIEW || this.terrainProvider instanceof I) ? (this._rsColor = e.createRenderState({cull: {enabled: !0}}), this._rsColorWithoutDepthTest = e.createRenderState({cull: {enabled: !0}}), this._depthCommand.renderState = e.createRenderState({cull: {enabled: !0}})) : (this._rsColor = e.createRenderState({cull: {enabled: !0}, depthTest: {enabled: !0}}), this._rsColorWithoutDepthTest = e.createRenderState({cull: {enabled: !0}}), this._depthCommand.renderState = e.createRenderState({cull: {enabled: !0}, depthTest: {enabled: !0, func: T.ALWAYS}, colorMask: {red: !1, green: !1, blue: !1, alpha: !1}}))), this._northPoleCommand.renderState = this._rsColorWithoutDepthTest, this._southPoleCommand.renderState = this._rsColorWithoutDepthTest;
                    var l = W(this, t);
                    if (this._depthCommand.vertexArray) {
                        var d = c.FLOAT;
                        this._depthCommand.vertexArray.getAttribute(0).vertexBuffer.copyFromArrayView(d.createTypedArray(l))
                    } else {
                        var f = new p({attributes: {position: new m({componentDatatype: c.FLOAT, componentsPerAttribute: 3, values: l})}, indices: [0, 1, 2, 2, 1, 3], primitiveType: w.TRIANGLES});
                        this._depthCommand.vertexArray = e.createVertexArrayFromGeometry({geometry: f, attributeIndices: {position: 0}, bufferUsage: x.DYNAMIC_DRAW})
                    }
                    var y = e.getShaderCache();
                    if ("undefined" == typeof this._depthCommand.shaderProgram && (this._depthCommand.shaderProgram = y.getShaderProgram(k, "#line 0\n" + F, {position: 0})), this._surface._terrainProvider.hasWaterMask() && this.oceanNormalMapUrl !== this._lastOceanNormalMapUrl) {
                        this._lastOceanNormalMapUrl = this.oceanNormalMapUrl;
                        var v = this;
                        q(n(this.oceanNormalMapUrl), function (t) {
                            v._oceanNormalMap = v._oceanNormalMap && v._oceanNormalMap.destroy(), v._oceanNormalMap = e.createTexture2D({source: t})
                        })
                    }
                    var g = this._projection !== s, _ = this._surface._terrainProvider.hasWaterMask(), C = this._hasWaterMask !== _;
                    if ("undefined" == typeof this._surfaceShaderSet || "undefined" == typeof this._northPoleCommand.shaderProgram || "undefined" == typeof this._southPoleCommand.shaderProgram || u || g || C || "undefined" != typeof this._oceanNormalMap !== this._showingPrettyOcean) {
                        var S, b = "vec4 getPosition(vec3 position3DWC) { return getPosition3DMode(position3DWC); }", E = "vec4 getPosition(vec3 position3DWC) { return getPosition2DMode(position3DWC); }", A = "vec4 getPosition(vec3 position3DWC) { return getPositionColumbusViewMode(position3DWC); }", M = "vec4 getPosition(vec3 position3DWC) { return getPositionMorphingMode(position3DWC); }";
                        switch (a) {
                            case R.SCENE3D:
                                S = b;
                                break;
                            case R.SCENE2D:
                                S = E;
                                break;
                            case R.COLUMBUS_VIEW:
                                S = A;
                                break;
                            case R.MORPHING:
                                S = M
                        }
                        var D, P = "float get2DYPositionFraction() { return get2DGeographicYPositionFraction(); }", O = "float get2DYPositionFraction() { return get2DMercatorYPositionFraction(); }";
                        D = s instanceof h ? P : O, this._surfaceShaderSet.baseVertexShaderString = (_ ? "#define SHOW_REFLECTIVE_OCEAN\n" : "") + B + "\n" + S + "\n" + D;
                        var L = _ && "undefined" != typeof this._oceanNormalMap;
                        this._surfaceShaderSet.baseFragmentShaderString = (_ ? "#define SHOW_REFLECTIVE_OCEAN\n" : "") + (L ? "#define SHOW_OCEAN_WAVES\n" : "") + "#line 0\n" + N, this._surfaceShaderSet.invalidateShaders();
                        var H = y.replaceShaderProgram(this._northPoleCommand.shaderProgram, U, V, z.attributeIndices);
                        this._northPoleCommand.shaderProgram = H, this._southPoleCommand.shaderProgram = H, this._showingPrettyOcean = "undefined" != typeof this._oceanNormalMap, this._hasWaterMask = _
                    }
                    var Y = t.camera.getPositionWC();
                    this._occluder.setCameraPosition(Y), G(this, e, t), this._mode = a, this._projection = s;
                    var X = t.passes, Z = this._commandLists;
                    if (Z.removeAll(), X.color) {
                        var K = Z.colorList;
                        a === R.SCENE3D && (this._drawNorthPole && K.push(this._northPoleCommand), this._drawSouthPole && K.push(this._southPoleCommand));
                        var J = this._drawUniforms;
                        this._zoomedOutOceanSpecularIntensity = a === R.SCENE3D ? .5 : 0, this._surface._tileCacheSize = this.tileCacheSize, this._surface.setTerrainProvider(this.terrainProvider), this._surface.update(e, t, K, J, this._surfaceShaderSet, this._rsColor, this._projection), j(this, t), a === R.SCENE3D && (this.depthTestAgainstTerrain || (K.push(this._clearDepthCommand), K.push(this._depthCommand)))
                    }
                    X.pick && Z.pickList.push(this._depthCommand), Z.empty() || i.push(Z)
                }
            }
        }, Y.prototype.isDestroyed = function () {
            return!1
        }, Y.prototype.destroy = function () {
            return this._northPoleCommand.vertexArray = this._northPoleCommand.vertexArray && this._northPoleCommand.vertexArray.destroy(), this._southPoleCommand.vertexArray = this._southPoleCommand.vertexArray && this._southPoleCommand.vertexArray.destroy(), this._surfaceShaderSet = this._surfaceShaderSet && this._surfaceShaderSet.destroy(), this._northPoleCommand.shaderProgram = this._northPoleCommand.shaderProgram && this._northPoleCommand.shaderProgram.release(), this._southPoleCommand.shaderProgram = this._northPoleCommand.shaderProgram, this._depthCommand.shaderProgram = this._depthCommand.shaderProgram && this._depthCommand.shaderProgram.release(), this._depthCommand.vertexArray = this._depthCommand.vertexArray && this._depthCommand.vertexArray.destroy(), this._surface = this._surface && this._surface.destroy(), this._oceanNormalMap = this._oceanNormalMap && this._oceanNormalMap.destroy(), r(this)
        }, Y
    }), n("Scene/CesiumTerrainProvider", ["../Core/defaultValue", "../Core/loadArrayBuffer", "../Core/throttleRequestByServer", "../Core/writeTextToCanvas", "../Core/DeveloperError", "../Core/Event", "./Credit", "./GeographicTilingScheme", "./HeightmapTerrainData", "./TerrainProvider", "../ThirdParty/when"], function (e, t, n, i, r, o, a, s, u, l, c) {
        "use strict";
        var d = function (e) {
            if ("undefined" == typeof e || "undefined" == typeof e.url)throw new r("description.url is required.");
            this._url = e.url, this._proxy = e.proxy, this._tilingScheme = new s({numberOfLevelZeroTilesX: 2, numberOfLevelZeroTilesY: 1}), this._heightmapWidth = 65, this._levelZeroMaximumGeometricError = l.getEstimatedLevelZeroGeometricErrorForAHeightmap(this._tilingScheme.getEllipsoid(), this._heightmapWidth, this._tilingScheme.getNumberOfXTilesAtLevel(0)), this._terrainDataStructure = {heightScale: .2, heightOffset: -1e3, elementsPerHeight: 1, stride: 1, elementMultiplier: 256, isBigEndian: !1}, this._errorEvent = new o;
            var t = e.credit;
            "string" == typeof t && (t = new a(t)), this._credit = t
        };
        return d.prototype.requestTileGeometry = function (i, r, o, a) {
            var s = this._tilingScheme.getNumberOfYTilesAtLevel(o), l = this._url + "/" + o + "/" + i + "/" + (s - r - 1) + ".terrain", d = this._proxy;
            "undefined" != typeof d && (l = d.getURL(l));
            var f;
            if (a = e(a, !0)) {
                if (f = n(l, t), "undefined" == typeof f)return void 0
            } else f = t(l);
            var h = this;
            return c(f, function (e) {
                var t = new Uint16Array(e, 0, h._heightmapWidth * h._heightmapWidth);
                return new u({buffer: t, childTileMask: new Uint8Array(e, t.byteLength, 1)[0], waterMask: new Uint8Array(e, t.byteLength + 1, e.byteLength - t.byteLength - 1), width: h._heightmapWidth, height: h._heightmapWidth, structure: h._terrainDataStructure})
            })
        }, d.prototype.getErrorEvent = function () {
            return this._errorEvent
        }, d.prototype.getLevelMaximumGeometricError = function (e) {
            return this._levelZeroMaximumGeometricError / (1 << e)
        }, d.prototype.getCredit = function () {
            return this._credit
        }, d.prototype.getTilingScheme = function () {
            return this._tilingScheme
        }, d.prototype.hasWaterMask = function () {
            return!0
        }, d.prototype.isReady = function () {
            return!0
        }, d
    }), n("Scene/CompositePrimitive", ["../Core/createGuid", "../Core/destroyObject", "../Core/DeveloperError"], function (e, t, n) {
        "use strict";
        function i(e, t) {
            if (!e.contains(t))throw new n("primitive is not in this composite.");
            return e._primitives.indexOf(t)
        }

        var r = function () {
            this._centralBody = void 0, this._primitives = [], this._guid = e(), this.destroyPrimitives = !0, this.show = !0
        };
        return r.prototype.getCentralBody = function () {
            return this._centralBody
        }, r.prototype.setCentralBody = function (e) {
            this._centralBody = this.destroyPrimitives && this._centralBody && this._centralBody.destroy(), this._centralBody = e
        }, r.prototype.add = function (e) {
            if ("undefined" == typeof e)throw new n("primitive is required.");
            var t = e._external = e._external || {}, i = t._composites = t._composites || {};
            i[this._guid] = {composite: this}, this._primitives.push(e)
        }, r.prototype.remove = function (e) {
            if (this.contains(e)) {
                var t = this._primitives.indexOf(e);
                if (-1 !== t)return this._primitives.splice(t, 1), delete e._external._composites[this._guid], this.destroyPrimitives && e.destroy(), !0
            }
            return!1
        }, r.prototype.removeAll = function () {
            if (this.destroyPrimitives)for (var e = this._primitives, t = e.length, n = 0; t > n; ++n)e[n].destroy();
            this._primitives = []
        }, r.prototype.contains = function (e) {
            return!!(e && e._external && e._external._composites && e._external._composites[this._guid])
        }, r.prototype.raise = function (e) {
            if ("undefined" != typeof e) {
                var t = i(this, e), n = this._primitives;
                if (t !== n.length - 1) {
                    var r = n[t];
                    n[t] = n[t + 1], n[t + 1] = r
                }
            }
        }, r.prototype.raiseToTop = function (e) {
            if ("undefined" != typeof e) {
                var t = i(this, e), n = this._primitives;
                t !== n.length - 1 && (n.splice(t, 1), n.push(e))
            }
        }, r.prototype.lower = function (e) {
            if ("undefined" != typeof e) {
                var t = i(this, e), n = this._primitives;
                if (0 !== t) {
                    var r = n[t];
                    n[t] = n[t - 1], n[t - 1] = r
                }
            }
        }, r.prototype.lowerToBottom = function (e) {
            if ("undefined" != typeof e) {
                var t = i(this, e), n = this._primitives;
                0 !== t && (n.splice(t, 1), n.unshift(e))
            }
        }, r.prototype.get = function (e) {
            if ("undefined" == typeof e)throw new n("index is required.");
            return this._primitives[e]
        }, r.prototype.getLength = function () {
            return this._primitives.length
        }, r.prototype.update = function (e, t, n) {
            if (this.show) {
                this._centralBody && this._centralBody.update(e, t, n);
                for (var i = this._primitives, r = i.length, o = 0; r > o; ++o)i[o].update(e, t, n)
            }
        }, r.prototype.isDestroyed = function () {
            return!1
        }, r.prototype.destroy = function () {
            return this.removeAll(), this._centralBody = this.destroyPrimitives && this._centralBody && this._centralBody.destroy(), t(this)
        }, r
    }), n("Scene/DebugAppearance", ["../Core/defaultValue", "../Core/DeveloperError", "./Appearance"], function (e, t, n) {
        "use strict";
        var i = function (i) {
            i = e(i, e.EMPTY_OBJECT);
            var r = i.attributeName;
            if ("undefined" == typeof r)throw new t("options.attributeName is required.");
            var o, a = e(i.glslDatatype, "vec3"), s = "v_" + r;
            if ("normal" === r || "binormal" === r | "tangent" === r)o = "vec4 getColor() { return vec4((" + s + " + vec3(1.0)) * 0.5, 1.0); }\n"; else switch ("st" === r && (a = "vec2"), a) {
                case"float":
                    o = "vec4 getColor() { return vec4(vec3(" + s + "), 1.0); }\n";
                    break;
                case"vec2":
                    o = "vec4 getColor() { return vec4(" + s + ", 0.0, 1.0); }\n";
                    break;
                case"vec3":
                    o = "vec4 getColor() { return vec4(" + s + ", 1.0); }\n";
                    break;
                case"vec4":
                    o = "vec4 getColor() { return " + s + "; }\n";
                    break;
                default:
                    throw new t("options.glslDatatype must be float, vec2, vec3, or vec4.")
            }
            var u = "attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute " + a + " " + r + ";\n" + "varying " + a + " " + s + ";\n" + "void main()\n" + "{\n" + "vec4 p = czm_translateRelativeToEye(position3DHigh, position3DLow);\n" + s + " = " + r + ";\n" + "gl_Position = czm_modelViewProjectionRelativeToEye * p;\n" + "}", l = "varying " + a + " " + s + ";\n" + o + "\n" + "void main()\n" + "{\n" + "gl_FragColor = getColor();\n" + "}";
            this.material = void 0, this.vertexShaderSource = e(i.vertexShaderSource, u), this.fragmentShaderSource = e(i.fragmentShaderSource, l), this.renderState = e(i.renderState, n.getDefaultRenderState(!1, !1)), this.attributeName = r, this.glslDatatype = a
        };
        return i.prototype.getFragmentShaderSource = n.prototype.getFragmentShaderSource, i
    }), n("Scene/ExtentPrimitive", ["../Core/DeveloperError", "../Core/defaultValue", "../Core/Color", "../Core/destroyObject", "../Core/Math", "../Core/Extent", "../Core/Ellipsoid", "../Core/GeometryInstance", "../Core/ExtentGeometry", "./EllipsoidSurfaceAppearance", "./Primitive", "./Material"], function (e, t, n, i, r, o, a, s, u, l, c, d) {
        "use strict";
        var f = function (e) {
            e = t(e, t.EMPTY_OBJECT), this.ellipsoid = t(e.ellipsoid, a.WGS84), this._ellipsoid = void 0, this.extent = o.clone(e.extent), this._extent = void 0, this.granularity = t(e.granularity, r.RADIANS_PER_DEGREE), this._granularity = void 0, this.height = t(e.height, 0), this._height = void 0, this.rotation = t(e.rotation, 0), this._rotation = void 0, this.textureRotationAngle = t(e.textureRotationAngle, 0), this._textureRotationAngle = void 0, this.show = t(e.show, !0);
            var i = d.fromType(void 0, d.ColorType);
            i.uniforms.color = new n(1, 1, 0, .5), this.material = t(e.material, i), this._primitive = void 0
        };
        return f.prototype.update = function (t, n, i) {
            if ("undefined" == typeof this.ellipsoid)throw new e("this.ellipsoid must be defined.");
            if ("undefined" == typeof this.material)throw new e("this.material must be defined.");
            if (this.granularity < 0)throw new e("this.granularity and scene2D/scene3D overrides must be greater than zero.");
            if (this.show && "undefined" != typeof this.extent) {
                if (!o.equals(this._extent, this.extent) || this._ellipsoid !== this.ellipsoid || this._granularity !== this.granularity || this._height !== this.height || this._rotation !== this.rotation || this._textureRotationAngle !== this.textureRotationAngle) {
                    this._extent = o.clone(this.extent, this._extent), this._ellipsoid = this.ellipsoid, this._granularity = this.granularity, this._height = this.height, this._rotation = this.rotation, this._textureRotationAngle = this.textureRotationAngle;
                    var r = new s({geometry: new u({extent: this.extent, vertexFormat: l.VERTEX_FORMAT, ellipsoid: this.ellipsoid, granularity: this.granularity, height: this.height, rotation: this.rotation, stRotation: this.textureRotationAngle}), id: this});
                    "undefined" != typeof this._primitive && this._primitive.destroy(), this._primitive = new c({geometryInstances: r, appearance: new l({aboveGround: this.height > 0})})
                }
                this._primitive.appearance.material = this.material, this._primitive.update(t, n, i)
            }
        }, f.prototype.isDestroyed = function () {
            return!1
        }, f.prototype.destroy = function () {
            return this._primitive = this._primitive && this._primitive.destroy(), i(this)
        }, f
    }), n("Scene/FrameState", ["../Core/DeveloperError", "../Core/Cartesian2", "./SceneMode"], function (e, t, n) {
        "use strict";
        var i = function (i) {
            if ("undefined" == typeof i)throw new e("credit display is required");
            this.mode = n.SCENE3D, this.morphTime = n.SCENE3D.morphTime, this.frameNumber = 0, this.time = void 0, this.scene2D = {projection: void 0}, this.camera = void 0, this.cullingVolume = void 0, this.occluder = void 0, this.canvasDimensions = new t, this.passes = {color: !1, pick: !1, overlay: !1}, this.creditDisplay = i
        };
        return i
    }), n("Scene/FrustumCommands", ["../Core/defaultValue"], function (e) {
        "use strict";
        var t = function (t, n) {
            this.near = e(t, 0), this.far = e(n, 0), this.commands = []
        };
        return t
    }), n("Scene/GridImageryProvider", ["../Core/defaultValue", "../Core/Color", "../Core/Event", "./GeographicTilingScheme"], function (e, t, n, i) {
        "use strict";
        var r = function (r) {
            r = e(r, {}), this._tilingScheme = e(r.tilingScheme, new i), this._cells = e(r.cells, 8), this._color = e(r.color, new t(1, 1, 1, .4)), this._glowColor = e(r.glowColor, new t(0, 1, 0, .05)), this._glowWidth = e(r.glowWidth, 6), this._backgroundColor = e(r.backgroundColor, new t(0, .5, 0, .2)), this._errorEvent = new n, this._tileWidth = e(r.tileWidth, 256), this._tileHeight = e(r.tileHeight, 256), this._canvasSize = e(r.canvasSize, 256), this._canvas = this._createGridCanvas()
        };
        return r.prototype.getProxy = function () {
            return void 0
        }, r.prototype.getTileWidth = function () {
            return this._tileWidth
        }, r.prototype.getTileHeight = function () {
            return this._tileHeight
        }, r.prototype.getMaximumLevel = function () {
            return void 0
        }, r.prototype.getMinimumLevel = function () {
            return void 0
        }, r.prototype.getTilingScheme = function () {
            return this._tilingScheme
        }, r.prototype.getExtent = function () {
            return this._tilingScheme.getExtent()
        }, r.prototype.getTileDiscardPolicy = function () {
            return void 0
        }, r.prototype.getErrorEvent = function () {
            return this._errorEvent
        }, r.prototype.isReady = function () {
            return!0
        }, r.prototype._drawGrid = function (e) {
            for (var t = 0, n = this._canvasSize, i = 0; i <= this._cells; ++i) {
                var r = i / this._cells, o = 1 + r * (n - 1);
                e.moveTo(o, t), e.lineTo(o, n), e.moveTo(t, o), e.lineTo(n, o)
            }
            e.stroke()
        }, r.prototype._createGridCanvas = function () {
            var e = document.createElement("canvas");
            e.width = this._canvasSize, e.height = this._canvasSize;
            var t = 0, n = this._canvasSize, i = e.getContext("2d"), r = this._backgroundColor.toCssColorString();
            i.fillStyle = r, i.fillRect(t, t, n, n);
            var o = this._glowColor.toCssColorString();
            i.strokeStyle = o, i.lineWidth = this._glowWidth, i.strokeRect(t, t, n, n), this._drawGrid(i), i.lineWidth = .5 * this._glowWidth, i.strokeRect(t, t, n, n), this._drawGrid(i);
            var a = this._color.toCssColorString();
            return i.strokeStyle = a, i.lineWidth = 2, i.strokeRect(t, t, n, n), i.lineWidth = 1, this._drawGrid(i), e
        }, r.prototype.requestImage = function () {
            return this._canvas
        }, r.prototype.getCredit = function () {
            return void 0
        }, r
    }), n("Scene/NeverTileDiscardPolicy", [], function () {
        "use strict";
        var e = function () {
        };
        return e.prototype.isReady = function () {
            return!0
        }, e.prototype.shouldDiscardImage = function () {
            return!1
        }, e
    }), n("Scene/OpenStreetMapImageryProvider", ["../Core/defaultValue", "../Core/DeveloperError", "../Core/Event", "../Core/writeTextToCanvas", "./ImageryProvider", "./WebMercatorTilingScheme", "./Credit"], function (e, t, n, i, r, o, a) {
        "use strict";
        function s(e, t, n, i) {
            var r = e._url + i + "/" + t + "/" + n + "." + e._fileExtension, o = e._proxy;
            return"undefined" != typeof o && (r = o.getURL(r)), r
        }

        var u = /\/$/, l = new a("MapQuest, Open Street Map and contributors, CC-BY-SA"), c = function (t) {
            t = e(t, {});
            var i = e(t.url, "http://tile.openstreetmap.org/");
            u.test(i) || (i += "/"), this._url = i, this._fileExtension = e(t.fileExtension, "png"), this._proxy = t.proxy, this._tileDiscardPolicy = t.tileDiscardPolicy, this._tilingScheme = new o, this._tileWidth = 256, this._tileHeight = 256, this._maximumLevel = e(t.maximumLevel, 18), this._extent = e(t.extent, this._tilingScheme.getExtent()), this._errorEvent = new n, this._ready = !0;
            var r = e(t.credit, l);
            "string" == typeof r && (r = new a(r)), this._credit = r
        };
        return c.prototype.getUrl = function () {
            return this._url
        }, c.prototype.getProxy = function () {
            return this._proxy
        }, c.prototype.getTileWidth = function () {
            if (!this._ready)throw new t("getTileWidth must not be called before the imagery provider is ready.");
            return this._tileWidth
        }, c.prototype.getTileHeight = function () {
            if (!this._ready)throw new t("getTileHeight must not be called before the imagery provider is ready.");
            return this._tileHeight
        }, c.prototype.getMaximumLevel = function () {
            if (!this._ready)throw new t("getMaximumLevel must not be called before the imagery provider is ready.");
            return this._maximumLevel
        }, c.prototype.getMinimumLevel = function () {
            if (!this._ready)throw new t("getMinimumLevel must not be called before the imagery provider is ready.");
            return 0
        }, c.prototype.getTilingScheme = function () {
            if (!this._ready)throw new t("getTilingScheme must not be called before the imagery provider is ready.");
            return this._tilingScheme
        }, c.prototype.getExtent = function () {
            if (!this._ready)throw new t("getExtent must not be called before the imagery provider is ready.");
            return this._extent
        }, c.prototype.getTileDiscardPolicy = function () {
            if (!this._ready)throw new t("getTileDiscardPolicy must not be called before the imagery provider is ready.");
            return this._tileDiscardPolicy
        }, c.prototype.getErrorEvent = function () {
            return this._errorEvent
        }, c.prototype.isReady = function () {
            return this._ready
        }, c.prototype.requestImage = function (e, n, i) {
            if (!this._ready)throw new t("requestImage must not be called before the imagery provider is ready.");
            var o = s(this, e, n, i);
            return r.loadImage(this, o)
        }, c.prototype.getCredit = function () {
            return this._credit
        }, c
    }), n("Scene/OrthographicFrustum", ["../Core/DeveloperError", "../Core/destroyObject", "../Core/Cartesian2", "../Core/Cartesian3", "../Core/Cartesian4", "../Core/Matrix4", "../Scene/CullingVolume"], function (e, t, n, i, r, o, a) {
        "use strict";
        function s(t) {
            if ("undefined" == typeof t.right || "undefined" == typeof t.left || "undefined" == typeof t.top || "undefined" == typeof t.bottom || "undefined" == typeof t.near || "undefined" == typeof t.far)throw new e("right, left, top, bottom, near, or far parameters are not set.");
            if (t.top !== t._top || t.bottom !== t._bottom || t.left !== t._left || t.right !== t._right || t.near !== t._near || t.far !== t._far) {
                if (t.left > t.right)throw new e("right must be greater than left.");
                if (t.bottom > t.top)throw new e("top must be greater than bottom.");
                if (t.near <= 0 || t.near > t.far)throw new e("near must be greater than zero and less than far.");
                t._left = t.left, t._right = t.right, t._top = t.top, t._bottom = t.bottom, t._near = t.near, t._far = t.far, t._orthographicMatrix = o.computeOrthographicOffCenter(t.left, t.right, t.bottom, t.top, t.near, t.far)
            }
        }

        var u = function () {
            this.left = void 0, this._left = void 0, this.right = void 0, this._right = void 0, this.top = void 0, this._top = void 0, this.bottom = void 0, this._bottom = void 0, this.near = 1, this._near = this.near, this.far = 5e8, this._far = this.far, this._cullingVolume = new a, this._orthographicMatrix = void 0
        };
        u.prototype.getProjectionMatrix = function () {
            return s(this), this._orthographicMatrix
        };
        var l = new i, c = new i, d = new i;
        return u.prototype.computeCullingVolume = function (t, n, o) {
            if ("undefined" == typeof t)throw new e("position is required.");
            if ("undefined" == typeof n)throw new e("direction is required.");
            if ("undefined" == typeof o)throw new e("up is required.");
            var a = this._cullingVolume.planes, s = this.top, u = this.bottom, f = this.right, h = this.left, p = this.near, m = this.far, y = i.cross(n, o, l), v = c;
            i.multiplyByScalar(n, p, v), i.add(t, v, v);
            var g = d;
            i.multiplyByScalar(y, h, g), i.add(v, g, g);
            var _ = a[0];
            return"undefined" == typeof _ && (_ = a[0] = new r), _.x = y.x, _.y = y.y, _.z = y.z, _.w = -i.dot(y, g), i.multiplyByScalar(y, f, g), i.add(v, g, g), _ = a[1], "undefined" == typeof _ && (_ = a[1] = new r), _.x = -y.x, _.y = -y.y, _.z = -y.z, _.w = -i.dot(y.negate(), g), i.multiplyByScalar(o, u, g), i.add(v, g, g), _ = a[2], "undefined" == typeof _ && (_ = a[2] = new r), _.x = o.x, _.y = o.y, _.z = o.z, _.w = -i.dot(o, g), i.multiplyByScalar(o, s, g), i.add(v, g, g), _ = a[3], "undefined" == typeof _ && (_ = a[3] = new r), _.x = -o.x, _.y = -o.y, _.z = -o.z, _.w = -i.dot(o.negate(), g), _ = a[4], "undefined" == typeof _ && (_ = a[4] = new r), _.x = n.x, _.y = n.y, _.z = n.z, _.w = -i.dot(n, v), i.multiplyByScalar(n, m, g), i.add(t, g, g), _ = a[5], "undefined" == typeof _ && (_ = a[5] = new r), _.x = -n.x, _.y = -n.y, _.z = -n.z, _.w = -i.dot(n.negate(), g), this._cullingVolume
        }, u.prototype.getPixelSize = function (t) {
            if (s(this), "undefined" == typeof t)throw new e("canvasDimensions is required.");
            var i = t.x, r = t.y;
            if (0 >= i)throw new e("canvasDimensions.x must be greater than zero.");
            if (0 >= r)throw new e("canvasDimensions.y must be greater than zero.");
            var o = this.right - this.left, a = this.top - this.bottom, u = o / i, l = a / r;
            return new n(u, l)
        }, u.prototype.clone = function () {
            var e = new u;
            return e.left = this.left, e.right = this.right, e.top = this.top, e.bottom = this.bottom, e.near = this.near, e.far = this.far, e
        }, u.prototype.equals = function (e) {
            return"undefined" != typeof e && this.right === e.right && this.left === e.left && this.top === e.top && this.bottom === e.bottom && this.near === e.near && this.far === e.far
        }, u
    }), n("Shaders/Appearances/PerInstanceColorAppearanceVS", [], function () {
        "use strict";
        return"attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 normal;\nattribute vec4 color;\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec4 v_color;\nvoid main()\n{\nvec4 p = czm_computePosition();\nv_positionEC = (czm_modelViewRelativeToEye * p).xyz;\nv_normalEC = czm_normal * normal;\nv_color = color;\ngl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"
    }), n("Shaders/Appearances/PerInstanceColorAppearanceFS", [], function () {
        "use strict";
        return"varying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec4 v_color;\nvoid main()\n{\nvec3 positionToEyeEC = -v_positionEC;\nvec3 normalEC;\n#ifdef FACE_FORWARD\nnormalEC = normalize(faceforward(v_normalEC, vec3(0.0, 0.0, 1.0), -v_normalEC));\n#else\nnormalEC = normalize(v_normalEC);\n#endif\nczm_materialInput materialInput;\nmaterialInput.normalEC = normalEC;\nmaterialInput.positionToEyeEC = positionToEyeEC;\nczm_material material = czm_getDefaultMaterial(materialInput);\nmaterial.diffuse = v_color.rgb;\nmaterial.alpha = v_color.a;\ngl_FragColor = czm_phong(normalize(positionToEyeEC), material);\n}\n"
    }), n("Shaders/Appearances/PerInstanceFlatColorAppearanceVS", [], function () {
        "use strict";
        return"attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec4 color;\nvarying vec4 v_color;\nvoid main()\n{\nvec4 p = czm_computePosition();\nv_color = color;\ngl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"
    }), n("Shaders/Appearances/PerInstanceFlatColorAppearanceFS", [], function () {
        "use strict";
        return"varying vec4 v_color;\nvoid main()\n{\ngl_FragColor = v_color;\n}\n"
    }), n("Scene/PerInstanceColorAppearance", ["../Core/defaultValue", "../Core/VertexFormat", "./Appearance", "../Shaders/Appearances/PerInstanceColorAppearanceVS", "../Shaders/Appearances/PerInstanceColorAppearanceFS", "../Shaders/Appearances/PerInstanceFlatColorAppearanceVS", "../Shaders/Appearances/PerInstanceFlatColorAppearanceFS"], function (e, t, n, i, r, o, a) {
        "use strict";
        var s = function (t) {
            t = e(t, e.EMPTY_OBJECT);
            var u = e(t.translucent, !0), l = e(t.closed, !1), c = e(t.flat, !1), d = c ? o : i, f = c ? a : r, h = c ? s.FLAT_VERTEX_FORMAT : s.VERTEX_FORMAT;
            this.material = void 0, this.vertexShaderSource = e(t.vertexShaderSource, d), this.fragmentShaderSource = e(t.fragmentShaderSource, f), this.renderState = e(t.renderState, n.getDefaultRenderState(u, l)), this.vertexFormat = h, this.flat = c, this.faceForward = e(t.faceForward, !1), this.translucent = u, this.closed = l
        };
        return s.VERTEX_FORMAT = t.POSITION_AND_NORMAL, s.FLAT_VERTEX_FORMAT = t.POSITION_ONLY, s.prototype.getFragmentShaderSource = n.prototype.getFragmentShaderSource, s
    }), n("Scene/PerformanceDisplay", ["../Core/BoundingRectangle", "../Core/Color", "../Core/defaultValue", "../Core/destroyObject", "../Renderer/PixelFormat", "./Material", "./ViewportQuad"], function (e, t, n, i, r, o, a) {
        "use strict";
        var s = t.fromCssColorString("#e52"), u = t.fromCssColorString("#de3"), l = t.fromCssColorString("rgba(0, 0, 30, 0.9)"), c = new e(0, 0, 80, 40), d = function (e) {
            e = n(e, n.EMPTY_OBJECT), this._fpsColor = n(e.fpsColor, s).toCssColorString(), this._frameTimeColor = n(e.frameTimeColor, u).toCssColorString(), this._backgroundColor = n(e.backgroundColor, l).toCssColorString(), this._font = n(e.font, "bold 10px Helvetica,Arial,sans-serif"), this._rectangle = n(e.rectangle, c), this._canvas = document.createElement("canvas"), this._canvas.width = this._rectangle.width, this._canvas.height = this._rectangle.height, this._canvasContext = this._canvas.getContext("2d"), this._canvasContext.font = this._font, this._canvasContext.lineWidth = 1, this._bufferLength = this._rectangle.width, this._frameTimeSamples = new Array(this._bufferLength), this._fpsSamples = new Array(this._bufferLength);
            for (var t = 0; t < this._bufferLength; t++)this._frameTimeSamples[t] = this._fpsSamples[t] = 0;
            this._frameTimeIndex = 0, this._fpsIndex = 0, this._lastFpsSampleTime = void 0, this._frameCount = 0, this._quad = void 0, this._time = void 0, this._texture = void 0, this._viewportHeight = 0
        };
        return d.prototype.update = function (e, t, n) {
            if ("undefined" == typeof this._time)return this._lastFpsSampleTime = this._time = Date.now(), void 0;
            var i = this._time, s = this._time = Date.now(), u = s - i;
            this._frameTimeSamples[this._frameTimeIndex++] = u, this._frameTimeIndex >= this._bufferLength && (this._frameTimeIndex = 0), this._frameCount++;
            var l = this._fps, c = s - this._lastFpsSampleTime;
            c > 1e3 && (l = this._fps = 0 | 1e3 * this._frameCount / c, this._fpsSamples[this._fpsIndex++] = l, this._fpsIndex >= this._bufferLength && (this._fpsIndex = 0), this._lastFpsSampleTime = s, this._frameCount = 0);
            var d = this._canvasContext, f = this._rectangle.width, h = this._rectangle.height;
            d.clearRect(0, 0, f, h), d.fillStyle = this._backgroundColor, d.fillRect(0, 0, f, h), "undefined" != typeof l && (d.fillStyle = this._fpsColor, d.textAlign = "left", d.fillText(l + " FPS", 1, 10)), d.fillStyle = this._frameTimeColor, d.textAlign = "right", d.fillText(u + " MS", f - 1, 10);
            for (var p = 0; p < this._bufferLength; p++)l = this._fpsSamples[(p + this._fpsIndex) % this._bufferLength], l > 0 && this._drawLine(this._fpsColor, p, l / 100), u = this._frameTimeSamples[(p + this._frameTimeIndex) % this._bufferLength], u > 0 && this._drawLine(this._frameTimeColor, p, u / 200);
            "undefined" == typeof this._quad && (this._quad = new a(void 0, o.fromType(e, o.ImageType))), "undefined" == typeof this._texture ? (this._texture = e.createTexture2D({source: this._canvas, pixelFormat: r.RGBA}), this._quad.material.uniforms.image = this._texture) : this._texture.copyFrom(this._canvas);
            var m = e.getCanvas().clientHeight;
            if (m !== this._viewportHeight) {
                this._viewportHeight = m;
                var y = this._quad.rectangle;
                y.x = this._rectangle.x, y.y = m - h - this._rectangle.y, y.width = f, y.height = h
            }
            this._quad.update(e, t, n)
        }, d.prototype._drawLine = function (e, t, n) {
            var i = this._canvasContext, r = this._rectangle.height, o = r - 10;
            t = .5 + t, i.beginPath(), i.strokeStyle = e, i.moveTo(t, r);
            var a = n * o;
            a > o && (a = o);
            var s = r - a;
            i.lineTo(t, s), i.stroke()
        }, d.prototype.destroy = function () {
            return this._quad = this._quad.destroy(), i(this)
        }, d
    }), n("Scene/RectangularPyramidSensorVolume", ["../Core/clone", "../Core/Color", "../Core/defaultValue", "../Core/destroyObject", "../Core/DeveloperError", "../Core/Math", "../Core/Matrix4", "../Renderer/BufferUsage", "./Material", "./CustomSensorVolume"], function (e, t, n, i, r, o, a, s, u, l) {
        "use strict";
        var c = function (i) {
            i = n(i, n.EMPTY_OBJECT), this.show = n(i.show, !0), this.showIntersection = n(i.showIntersection, !0), this.showThroughEllipsoid = n(i.showThroughEllipsoid, !1), this.modelMatrix = a.clone(n(i.modelMatrix, a.IDENTITY)), this.bufferUsage = n(i.bufferUsage, s.STATIC_DRAW), this.radius = n(i.radius, Number.POSITIVE_INFINITY), this.xHalfAngle = n(i.xHalfAngle, o.PI_OVER_TWO), this._xHalfAngle = void 0, this.yHalfAngle = n(i.yHalfAngle, o.PI_OVER_TWO), this._yHalfAngle = void 0, this.material = "undefined" != typeof i.material ? i.material : u.fromType(void 0, u.ColorType), this.intersectionColor = t.clone(n(i.intersectionColor, t.WHITE)), this.intersectionWidth = n(i.intersectionWidth, 5);
            var r = e(i);
            r._pickIdThis = n(i._pickIdThis, this), this._customSensor = new l(r)
        };
        return c.prototype.update = function (e, t, n) {
            if (this.xHalfAngle > o.PI_OVER_TWO || this.yHalfAngle > o.PI_OVER_TWO)throw new r("this.xHalfAngle and this.yHalfAngle must each be less than or equal to 90 degrees.");
            var i = this._customSensor;
            if (i.show = this.show, i.showIntersection = this.showIntersection, i.showThroughEllipsoid = this.showThroughEllipsoid, i.modelMatrix = this.modelMatrix, i.bufferUsage = this.bufferUsage, i.radius = this.radius, i.material = this.material, i.intersectionColor = this.intersectionColor, i.intersectionWidth = this.intersectionWidth, this._xHalfAngle !== this.xHalfAngle || this._yHalfAngle !== this.yHalfAngle) {
                this._xHalfAngle = this.xHalfAngle, this._yHalfAngle = this.yHalfAngle;
                var a = Math.tan(Math.min(this.xHalfAngle, o.toRadians(89))), s = Math.tan(Math.min(this.yHalfAngle, o.toRadians(89))), u = Math.atan(a / s), l = Math.atan(Math.sqrt(a * a + s * s));
                i.setDirections([
                    {clock: u, cone: l},
                    {clock: o.toRadians(180) - u, cone: l},
                    {clock: o.toRadians(180) + u, cone: l},
                    {clock: -u, cone: l}
                ])
            }
            i.update(e, t, n)
        }, c.prototype.isDestroyed = function () {
            return!1
        }, c.prototype.destroy = function () {
            return this._customSensor = this._customSensor && this._customSensor.destroy(), i(this)
        }, c
    }), n("Scene/ScreenSpaceCameraController", ["../Core/destroyObject", "../Core/Cartesian2", "../Core/Cartesian3", "../Core/Cartesian4", "../Core/Cartographic", "../Core/DeveloperError", "../Core/Ellipsoid", "../Core/KeyboardEventModifier", "../Core/FAR", "../Core/IntersectionTests", "../Core/Math", "../Core/Matrix4", "../Core/Ray", "../Core/Transforms", "./AnimationCollection", "./CameraEventAggregator", "./CameraEventType", "./CameraColumbusViewMode", "./SceneMode"], function (e, t, n, i, r, o, a, s, u, l, c, d, f, h, p, m, y, v, g) {
        "use strict";
        function _(e, t) {
            if (0 > e)return 0;
            var n = 25 * (1 - t);
            return Math.exp(-n * e)
        }

        function w(e) {
            return e.startPosition.equalsEpsilon(e.endPosition, c.EPSILON14)
        }

        function C(e, n, i, r, o) {
            var a = e.getButtonPressTime(), s = e.getButtonReleaseTime(), u = a && s && (s.getTime() - a.getTime()) / 1e3, l = new Date, c = s && (l.getTime() - s.getTime()) / 1e3;
            if (a && s && k > u) {
                var d = _(c, n);
                if ("undefined" == typeof r[o]) {
                    var f = e.getLastMovement();
                    if (!f || w(f))return;
                    var h = .5 * (f.endPosition.x - f.startPosition.x), p = .5 * (f.endPosition.y - f.startPosition.y);
                    r[o] = {startPosition: new t(f.startPosition.x, f.startPosition.y), endPosition: new t(f.startPosition.x + h * d, f.startPosition.y + p * d), motion: new t(h, p)}
                } else r[o] = {startPosition: r[o].endPosition.clone(), endPosition: new t(r[o].endPosition.x + r[o].motion.x * d, r[o].endPosition.y + r[o].motion.y * d), motion: new t};
                if (isNaN(r[o].endPosition.x) || isNaN(r[o].endPosition.y) || w(r[o]))return r[o] = void 0, void 0;
                e.isButtonDown() || i(r, r[o])
            } else r[o] = void 0
        }

        function x(e, t, n, i, r) {
            var o = 1;
            "undefined" != typeof r && (o = c.clamp(Math.abs(r), .25, 1));
            var a = e.minimumZoomDistance * o, s = e.maximumZoomDistance, u = i - a, l = n * u;
            l = c.clamp(l, e._minimumZoomRate, e._maximumZoomRate);
            var d = t.endPosition.y - t.startPosition.y, f = d / e._canvas.clientHeight;
            f = Math.min(f, e.maximumMovementRatio);
            var h = l * f;
            h > 0 && Math.abs(i - a) < 1 || 0 > h && Math.abs(i - s) < 1 || (a > i - h ? h = i - a - 1 : i - h > s && (h = i - s), e._cameraController.zoomIn(h))
        }

        function S(e, t) {
            var n = e._cameraController, i = n.getPickRay(t.startPosition, U).origin, r = n.getPickRay(t.endPosition, q).origin;
            n.moveRight(i.x - r.x), n.moveUp(i.y - r.y)
        }

        function b(e, t) {
            x(e, t, e._zoomFactor, e._cameraController.getMagnitude())
        }

        function T(e, n) {
            var i = e._canvas.clientWidth, r = e._canvas.clientHeight, o = W;
            o.x = 2 / i * n.startPosition.x - 1, o.y = 2 / r * (r - n.startPosition.y) - 1, t.normalize(o, o);
            var a = H;
            a.x = 2 / i * n.endPosition.x - 1, a.y = 2 / r * (r - n.endPosition.y) - 1, t.normalize(a, a);
            var s = Math.acos(o.x);
            o.y < 0 && (s = c.TWO_PI - s);
            var u = Math.acos(a.x);
            a.y < 0 && (u = c.TWO_PI - u);
            var l = u - s;
            e._cameraController.twistRight(l)
        }

        function E(e, t) {
            var n = e._rotateFactor * e._rotateRateRangeAdjustment;
            n > e._maximumRotateRate && (n = e._maximumRotateRate), n < e._minimumRotateRate && (n = e._minimumRotateRate);
            var i = (t.endPosition.x - t.startPosition.x) / e._canvas.clientWidth;
            i = Math.min(i, e.maximumMovementRatio);
            var r = 4 * n * i * Math.PI;
            e._cameraController.twistRight(r)
        }

        function A(e) {
            var t = e._translateHandler, n = e._zoomHandler, i = e._zoomWheelHandler, r = e._pinchHandler, o = t.isMoving() && t.getMovement(), a = n.isMoving() && n.getMovement(), s = i.isMoving() && i.getMovement(), u = r.isMoving() && r.getMovement();
            if ((t.isButtonDown() || n.isButtonDown() || s) && e._animationCollection.removeAll(), e.enableTranslate && (o && S(e, t.getMovement()), !o && e.inertiaTranslate < 1 && C(t, e.inertiaTranslate, S, e, "_lastInertiaTranslateMovement")), e.enableZoom && (a ? b(e, n.getMovement()) : s ? b(e, i.getMovement()) : u && b(e, r.getMovement().distance), !a && e.inertiaZoom < 1 && C(n, e.inertiaZoom, b, e, "_lastInertiaZoomMovement"), !s && e.inertiaZoom < 1 && C(i, e.inertiaZoom, b, e, "_lastInertiaWheelZoomMovement"), !u && e.inertiaZoom < 1 && C(r, e.inertiaZoom, b, e, "_lastInertiaZoomMovement")), e.enableRotate && (e._rotateHandler.isMoving() && T(e, e._rotateHandler.getMovement()), u && E(e, r.getMovement().angleAndHeight)), !(t.isButtonDown() || n.isButtonDown() || e._lastInertiaZoomMovement || e._lastInertiaTranslateMovement || e._animationCollection.contains(e._animation))) {
                var l = e._cameraController.createCorrectPositionAnimation(e.bounceAnimationTime);
                "undefined" != typeof l && (e._animation = e._animationCollection.add(l))
            }
            return e._animationCollection.update(), !0
        }

        function M(e, t) {
            var i = e._cameraController, r = i.getPickRay(t.startPosition, G), o = i.getPickRay(t.endPosition, j), a = n.UNIT_X, s = r.origin, u = r.direction, l = -a.dot(s) / a.dot(u), d = n.multiplyByScalar(u, l, Y);
            n.add(s, d, d), s = o.origin, u = o.direction, l = -a.dot(s) / a.dot(u);
            var f = n.multiplyByScalar(u, l, X);
            n.add(s, f, f);
            var h = n.subtract(d, f, Z), p = h.x;
            h.x = h.y, h.y = h.z, h.z = p;
            var m = h.magnitude();
            m > c.EPSILON6 && (n.normalize(h, h), i.move(h, m))
        }

        function D(e, t) {
            var i = K;
            i.x = e._canvas.clientWidth / 2, i.y = e._canvas.clientHeight / 2;
            var r = e._cameraController.getPickRay(i, J), o = n.UNIT_X, s = r.origin, u = r.direction, l = -o.dot(s) / o.dot(u), c = n.multiplyByScalar(u, l, Q);
            n.add(s, c, c);
            var f = d.fromTranslation(c, $), h = e._ellipsoid;
            e.setEllipsoid(a.UNIT_SPHERE), R(e, t, f, n.UNIT_Z), e.setEllipsoid(h)
        }

        function I(e, t) {
            var i = et;
            i.x = e._canvas.clientWidth / 2, i.y = e._canvas.clientHeight / 2;
            var r = e._cameraController.getPickRay(i, tt), o = n.UNIT_X, a = r.origin, s = r.direction, u = -o.dot(a) / o.dot(s);
            x(e, t, e._zoomFactor, u)
        }

        function P(e) {
            var t = e._zoomHandler, n = t.isMoving() && t.getMovement(), i = e._zoomWheelHandler, r = i.isMoving() && i.getMovement(), o = e._pinchHandler, a = o.isMoving() && o.getMovement(), s = e._translateHandler, u = s.isMoving() && s.getMovement(), l = e._rotateHandler, c = l.isMoving() && l.getMovement(), d = e._spinHandler, f = d.isMoving() && d.getMovement(), h = e._lookHandler, p = h.isMoving() && h.getMovement(), m = l.isButtonDown() || d.isButtonDown() || s.isButtonDown() || t.isButtonDown() || p || r || a;
            if (e.columbusViewMode === v.LOCKED)e.enableRotate && (f && R(e, d.getMovement()), !m && e.inertiaSpin >= 0 && e.inertiaSpin < 1 && C(d, e.inertiaSpin, R, e, "_lastInertiaSpinMovement")), e.enableZoom && (n ? L(e, t.getMovement()) : r ? L(e, i.getMovement()) : a && L(e, o.getMovement().distance), !m && e.inertiaZoom >= 0 && e.inertiaZoom < 1 && C(t, e.inertiaZoom, L, e, "_lastInertiaZoomMovement"), !m && e.inertiaZoom >= 0 && e.inertiaZoom < 1 && C(i, e.inertiaZoom, L, e, "_lastInertiaWheelZoomMovement"), !m && e.inertiaZoom >= 0 && e.inertiaZoom < 1 && C(o, e.inertiaZoom, L, e, "_lastInertiaZoomMovement")); else {
                if (m && e._animationCollection.removeAll(), e.enableTilt && (c && D(e, l.getMovement()), a && D(e, o.getMovement().angleAndHeight), !m && e.inertiaSpin >= 0 && e.inertiaSpin < 1 && C(l, e.inertiaSpin, D, e, "_lastInertiaTiltMovement"), !m && e.inertiaZoom >= 0 && e.inertiaZoom < 1 && C(o, e.inertiaZoom, I, e, "_lastInertiaZoomMovement")), e.enableTranslate && (u && M(e, s.getMovement()), !m && e.inertiaTranslate >= 0 && e.inertiaTranslate < 1 && C(s, e.inertiaTranslate, M, e, "_lastInertiaTranslateMovement")), e.enableZoom && (n ? I(e, t.getMovement()) : r ? I(e, i.getMovement()) : a && I(e, o.getMovement().distance), !m && e.inertiaZoom >= 0 && e.inertiaZoom < 1 && C(t, e.inertiaZoom, I, e, "_lastInertiaZoomMovement"), !m && e.inertiaZoom >= 0 && e.inertiaZoom < 1 && C(i, e.inertiaZoom, I, e, "_lastInertiaWheelZoomMovement"), !m && e.inertiaZoom >= 0 && e.inertiaZoom < 1 && C(o, e.inertiaZoom, I, e, "_lastInertiaZoomMovement")), e.enableLook && p && F(e, h.getMovement()), !(m || e._lastInertiaZoomMovement || e._lastInertiaTranslateMovement || e._animationCollection.contains(e._animation))) {
                    var y = e._cameraController.createCorrectPositionAnimation(e.bounceAnimationTime);
                    "undefined" != typeof y && (e._animation = e._animationCollection.add(y))
                }
                e._animationCollection.update()
            }
            return!0
        }

        function O(e, t) {
            "undefined" != typeof e._cameraController.pickEllipsoid(t.startPosition, e._ellipsoid, nt) ? z(e, t) : R(e, t)
        }

        function R(e, t, i, r, o) {
            var a = e._cameraController, s = a.constrainedAxis;
            "undefined" != typeof r && (a.constrainedAxis = r);
            var u = a._camera.position.magnitude(), l = e._rotateFactor * (u - e._rotateRateRangeAdjustment);
            l > e._maximumRotateRate && (l = e._maximumRotateRate), l < e._minimumRotateRate && (l = e._minimumRotateRate);
            var f = (t.startPosition.x - t.endPosition.x) / e._canvas.clientWidth, h = (t.startPosition.y - t.endPosition.y) / e._canvas.clientHeight;
            f = Math.min(f, e.maximumMovementRatio), h = Math.min(h, e.maximumMovementRatio);
            var p = 2 * l * f * Math.PI, m = l * h * Math.PI;
            if ("undefined" != typeof a.constrainedAxis && "undefined" == typeof i) {
                var y = a._camera, v = y.position.normalize(), g = v.equalsEpsilon(a.constrainedAxis, c.EPSILON2), _ = v.equalsEpsilon(a.constrainedAxis.negate(), c.EPSILON2);
                if (!g && !_) {
                    var w;
                    w = n.dot(y.position, y.direction) + 1 < c.EPSILON4 ? y.up : y.direction;
                    var C;
                    C = n.equalsEpsilon(a.constrainedAxis, y.position.normalize(), c.EPSILON2) ? y.right : n.cross(a.constrainedAxis, y.position).normalize();
                    var x = n.dot(y.right, C), S = c.sign(x) < 0 ? -1 : 1;
                    x = Math.abs(x);
                    var b = n.dot(w, a.constrainedAxis), T = n.dot(w, C), E = b > 0 && T > 0 || 0 > b && 0 > T ? -1 : 1;
                    b = Math.abs(b);
                    var A = m;
                    m = S * (m * b - E * p * (1 - x)), p = S * (p * x + E * A * (1 - b))
                }
            }
            if (a.rotateRight(p, i), a.rotateUp(m, i), "undefined" != typeof o) {
                var M = n.clone(a._camera.getDirectionWC(), it), D = i.inverseTransformation();
                d.multiplyByVector(D, M, M);
                var I = -n.dot(M, r), P = Math.acos(I);
                P > o && (P -= o, a.rotateUp(-P, i))
            }
            a.constrainedAxis = s
        }

        function z(e, t) {
            var i = e._cameraController, r = i.pickEllipsoid(t.startPosition, e._ellipsoid, rt), o = i.pickEllipsoid(t.endPosition, e._ellipsoid, ot);
            if ("undefined" != typeof r && "undefined" != typeof o)if (r = i._camera.worldToCameraCoordinates(r, r), o = i._camera.worldToCameraCoordinates(o, o), "undefined" == typeof i.constrainedAxis) {
                n.normalize(r, r), n.normalize(o, o);
                var a = n.dot(r, o), s = n.cross(r, o, at);
                if (1 > a && !s.equalsEpsilon(n.ZERO, c.EPSILON14)) {
                    var u = Math.acos(a);
                    i.rotate(s, u)
                }
            } else {
                var l = i.constrainedAxis, d = n.mostOrthogonalAxis(l, at);
                n.cross(d, l, d), n.normalize(d, d);
                var f = n.cross(l, d, st), h = n.magnitude(r), p = n.dot(l, r), m = Math.acos(p / h), y = n.multiplyByScalar(l, p, ut);
                n.subtract(r, y, y), n.normalize(y, y);
                var v = n.magnitude(o), g = n.dot(l, o), _ = Math.acos(g / v), w = n.multiplyByScalar(l, g, lt);
                n.subtract(o, w, w), n.normalize(w, w);
                var C = Math.acos(n.dot(y, d));
                n.dot(y, f) < 0 && (C = c.TWO_PI - C);
                var x = Math.acos(n.dot(w, d));
                n.dot(w, f) < 0 && (x = c.TWO_PI - x);
                var S, b = C - x;
                S = n.equalsEpsilon(l, i._camera.position, c.EPSILON2) ? i._camera.right : n.cross(l, i._camera.position);
                var T, E = n.cross(l, S, at), A = n.dot(E, n.subtract(r, l, st)), M = n.dot(E, n.subtract(o, l, st));
                T = A > 0 && M > 0 ? _ - m : A > 0 && 0 >= M ? n.dot(i._camera.position, l) > 0 ? -m - _ : m + _ : m - _, i.rotateRight(b), i.rotateUp(T)
            }
        }

        function L(e, t) {
            var i = e._cameraController._camera, r = e._ellipsoid, o = r.cartesianToCartographic(i.position).height, a = n.normalize(i.position, ct);
            x(e, t, e._zoomFactor, o, n.dot(a, i.direction))
        }

        function N(e, t) {
            var i = e._cameraController, r = e._ellipsoid, o = .25 * e.minimumZoomDistance, s = r.cartesianToCartographic(e._cameraController._camera.position).height;
            if (!(s - o - 1 < c.EPSILON3 && t.endPosition.y - t.startPosition.y < 0)) {
                var u = dt;
                u.x = e._canvas.clientWidth / 2, u.y = e._canvas.clientHeight / 2;
                var d, f = i.getPickRay(u, ft), p = l.rayEllipsoid(f, r);
                if ("undefined" != typeof p)d = f.getPoint(p.start, pt); else {
                    var m = l.grazingAltitudeLocation(f, r);
                    if ("undefined" == typeof m)return;
                    var y = r.cartesianToCartographic(m, ht);
                    y.height = 0, d = r.cartographicToCartesian(y, pt)
                }
                var v = i._camera;
                d = v.worldToCameraCoordinates(d, d);
                var g = h.eastNorthUpToFixedFrame(d, r, mt), _ = e._ellipsoid;
                e.setEllipsoid(a.UNIT_SPHERE);
                var w = .25 * o / n.subtract(d, v.position).magnitude();
                R(e, t, g, n.UNIT_Z, c.PI_OVER_TWO - w), e.setEllipsoid(_)
            }
        }

        function F(e, t) {
            var n = e._cameraController, i = yt;
            i.x = t.startPosition.x, i.y = 0;
            var r = vt;
            r.x = t.endPosition.x, r.y = 0;
            var o = n.getPickRay(i, gt).direction, a = n.getPickRay(r, _t).direction, s = 0, u = o.dot(a);
            1 > u && (s = Math.acos(u)), s = t.startPosition.x > t.endPosition.x ? -s : s;
            var l = e._horizontalRotationAxis;
            "undefined" != typeof l ? n.look(l, s) : n.lookLeft(s), i.x = 0, i.y = t.startPosition.y, r.x = 0, r.y = t.endPosition.y, o = n.getPickRay(i, gt).direction, a = n.getPickRay(r, _t).direction, s = 0, u = o.dot(a), 1 > u && (s = Math.acos(u)), s = t.startPosition.y > t.endPosition.y ? -s : s, n.lookUp(s)
        }

        function V(e) {
            var t = e._spinHandler, n = e._zoomHandler, i = e._zoomWheelHandler, r = e._pinchHandler, o = t.isMoving() && t.getMovement(), a = n.isMoving() && n.getMovement(), s = i.isMoving() && i.getMovement(), u = r.isMoving() && r.getMovement(), l = e._rotateHandler, c = l.isMoving() && l.getMovement(), d = e._lookHandler, f = d.isMoving() && d.getMovement(), h = t.isButtonDown() || n.isButtonDown() || l.isButtonDown() || f || s || u;
            return e.enableRotate && (o && O(e, t.getMovement()), !h && e.inertiaSpin >= 0 && e.inertiaSpin < 1 && C(t, e.inertiaSpin, O, e, "_lastInertiaSpinMovement")), e.enableTilt && (c && N(e, l.getMovement()), u && N(e, r.getMovement().angleAndHeight), !h && e.inertiaSpin >= 0 && e.inertiaSpin < 1 && C(l, e.inertiaSpin, N, e, "_lastInertiaTiltMovement"), !h && e.inertiaSpin >= 0 && e.inertiaSpin < 1 && C(r, e.inertiaSpin, N, e, "_lastInertiaTiltMovement")), e.enableZoom && (a ? L(e, n.getMovement()) : s ? L(e, i.getMovement()) : u && L(e, r.getMovement().distance), !h && e.inertiaZoom >= 0 && e.inertiaZoom < 1 && C(n, e.inertiaZoom, L, e, "_lastInertiaZoomMovement"), !h && e.inertiaZoom >= 0 && e.inertiaZoom < 1 && C(i, e.inertiaZoom, L, e, "_lastInertiaWheelZoomMovement"), !h && e.inertiaZoom >= 0 && e.inertiaZoom < 1 && C(r, e.inertiaZoom, L, e, "_lastInertiaZoomMovement")), e.enableLook && f && F(e, d.getMovement()), !0
        }

        var B = function (e, t) {
            if ("undefined" == typeof e)throw new o("canvas is required.");
            if ("undefined" == typeof t)throw new o("cameraController is required.");
            this.enableTranslate = !0, this.enableZoom = !0, this.enableRotate = !0, this.enableTilt = !0, this.enableLook = !0, this.inertiaSpin = .9, this.inertiaTranslate = .9, this.inertiaZoom = .8, this.maximumMovementRatio = .1, this.columbusViewMode = v.FREE, this.bounceAnimationTime = 3e3, this.minimumZoomDistance = 20, this.maximumZoomDistance = Number.POSITIVE_INFINITY, this._canvas = e, this._cameraController = t, this._ellipsoid = a.WGS84, this._spinHandler = new m(e, y.LEFT_DRAG), this._translateHandler = new m(e, y.LEFT_DRAG), this._lookHandler = new m(e, y.LEFT_DRAG, s.SHIFT), this._rotateHandler = new m(e, y.MIDDLE_DRAG), this._zoomHandler = new m(e, y.RIGHT_DRAG), this._zoomWheelHandler = new m(e, y.WHEEL), this._pinchHandler = new m(e, y.PINCH), this._lastInertiaSpinMovement = void 0, this._lastInertiaZoomMovement = void 0, this._lastInertiaTranslateMovement = void 0, this._lastInertiaWheelZoomMovement = void 0, this._lastInertiaTiltMovement = void 0, this._animationCollection = new p, this._animation = void 0, this._horizontalRotationAxis = void 0;
            var n = this._ellipsoid.getMaximumRadius();
            this._zoomFactor = 5, this._rotateFactor = 1 / n, this._rotateRateRangeAdjustment = n, this._maximumRotateRate = 1.77, this._minimumRotateRate = 2e-4, this._translateFactor = 1, this._minimumZoomRate = 20, this._maximumZoomRate = u
        };
        B.prototype.getEllipsoid = function () {
            return this._ellipsoid
        }, B.prototype.setEllipsoid = function (e) {
            e = e || a.WGS84;
            var t = e.getMaximumRadius();
            this._ellipsoid = e, this._rotateFactor = 1 / t, this._rotateRateRangeAdjustment = t
        };
        var k = .4, U = new f, q = new f, W = new t, H = new t, G = new f, j = new f, Y = new n, X = new n, Z = new n, K = new t, J = new f, Q = new n, $ = new d, et = new t, tt = new f, nt = new n, it = i.ZERO.clone(), rt = i.UNIT_W.clone(), ot = i.UNIT_W.clone(), at = new n, st = new n, ut = new n, lt = new n, ct = new n, dt = new t, ft = new f, ht = new r, pt = i.UNIT_W.clone(), mt = new d, yt = new t, vt = new t, gt = new f, _t = new f;
        return B.prototype.update = function (e) {
            e === g.SCENE2D ? A(this) : e === g.COLUMBUS_VIEW ? (this._horizontalRotationAxis = n.UNIT_Z, P(this)) : e === g.SCENE3D && (this._horizontalRotationAxis = void 0, V(this))
        }, B.prototype.isDestroyed = function () {
            return!1
        }, B.prototype.destroy = function () {
            return this._spinHandler = this._spinHandler && this._spinHandler.destroy(), this._translateHandler = this._translateHandler && this._translateHandler.destroy(), this._lookHandler = this._lookHandler && this._lookHandler.destroy(), this._rotateHandler = this._rotateHandler && this._rotateHandler.destroy(), this._zoomHandler = this._zoomHandler && this._zoomHandler.destroy(), this._zoomWheelHandler = this._zoomWheelHandler && this._zoomWheelHandler.destroy(), this._pinchHandler = this._pinchHandler && this._pinchHandler.destroy(), e(this)
        }, B
    }), n("Shaders/PostProcessFilters/AdditiveBlend", [], function () {
        "use strict";
        return"uniform sampler2D u_texture0;\nuniform sampler2D u_texture1;\nuniform vec2 u_center;\nuniform float u_radius;\nvarying vec2 v_textureCoordinates;\nvoid main()\n{\nvec4 color0 = texture2D(u_texture0, v_textureCoordinates);\nvec4 color1 = texture2D(u_texture1, v_textureCoordinates);\nfloat x = length(gl_FragCoord.xy - u_center) / u_radius;\nfloat t = smoothstep(0.5, 0.8, x);\ngl_FragColor = mix(color0 + color1, color0, t);\n}\n"
    }), n("Shaders/PostProcessFilters/BrightPass", [], function () {
        "use strict";
        return"uniform sampler2D u_texture;\nuniform float u_avgLuminance;\nuniform float u_threshold;\nuniform float u_offset;\nvarying vec2 v_textureCoordinates;\nfloat key(float avg)\n{\nfloat guess = 1.5 - (1.5 / (avg * 0.1 + 1.0));\nreturn max(0.0, guess) + 0.1;\n}\nvoid main()\n{\nvec4 color = texture2D(u_texture, v_textureCoordinates);\nvec3 xyz = czm_RGBToXYZ(color.rgb);\nfloat luminance = xyz.r;\nfloat scaledLum = key(u_avgLuminance) * luminance / u_avgLuminance;\nfloat brightLum = max(scaledLum - u_threshold, 0.0);\nfloat brightness = brightLum / (u_offset + brightLum);\nxyz.r = brightness;\ngl_FragColor = vec4(czm_XYZToRGB(xyz), 1.0);\n}\n"
    }), n("Shaders/PostProcessFilters/GaussianBlur1D", [], function () {
        "use strict";
        return"#define SAMPLES 8\nuniform float delta;\nuniform float sigma;\nuniform float direction;\nuniform sampler2D u_texture;\nuniform vec2 u_step;\nvarying vec2 v_textureCoordinates;\nvoid main()\n{\nvec2 st = v_textureCoordinates;\nvec2 dir = vec2(1.0 - direction, direction);\nvec3 g;\ng.x = 1.0 / (sqrt(czm_twoPi) * sigma);\ng.y = exp((-0.5 * delta * delta) / (sigma * sigma));\ng.z = g.y * g.y;\nvec4 result = texture2D(u_texture, st) * g.x;\nfor (int i = 1; i < SAMPLES; ++i)\n{\ng.xy *= g.yz;\nvec2 offset = float(i) * dir * u_step;\nresult += texture2D(u_texture, st - offset) * g.x;\nresult += texture2D(u_texture, st + offset) * g.x;\n}\ngl_FragColor = result;\n}\n"
    }), n("Shaders/PostProcessFilters/PassThrough", [], function () {
        "use strict";
        return"uniform sampler2D u_texture;\nvarying vec2 v_textureCoordinates;\nvoid main()\n{\ngl_FragColor = texture2D(u_texture, v_textureCoordinates);\n}\n"
    }), n("Scene/SunPostProcess", ["../Core/BoundingRectangle", "../Core/Cartesian2", "../Core/Cartesian4", "../Core/Color", "../Core/ComponentDatatype", "../Core/defaultValue", "../Core/destroyObject", "../Core/Geometry", "../Core/GeometryAttribute", "../Core/Math", "../Core/Matrix4", "../Core/PrimitiveType", "../Core/Transforms", "../Renderer/BufferUsage", "../Renderer/ClearCommand", "../Renderer/DrawCommand", "../Renderer/PassState", "../Renderer/PixelDatatype", "../Renderer/PixelFormat", "../Renderer/RenderbufferFormat", "../Shaders/PostProcessFilters/AdditiveBlend", "../Shaders/PostProcessFilters/BrightPass", "../Shaders/PostProcessFilters/GaussianBlur1D", "../Shaders/PostProcessFilters/PassThrough", "../Shaders/ViewportQuadVS"], function (e, t, n, i, r, o, a, s, u, l, c, d, f, h, p, m, y, v, g, _, w, C, x, S, b) {
        "use strict";
        function T(e) {
            var t = e.cache.viewportQuad_vertexArray;
            if ("undefined" != typeof t)return t;
            var n = new s({attributes: {position: new u({componentDatatype: r.FLOAT, componentsPerAttribute: 2, values: [-1, -1, 1, -1, 1, 1, -1, 1]}), textureCoordinates: new u({componentDatatype: r.FLOAT, componentsPerAttribute: 2, values: [0, 0, 1, 0, 1, 1, 0, 1]})}, primitiveType: d.TRIANGLES});
            return t = e.createVertexArrayFromGeometry({geometry: n, attributeIndices: A, bufferUsage: h.STATIC_DRAW}), e.cache.viewportQuad_vertexArray = t, t
        }

        var E = function () {
            this._fbo = void 0, this._downSampleFBO1 = void 0, this._downSampleFBO2 = void 0, this._clearFBO1Command = void 0, this._clearFBO2Command = void 0, this._downSampleCommand = void 0, this._brightPassCommand = void 0, this._blurXCommand = void 0, this._blurYCommand = void 0, this._blendCommand = void 0, this._fullScreenCommand = void 0, this._downSamplePassState = new y, this._downSamplePassState.scissorTest = {enable: !0, rectangle: new e}, this._upSamplePassState = new y, this._upSamplePassState.scissorTest = {enabled: !0, rectangle: new e}, this._uCenter = new t, this._uRadius = void 0
        };
        E.prototype.clear = function (e, t) {
            var n = this._clearFBO1Command;
            i.clone(o(t, i.BLACK), n.color), n.execute(e), n = this._clearFBO2Command, i.clone(o(t, i.BLACK), n.color), n.execute(e)
        }, E.prototype.execute = function (e) {
            this._downSampleCommand.execute(e, this._downSamplePassState), this._brightPassCommand.execute(e, this._downSamplePassState), this._blurXCommand.execute(e, this._downSamplePassState), this._blurYCommand.execute(e, this._downSamplePassState), this._fullScreenCommand.execute(e), this._blendCommand.execute(e, this._upSamplePassState)
        };
        var A = {position: 0, textureCoordinates: 1}, M = new e, D = new e, I = new n, P = new t, O = new t, R = new c;
        return E.prototype.update = function (e) {
            var n = e.getCanvas(), r = n.clientWidth, o = n.clientHeight, a = this;
            if ("undefined" == typeof this._fbo) {
                this._fbo = e.createFramebuffer(), this._downSampleFBO1 = e.createFramebuffer(), this._downSampleFBO2 = e.createFramebuffer(), this._clearFBO1Command = new p, this._clearFBO1Command.color = new i, this._clearFBO1Command.framebuffer = this._downSampleFBO1, this._clearFBO2Command = new p, this._clearFBO2Command.color = new i, this._clearFBO2Command.framebuffer = this._downSampleFBO2;
                var s = d.TRIANGLE_FAN, u = T(e), h = this._downSampleCommand = new m;
                h.owner = this, h.primitiveType = s, h.vertexArray = u, h.shaderProgram = e.getShaderCache().getShaderProgram(b, S, A), h.uniformMap = {}, h.framebuffer = this._downSampleFBO1;
                var y = this._brightPassCommand = new m;
                y.owner = this, y.primitiveType = s, y.vertexArray = u, y.shaderProgram = e.getShaderCache().getShaderProgram(b, C, A), y.uniformMap = {u_avgLuminance: function () {
                    return.5
                }, u_threshold: function () {
                    return.25
                }, u_offset: function () {
                    return.1
                }}, y.framebuffer = this._downSampleFBO2;
                var E = 1, z = 2, L = this._blurXCommand = new m;
                L.owner = this, L.primitiveType = s, L.vertexArray = u, L.shaderProgram = e.getShaderCache().getShaderProgram(b, x, A), L.uniformMap = {delta: function () {
                    return E
                }, sigma: function () {
                    return z
                }, direction: function () {
                    return 0
                }}, L.framebuffer = this._downSampleFBO1;
                var N = this._blurYCommand = new m;
                N.owner = this, N.primitiveType = s, N.vertexArray = u, N.shaderProgram = e.getShaderCache().getShaderProgram(b, x, A), N.uniformMap = {delta: function () {
                    return E
                }, sigma: function () {
                    return z
                }, direction: function () {
                    return 1
                }}, N.framebuffer = this._downSampleFBO2;
                var F = this._blendCommand = new m;
                F.owner = this, F.primitiveType = s, F.vertexArray = u, F.shaderProgram = e.getShaderCache().getShaderProgram(b, w, A), F.uniformMap = {u_center: function () {
                    return a._uCenter
                }, u_radius: function () {
                    return a._uRadius
                }};
                var V = this._fullScreenCommand = new m;
                V.owner = this, V.primitiveType = s, V.vertexArray = u, V.shaderProgram = e.getShaderCache().getShaderProgram(b, S, A), V.uniformMap = {}
            }
            var B = Math.pow(2, Math.ceil(Math.log(r) / Math.log(2)) - 2), k = Math.pow(2, Math.ceil(Math.log(o) / Math.log(2)) - 2), U = Math.max(B, k), q = M;
            q.width = r, q.height = o;
            var W = D;
            W.width = U, W.height = U;
            var H = this._fbo, G = H.getColorTexture();
            if ("undefined" == typeof G || G.getWidth() !== r || G.getHeight() !== o) {
                H.setColorTexture(e.createTexture2D({width: r, height: o})), e.getDepthTexture() ? H.setDepthTexture(e.createTexture2D({width: r, height: o, pixelFormat: g.DEPTH_COMPONENT, pixelDatatype: v.UNSIGNED_SHORT})) : H.setDepthRenderbuffer(e.createRenderbuffer({format: _.DEPTH_COMPONENT16})), this._downSampleFBO1.setColorTexture(e.createTexture2D({width: U, height: U})), this._downSampleFBO2.setColorTexture(e.createTexture2D({width: U, height: U}));
                var j = e.createRenderState({viewport: W}), Y = e.createRenderState();
                this._downSampleCommand.uniformMap.u_texture = function () {
                    return H.getColorTexture()
                }, this._downSampleCommand.renderState = j, this._brightPassCommand.uniformMap.u_texture = function () {
                    return a._downSampleFBO1.getColorTexture()
                }, this._brightPassCommand.renderState = j, this._blurXCommand.uniformMap.u_texture = function () {
                    return a._downSampleFBO2.getColorTexture()
                }, this._blurXCommand.uniformMap.u_step = function () {
                    return new t(1 / U, 1 / U)
                }, this._blurXCommand.renderState = j, this._blurYCommand.uniformMap.u_texture = function () {
                    return a._downSampleFBO1.getColorTexture()
                }, this._blurYCommand.uniformMap.u_step = function () {
                    return new t(1 / U, 1 / U)
                }, this._blurYCommand.renderState = j, this._blendCommand.uniformMap.u_texture0 = function () {
                    return H.getColorTexture()
                }, this._blendCommand.uniformMap.u_texture1 = function () {
                    return a._downSampleFBO2.getColorTexture()
                }, this._blendCommand.renderState = Y, this._fullScreenCommand.uniformMap.u_texture = function () {
                    return H.getColorTexture()
                }, this._fullScreenCommand.renderState = Y
            }
            var X = e.getUniformState(), Z = X.getSunPositionWC(), K = X.getView(), J = X.getViewProjection(), Q = X.getProjection(), $ = c.computeViewportTransformation(q, 0, 1, R), et = c.multiplyByPoint(K, Z, I), tt = f.pointToWindowCoordinates(J, $, Z, P);
            et.x += l.SOLAR_RADIUS;
            var nt = f.pointToWindowCoordinates(Q, $, et, et), it = 2 * 30 * t.magnitude(t.subtract(nt, tt, nt)), rt = O;
            rt.x = it, rt.y = it;
            var ot = this._upSamplePassState.scissorTest.rectangle;
            return ot.x = Math.max(tt.x - .5 * rt.x, 0), ot.y = Math.max(tt.y - .5 * rt.y, 0), ot.width = Math.min(rt.x, r), ot.height = Math.min(rt.y, o), t.clone(tt, this._uCenter), this._uRadius = .5 * Math.max(rt.x, rt.y), $ = c.computeViewportTransformation(W, 0, 1, R), tt = f.pointToWindowCoordinates(J, $, Z, P), rt.x *= B / r, rt.y *= k / o, ot = this._downSamplePassState.scissorTest.rectangle, ot.x = Math.max(tt.x - .5 * rt.x, 0), ot.y = Math.max(tt.y - .5 * rt.y, 0), ot.width = Math.min(rt.x, r), ot.height = Math.min(rt.y, o), this._downSamplePassState.context = e, this._upSamplePassState.context = e, this._fbo
        }, E.prototype.isDestroyed = function () {
            return!1
        }, E.prototype.destroy = function () {
            return this._fbo = this._fbo && this._fbo.destroy(), this._downSampleFBO1 = this._downSampleFBO1 && this._downSampleFBO1.destroy(), this._downSampleFBO2 = this._downSampleFBO2 && this._downSampleFBO2.destroy(), this._downSampleCommand = this._downSampleCommand && this._downSampleCommand.shaderProgram && this._downSampleCommand.shaderProgram.release(), this._brightPassCommand = this._brightPassCommand && this._brightPassCommand.shaderProgram && this._brightPassCommand.shaderProgram.release(), this._blurXCommand = this._blurXCommand && this._blurXCommand.shaderProgram && this._blurXCommand.shaderProgram.release(), this._blurYCommand = this._blurYCommand && this._blurYCommand.shaderProgram && this._blurYCommand.shaderProgram.release(), this._blendCommand = this._blendCommand && this._blendCommand.shaderProgram && this._blendCommand.shaderProgram.release(), this._fullScreenCommand = this._fullScreenCommand && this._fullScreenCommand.shaderProgram && this._fullScreenCommand.shaderProgram.release(), a(this)
        }, E
    }), n("Scene/Scene", ["../Core/Math", "../Core/Color", "../Core/defaultValue", "../Core/destroyObject", "../Core/GeographicProjection", "../Core/Ellipsoid", "../Core/Occluder", "../Core/BoundingRectangle", "../Core/BoundingSphere", "../Core/Cartesian2", "../Core/Cartesian3", "../Core/Intersect", "../Core/Interval", "../Core/Matrix4", "../Core/JulianDate", "../Core/EllipsoidGeometry", "../Core/GeometryInstance", "../Core/GeometryPipeline", "../Core/ColorGeometryInstanceAttribute", "../Renderer/Context", "../Renderer/ClearCommand", "../Renderer/PassState", "./Camera", "./ScreenSpaceCameraController", "./CompositePrimitive", "./CullingVolume", "./AnimationCollection", "./SceneMode", "./FrameState", "./OrthographicFrustum", "./PerspectiveOffCenterFrustum", "./FrustumCommands", "./Primitive", "./PerInstanceColorAppearance", "./SunPostProcess", "./CreditDisplay"], function (e, t, n, i, r, o, a, s, u, l, c, d, f, h, p, m, y, v, g, _, w, C, x, S, b, T, E, A, M, D, I, P, O, R, z, L) {
        "use strict";
        function N(e) {
            e.color = !1, e.pick = !1, e.overlay = !1
        }

        function F(e, t, n) {
            var i = e._camera, r = e._frameState;
            r.mode = e.mode, r.morphTime = e.morphTime, r.scene2D = e.scene2D, r.frameNumber = t, r.time = n, r.camera = i, r.cullingVolume = i.frustum.computeCullingVolume(i.getPositionWC(), i.getDirectionWC(), i.getUpWC()), r.occluder = void 0, r.canvasDimensions.x = e._canvas.clientWidth, r.canvasDimensions.y = e._canvas.clientHeight;
            var o = e._primitives.getCentralBody();
            if (e.mode === A.SCENE3D && "undefined" != typeof o) {
                var s = o.getEllipsoid(), l = new a(new u(c.ZERO, s.getMinimumRadius()), i.getPositionWC());
                r.occluder = l
            }
            N(r.passes)
        }

        function V(e, t, n, i, r) {
            r.length = i;
            for (var o = 0; i > o; ++o) {
                var a = Math.max(e, Math.pow(n, o) * e), s = Math.min(t, n * a);
                a *= .99;
                var u = r[o];
                "undefined" == typeof u ? u = r[o] = new P(a, s) : (u.near = a, u.far = s)
            }
        }

        function B(e, t, n) {
            for (var i = e._frustumCommandsList, r = i.length, o = 0; r > o; ++o) {
                var a = i[o], s = a.near, u = a.far;
                if ("undefined" != typeof n) {
                    if (n.start > u)continue;
                    if (n.stop < s)break
                }
                if (a.commands[a.index++] = t, t.executeInClosestFrustum)break
            }
        }

        function k(e, t) {
            for (var i = e._commandList, r = e._frameState.cullingVolume, o = e._camera, a = o.getDirectionWC(), s = o.getPositionWC(), u = e._frustumCommandsList, l = u.length, c = 0; l > c; ++c)u[c].index = 0;
            var f, p = Number.MAX_VALUE, m = Number.MIN_VALUE, y = !1;
            e._frameState.mode === A.SCENE3D && (f = e._frameState.occluder);
            for (var v = Z.planes, g = 0; 5 > g; ++g)v[g] = r.planes[g];
            r = Z;
            for (var _ = i.length, C = 0; _ > C; ++C)for (var x = i[C][t], S = x.length, b = 0; S > b; ++b) {
                var T = x[b], E = T.boundingVolume;
                if ("undefined" != typeof E) {
                    var M = n(T.modelMatrix, h.IDENTITY), D = E.transform(M);
                    if (T.cull && (r.getVisibility(D) === d.OUTSIDE || "undefined" != typeof f && !f.isBoundingSphereVisible(D)))continue;
                    K = D.getPlaneDistances(s, a, K), p = Math.min(p, K.start), m = Math.max(m, K.stop), B(e, T, K)
                } else y = !(T instanceof w), B(e, T)
            }
            y ? (p = o.frustum.near, m = o.frustum.far) : (p = Math.min(Math.max(p, o.frustum.near), o.frustum.far), m = Math.max(Math.min(m, o.frustum.far), p));
            var I = e.farToNearRatio, P = Math.ceil(Math.log(m / p) / Math.log(I));
            p !== Number.MAX_VALUE && (P !== l || 0 !== u.length && (p < u[0].near || m > u[l - 1].far)) && (V(p, m, I, P, u), k(e, t))
        }

        function U(e, t, i, r) {
            if (("undefined" == typeof t.debugCommandFilter || t.debugCommandFilter(e)) && (e.execute(i, r), e.debugShowBoundingVolume && "undefined" != typeof e.boundingVolume)) {
                if ("undefined" == typeof t._debugSphere) {
                    var a = new m({ellipsoid: o.UNIT_SPHERE, numberOfPartitions: 20, vertexFormat: R.FLAT_VERTEX_FORMAT});
                    t._debugSphere = new O({geometryInstances: new y({geometry: v.toWireframe(a), attributes: {color: new g(1, 0, 0, 1)}}), appearance: new R({flat: !0, translucent: !1})})
                }
                var s = h.multiplyByTranslation(n(e.modelMatrix, h.IDENTITY), e.boundingVolume.center);
                t._debugSphere.modelMatrix = h.multiplyByUniformScale(h.fromTranslation(c.fromArray(s, 12)), e.boundingVolume.radius);
                var u = [];
                t._debugSphere.update(i, t._frameState, u), u[0].colorList[0].execute(i, r)
            }
        }

        function q(e, t) {
            for (var n = t.mode === A.SCENE3D ? t.occluder : void 0, i = t.cullingVolume, r = Z.planes, o = 0; 5 > o; ++o)r[o] = i.planes[o];
            return i = Z, "undefined" != typeof e && ("undefined" == typeof e.boundingVolume || !e.cull || i.getVisibility(e.boundingVolume) !== d.OUTSIDE && ("undefined" == typeof n || n.isBoundingSphereVisible(e.boundingVolume)))
        }

        function W(e, i) {
            var r = e._frameState, o = e._camera, a = o.frustum.clone(), s = e._context, u = s.getUniformState(), l = r.passes.color && "undefined" != typeof e.skyBox ? e.skyBox.update(s, r) : void 0, c = r.passes.color && "undefined" != typeof e.skyAtmosphere ? e.skyAtmosphere.update(s, r) : void 0, d = r.passes.color && "undefined" != typeof e.sun ? e.sun.update(s, r) : void 0, f = q(d, r);
            f && (i.framebuffer = e._sunPostProcess.update(s));
            var h = e._clearColorCommand;
            t.clone(n(e.backgroundColor, t.BLACK), h.color), h.execute(s, i), f && e._sunPostProcess.clear(s, e.backgroundColor), a.near = o.frustum.near, a.far = o.frustum.far, u.updateFrustum(a), "undefined" != typeof l && U(l, e, s, i), "undefined" != typeof c && U(c, e, s, i), "undefined" != typeof d && f && (d.execute(s, i), e._sunPostProcess.execute(s), i.framebuffer = void 0);
            for (var p = e._clearDepthStencilCommand, m = e._frustumCommandsList, y = m.length, v = 0; y > v; ++v) {
                p.execute(s, i);
                var g = y - v - 1, _ = m[g];
                a.near = _.near, a.far = _.far, u.updateFrustum(a);
                for (var w = _.commands, C = _.index, x = 0; C > x; ++x)U(w[x], e, s, i)
            }
        }

        function H(e, t) {
            for (var n = e._context, i = e._commandList, r = i.length, o = 0; r > o; ++o)for (var a = i[o].overlayList, s = a.length, u = 0; s > u; ++u)a[u].execute(n, t)
        }

        function G(e, t) {
            var n = e._canvas, i = e._camera, r = i.frustum, o = n.clientWidth, a = n.clientHeight, s = 2 / o * t.x - 1;
            s *= .5 * (r.right - r.left);
            var u = 2 / a * (a - t.y) - 1;
            u *= .5 * (r.top - r.bottom);
            var d = i.position;
            d = new c(d.z, d.x, d.y), d.y += s, d.z += u;
            var f = r.getPixelSize(new l(o, a)), h = J;
            return h.right = .5 * f.x, h.left = -h.right, h.top = .5 * f.y, h.bottom = -h.top, h.near = r.near, h.far = r.far, h.computeCullingVolume(d, i.getDirectionWC(), i.getUpWC())
        }

        function j(e, t, n, i) {
            var r = e._canvas, o = e._camera, a = o.frustum, s = a.near, u = r.clientWidth, c = r.clientHeight, d = Math.tan(.5 * a.fovy), f = a.aspectRatio * d, h = 2 / u * t.x - 1, p = 2 / c * (c - t.y) - 1, m = h * s * f, y = p * s * d, v = a.getPixelSize(new l(u, c)), g = .5 * v.x * n, _ = .5 * v.y * i, w = Q;
            return w.top = y + _, w.bottom = y - _, w.right = m + g, w.left = m - g, w.near = s, w.far = a.far, w.computeCullingVolume(o.getPositionWC(), o.getDirectionWC(), o.getUpWC())
        }

        function Y(e, t, n, i) {
            return e.mode === A.SCENE2D ? G(e, t, n, i) : j(e, t, n, i)
        }

        var X = function (e, n, i) {
            var a, s = new _(e, n);
            if ("undefined" != typeof i)a = new L(i); else {
                var u = document.createElement("div");
                u.style.position = "absolute", u.style.bottom = "0", u.style["text-shadow"] = "0px 0px 2px #000000", u.style.color = "#ffffff", u.style["font-size"] = "10pt", u.style["padding-right"] = "5px", e.parentNode.appendChild(u), a = new L(u)
            }
            this._frameState = new M(a), this._passState = new C(s), this._canvas = e, this._context = s, this._primitives = new b, this._pickFramebuffer = void 0, this._camera = new x(e), this._screenSpaceCameraController = new S(e, this._camera.controller), this._animations = new E, this._shaderFrameCount = 0, this._sunPostProcess = new z, this._commandList = [], this._frustumCommandsList = [], this._clearColorCommand = new w, this._clearColorCommand.color = new t, this._clearColorCommand.owner = !0;
            var l = new w;
            l.depth = 1, l.stencil = 1, l.owner = this, this._clearDepthStencilCommand = l, this.skyBox = void 0, this.skyAtmosphere = void 0, this.sun = void 0, this.backgroundColor = t.BLACK.clone(), this.mode = A.SCENE3D, this.scene2D = {projection: new r(o.WGS84)}, this.morphTime = 1, this.farToNearRatio = 1e3, this.debugCommandFilter = void 0, this._debugSphere = void 0;
            var c = this._camera.frustum.near, d = this._camera.frustum.far, f = Math.ceil(Math.log(d / c) / Math.log(this.farToNearRatio));
            V(c, d, this.farToNearRatio, f, this._frustumCommandsList), F(this, 0, new p), this.initializeFrame()
        };
        X.prototype.getCanvas = function () {
            return this._canvas
        }, X.prototype.getContext = function () {
            return this._context
        }, X.prototype.getPrimitives = function () {
            return this._primitives
        }, X.prototype.getCamera = function () {
            return this._camera
        }, X.prototype.getScreenSpaceCameraController = function () {
            return this._screenSpaceCameraController
        }, X.prototype.getUniformState = function () {
            return this._context.getUniformState()
        }, X.prototype.getFrameState = function () {
            return this._frameState
        }, X.prototype.getAnimations = function () {
            return this._animations
        };
        var Z = new T, K = new f;
        X.prototype.initializeFrame = function () {
            120 === this._shaderFrameCount++ && (this._shaderFrameCount = 0, this._context.getShaderCache().destroyReleasedShaderPrograms()), this._animations.update(), this._camera.controller.update(this.mode, this.scene2D), this._screenSpaceCameraController.update(this.mode)
        }, X.prototype.render = function (t) {
            "undefined" == typeof t && (t = new p);
            var n = this.getUniformState(), i = this._frameState, r = e.incrementWrap(i.frameNumber, 15e6, 1);
            F(this, r, t), i.passes.color = !0, i.passes.overlay = !0, i.creditDisplay.beginFrame(), n.update(i);
            var o = this._context;
            this._commandList.length = 0, this._primitives.update(o, i, this._commandList), k(this, "colorList");
            var a = this._passState;
            W(this, a), H(this, a), i.creditDisplay.endFrame()
        };
        var J = new D, Q = new I, $ = 3, et = 3, tt = new s(0, 0, $, et);
        return X.prototype.pick = function (e) {
            var t = this._context, n = this._primitives, i = this._frameState;
            "undefined" == typeof this._pickFramebuffer && (this._pickFramebuffer = t.createPickFramebuffer()), F(this, i.frameNumber, i.time), i.cullingVolume = Y(this, e, $, et), i.passes.pick = !0;
            var r = this._commandList;
            return r.length = 0, n.update(t, i, r), k(this, "pickList"), tt.x = e.x - .5 * ($ - 1), tt.y = this._canvas.clientHeight - e.y - .5 * (et - 1), W(this, this._pickFramebuffer.begin(tt)), this._pickFramebuffer.end(tt)
        }, X.prototype.isDestroyed = function () {
            return!1
        }, X.prototype.destroy = function () {
            return this._screenSpaceCameraController = this._screenSpaceCameraController && this._screenSpaceCameraController.destroy(), this._pickFramebuffer = this._pickFramebuffer && this._pickFramebuffer.destroy(), this._primitives = this._primitives && this._primitives.destroy(), this.skyBox = this.skyBox && this.skyBox.destroy(), this.skyAtmosphere = this.skyAtmosphere && this.skyAtmosphere.destroy(), this._debugSphere = this._debugSphere && this._debugSphere.destroy(), this.sun = this.sun && this.sun.destroy(), this._sunPostProcess = this._sunPostProcess && this._sunPostProcess.destroy(), this._context = this._context && this._context.destroy(), this._frameState.creditDisplay.destroy(), i(this)
        }, X
    }), n("Scene/SceneTransitioner", ["../Core/defaultValue", "../Core/destroyObject", "../Core/DeveloperError", "../Core/Math", "../Core/Event", "../Core/ScreenSpaceEventHandler", "../Core/ScreenSpaceEventType", "../Core/Ellipsoid", "../Core/Cartesian3", "../Core/Cartesian4", "../Core/Cartographic", "../Core/Matrix4", "../ThirdParty/Tween", "./OrthographicFrustum", "./PerspectiveFrustum", "./SceneMode"], function (e, t, n, i, r, o, a, s, u, l, c, d, f, h, p, m) {
        "use strict";
        function y(e, t) {
            var n = new l(e.position.x, e.position.y, e.position.z, 1), i = new l(e.direction.x, e.direction.y, e.direction.z, 0), r = new l(e.up.x, e.up.y, e.up.z, 0), o = t.inverseTransformation().multiply(e.transform);
            e.transform = t.clone(), e.position = u.fromCartesian4(o.multiplyByVector(n)), e.direction = u.fromCartesian4(o.multiplyByVector(i)), e.up = u.fromCartesian4(o.multiplyByVector(r)), e.right = e.direction.cross(e.up)
        }

        function v(e, t) {
            if (e.completeMorphOnUserInput) {
                e._morphHandler = new o(e._scene.getCanvas());
                var n = function () {
                    e._morphCancelled = !0, t(e)
                };
                e._completeMorph = n, e._morphHandler.setInputAction(n, a.LEFT_DOWN), e._morphHandler.setInputAction(n, a.MIDDLE_DOWN), e._morphHandler.setInputAction(n, a.RIGHT_DOWN), e._morphHandler.setInputAction(n, a.WHEEL)
            }
        }

        function g(e) {
            for (var t = e._scene.getAnimations(), n = 0; n < e._currentAnimations.length; ++n)t.remove(e._currentAnimations[n]);
            e._currentAnimations.length = 0, e._morphHandler = e._morphHandler && e._morphHandler.destroy()
        }

        function _(e, t, n) {
            var i = e._scene, r = i.getCamera();
            y(r, d.IDENTITY);
            var o = r.position, a = r.direction, s = r.up, l = e._ellipsoid.getMaximumRadius(), h = e._ellipsoid.cartographicToCartesian(new c(0, 0, 10));
            h = h.normalize().multiplyByScalar(2 * l);
            var p = u.ZERO.subtract(h).normalize(), m = p.cross(u.UNIT_Z).normalize(), v = m.cross(p), g = function (e) {
                r.position = C(o, h, e.time), r.direction = C(a, p, e.time), r.up = C(s, v, e.time), r.right = r.direction.cross(r.up)
            }, _ = i.getAnimations().add({duration: t, easingFunction: f.Easing.Quartic.Out, startValue: {time: 0}, stopValue: {time: 1}, onUpdate: g});
            e._currentAnimations.push(_), M(e, i, 0, 1, t, n)
        }

        function w(e, t, n) {
            t = .5 * t;
            var i = e._scene.getCamera();
            T(e, t, function () {
                i.frustum = e._cameraCV.frustum.clone(), i.transform = e._cameraCV.transform.clone(), _(e, t, n)
            })
        }

        function C(e, t, n) {
            return e.lerp(t, n)
        }

        function x(e, t, n) {
            var r = e._scene, o = r.getCamera(), a = o.position, s = o.frustum.fovy, u = .5 * i.RADIANS_PER_DEGREE, l = a.magnitude() * Math.tan(.5 * s);
            o.frustum.far = l / Math.tan(.5 * u) + 1e7;
            var c = function (e) {
                o.frustum.fovy = i.lerp(s, u, e.time);
                var t = l / Math.tan(.5 * o.frustum.fovy);
                o.position = o.position.normalize().multiplyByScalar(t)
            }, d = r.getAnimations().add({duration: t, easingFunction: f.Easing.Quartic.Out, startValue: {time: 0}, stopValue: {time: 1}, onUpdate: c, onComplete: function () {
                o.frustum = e._camera2D.frustum.clone(), n(e)
            }});
            e._currentAnimations.push(d)
        }

        function S(e, t, n) {
            var i = e._scene, r = i.getCamera(), o = e._ellipsoid.getMaximumRadius();
            y(r, e._cameraCV.transform);
            var a = r.position.clone(), s = r.direction.clone(), u = r.up.clone(), l = Math.tan(.5 * e._cameraCV.frustum.fovy), c = e._cameraCV.frustum.aspectRatio * l, d = o * Math.PI / c, h = e._camera2D.position.normalize().multiplyByScalar(d), p = e._camera2D.direction.clone(), m = e._camera2D.up.clone(), v = function (e) {
                r.position = C(a, h, e.time), r.direction = C(s, p, e.time), r.up = C(u, m, e.time), r.right = r.direction.cross(r.up)
            };
            t = .5 * t;
            var g = i.getAnimations().add({duration: t, easingFunction: f.Easing.Quartic.Out, startValue: {time: 0}, stopValue: {time: 1}, onUpdate: v, onComplete: function () {
                x(e, t, n)
            }});
            e._currentAnimations.push(g)
        }

        function b(e, t, n) {
            t = .5 * t;
            var i = e._ellipsoid.getMaximumRadius(), r = Math.tan(.5 * e._camera3D.frustum.fovy), o = e._camera3D.frustum.aspectRatio * r, a = i * Math.PI / o, s = {};
            s.position = e._camera2D.position.normalize().multiplyByScalar(a), s.direction = e._camera2D.direction.clone(), s.up = e._camera2D.up.clone();
            var u = function () {
                x(e, t, n)
            };
            A(e, t, s, u)
        }

        function T(e, t, n) {
            var r = e._scene, o = r.getCamera(), a = e._ellipsoid.getMaximumRadius(), s = Math.tan(.5 * e._cameraCV.frustum.fovy), u = e._cameraCV.frustum.aspectRatio * s, l = a * Math.PI / u, c = e._camera2D.position.normalize().multiplyByScalar(l), d = o.frustum.top, h = o.frustum.bottom, p = o.frustum.right, m = o.frustum.left, y = e._camera2D.frustum, v = e._cameraCV.frustum, g = o.position.clone(), _ = function (e) {
                o.position = C(g, c, e.time), o.frustum.top = i.lerp(d, y.top, e.time), o.frustum.bottom = i.lerp(h, y.bottom, e.time), o.frustum.right = i.lerp(p, y.right, e.time), o.frustum.left = i.lerp(m, y.left, e.time)
            }, w = (p - m) / (2 * a * Math.PI), x = 1;
            w > x && (w = 0);
            var S = (x - w) * t;
            if (S < i.EPSILON6) {
                if (g.equalsEpsilon(c, i.EPSILON6))return o.position = c, o.frustum = v.clone(), n(e), void 0;
                S = t, w = 0, x = 1
            }
            var b = r.getAnimations().add({easingFunction: f.Easing.Quartic.Out, duration: S, startValue: {time: w}, stopValue: {time: x}, onUpdate: _, onComplete: function () {
                o.frustum = v.clone(), n(e)
            }});
            e._currentAnimations.push(b)
        }

        function E(e, t, n) {
            var i = e._scene, r = i.getCamera();
            t = .5 * t;
            var o = function () {
                var o = r.position.clone(), a = r.direction.clone(), s = r.up.clone(), u = e._cameraCV.position.clone(), l = e._cameraCV.direction.clone(), c = e._cameraCV.up.clone(), d = function (e) {
                    r.position = C(o, u, e.time), r.direction = C(a, l, e.time), r.up = C(s, c, e.time), r.right = r.direction.cross(r.up)
                }, h = i.getAnimations().add({duration: t, easingFunction: f.Easing.Quartic.Out, startValue: {time: 0}, stopValue: {time: 1}, onUpdate: d, onComplete: function () {
                    n(e)
                }});
                e._currentAnimations.push(h)
            };
            T(e, t, o)
        }

        function A(e, t, n, i) {
            var r = e._scene, o = r.getCamera();
            y(o, e._cameraCV.transform);
            var a = o.position.clone(), s = o.direction.clone(), u = o.up.clone(), l = n.position.clone(), c = n.direction.clone(), d = n.up.clone(), h = function (e) {
                o.position = C(a, l, e.time), o.direction = C(s, c, e.time), o.up = C(u, d, e.time), o.right = o.direction.cross(o.up)
            }, p = r.getAnimations().add({duration: t, easingFunction: f.Easing.Quartic.Out, startValue: {time: 0}, stopValue: {time: 1}, onUpdate: h, onComplete: function () {
                o.position = l, o.direction = c, o.up = d
            }});
            e._currentAnimations.push(p), M(e, r, 1, 0, t, i)
        }

        function M(e, t, n, i, r, o) {
            var a = {duration: r, easingFunction: f.Easing.Quartic.Out};
            "undefined" != typeof o && (a.onComplete = function () {
                o(e)
            });
            var s = t.getAnimations().addProperty(t, "morphTime", n, i, a);
            e._currentAnimations.push(s)
        }

        function D(e) {
            var t = e._scene, n = t.getCanvas(), i = n.clientHeight / n.clientWidth, r = e._camera2D.frustum;
            r.top = r.right * i, r.bottom = -r.top, i = 1 / i, r = e._cameraCV.frustum, r.aspectRatio = i, r = e._camera3D.frustum, r.aspectRatio = i;
            var o = t.getCamera();
            switch (t.mode) {
                case m.SCENE3D:
                    o.frustum = e._camera3D.frustum.clone();
                    break;
                case m.COLUMBUS_VIEW:
                    o.frustum = e._cameraCV.frustum.clone();
                    break;
                case m.SCENE2D:
                    o.frustum = e._camera2D.frustum.clone()
            }
        }

        function I(e) {
            var t = e._scene;
            t.mode = m.SCENE3D, t.morphTime = m.SCENE3D.morphTime, g(e), D(e);
            var n = t.getCamera();
            n.transform = d.IDENTITY.clone(), (e._previousMode !== m.MORPHING || e._morphCancelled) && (e._morphCancelled = !1, n.position = e._camera3D.position.clone(), n.direction = e._camera3D.direction.clone(), n.up = e._camera3D.up.clone());
            var i = "undefined" != typeof e._completeMorph;
            e._completeMorph = void 0, e.onTransitionComplete.raiseEvent(e, e._previousMode, m.SCENE3D, i)
        }

        function P(e) {
            var t = e._scene;
            t.mode = m.SCENE2D, t.morphTime = m.SCENE2D.morphTime, g(e), D(e);
            var n = t.getCamera();
            n.transform = e._camera2D.transform.clone(), n.position = e._camera2D.position.clone(), n.direction = e._camera2D.direction.clone(), n.up = e._camera2D.up.clone();
            var i = "undefined" != typeof e._completeMorph;
            e._completeMorph = void 0, e.onTransitionComplete.raiseEvent(e, e._previousMode, m.SCENE2D, i)
        }

        function O(e) {
            var t = e._scene;
            t.mode = m.COLUMBUS_VIEW, t.morphTime = m.COLUMBUS_VIEW.morphTime, g(e), D(e);
            var n = t.getCamera();
            n.transform = e._cameraCV.transform.clone(), (e._previousModeMode !== m.MORPHING || e._morphCancelled) && (e._morphCancelled = !1, n.position = e._cameraCV.position.clone(), n.direction = e._cameraCV.direction.clone(), n.up = e._cameraCV.up.clone(), n.right = n.direction.cross(n.up));
            var i = "undefined" != typeof e._completeMorph;
            e._completeMorph = void 0, e.onTransitionComplete.raiseEvent(e, e._previousMode, m.COLUMBUS_VIEW, i)
        }

        var R = function (t, o) {
            if ("undefined" == typeof t)throw new n("scene is required.");
            this.morphDuration = 2e3, this.completeMorphOnUserInput = !0, this.onTransitionStart = new r, this.onTransitionComplete = new r, this._scene = t, this._ellipsoid = e(o, s.WGS84);
            var a = t.getCanvas(), l = this._ellipsoid.getMaximumRadius(), c = new u(0, 0, 2 * l), f = c.negate().normalize(), m = u.UNIT_Y, y = new h;
            y.right = l * Math.PI, y.left = -y.right, y.top = y.right * (a.clientHeight / a.clientWidth), y.bottom = -y.top;
            var v = new d(0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1);
            this._camera2D = {position: c, direction: f, up: m, frustum: y, transform: v}, c = new u(0, -1, 1).normalize().multiplyByScalar(5 * l), f = u.ZERO.subtract(c).normalize();
            var g = f.cross(u.UNIT_Z).normalize();
            m = g.cross(f), y = new p, y.fovy = i.toRadians(60), y.aspectRatio = a.clientWidth / a.clientHeight, this._cameraCV = {position: c, direction: f, up: m, frustum: y, transform: v}, c = new u(0, -2, 1).normalize().multiplyByScalar(2 * l), f = u.ZERO.subtract(c).normalize(), g = f.cross(u.UNIT_Z).normalize(), m = g.cross(f), this._camera3D = {position: c, direction: f, up: m, frustum: y}, this._currentAnimations = [], this._morphHandler = void 0, this._morphCancelled = !1, this._completeMorph = void 0
        };
        return R.prototype.getScene = function () {
            return this._scene
        }, R.prototype.getEllipsoid = function () {
            return this._ellipsoid
        }, R.prototype.to2D = function () {
            "undefined" != typeof this._completeMorph && this._completeMorph(), this._previousMode = this._scene.mode, this._previousMode !== m.SCENE2D && (this.onTransitionStart.raiseEvent(this, this._previousMode, m.SCENE2D, !1), P(this))
        }, R.prototype.toColumbusView = function () {
            "undefined" != typeof this._completeMorph && this._completeMorph();
            var e = this._scene;
            this._previousMode = e.mode, this._previousMode !== m.COLUMBUS_VIEW && (this.onTransitionStart.raiseEvent(this, this._previousMode, m.COLUMBUS_VIEW, !1), O(this))
        }, R.prototype.to3D = function () {
            "undefined" != typeof this._completeMorph && this._completeMorph();
            var e = this._scene;
            this._previousMode = e.mode, e.mode !== m.SCENE3D && (this.onTransitionStart.raiseEvent(this, this._previousMode, m.SCENE3D, !1), I(this))
        }, R.prototype.completeMorph = function () {
            if ("undefined" == typeof this._completeMorph)throw new n("completeMorph can only be called while morphing");
            this._completeMorph()
        }, R.prototype.morphTo2D = function () {
            "undefined" != typeof this._completeMorph && this._completeMorph();
            var e = this._scene;
            this._previousMode = e.mode, this._previousMode !== m.SCENE2D && this._previousMode !== m.MORPHING && (this.onTransitionStart.raiseEvent(this, this._previousMode, m.SCENE2D, !0), D(this), e.mode = m.MORPHING, v(this, P), this._previousMode === m.COLUMBUS_VIEW ? S(this, this.morphDuration, P) : b(this, this.morphDuration, P))
        }, R.prototype.morphToColumbusView = function () {
            "undefined" != typeof this._completeMorph && this._completeMorph();
            var e = this._scene;
            this._previousMode = e.mode, this._previousMode !== m.COLUMBUS_VIEW && this._previousMode !== m.MORPHING && (this.onTransitionStart.raiseEvent(this, this._previousMode, m.COLUMBUS_VIEW, !0), D(this), e.mode = m.MORPHING, v(this, O), this._previousMode === m.SCENE2D ? E(this, this.morphDuration, O) : A(this, this.morphDuration, this._cameraCV, O))
        }, R.prototype.morphTo3D = function () {
            "undefined" != typeof this._completeMorph && this._completeMorph();
            var e = this._scene;
            this._previousMode = e.mode, this._previousMode !== m.SCENE3D && this._previousMode !== m.MORPHING && (this.onTransitionStart.raiseEvent(this, this._previousMode, m.SCENE3D, !0), D(this), e.mode = m.MORPHING, v(this, I), this._previousMode === m.SCENE2D ? w(this, this.morphDuration, I) : _(this, this.morphDuration, I))
        }, R.prototype.isDestroyed = function () {
            return!1
        }, R.prototype.destroy = function () {
            return g(this), t(this)
        }, R
    }), n("Scene/SensorVolumeCollection", ["../Core/destroyObject", "../Core/DeveloperError", "./CustomSensorVolume", "./RectangularPyramidSensorVolume", "./SceneMode"], function (e, t, n, i, r) {
        "use strict";
        var o = function () {
            this._sensors = []
        };
        return o.prototype.addRectangularPyramid = function (e) {
            var t = new i(e);
            return this._sensors.push(t), t
        }, o.prototype.addCustom = function (e) {
            var t = new n(e);
            return this._sensors.push(t), t
        }, o.prototype.remove = function (e) {
            if (e) {
                var t = this._sensors, n = t.indexOf(e);
                if (-1 !== n)return t[n].destroy(), t.splice(n, 1), !0
            }
            return!1
        }, o.prototype.removeAll = function () {
            for (var e = this._sensors, t = e.length, n = 0; t > n; ++n)e[n].destroy();
            this._sensors = []
        }, o.prototype.contains = function (e) {
            return e ? -1 !== this._sensors.indexOf(e) : !1
        }, o.prototype.get = function (e) {
            if ("undefined" == typeof e)throw new t("index is required.");
            return this._sensors[e]
        }, o.prototype.getLength = function () {
            return this._sensors.length
        }, o.prototype.update = function (e, t, n) {
            var i = t.mode;
            if (i === r.SCENE3D)for (var o = this._sensors, a = o.length, s = 0; a > s; ++s)o[s].update(e, t, n)
        }, o.prototype.isDestroyed = function () {
            return!1
        }, o.prototype.destroy = function () {
            return this.removeAll(), e(this)
        }, o
    }), n("Scene/SingleTileImageryProvider", ["../Core/defaultValue", "../Core/loadImage", "../Core/writeTextToCanvas", "../Core/DeveloperError", "../Core/Event", "../Core/Extent", "./Credit", "./GeographicTilingScheme", "./TileProviderError", "../ThirdParty/when"], function (e, t, n, i, r, o, a, s, u, l) {
        "use strict";
        var c = function (n) {
            function c(e) {
                w._image = e, w._tileWidth = e.width, w._tileHeight = e.height, w._ready = !0, u.handleSuccess(w._errorEvent)
            }

            function d() {
                var e = "Failed to load image " + v + ".";
                _ = u.handleError(_, w, w._errorEvent, e, 0, 0, 0, f)
            }

            function f() {
                l(t(v), c, d)
            }

            n = e(n, {});
            var h = n.url;
            if ("undefined" == typeof h)throw new i("url is required.");
            this._url = h;
            var p = n.proxy;
            this._proxy = p;
            var m = e(n.extent, o.MAX_VALUE), y = new s({extent: m, numberOfLevelZeroTilesX: 1, numberOfLevelZeroTilesY: 1});
            this._tilingScheme = y, this._image = void 0, this._texture = void 0, this._tileWidth = 0, this._tileHeight = 0, this._errorEvent = new r, this._ready = !1;
            var v = h;
            "undefined" != typeof p && (v = p.getURL(v));
            var g = n.credit;
            "string" == typeof g && (g = new a(g)), this._credit = g;
            var _, w = this;
            f()
        };
        return c.prototype.getUrl = function () {
            return this._url
        }, c.prototype.getProxy = function () {
            return this._proxy
        }, c.prototype.getTileWidth = function () {
            if (!this._ready)throw new i("getTileWidth must not be called before the imagery provider is ready.");
            return this._tileWidth
        }, c.prototype.getTileHeight = function () {
            if (!this._ready)throw new i("getTileHeight must not be called before the imagery provider is ready.");
            return this._tileHeight
        }, c.prototype.getMaximumLevel = function () {
            if (!this._ready)throw new i("getMaximumLevel must not be called before the imagery provider is ready.");
            return 0
        }, c.prototype.getMinimumLevel = function () {
            if (!this._ready)throw new i("getMinimumLevel must not be called before the imagery provider is ready.");
            return 0
        }, c.prototype.getTilingScheme = function () {
            if (!this._ready)throw new i("getTilingScheme must not be called before the imagery provider is ready.");
            return this._tilingScheme
        }, c.prototype.getExtent = function () {
            return this._tilingScheme.getExtent()
        }, c.prototype.getTileDiscardPolicy = function () {
            if (!this._ready)throw new i("getTileDiscardPolicy must not be called before the imagery provider is ready.");
            return void 0
        }, c.prototype.getErrorEvent = function () {
            return this._errorEvent
        }, c.prototype.isReady = function () {
            return this._ready
        }, c.prototype.requestImage = function () {
            if (!this._ready)throw new i("requestImage must not be called before the imagery provider is ready.");
            return this._image
        }, c.prototype.getCredit = function () {
            return this._credit
        }, c
    }), n("Shaders/SkyAtmosphereVS", [], function () {
        "use strict";
        return"attribute vec4 position;\nuniform float fCameraHeight;\nuniform float fCameraHeight2;\nuniform float fOuterRadius;\nuniform float fOuterRadius2;\nuniform float fInnerRadius;\nuniform float fScale;\nuniform float fScaleDepth;\nuniform float fScaleOverScaleDepth;\nconst float Kr = 0.0025;\nconst float fKr4PI = Kr * 4.0 * czm_pi;\nconst float Km = 0.0015;\nconst float fKm4PI = Km * 4.0 * czm_pi;\nconst float ESun = 15.0;\nconst float fKmESun = Km * ESun;\nconst float fKrESun = Kr * ESun;\nconst vec3 v3InvWavelength = vec3(\n5.60204474633241,\n9.473284437923038,\n19.643802610477206);\nconst float rayleighScaleDepth = 0.25;\nconst int nSamples = 2;\nconst float fSamples = 2.0;\nvarying vec3 v_rayleighColor;\nvarying vec3 v_mieColor;\nvarying vec3 v_toCamera;\nvarying vec3 v_positionEC;\nfloat scale(float fCos)\n{\nfloat x = 1.0 - fCos;\nreturn fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n}\nvoid main(void)\n{\nvec3 v3Pos = position.xyz;\nvec3 v3Ray = v3Pos - czm_viewerPositionWC;\nfloat fFar = length(v3Ray);\nv3Ray /= fFar;\n#ifdef SKY_FROM_SPACE\nfloat B = 2.0 * dot(czm_viewerPositionWC, v3Ray);\nfloat C = fCameraHeight2 - fOuterRadius2;\nfloat fDet = max(0.0, B*B - 4.0 * C);\nfloat fNear = 0.5 * (-B - sqrt(fDet));\nvec3 v3Start = czm_viewerPositionWC + v3Ray * fNear;\nfFar -= fNear;\nfloat fStartAngle = dot(v3Ray, v3Start) / fOuterRadius;\nfloat fStartDepth = exp(-1.0 / fScaleDepth);\nfloat fStartOffset = fStartDepth*scale(fStartAngle);\n#else\nvec3 v3Start = czm_viewerPositionWC;\nfloat fHeight = length(v3Start);\nfloat fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fCameraHeight));\nfloat fStartAngle = dot(v3Ray, v3Start) / fHeight;\nfloat fStartOffset = fDepth*scale(fStartAngle);\n#endif\nfloat fSampleLength = fFar / fSamples;\nfloat fScaledLength = fSampleLength * fScale;\nvec3 v3SampleRay = v3Ray * fSampleLength;\nvec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\nvec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\nfor(int i=0; i<nSamples; i++)\n{\nfloat fHeight = length(v3SamplePoint);\nfloat fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\nvec3 lightPosition = normalize(czm_viewerPositionWC);\nfloat fLightAngle = dot(lightPosition, v3SamplePoint) / fHeight;\nfloat fCameraAngle = dot(v3Ray, v3SamplePoint) / fHeight;\nfloat fScatter = (fStartOffset + fDepth*(scale(fLightAngle) - scale(fCameraAngle)));\nvec3 v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\nv3FrontColor += v3Attenuate * (fDepth * fScaledLength);\nv3SamplePoint += v3SampleRay;\n}\nv_mieColor = v3FrontColor * fKmESun;\nv_rayleighColor = v3FrontColor * (v3InvWavelength * fKrESun);\nv_toCamera = czm_viewerPositionWC - v3Pos;\nv_positionEC = (czm_modelView * position).xyz;\ngl_Position = czm_modelViewProjection * position;\n}\n"
    }), n("Shaders/SkyAtmosphereFS", [], function () {
        "use strict";
        return"const float g = -0.95;\nconst float g2 = g * g;\nvarying vec3 v_rayleighColor;\nvarying vec3 v_mieColor;\nvarying vec3 v_toCamera;\nvarying vec3 v_positionEC;\nvoid main (void)\n{\nczm_ellipsoid ellipsoid = czm_getWgs84EllipsoidEC();\nvec3 direction = normalize(v_positionEC);\nczm_ray ray = czm_ray(vec3(0.0), direction);\nczm_raySegment intersection = czm_rayEllipsoidIntersectionInterval(ray, ellipsoid);\nif (!czm_isEmpty(intersection)) {\ndiscard;\n}\nfloat fCos = dot(czm_sunDirectionWC, normalize(v_toCamera)) / length(v_toCamera);\nfloat fRayleighPhase = 0.75 * (1.0 + fCos*fCos);\nfloat fMiePhase = 1.5 * ((1.0 - g2) / (2.0 + g2)) * (1.0 + fCos*fCos) / pow(1.0 + g2 - 2.0*g*fCos, 1.5);\nconst float fExposure = 2.0;\nvec3 rgb = fRayleighPhase * v_rayleighColor + fMiePhase * v_mieColor;\nrgb = vec3(1.0) - exp(-fExposure * rgb);\nfloat l = czm_luminance(rgb);\ngl_FragColor = vec4(rgb, min(smoothstep(0.0, 0.1, l), 1.0) * smoothstep(0.0, 1.0, czm_morphTime));\n}\n"
    }), n("Scene/SkyAtmosphere", ["../Core/defaultValue", "../Core/EllipsoidGeometry", "../Core/destroyObject", "../Core/GeometryPipeline", "../Core/PrimitiveType", "../Core/Ellipsoid", "../Renderer/BufferUsage", "../Renderer/DrawCommand", "../Renderer/CullFace", "../Renderer/BlendingState", "../Scene/SceneMode", "../Shaders/SkyAtmosphereVS", "../Shaders/SkyAtmosphereFS"], function (e, t, n, i, r, o, a, s, u, l, c, d, f) {
        "use strict";
        var h = function (t) {
            t = e(t, o.WGS84), this.show = !0, this._ellipsoid = t, this._command = new s, this._command.owner = this, this._spSkyFromSpace = void 0, this._spSkyFromAtmosphere = void 0, this._fCameraHeight = void 0, this._fCameraHeight2 = void 0, this._outerRadius = t.getRadii().multiplyByScalar(1.025).getMaximumComponent();
            var n = t.getMaximumRadius(), i = .25, r = this;
            this._command.uniformMap = {fCameraHeight: function () {
                return r._fCameraHeight
            }, fCameraHeight2: function () {
                return r._fCameraHeight2
            }, fOuterRadius: function () {
                return r._outerRadius
            }, fOuterRadius2: function () {
                return r._outerRadius * r._outerRadius
            }, fInnerRadius: function () {
                return n
            }, fScale: function () {
                return 1 / (r._outerRadius - n)
            }, fScaleDepth: function () {
                return i
            }, fScaleOverScaleDepth: function () {
                return 1 / (r._outerRadius - n) / i
            }}
        };
        return h.prototype.getEllipsoid = function () {
            return this._ellipsoid
        }, h.prototype.update = function (e, n) {
            if (!this.show)return void 0;
            if (n.mode !== c.SCENE3D && n.mode !== c.MORPHING)return void 0;
            if (!n.passes.color)return void 0;
            var o = this._command;
            if ("undefined" == typeof o.vertexArray) {
                var s = new t({radii: this._ellipsoid.getRadii().multiplyByScalar(1.025), numberOfPartitions: 60});
                o.vertexArray = e.createVertexArrayFromGeometry({geometry: s, attributeIndices: i.createAttributeIndices(s), bufferUsage: a.STATIC_DRAW}), o.primitiveType = r.TRIANGLES, o.renderState = e.createRenderState({cull: {enabled: !0, face: u.FRONT}, blending: l.ALPHA_BLEND});
                var h, p, m = e.getShaderCache();
                h = "#define SKY_FROM_SPACE\n#line 0\n" + d, p = "#line 0\n" + f, this._spSkyFromSpace = m.getShaderProgram(h, p), h = "#define SKY_FROM_ATMOSPHERE\n#line 0\n" + d, this._spSkyFromAtmosphere = m.getShaderProgram(h, p)
            }
            var y = n.camera.getPositionWC();
            return this._fCameraHeight2 = y.magnitudeSquared(), this._fCameraHeight = Math.sqrt(this._fCameraHeight2), o.shaderProgram = this._fCameraHeight > this._outerRadius ? this._spSkyFromSpace : this._spSkyFromAtmosphere, o
        }, h.prototype.isDestroyed = function () {
            return!1
        }, h.prototype.destroy = function () {
            var e = this._command;
            return e.vertexArray = e.vertexArray && e.vertexArray.destroy(), this._spSkyFromSpace = this._spSkyFromSpace && this._spSkyFromSpace.release(), this._spSkyFromAtmosphere = this._spSkyFromAtmosphere && this._spSkyFromAtmosphere.release(), n(this)
        }, h
    }), n("Shaders/SkyBoxVS", [], function () {
        "use strict";
        return"attribute vec3 position;\nvarying vec3 v_texCoord;\nvoid main()\n{\nvec3 p = czm_viewRotation * (czm_temeToPseudoFixed * (czm_entireFrustum.y * position));\ngl_Position = czm_projection * vec4(p, 1.0);\nv_texCoord = position.xyz;\n}\n"
    }), n("Shaders/SkyBoxFS", [], function () {
        "use strict";
        return"uniform samplerCube u_cubeMap;\nvarying vec3 v_texCoord;\nvoid main()\n{\nvec3 rgb = textureCube(u_cubeMap, normalize(v_texCoord)).rgb;\ngl_FragColor = vec4(rgb, czm_morphTime);\n}\n"
    }), n("Scene/SkyBox", ["../Core/BoxGeometry", "../Core/Cartesian3", "../Core/destroyObject", "../Core/DeveloperError", "../Core/Matrix4", "../Core/GeometryPipeline", "../Core/VertexFormat", "../Core/PrimitiveType", "../Renderer/loadCubeMap", "../Renderer/BufferUsage", "../Renderer/DrawCommand", "../Renderer/BlendingState", "../Scene/SceneMode", "../Shaders/SkyBoxVS", "../Shaders/SkyBoxFS"], function (e, t, n, i, r, o, a, s, u, l, c, d, f, h, p) {
        "use strict";
        var m = function (e) {
            if ("undefined" == typeof e || "undefined" == typeof e.positiveX || "undefined" == typeof e.negativeX || "undefined" == typeof e.positiveY || "undefined" == typeof e.negativeY || "undefined" == typeof e.positiveZ || "undefined" == typeof e.negativeZ)throw new i("sources is required and must have positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ properties.");
            if (typeof e.positiveX != typeof e.negativeX || typeof e.positiveX != typeof e.positiveY || typeof e.positiveX != typeof e.negativeY || typeof e.positiveX != typeof e.positiveZ || typeof e.positiveX != typeof e.negativeZ)throw new i("sources properties must all be the same type.");
            this._command = new c, this._command.owner = this, this._cubeMap = void 0, this._sources = e, this.show = !0
        };
        return m.prototype.getSources = function () {
            return this._sources
        }, m.prototype.update = function (n, i) {
            if (!this.show)return void 0;
            if (i.mode !== f.SCENE3D && i.mode !== f.MORPHING)return void 0;
            if (!i.passes.color)return void 0;
            var c = this._command;
            if ("undefined" == typeof c.vertexArray) {
                var m = this._sources, y = this;
                "string" == typeof m.positiveX ? u(n, this._sources).then(function (e) {
                    y._cubeMap = e
                }) : this._cubeMap = n.createCubeMap({source: m}), c.uniformMap = {u_cubeMap: function () {
                    return y._cubeMap
                }};
                var v = e.fromDimensions({dimensions: new t(2, 2, 2), vertexFormat: a.POSITION_ONLY}), g = o.createAttributeIndices(v);
                c.primitiveType = s.TRIANGLES, c.modelMatrix = r.IDENTITY.clone(), c.vertexArray = n.createVertexArrayFromGeometry({geometry: v, attributeIndices: g, bufferUsage: l.STATIC_DRAW}), c.shaderProgram = n.getShaderCache().getShaderProgram(h, p, g), c.renderState = n.createRenderState({blending: d.ALPHA_BLEND})
            }
            return"undefined" == typeof this._cubeMap ? void 0 : c
        }, m.prototype.isDestroyed = function () {
            return!1
        }, m.prototype.destroy = function () {
            var e = this._command;
            return e.vertexArray = e.vertexArray && e.vertexArray.destroy(), e.shaderProgram = e.shaderProgram && e.shaderProgram.release(), this._cubeMap = this._cubeMap && this._cubeMap.destroy(), n(this)
        }, m
    }), n("Shaders/SunVS", [], function () {
        "use strict";
        return"attribute vec2 direction;\nvarying vec2 v_textureCoordinates;\nvoid main()\n{\nvec4 position;\nif (czm_morphTime == 1.0)\n{\nposition = vec4(czm_sunPositionWC, 1.0);\n}\nelse\n{\nposition = vec4(czm_sunPositionColumbusView.zxy, 1.0);\n}\nvec4 positionEC = czm_view * position;\nvec4 positionWC = czm_eyeToWindowCoordinates(positionEC);\nvec4 limb = czm_eyeToWindowCoordinates(positionEC + vec4(czm_solarRadius, 0.0, 0.0, 0.0));\nvec2 halfSize = vec2(length(limb.xy - positionWC.xy));\nhalfSize *= 30.0;\nhalfSize *= ((direction * 2.0) - 1.0);\ngl_Position = czm_viewportOrthographic * vec4(positionWC.xy + halfSize, -positionWC.z, 1.0);\nv_textureCoordinates = direction;\n}\n"
    }), n("Shaders/SunFS", [], function () {
        "use strict";
        return"varying vec2 v_textureCoordinates;\nvoid main()\n{\nvec4 color = vec4(1.0, 1.0, 0.0, 1.0);\nfloat b = smoothstep(0.03, 0.3, length(v_textureCoordinates - vec2(0.5)));\ncolor.ba = mix(vec2(1.0), vec2(0.0), b);\ngl_FragColor = color;\n}\n"
    }), n("Scene/Sun", ["../Core/BoundingSphere", "../Core/Cartesian3", "../Core/ComponentDatatype", "../Core/destroyObject", "../Core/Math", "../Core/PrimitiveType", "../Renderer/BlendingState", "../Renderer/BufferUsage", "../Renderer/DrawCommand", "./SceneMode", "../Shaders/SunVS", "../Shaders/SunFS"], function (e, t, n, i, r, o, a, s, u, l, c, d) {
        "use strict";
        var f = function () {
            this._command = new u, this._boundingVolume = new e, this._boundingVolume.radius = 30 * r.SOLAR_RADIUS, this._boundingVolume2D = new e, this._boundingVolume2D.radius = this._boundingVolume.radius, this.show = !0
        };
        return f.prototype.update = function (i, r) {
            if (!this.show)return void 0;
            var u = r.mode;
            if (u === l.SCENE2D || u === l.MORPHING)return void 0;
            if (!r.passes.color)return void 0;
            var f = this._command;
            if ("undefined" == typeof f.vertexArray) {
                var h = {direction: 0}, p = new Uint8Array(8);
                p[0] = 0, p[1] = 0, p[2] = 255, p[3] = 0, p[4] = 255, p[5] = 255, p[6] = 0, p[7] = 255;
                var m = i.createVertexBuffer(p, s.STATIC_DRAW), y = [
                    {index: h.direction, vertexBuffer: m, componentsPerAttribute: 2, normalize: !0, componentDatatype: n.UNSIGNED_BYTE}
                ];
                f.vertexArray = i.createVertexArray(y), f.primitiveType = o.TRIANGLE_FAN, f.shaderProgram = i.getShaderCache().getShaderProgram(c, d, h), f.renderState = i.createRenderState({blending: a.ALPHA_BLEND}), f.boundingVolume = new e
            }
            var v = i.getUniformState().getSunPositionWC(), g = i.getUniformState().getSunPositionColumbusView(), _ = this._boundingVolume, w = this._boundingVolume2D;
            return t.clone(v, _.center), w.center.x = g.z, w.center.y = g.x, w.center.z = g.y, u === l.SCENE3D ? e.clone(_, f.boundingVolume) : u === l.COLUMBUS_VIEW && e.clone(w, f.boundingVolume), f
        }, f.prototype.isDestroyed = function () {
            return!1
        }, f.prototype.destroy = function () {
            var e = this._command;
            return e.vertexArray = e.vertexArray && e.vertexArray.destroy(), e.shaderProgram = e.shaderProgram && e.shaderProgram.release(), i(this)
        }, f
    }), n("Scene/TerrainData", ["../Core/DeveloperError"], function (e) {
        "use strict";
        var t = function () {
            throw new e("This type should not be instantiated directly.")
        };
        return t.prototype.interpolateHeight = function () {
            throw new e("This type should not be instantiated directly.")
        }, t.prototype.isChildAvailable = function () {
            throw new e("This type should not be instantiated directly.")
        }, t.prototype.getWaterMask = function () {
            throw new e("This type should not be instantiated directly.")
        }, t.prototype.createMesh = function () {
            throw new e("This type should not be instantiated directly.")
        }, t.prototype.upsample = function () {
            throw new e("This type should not be instantiated directly.")
        }, t.prototype.wasCreatedByUpsampling = function () {
            throw new e("This type should not be instantiated directly.")
        }, t
    }), n("Scene/TileCoordinatesImageryProvider", ["../Core/defaultValue", "../Core/Color", "../Core/Event", "./GeographicTilingScheme"], function (e, t, n, i) {
        "use strict";
        var r = function (r) {
            r = e(r, {}), this._tilingScheme = e(r.tilingScheme, new i), this._color = e(r.color, t.YELLOW), this._errorEvent = new n, this._tileWidth = e(r.tileWidth, 256), this._tileHeight = e(r.tileHeight, 256)
        };
        return r.prototype.getProxy = function () {
            return void 0
        }, r.prototype.getTileWidth = function () {
            return this._tileWidth
        }, r.prototype.getTileHeight = function () {
            return this._tileHeight
        }, r.prototype.getMaximumLevel = function () {
            return void 0
        }, r.prototype.getMinimumLevel = function () {
            return void 0
        }, r.prototype.getTilingScheme = function () {
            return this._tilingScheme
        }, r.prototype.getExtent = function () {
            return this._tilingScheme.getExtent()
        }, r.prototype.getTileDiscardPolicy = function () {
            return void 0
        }, r.prototype.getErrorEvent = function () {
            return this._errorEvent
        }, r.prototype.isReady = function () {
            return!0
        }, r.prototype.requestImage = function (e, t, n) {
            var i = document.createElement("canvas");
            i.width = 256, i.height = 256;
            var r = i.getContext("2d"), o = this._color.toCssColorString();
            r.strokeStyle = o, r.lineWidth = 2, r.strokeRect(1, 1, 255, 255);
            var a = "L" + n + "X" + e + "Y" + t;
            return r.font = "bold 25px Arial", r.textAlign = "center", r.fillStyle = "black", r.fillText(a, 127, 127), r.fillStyle = o, r.fillText(a, 124, 124), i
        }, r.prototype.getCredit = function () {
            return void 0
        }, r
    }), n("Scene/TileDiscardPolicy", ["../Core/DeveloperError"], function (e) {
        "use strict";
        var t = function () {
            throw new e("This type should not be instantiated directly.")
        };
        return t.prototype.isReady = function () {
            throw new e("This type should not be instantiated directly.")
        }, t.prototype.shouldDiscardImage = function () {
            throw new e("This type should not be instantiated directly.")
        }, t
    }), n("Scene/TileMapServiceImageryProvider", ["../Core/defaultValue", "../Core/Cartographic", "../Core/DeveloperError", "../Core/Event", "../Core/loadXML", "../Core/writeTextToCanvas", "../Core/Extent", "./Credit", "./ImageryProvider", "./WebMercatorTilingScheme", "./GeographicTilingScheme"], function (e, t, n, i, r, o, a, s, u, l, c) {
        "use strict";
        function d(e, t, n, i) {
            var r = e._tilingScheme.getNumberOfYTilesAtLevel(i), o = e._url + i + "/" + t + "/" + (r - n - 1) + "." + e._fileExtension, a = e._proxy;
            return"undefined" != typeof a && (o = a.getURL(o)), o
        }

        var f = /\/$/, h = function (o) {
            if (o = e(o, {}), "undefined" == typeof o.url)throw new n("description.url is required.");
            var u = o.url;
            f.test(u) || (u += "/"), this._url = u, this._ready = !1, this._proxy = o.proxy, this._tileDiscardPolicy = o.tileDiscardPolicy, this._errorEvent = new i;
            var d = o.credit;
            "string" == typeof d && (d = new s(d)), this._credit = d;
            var h = this;
            r(u + "tilemapresource.xml").then(function (n) {
                var i = n.getElementsByTagName("TileFormat")[0];
                h._fileExtension = e(o.fileExtension, i.getAttribute("extension")), h._tileWidth = e(o.tileWidth, parseInt(i.getAttribute("width"), 10)), h._tileHeight = e(o.tileHeight, parseInt(i.getAttribute("height"), 10));
                var r = n.getElementsByTagName("TileSet");
                if (h._minimumLevel = e(o.minimumLevel, parseInt(r[0].getAttribute("order"), 10)), h._maximumLevel = e(o.maximumLevel, parseInt(r[r.length - 1].getAttribute("order"), 10)), h._extent = o.extent, "undefined" == typeof h._extent) {
                    var s = n.getElementsByTagName("BoundingBox")[0], u = t.fromDegrees(parseFloat(s.getAttribute("miny")), parseFloat(s.getAttribute("minx"))), d = t.fromDegrees(parseFloat(s.getAttribute("maxy")), parseFloat(s.getAttribute("maxx")));
                    h._extent = new a(u.longitude, u.latitude, d.longitude, d.latitude)
                } else h._extent = h._extent.clone();
                var f = o.tilingScheme;
                if ("undefined" == typeof f) {
                    var p = n.getElementsByTagName("TileSets")[0].getAttribute("profile");
                    f = "geodetic" === p ? new c : new l
                }
                h._extent.west < f.getExtent().west && (h._extent.west = f.getExtent().west), h._extent.east > f.getExtent().east && (h._extent.east = f.getExtent().east), h._extent.south < f.getExtent().south && (h._extent.south = f.getExtent().south), h._extent.north > f.getExtent().north && (h._extent.north = f.getExtent().north);
                var m = f.positionToTileXY(h._extent.getSouthwest(), h._minimumLevel), y = f.positionToTileXY(h._extent.getNortheast(), h._minimumLevel), v = (Math.abs(y.x - m.x) + 1) * (Math.abs(y.y - m.y) + 1);
                v > 4 && (h._minimumLevel = 0), h._tilingScheme = f, h._ready = !0
            }, function () {
                h._fileExtension = e(o.fileExtension, "png"), h._tileWidth = e(o.tileWidth, 256), h._tileHeight = e(o.tileHeight, 256), h._minimumLevel = e(o.minimumLevel, 0), h._maximumLevel = e(o.maximumLevel, 18), h._tilingScheme = e(o.tilingScheme, new l), h._extent = e(o.extent, h._tilingScheme.getExtent()), h._ready = !0
            })
        };
        return h.prototype.getUrl = function () {
            return this._url
        }, h.prototype.getProxy = function () {
            return this._proxy
        }, h.prototype.getTileWidth = function () {
            if (!this._ready)throw new n("getTileWidth must not be called before the imagery provider is ready.");
            return this._tileWidth
        }, h.prototype.getTileHeight = function () {
            if (!this._ready)throw new n("getTileHeight must not be called before the imagery provider is ready.");
            return this._tileHeight
        }, h.prototype.getMinimumLevel = function () {
            if (!this._ready)throw new n("getMinimumLevel must not be called before the imagery provider is ready.");
            return this._minimumLevel
        }, h.prototype.getMaximumLevel = function () {
            if (!this._ready)throw new n("getMaximumLevel must not be called before the imagery provider is ready.");
            return this._maximumLevel
        }, h.prototype.getTilingScheme = function () {
            if (!this._ready)throw new n("getTilingScheme must not be called before the imagery provider is ready.");
            return this._tilingScheme
        }, h.prototype.getExtent = function () {
            if (!this._ready)throw new n("getExtent must not be called before the imagery provider is ready.");
            return this._extent
        }, h.prototype.getTileDiscardPolicy = function () {
            if (!this._ready)throw new n("getTileDiscardPolicy must not be called before the imagery provider is ready.");
            return this._tileDiscardPolicy
        }, h.prototype.getErrorEvent = function () {
            return this._errorEvent
        }, h.prototype.isReady = function () {
            return this._ready
        }, h.prototype.requestImage = function (e, t, i) {
            if (!this._ready)throw new n("requestImage must not be called before the imagery provider is ready.");
            var r = d(this, e, t, i);
            return u.loadImage(this, r)
        }, h.prototype.getCredit = function () {
            return this._credit
        }, h
    }), n("Scene/VRTheWorldTerrainProvider", ["../Core/defaultValue", "../Core/loadImage", "../Core/loadXML", "../Core/getImagePixels", "../Core/throttleRequestByServer", "../Core/writeTextToCanvas", "../Core/DeveloperError", "../Core/Extent", "../Core/Math", "../Core/Ellipsoid", "../Core/Event", "./Credit", "./TerrainProvider", "./TileProviderError", "./GeographicTilingScheme", "./HeightmapTerrainData", "../ThirdParty/when"], function (e, t, n, i, r, o, a, s, u, l, c, d, f, h, p, m, y) {
        "use strict";
        function v(e, t) {
            this.extent = e, this.maxLevel = t
        }

        function g(e, t, n, i) {
            for (var r = e._tilingScheme, o = e._extents, a = r.tileXYToExtent(t, n, i), s = 0, u = 0; u < o.length && 15 !== s; ++u) {
                var l = o[u];
                if (!(l.maxLevel <= i)) {
                    var c = l.extent, d = c.intersectWith(a, C);
                    d.isEmpty() || (_(r, c, 2 * t, 2 * n, i + 1) && (s |= 4), _(r, c, 2 * t + 1, 2 * n, i + 1) && (s |= 8), _(r, c, 2 * t, 2 * n + 1, i + 1) && (s |= 1), _(r, c, 2 * t + 1, 2 * n + 1, i + 1) && (s |= 2))
                }
            }
            return s
        }

        function _(e, t, n, i, r) {
            var o = e.tileXYToExtent(n, i, r);
            return!o.intersectWith(t, C).isEmpty()
        }

        var w = function (t) {
            function i(e) {
                var t = e.getElementsByTagName("SRS")[0].textContent;
                if ("EPSG:4326" !== t)return r("SRS " + t + " is not supported."), void 0;
                _._tilingScheme = new p({ellipsoid: w});
                var n = e.getElementsByTagName("TileFormat")[0];
                _._heightmapWidth = parseInt(n.getAttribute("width"), 10), _._heightmapHeight = parseInt(n.getAttribute("height"), 10), _._levelZeroMaximumGeometricError = f.getEstimatedLevelZeroGeometricErrorForAHeightmap(w, Math.min(_._heightmapWidth, _._heightmapHeight), _._tilingScheme.getNumberOfXTilesAtLevel(0));
                for (var i = e.getElementsByTagName("DataExtent"), o = 0; o < i.length; ++o) {
                    var a = i[o], l = u.toRadians(parseFloat(a.getAttribute("minx"))), c = u.toRadians(parseFloat(a.getAttribute("miny"))), d = u.toRadians(parseFloat(a.getAttribute("maxx"))), h = u.toRadians(parseFloat(a.getAttribute("maxy"))), m = parseInt(a.getAttribute("maxlevel"), 10);
                    _._extents.push(new v(new s(l, c, d, h), m))
                }
                _._ready = !0
            }

            function r(t) {
                var n = e(t, "An error occurred while accessing " + _._url + ".");
                g = h.handleError(g, _, _._errorEvent, n, void 0, void 0, void 0, o)
            }

            function o() {
                y(n(_._url), i, r)
            }

            if (t = e(t, e.EMPTY_OBJECT), "undefined" == typeof t.url)throw new a("description.url is required.");
            this._url = t.url, this._url.length > 0 && "/" !== this._url[this._url.length - 1] && (this._url += "/"), this._errorEvent = new c, this._ready = !1, this._proxy = t.proxy, this._terrainDataStructure = {heightScale: .001, heightOffset: -1e3, elementsPerHeight: 3, stride: 4, elementMultiplier: 256, isBigEndian: !0};
            var m = t.credit;
            "string" == typeof m && (m = new d(m)), this._credit = m, this._tilingScheme = void 0, this._extents = [];
            var g, _ = this, w = e(t.ellipsoid, l.WGS84);
            o()
        };
        w.prototype.requestTileGeometry = function (n, o, s, u) {
            if (!this.isReady())throw new a("requestTileGeometry must not be called before isReady returns true.");
            var l = this._tilingScheme.getNumberOfYTilesAtLevel(s), c = this._url + s + "/" + n + "/" + (l - o - 1) + ".tif?cesium=true", d = this._proxy;
            "undefined" != typeof d && (c = d.getURL(c));
            var f;
            if (u = e(u, !0)) {
                if (f = r(c, t), "undefined" == typeof f)return void 0
            } else f = t(c);
            var h = this;
            return y(f, function (e) {
                return new m({buffer: i(e), width: h._heightmapWidth, height: h._heightmapHeight, childTileMask: g(h, n, o, s), structure: h._terrainDataStructure})
            })
        }, w.prototype.getErrorEvent = function () {
            return this._errorEvent
        }, w.prototype.getLevelMaximumGeometricError = function (e) {
            if (!this.isReady())throw new a("requestTileGeometry must not be called before isReady returns true.");
            return this._levelZeroMaximumGeometricError / (1 << e)
        }, w.prototype.getCredit = function () {
            return this._credit
        }, w.prototype.getTilingScheme = function () {
            if (!this.isReady())throw new a("requestTileGeometry must not be called before isReady returns true.");
            return this._tilingScheme
        }, w.prototype.hasWaterMask = function () {
            return!1
        }, w.prototype.isReady = function () {
            return this._ready
        };
        var C = new s;
        return w
    }), n("Scene/WebMapServiceImageryProvider", ["../Core/clone", "../Core/defaultValue", "../Core/freezeObject", "../Core/writeTextToCanvas", "../Core/DeveloperError", "../Core/Event", "../Core/Extent", "./Credit", "./ImageryProvider", "./GeographicTilingScheme"], function (e, t, n, i, r, o, a, s, u, l) {
        "use strict";
        function c(e, t, n, i) {
            var r = e._url, o = r.indexOf("?");
            o >= 0 && o < r.length - 1 ? "&" !== r[r.length - 1] && (r += "&") : 0 > o && (r += "?");
            var a = e._parameters;
            for (var s in a)a.hasOwnProperty(s) && (r += s + "=" + a[s] + "&");
            if ("undefined" == typeof a.layers && (r += "layers=" + e._layers + "&"), "undefined" == typeof a.srs && (r += "srs=EPSG:4326&"), "undefined" == typeof a.bbox) {
                var u = e._tilingScheme.tileXYToNativeExtent(t, n, i), l = u.west + "," + u.south + "," + u.east + "," + u.north;
                r += "bbox=" + l + "&"
            }
            "undefined" == typeof a.width && (r += "width=256&"), "undefined" == typeof a.height && (r += "height=256&");
            var c = e._proxy;
            return"undefined" != typeof c && (r = c.getURL(r)), r
        }

        var d = function f(n) {
            if (n = t(n, {}), "undefined" == typeof n.url)throw new r("description.url is required.");
            if ("undefined" == typeof n.layers)throw new r("description.layers is required.");
            this._url = n.url, this._tileDiscardPolicy = n.tileDiscardPolicy, this._proxy = n.proxy, this._layers = n.layers;
            var i = e(f.DefaultParameters);
            if ("undefined" != typeof n.parameters)for (var u in n.parameters)if (n.parameters.hasOwnProperty(u)) {
                var c = u.toLowerCase();
                i[c] = n.parameters[u]
            }
            this._parameters = i, this._tileWidth = 256, this._tileHeight = 256, this._maximumLevel = n.maximumLevel;
            var d = t(n.extent, a.MAX_VALUE);
            this._tilingScheme = new l({extent: d});
            var h = n.credit;
            "string" == typeof h && (h = new s(h)), this._credit = h, this._errorEvent = new o, this._ready = !0
        };
        return d.prototype.getUrl = function () {
            return this._url
        }, d.prototype.getProxy = function () {
            return this._proxy
        }, d.prototype.getLayers = function () {
            return this._layers
        }, d.prototype.getTileWidth = function () {
            if (!this._ready)throw new r("getTileWidth must not be called before the imagery provider is ready.");
            return this._tileWidth
        }, d.prototype.getTileHeight = function () {
            if (!this._ready)throw new r("getTileHeight must not be called before the imagery provider is ready.");
            return this._tileHeight
        }, d.prototype.getMinimumLevel = function () {
            if (!this._ready)throw new r("getMinimumLevel must not be called before the imagery provider is ready.");
            return 0
        }, d.prototype.getMaximumLevel = function () {
            if (!this._ready)throw new r("getMaximumLevel must not be called before the imagery provider is ready.");
            return this._maximumLevel
        }, d.prototype.getTilingScheme = function () {
            if (!this._ready)throw new r("getTilingScheme must not be called before the imagery provider is ready.");
            return this._tilingScheme
        }, d.prototype.getExtent = function () {
            if (!this._ready)throw new r("getExtent must not be called before the imagery provider is ready.");
            return this._tilingScheme.getExtent()
        }, d.prototype.getTileDiscardPolicy = function () {
            if (!this._ready)throw new r("getTileDiscardPolicy must not be called before the imagery provider is ready.");
            return this._tileDiscardPolicy
        }, d.prototype.getErrorEvent = function () {
            return this._errorEvent
        }, d.prototype.isReady = function () {
            return this._ready
        }, d.prototype.requestImage = function (e, t, n) {
            if (!this._ready)throw new r("requestImage must not be called before the imagery provider is ready.");
            var i = c(this, e, t, n);
            return u.loadImage(this, i)
        }, d.prototype.getCredit = function () {
            return this._credit
        }, d.DefaultParameters = n({service: "WMS", version: "1.1.1", request: "GetMap", styles: "", format: "image/jpeg"}), d
    }), n("Scene/createTangentSpaceDebugPrimitive", ["../Core/defaultValue", "../Core/DeveloperError", "../Core/ColorGeometryInstanceAttribute", "../Core/GeometryInstance", "../Core/GeometryPipeline", "../Core/Matrix4", "./Primitive", "./PerInstanceColorAppearance"], function (e, t, n, i, r, o, a, s) {
        "use strict";
        function u(u) {
            u = e(u, e.EMPTY_OBJECT);
            var l = [], c = u.geometry;
            if ("undefined" == typeof c)throw new t("options.geometry is required.");
            var d = c.attributes, f = o.clone(e(u.modelMatrix, o.IDENTITY)), h = e(u.length, 1e4);
            return"undefined" != typeof d.normal && l.push(new i({geometry: r.createLineSegmentsForVectors(c, "normal", h), attributes: {color: new n(1, 0, 0, 1)}, modelMatrix: f})), "undefined" != typeof d.binormal && l.push(new i({geometry: r.createLineSegmentsForVectors(c, "binormal", h), attributes: {color: new n(0, 1, 0, 1)}, modelMatrix: f})), "undefined" != typeof d.tangent && l.push(new i({geometry: r.createLineSegmentsForVectors(c, "tangent", h), attributes: {color: new n(0, 0, 1, 1)}, modelMatrix: f})), new a({geometryInstances: l, appearance: new s({flat: !0, translucent: !1})})
        }

        return u
    }), n("Scene/sampleTerrain", ["../Core/DeveloperError", "../ThirdParty/when"], function (e, t) {
        "use strict";
        function n(e) {
            var t = e.positions, n = e.tilingScheme.tileXYToExtent(e.x, e.y, e.level);
            return function (e) {
                for (var i = 0; i < t.length; ++i) {
                    var r = t[i];
                    r.height = e.interpolateHeight(n, r.longitude, r.latitude)
                }
            }
        }

        function i(e) {
            var t = e.positions;
            return function () {
                for (var e = 0; e < t.length; ++e) {
                    var n = t[e];
                    n.height = void 0
                }
            }
        }

        var r = function (r, o, a) {
            if ("undefined" == typeof r)throw new e("terrainProvider is required.");
            if ("undefined" == typeof o)throw new e("level is required.");
            if ("undefined" == typeof a)throw new e("positions is required.");
            var s, u = r.getTilingScheme(), l = [], c = {};
            for (s = 0; s < a.length; ++s) {
                var d = u.positionToTileXY(a[s], o), f = d.toString();
                if (!c.hasOwnProperty(f)) {
                    var h = {x: d.x, y: d.y, level: o, tilingScheme: u, terrainProvider: r, positions: []};
                    c[f] = h, l.push(h)
                }
                c[f].positions.push(a[s])
            }
            var p = [];
            for (s = 0; s < l.length; ++s) {
                var m = l[s], y = m.terrainProvider.requestTileGeometry(m.x, m.y, m.level, !1), v = t(y, n(m), i(m));
                p.push(v)
            }
            return t.all(p, function () {
                return a
            })
        };
        return r
    }), function () {
        function e(e) {
            throw e
        }

        function i(e) {
            return function () {
                return e
            }
        }

        function r(t) {
            function n(e, t, n, i, o) {
                var s = [];
                return e = O.j(function () {
                    var e = t(n, o) || [];
                    0 < s.length && (O.a.Ya(r(s), e), i && O.r.K(i, a, [n, e, o])), s.splice(0, s.length), O.a.P(s, e)
                }, a, {W: e, Ka: function () {
                    return 0 == s.length || !O.a.X(s[0])
                }}), {M: s, j: e.pa() ? e : f}
            }

            function r(e) {
                for (; e.length && !O.a.X(e[0]);)e.splice(0, 1);
                if (1 < e.length) {
                    for (var t = e[0], n = e[e.length - 1], i = [t]; t !== n;) {
                        if (t = t.nextSibling, !t)return;
                        i.push(t)
                    }
                    Array.prototype.splice.apply(e, [0, e.length].concat(i))
                }
                return e
            }

            function h(e, t, n, i, r) {
                var o, a, s, u, l, c = Math.min, d = Math.max, f = [], h = e.length, p = t.length, m = p - h || 1, y = h + p + 1;
                for (o = 0; h >= o; o++)for (u = s, f.push(s = []), l = c(p, o + m), a = d(0, o - 1); l >= a; a++)s[a] = a ? o ? e[o - 1] === t[a - 1] ? u[a - 1] : c(u[a] || y, s[a - 1] || y) + 1 : a + 1 : o + 1;
                for (c = [], d = [], m = [], o = h, a = p; o || a;)p = f[o][a] - 1, a && p === f[o][a - 1] ? d.push(c[c.length] = {status: n, value: t[--a], index: a}) : o && p === f[o - 1][a] ? m.push(c[c.length] = {status: i, value: e[--o], index: o}) : (c.push({status: "retained", value: t[--a]}), --o);
                if (d.length && m.length) {
                    e = 10 * h;
                    var v;
                    for (t = n = 0; (r || e > t) && (v = d[n]); n++) {
                        for (i = 0; f = m[i]; i++)if (v.value === f.value) {
                            v.moved = f.index, f.moved = v.index, m.splice(i, 1), t = i = 0;
                            break
                        }
                        t += i
                    }
                }
                return c.reverse()
            }

            function p(t, n, i, r, u) {
                u = u || {};
                var l = t && m(t), l = l && l.ownerDocument, c = u.templateEngine || X;
                switch (O.za.vb(i, c, l), i = c.renderTemplate(i, r, u, l), ("number" != typeof i.length || 0 < i.length && "number" != typeof i[0].nodeType) && e(Error("Template engine must return an array of DOM nodes")), l = s, n) {
                    case"replaceChildren":
                        O.e.N(t, i), l = o;
                        break;
                    case"replaceNode":
                        O.a.Ya(t, i), l = o;
                        break;
                    case"ignoreTargetNode":
                        break;
                    default:
                        e(Error("Unknown renderMode: " + n))
                }
                return l && (y(i, r), u.afterRender && O.r.K(u.afterRender, a, [i, r.$data])), i
            }

            function m(e) {
                return e.nodeType ? e : 0 < e.length ? e[0] : a
            }

            function y(e, t) {
                if (e.length) {
                    var n = e[0], i = e[e.length - 1];
                    v(n, i, function (e) {
                        O.Da(t, e)
                    }), v(n, i, function (e) {
                        O.s.ib(e, [t])
                    })
                }
            }

            function v(e, t, n) {
                var i;
                for (t = O.e.nextSibling(t); e && (i = e) !== t;)e = O.e.nextSibling(i), (1 === i.nodeType || 8 === i.nodeType) && n(i)
            }

            function g(t, n, i) {
                t = O.g.aa(t);
                for (var r = O.g.Q, o = 0; o < t.length; o++) {
                    var a = t[o].key;
                    if (r.hasOwnProperty(a)) {
                        var s = r[a];
                        "function" == typeof s ? (a = s(t[o].value)) && e(Error(a)) : s || e(Error("This template engine does not support the '" + a + "' binding within its templates"))
                    }
                }
                return t = "ko.__tr_ambtns(function($context,$element){return(function(){return{ " + O.g.ba(t) + " } })()})", i.createJavaScriptEvaluatorBlock(t) + n
            }

            function _(t, n, i, r) {
                function o(e) {
                    return function () {
                        return u[e]
                    }
                }

                function s() {
                    return u
                }

                var u, l, c = 0;
                return O.j(function () {
                    var a = i && i instanceof O.z ? i : new O.z(O.a.d(i)), d = a.$data;
                    if (r && O.eb(t, a), u = ("function" == typeof n ? n(a, t) : n) || O.J.instance.getBindings(t, a)) {
                        if (0 === c) {
                            c = 1;
                            for (var h in u) {
                                var p = O.c[h];
                                p && 8 === t.nodeType && !O.e.I[h] && e(Error("The binding '" + h + "' cannot be used with virtual elements")), p && "function" == typeof p.init && (p = p.init(t, o(h), s, d, a)) && p.controlsDescendantBindings && (l !== f && e(Error("Multiple bindings (" + l + " and " + h + ") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.")), l = h)
                            }
                            c = 2
                        }
                        if (2 === c)for (h in u)(p = O.c[h]) && "function" == typeof p.update && p.update(t, o(h), s, d, a)
                    }
                }, a, {W: t}), {Nb: l === f}
            }

            function w(e, t, n) {
                var i = o, r = 1 === t.nodeType;
                r && O.e.Ta(t), (r && n || O.J.instance.nodeHasBindings(t)) && (i = _(t, a, e, n).Nb), i && C(e, t, !r)
            }

            function C(e, t, n) {
                for (var i = O.e.firstChild(t); t = i;)i = O.e.nextSibling(t), w(e, t, n)
            }

            function x(e, t) {
                var n = S(e, t);
                return n ? 0 < n.length ? n[n.length - 1].nextSibling : e.nextSibling : a
            }

            function S(t, n) {
                for (var i = t, r = 1, o = []; i = i.nextSibling;) {
                    if (b(i) && (r--, 0 === r))return o;
                    o.push(i), T(i) && r++
                }
                return n || e(Error("Cannot find closing comment tag to match: " + t.nodeValue)), a
            }

            function b(e) {
                return 8 == e.nodeType && (k ? e.text : e.nodeValue).match(q)
            }

            function T(e) {
                return 8 == e.nodeType && (k ? e.text : e.nodeValue).match(U)
            }

            function E(e, t) {
                for (var n = a; e != n;)n = e, e = e.replace(F, function (e, n) {
                    return t[n]
                });
                return e
            }

            function A() {
                var e = [], t = [];
                this.save = function (n, i) {
                    var r = O.a.i(e, n);
                    r >= 0 ? t[r] = i : (e.push(n), t.push(i))
                }, this.get = function (n) {
                    return n = O.a.i(e, n), n >= 0 ? t[n] : f
                }
            }

            function M(e, t, n) {
                function i(i) {
                    var o = t(e[i]);
                    switch (typeof o) {
                        case"boolean":
                        case"number":
                        case"string":
                        case"function":
                            r[i] = o;
                            break;
                        case"object":
                        case"undefined":
                            var a = n.get(o);
                            r[i] = a !== f ? a : M(o, t, n)
                    }
                }

                if (n = n || new A, e = t(e), "object" != typeof e || e === a || e === f || e instanceof Date)return e;
                var r = e instanceof Array ? [] : {};
                n.save(e, r);
                var o = e;
                if (o instanceof Array) {
                    for (var s = 0; s < o.length; s++)i(s);
                    "function" == typeof o.toJSON && i("toJSON")
                } else for (s in o)i(s);
                return r
            }

            function D(e, t) {
                if (e)if (8 == e.nodeType) {
                    var n = O.s.Ua(e.nodeValue);
                    n != a && t.push({sb: e, Fb: n})
                } else if (1 == e.nodeType)for (var n = 0, i = e.childNodes, r = i.length; r > n; n++)D(i[n], t)
            }

            function I(e, t, n, i) {
                O.c[e] = {init: function (e) {
                    return O.a.f.set(e, G, {}), {controlsDescendantBindings: o}
                }, update: function (e, r, a, s, u) {
                    a = O.a.f.get(e, G), r = O.a.d(r()), s = !n != !r;
                    var l = !a.Za;
                    (l || t || s !== a.qb) && (l && (a.Za = O.a.Ia(O.e.childNodes(e), o)), s ? (l || O.e.N(e, O.a.Ia(a.Za)), O.Ea(i ? i(u, r) : u, e)) : O.e.Y(e), a.qb = s)
                }}, O.g.Q[e] = s, O.e.I[e] = o
            }

            function P(e, t, n) {
                n && t !== O.k.q(e) && O.k.T(e, t), t !== O.k.q(e) && O.r.K(O.a.Ba, a, [e, "change"])
            }

            var O = "undefined" != typeof t ? t : {};
            O.b = function (e, t) {
                for (var n = e.split("."), i = O, r = 0; r < n.length - 1; r++)i = i[n[r]];
                i[n[n.length - 1]] = t
            }, O.p = function (e, t, n) {
                e[t] = n
            }, O.version = "2.2.1", O.b("version", O.version), O.a = new function () {
                function t(e, t) {
                    if ("input" !== O.a.u(e) || !e.type || "click" != t.toLowerCase())return s;
                    var n = e.type;
                    return"checkbox" == n || "radio" == n
                }

                var n = /^(\s|\u00A0)+|(\s|\u00A0)+$/g, i = {}, r = {};
                i[/Firefox\/2/i.test(c.userAgent) ? "KeyboardEvent" : "UIEvents"] = ["keyup", "keydown", "keypress"], i.MouseEvents = "click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave".split(" ");
                for (var h in i) {
                    var p = i[h];
                    if (p.length)for (var m = 0, y = p.length; y > m; m++)r[p[m]] = h
                }
                var v, g = {propertychange: o}, i = 3;
                for (h = l.createElement("div"), p = h.getElementsByTagName("i"); h.innerHTML = "<!--[if gt IE " + ++i + "]><i></i><![endif]-->", p[0];);
                return v = i > 4 ? i : f, {Na: ["authenticity_token", /^__RequestVerificationToken(_.*)?$/], o: function (e, t) {
                    for (var n = 0, i = e.length; i > n; n++)t(e[n])
                }, i: function (e, t) {
                    if ("function" == typeof Array.prototype.indexOf)return Array.prototype.indexOf.call(e, t);
                    for (var n = 0, i = e.length; i > n; n++)if (e[n] === t)return n;
                    return-1
                }, lb: function (e, t, n) {
                    for (var i = 0, r = e.length; r > i; i++)if (t.call(n, e[i]))return e[i];
                    return a
                }, ga: function (e, t) {
                    var n = O.a.i(e, t);
                    n >= 0 && e.splice(n, 1)
                }, Ga: function (e) {
                    e = e || [];
                    for (var t = [], n = 0, i = e.length; i > n; n++)0 > O.a.i(t, e[n]) && t.push(e[n]);
                    return t
                }, V: function (e, t) {
                    e = e || [];
                    for (var n = [], i = 0, r = e.length; r > i; i++)n.push(t(e[i]));
                    return n
                }, fa: function (e, t) {
                    e = e || [];
                    for (var n = [], i = 0, r = e.length; r > i; i++)t(e[i]) && n.push(e[i]);
                    return n
                }, P: function (e, t) {
                    if (t instanceof Array)e.push.apply(e, t); else for (var n = 0, i = t.length; i > n; n++)e.push(t[n]);
                    return e
                }, extend: function (e, t) {
                    if (t)for (var n in t)t.hasOwnProperty(n) && (e[n] = t[n]);
                    return e
                }, ka: function (e) {
                    for (; e.firstChild;)O.removeNode(e.firstChild)
                }, Hb: function (e) {
                    e = O.a.L(e);
                    for (var t = l.createElement("div"), n = 0, i = e.length; i > n; n++)t.appendChild(O.A(e[n]));
                    return t
                }, Ia: function (e, t) {
                    for (var n = 0, i = e.length, r = []; i > n; n++) {
                        var a = e[n].cloneNode(o);
                        r.push(t ? O.A(a) : a)
                    }
                    return r
                }, N: function (e, t) {
                    if (O.a.ka(e), t)for (var n = 0, i = t.length; i > n; n++)e.appendChild(t[n])
                }, Ya: function (e, t) {
                    var n = e.nodeType ? [e] : e;
                    if (0 < n.length) {
                        for (var i = n[0], r = i.parentNode, o = 0, a = t.length; a > o; o++)r.insertBefore(t[o], i);
                        for (o = 0, a = n.length; a > o; o++)O.removeNode(n[o])
                    }
                }, bb: function (e, t) {
                    7 > v ? e.setAttribute("selected", t) : e.selected = t
                }, D: function (e) {
                    return(e || "").replace(n, "")
                }, Rb: function (e, t) {
                    for (var n = [], i = (e || "").split(t), r = 0, o = i.length; o > r; r++) {
                        var a = O.a.D(i[r]);
                        "" !== a && n.push(a)
                    }
                    return n
                }, Ob: function (e, t) {
                    return e = e || "", t.length > e.length ? s : e.substring(0, t.length) === t
                }, tb: function (e, t) {
                    if (t.compareDocumentPosition)return 16 == (16 & t.compareDocumentPosition(e));
                    for (; e != a;) {
                        if (e == t)return o;
                        e = e.parentNode
                    }
                    return s
                }, X: function (e) {
                    return O.a.tb(e, e.ownerDocument)
                }, u: function (e) {
                    return e && e.tagName && e.tagName.toLowerCase()
                }, n: function (n, i, r) {
                    var a = v && g[i];
                    if (a || "undefined" == typeof d)a || "function" != typeof n.addEventListener ? "undefined" != typeof n.attachEvent ? n.attachEvent("on" + i, function (e) {
                        r.call(n, e)
                    }) : e(Error("Browser doesn't support addEventListener or attachEvent")) : n.addEventListener(i, r, s); else {
                        if (t(n, i)) {
                            var u = r;
                            r = function (e, t) {
                                var n = this.checked;
                                t && (this.checked = t.nb !== o), u.call(this, e), this.checked = n
                            }
                        }
                        d(n).bind(i, r)
                    }
                }, Ba: function (n, i) {
                    if ((!n || !n.nodeType) && e(Error("element must be a DOM node when calling triggerEvent")), "undefined" != typeof d) {
                        var a = [];
                        t(n, i) && a.push({nb: n.checked}), d(n).trigger(i, a)
                    } else"function" == typeof l.createEvent ? "function" == typeof n.dispatchEvent ? (a = l.createEvent(r[i] || "HTMLEvents"), a.initEvent(i, o, o, u, 0, 0, 0, 0, 0, s, s, s, s, 0, n), n.dispatchEvent(a)) : e(Error("The supplied element doesn't support dispatchEvent")) : "undefined" != typeof n.fireEvent ? (t(n, i) && (n.checked = n.checked !== o), n.fireEvent("on" + i)) : e(Error("Browser doesn't support triggering events"))
                }, d: function (e) {
                    return O.$(e) ? e() : e
                }, ua: function (e) {
                    return O.$(e) ? e.t() : e
                }, da: function (e, t, n) {
                    if (t) {
                        var i = /[\w-]+/g, r = e.className.match(i) || [];
                        O.a.o(t.match(i), function (e) {
                            var t = O.a.i(r, e);
                            t >= 0 ? n || r.splice(t, 1) : n && r.push(e)
                        }), e.className = r.join(" ")
                    }
                }, cb: function (e, t) {
                    var n = O.a.d(t);
                    if ((n === a || n === f) && (n = ""), 3 === e.nodeType)e.data = n; else {
                        var i = O.e.firstChild(e);
                        !i || 3 != i.nodeType || O.e.nextSibling(i) ? O.e.N(e, [l.createTextNode(n)]) : i.data = n, O.a.wb(e)
                    }
                }, ab: function (e, t) {
                    if (e.name = t, 7 >= v)try {
                        e.mergeAttributes(l.createElement("<input name='" + e.name + "'/>"), s)
                    } catch (n) {
                    }
                }, wb: function (e) {
                    v >= 9 && (e = 1 == e.nodeType ? e : e.parentNode, e.style && (e.style.zoom = e.style.zoom))
                }, ub: function (e) {
                    if (v >= 9) {
                        var t = e.style.width;
                        e.style.width = 0, e.style.width = t
                    }
                }, Lb: function (e, t) {
                    e = O.a.d(e), t = O.a.d(t);
                    for (var n = [], i = e; t >= i; i++)n.push(i);
                    return n
                }, L: function (e) {
                    for (var t = [], n = 0, i = e.length; i > n; n++)t.push(e[n]);
                    return t
                }, Pb: 6 === v, Qb: 7 === v, Z: v, Oa: function (e, t) {
                    for (var n = O.a.L(e.getElementsByTagName("input")).concat(O.a.L(e.getElementsByTagName("textarea"))), i = "string" == typeof t ? function (e) {
                        return e.name === t
                    } : function (e) {
                        return t.test(e.name)
                    }, r = [], o = n.length - 1; o >= 0; o--)i(n[o]) && r.push(n[o]);
                    return r
                }, Ib: function (e) {
                    return"string" == typeof e && (e = O.a.D(e)) ? u.JSON && u.JSON.parse ? u.JSON.parse(e) : new Function("return " + e)() : a
                }, xa: function (t, n, i) {
                    return("undefined" == typeof JSON || "undefined" == typeof JSON.stringify) && e(Error("Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js")), JSON.stringify(O.a.d(t), n, i)
                }, Jb: function (e, t, n) {
                    n = n || {};
                    var i = n.params || {}, r = n.includeFields || this.Na, o = e;
                    if ("object" == typeof e && "form" === O.a.u(e))for (var o = e.action, a = r.length - 1; a >= 0; a--)for (var s = O.a.Oa(e, r[a]), u = s.length - 1; u >= 0; u--)i[s[u].name] = s[u].value;
                    t = O.a.d(t);
                    var c = l.createElement("form");
                    c.style.display = "none", c.action = o, c.method = "post";
                    for (var d in t)e = l.createElement("input"), e.name = d, e.value = O.a.xa(O.a.d(t[d])), c.appendChild(e);
                    for (d in i)e = l.createElement("input"), e.name = d, e.value = i[d], c.appendChild(e);
                    l.body.appendChild(c), n.submitter ? n.submitter(c) : c.submit(), setTimeout(function () {
                        c.parentNode.removeChild(c)
                    }, 0)
                }}
            }, O.b("utils", O.a), O.b("utils.arrayForEach", O.a.o), O.b("utils.arrayFirst", O.a.lb), O.b("utils.arrayFilter", O.a.fa), O.b("utils.arrayGetDistinctValues", O.a.Ga), O.b("utils.arrayIndexOf", O.a.i), O.b("utils.arrayMap", O.a.V), O.b("utils.arrayPushAll", O.a.P), O.b("utils.arrayRemoveItem", O.a.ga), O.b("utils.extend", O.a.extend), O.b("utils.fieldsIncludedWithJsonPost", O.a.Na), O.b("utils.getFormFields", O.a.Oa), O.b("utils.peekObservable", O.a.ua), O.b("utils.postJson", O.a.Jb), O.b("utils.parseJson", O.a.Ib), O.b("utils.registerEventHandler", O.a.n), O.b("utils.stringifyJson", O.a.xa), O.b("utils.range", O.a.Lb), O.b("utils.toggleDomNodeCssClass", O.a.da), O.b("utils.triggerEvent", O.a.Ba), O.b("utils.unwrapObservable", O.a.d), Function.prototype.bind || (Function.prototype.bind = function (e) {
                var t = this, n = Array.prototype.slice.call(arguments);
                return e = n.shift(), function () {
                    return t.apply(e, n.concat(Array.prototype.slice.call(arguments)))
                }
            }), O.a.f = new function () {
                var e = 0, t = "__ko__" + (new Date).getTime(), n = {};
                return{get: function (e, t) {
                    var n = O.a.f.la(e, s);
                    return n === f ? f : n[t]
                }, set: function (e, t, n) {
                    n === f && O.a.f.la(e, s) === f || (O.a.f.la(e, o)[t] = n)
                }, la: function (i, r) {
                    var o = i[t];
                    if (!o || "null" === o || !n[o]) {
                        if (!r)return f;
                        o = i[t] = "ko" + e++, n[o] = {}
                    }
                    return n[o]
                }, clear: function (e) {
                    var i = e[t];
                    return i ? (delete n[i], e[t] = a, o) : s
                }}
            }, O.b("utils.domData", O.a.f), O.b("utils.domData.clear", O.a.f.clear), O.a.F = new function () {
                function t(e, t) {
                    var n = O.a.f.get(e, i);
                    return n === f && t && (n = [], O.a.f.set(e, i, n)), n
                }

                function n(e) {
                    var i = t(e, s);
                    if (i)for (var i = i.slice(0), r = 0; r < i.length; r++)i[r](e);
                    if (O.a.f.clear(e), "function" == typeof d && "function" == typeof d.cleanData && d.cleanData([e]), a[e.nodeType])for (i = e.firstChild; e = i;)i = e.nextSibling, 8 === e.nodeType && n(e)
                }

                var i = "__ko_domNodeDisposal__" + (new Date).getTime(), r = {1: o, 8: o, 9: o}, a = {1: o, 9: o};
                return{Ca: function (n, i) {
                    "function" != typeof i && e(Error("Callback must be a function")), t(n, o).push(i)
                }, Xa: function (e, n) {
                    var r = t(e, s);
                    r && (O.a.ga(r, n), 0 == r.length && O.a.f.set(e, i, f))
                }, A: function (e) {
                    if (r[e.nodeType] && (n(e), a[e.nodeType])) {
                        var t = [];
                        O.a.P(t, e.getElementsByTagName("*"));
                        for (var i = 0, o = t.length; o > i; i++)n(t[i])
                    }
                    return e
                }, removeNode: function (e) {
                    O.A(e), e.parentNode && e.parentNode.removeChild(e)
                }}
            }, O.A = O.a.F.A, O.removeNode = O.a.F.removeNode, O.b("cleanNode", O.A), O.b("removeNode", O.removeNode), O.b("utils.domNodeDisposal", O.a.F), O.b("utils.domNodeDisposal.addDisposeCallback", O.a.F.Ca), O.b("utils.domNodeDisposal.removeDisposeCallback", O.a.F.Xa), O.a.ta = function (e) {
                var t;
                if ("undefined" != typeof d) {
                    if (d.parseHTML)t = d.parseHTML(e); else if ((t = d.clean([e])) && t[0]) {
                        for (e = t[0]; e.parentNode && 11 !== e.parentNode.nodeType;)e = e.parentNode;
                        e.parentNode && e.parentNode.removeChild(e)
                    }
                } else {
                    var n = O.a.D(e).toLowerCase();
                    for (t = l.createElement("div"), n = n.match(/^<(thead|tbody|tfoot)/) && [1, "<table>", "</table>"] || !n.indexOf("<tr") && [2, "<table><tbody>", "</tbody></table>"] || (!n.indexOf("<td") || !n.indexOf("<th")) && [3, "<table><tbody><tr>", "</tr></tbody></table>"] || [0, "", ""], e = "ignored<div>" + n[1] + e + n[2] + "</div>", "function" == typeof u.innerShiv ? t.appendChild(u.innerShiv(e)) : t.innerHTML = e; n[0]--;)t = t.lastChild;
                    t = O.a.L(t.lastChild.childNodes)
                }
                return t
            }, O.a.ca = function (e, t) {
                if (O.a.ka(e), t = O.a.d(t), t !== a && t !== f)if ("string" != typeof t && (t = t.toString()), "undefined" != typeof d)d(e).html(t); else for (var n = O.a.ta(t), i = 0; i < n.length; i++)e.appendChild(n[i])
            }, O.b("utils.parseHtmlFragment", O.a.ta), O.b("utils.setHtml", O.a.ca);
            var R = {};
            O.s = {ra: function (t) {
                "function" != typeof t && e(Error("You can only pass a function to ko.memoization.memoize()"));
                var n = (0 | 4294967296 * (1 + Math.random())).toString(16).substring(1) + (0 | 4294967296 * (1 + Math.random())).toString(16).substring(1);
                return R[n] = t, "<!--[ko_memo:" + n + "]-->"
            }, hb: function (t, n) {
                var i = R[t];
                i === f && e(Error("Couldn't find any memo with ID " + t + ". Perhaps it's already been unmemoized."));
                try {
                    return i.apply(a, n || []), o
                } finally {
                    delete R[t]
                }
            }, ib: function (e, t) {
                var n = [];
                D(e, n);
                for (var i = 0, r = n.length; r > i; i++) {
                    var o = n[i].sb, a = [o];
                    t && O.a.P(a, t), O.s.hb(n[i].Fb, a), o.nodeValue = "", o.parentNode && o.parentNode.removeChild(o)
                }
            }, Ua: function (e) {
                return(e = e.match(/^\[ko_memo\:(.*?)\]$/)) ? e[1] : a
            }}, O.b("memoization", O.s), O.b("memoization.memoize", O.s.ra), O.b("memoization.unmemoize", O.s.hb), O.b("memoization.parseMemoText", O.s.Ua), O.b("memoization.unmemoizeDomNodeAndDescendants", O.s.ib), O.Ma = {throttle: function (e, t) {
                e.throttleEvaluation = t;
                var n = a;
                return O.j({read: e, write: function (i) {
                    clearTimeout(n), n = setTimeout(function () {
                        e(i)
                    }, t)
                }})
            }, notify: function (e, t) {
                return e.equalityComparer = "always" == t ? i(s) : O.m.fn.equalityComparer, e
            }}, O.b("extenders", O.Ma), O.fb = function (e, t, n) {
                this.target = e, this.ha = t, this.rb = n, O.p(this, "dispose", this.B)
            }, O.fb.prototype.B = function () {
                this.Cb = o, this.rb()
            }, O.S = function () {
                this.w = {}, O.a.extend(this, O.S.fn), O.p(this, "subscribe", this.ya), O.p(this, "extend", this.extend), O.p(this, "getSubscriptionsCount", this.yb)
            }, O.S.fn = {ya: function (e, t, n) {
                n = n || "change";
                var i = new O.fb(this, t ? e.bind(t) : e, function () {
                    O.a.ga(this.w[n], i)
                }.bind(this));
                return this.w[n] || (this.w[n] = []), this.w[n].push(i), i
            }, notifySubscribers: function (e, t) {
                t = t || "change", this.w[t] && O.r.K(function () {
                    O.a.o(this.w[t].slice(0), function (t) {
                        t && t.Cb !== o && t.ha(e)
                    })
                }, this)
            }, yb: function () {
                var e, t = 0;
                for (e in this.w)this.w.hasOwnProperty(e) && (t += this.w[e].length);
                return t
            }, extend: function (e) {
                var t = this;
                if (e)for (var n in e) {
                    var i = O.Ma[n];
                    "function" == typeof i && (t = i(t, e[n]))
                }
                return t
            }}, O.Qa = function (e) {
                return"function" == typeof e.ya && "function" == typeof e.notifySubscribers
            }, O.b("subscribable", O.S), O.b("isSubscribable", O.Qa);
            var z = [];
            O.r = {mb: function (e) {
                z.push({ha: e, La: []})
            }, end: function () {
                z.pop()
            }, Wa: function (t) {
                if (O.Qa(t) || e(Error("Only subscribable things can act as dependencies")), 0 < z.length) {
                    var n = z[z.length - 1];
                    n && !(0 <= O.a.i(n.La, t)) && (n.La.push(t), n.ha(t))
                }
            }, K: function (e, t, n) {
                try {
                    return z.push(a), e.apply(t, n || [])
                } finally {
                    z.pop()
                }
            }};
            var L = {undefined: o, "boolean": o, number: o, string: o};
            O.m = function (e) {
                function t() {
                    return 0 < arguments.length ? (t.equalityComparer && t.equalityComparer(n, arguments[0]) || (t.H(), n = arguments[0], t.G()), this) : (O.r.Wa(t), n)
                }

                var n = e;
                return O.S.call(t), t.t = function () {
                    return n
                }, t.G = function () {
                    t.notifySubscribers(n)
                }, t.H = function () {
                    t.notifySubscribers(n, "beforeChange")
                }, O.a.extend(t, O.m.fn), O.p(t, "peek", t.t), O.p(t, "valueHasMutated", t.G), O.p(t, "valueWillMutate", t.H), t
            }, O.m.fn = {equalityComparer: function (e, t) {
                return e === a || typeof e in L ? e === t : s
            }};
            var N = O.m.Kb = "__ko_proto__";
            O.m.fn[N] = O.m, O.ma = function (e, t) {
                return e === a || e === f || e[N] === f ? s : e[N] === t ? o : O.ma(e[N], t)
            }, O.$ = function (e) {
                return O.ma(e, O.m)
            }, O.Ra = function (e) {
                return"function" == typeof e && e[N] === O.m || "function" == typeof e && e[N] === O.j && e.zb ? o : s
            }, O.b("observable", O.m), O.b("isObservable", O.$), O.b("isWriteableObservable", O.Ra), O.R = function (t) {
                0 == arguments.length && (t = []), t !== a && t !== f && !("length"in t) && e(Error("The argument passed when initializing an observable array must be an array, or null, or undefined."));
                var n = O.m(t);
                return O.a.extend(n, O.R.fn), n
            }, O.R.fn = {remove: function (e) {
                for (var t = this.t(), n = [], i = "function" == typeof e ? e : function (t) {
                    return t === e
                }, r = 0; r < t.length; r++) {
                    var o = t[r];
                    i(o) && (0 === n.length && this.H(), n.push(o), t.splice(r, 1), r--)
                }
                return n.length && this.G(), n
            }, removeAll: function (e) {
                if (e === f) {
                    var t = this.t(), n = t.slice(0);
                    return this.H(), t.splice(0, t.length), this.G(), n
                }
                return e ? this.remove(function (t) {
                    return 0 <= O.a.i(e, t)
                }) : []
            }, destroy: function (e) {
                var t = this.t(), n = "function" == typeof e ? e : function (t) {
                    return t === e
                };
                this.H();
                for (var i = t.length - 1; i >= 0; i--)n(t[i]) && (t[i]._destroy = o);
                this.G()
            }, destroyAll: function (e) {
                return e === f ? this.destroy(i(o)) : e ? this.destroy(function (t) {
                    return 0 <= O.a.i(e, t)
                }) : []
            }, indexOf: function (e) {
                var t = this();
                return O.a.i(t, e)
            }, replace: function (e, t) {
                var n = this.indexOf(e);
                n >= 0 && (this.H(), this.t()[n] = t, this.G())
            }}, O.a.o("pop push reverse shift sort splice unshift".split(" "), function (e) {
                O.R.fn[e] = function () {
                    var t = this.t();
                    return this.H(), t = t[e].apply(t, arguments), this.G(), t
                }
            }), O.a.o(["slice"], function (e) {
                O.R.fn[e] = function () {
                    var t = this();
                    return t[e].apply(t, arguments)
                }
            }), O.b("observableArray", O.R), O.j = function (t, n, r) {
                function u() {
                    O.a.o(x, function (e) {
                        e.B()
                    }), x = []
                }

                function l() {
                    var e = d.throttleEvaluation;
                    e && e >= 0 ? (clearTimeout(S), S = setTimeout(c, e)) : c()
                }

                function c() {
                    if (!y)if (m && w())C(); else {
                        y = o;
                        try {
                            var e = O.a.V(x, function (e) {
                                return e.target
                            });
                            O.r.mb(function (t) {
                                var n;
                                0 <= (n = O.a.i(e, t)) ? e[n] = f : x.push(t.ya(l))
                            });
                            for (var t = v.call(n), i = e.length - 1; i >= 0; i--)e[i] && x.splice(i, 1)[0].B();
                            m = o, d.notifySubscribers(p, "beforeChange"), p = t
                        } finally {
                            O.r.end()
                        }
                        d.notifySubscribers(p), y = s, x.length || C()
                    }
                }

                function d() {
                    return 0 < arguments.length ? ("function" == typeof g ? g.apply(n, arguments) : e(Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.")), this) : (m || c(), O.r.Wa(d), p)
                }

                function h() {
                    return!m || 0 < x.length
                }

                var p, m = s, y = s, v = t;
                v && "object" == typeof v ? (r = v, v = r.read) : (r = r || {}, v || (v = r.read)), "function" != typeof v && e(Error("Pass a function that returns the value of the ko.computed"));
                var g = r.write, _ = r.disposeWhenNodeIsRemoved || r.W || a, w = r.disposeWhen || r.Ka || i(s), C = u, x = [], S = a;
                if (n || (n = r.owner), d.t = function () {
                    return m || c(), p
                }, d.xb = function () {
                    return x.length
                }, d.zb = "function" == typeof r.write, d.B = function () {
                    C()
                }, d.pa = h, O.S.call(d), O.a.extend(d, O.j.fn), O.p(d, "peek", d.t), O.p(d, "dispose", d.B), O.p(d, "isActive", d.pa), O.p(d, "getDependenciesCount", d.xb), r.deferEvaluation !== o && c(), _ && h()) {
                    C = function () {
                        O.a.F.Xa(_, arguments.callee), u()
                    }, O.a.F.Ca(_, C);
                    var b = w, w = function () {
                        return!O.a.X(_) || b()
                    }
                }
                return d
            }, O.Bb = function (e) {
                return O.ma(e, O.j)
            }, t = O.m.Kb, O.j[t] = O.m, O.j.fn = {}, O.j.fn[t] = O.j, O.b("dependentObservable", O.j), O.b("computed", O.j), O.b("isComputed", O.Bb), O.gb = function (t) {
                return 0 == arguments.length && e(Error("When calling ko.toJS, pass the object you want to convert.")), M(t, function (e) {
                    for (var t = 0; O.$(e) && 10 > t; t++)e = e();
                    return e
                })
            }, O.toJSON = function (e, t, n) {
                return e = O.gb(e), O.a.xa(e, t, n)
            }, O.b("toJS", O.gb), O.b("toJSON", O.toJSON), O.k = {q: function (e) {
                switch (O.a.u(e)) {
                    case"option":
                        return e.__ko__hasDomDataOptionValue__ === o ? O.a.f.get(e, O.c.options.sa) : 7 >= O.a.Z ? e.getAttributeNode("value").specified ? e.value : e.text : e.value;
                    case"select":
                        return 0 <= e.selectedIndex ? O.k.q(e.options[e.selectedIndex]) : f;
                    default:
                        return e.value
                }
            }, T: function (e, t) {
                switch (O.a.u(e)) {
                    case"option":
                        switch (typeof t) {
                            case"string":
                                O.a.f.set(e, O.c.options.sa, f), "__ko__hasDomDataOptionValue__"in e && delete e.__ko__hasDomDataOptionValue__, e.value = t;
                                break;
                            default:
                                O.a.f.set(e, O.c.options.sa, t), e.__ko__hasDomDataOptionValue__ = o, e.value = "number" == typeof t ? t : ""
                        }
                        break;
                    case"select":
                        for (var n = e.options.length - 1; n >= 0; n--)if (O.k.q(e.options[n]) == t) {
                            e.selectedIndex = n;
                            break
                        }
                        break;
                    default:
                        (t === a || t === f) && (t = ""), e.value = t
                }
            }}, O.b("selectExtensions", O.k), O.b("selectExtensions.readValue", O.k.q), O.b("selectExtensions.writeValue", O.k.T);
            var F = /\@ko_token_(\d+)\@/g, V = ["true", "false"], B = /^(?:[$_a-z][$\w]*|(.+)(\.\s*[$_a-z][$\w]*|\[.+\]))$/i;
            O.g = {Q: [], aa: function (e) {
                var t = O.a.D(e);
                if (3 > t.length)return[];
                "{" === t.charAt(0) && (t = t.substring(1, t.length - 1)), e = [];
                for (var n, i = a, r = 0; r < t.length; r++) {
                    var o = t.charAt(r);
                    if (i === a)switch (o) {
                        case'"':
                        case"'":
                        case"/":
                            i = r, n = o
                    } else if (o == n && "\\" !== t.charAt(r - 1)) {
                        o = t.substring(i, r + 1), e.push(o);
                        var s = "@ko_token_" + (e.length - 1) + "@", t = t.substring(0, i) + s + t.substring(r + 1), r = r - (o.length - s.length), i = a
                    }
                }
                n = i = a;
                for (var u = 0, l = a, r = 0; r < t.length; r++) {
                    if (o = t.charAt(r), i === a)switch (o) {
                        case"{":
                            i = r, l = o, n = "}";
                            break;
                        case"(":
                            i = r, l = o, n = ")";
                            break;
                        case"[":
                            i = r, l = o, n = "]"
                    }
                    o === l ? u++ : o === n && (u--, 0 === u && (o = t.substring(i, r + 1), e.push(o), s = "@ko_token_" + (e.length - 1) + "@", t = t.substring(0, i) + s + t.substring(r + 1), r -= o.length - s.length, i = a))
                }
                for (n = [], t = t.split(","), i = 0, r = t.length; r > i; i++)u = t[i], l = u.indexOf(":"), l > 0 && l < u.length - 1 ? (o = u.substring(l + 1), n.push({key: E(u.substring(0, l), e), value: E(o, e)})) : n.push({unknown: E(u, e)});
                return n
            }, ba: function (e) {
                var t = "string" == typeof e ? O.g.aa(e) : e, n = [];
                e = [];
                for (var i, r = 0; i = t[r]; r++)if (0 < n.length && n.push(","), i.key) {
                    var o;
                    e:{
                        o = i.key;
                        var u = O.a.D(o);
                        switch (u.length && u.charAt(0)) {
                            case"'":
                            case'"':
                                break e;
                            default:
                                o = "'" + u + "'"
                        }
                    }
                    i = i.value, n.push(o), n.push(":"), n.push(i), i = O.a.D(i), 0 <= O.a.i(V, O.a.D(i).toLowerCase()) ? i = s : (u = i.match(B), i = u === a ? s : u[1] ? "Object(" + u[1] + ")" + u[2] : i), i && (0 < e.length && e.push(", "), e.push(o + " : function(__ko_value) { " + i + " = __ko_value; }"))
                } else i.unknown && n.push(i.unknown);
                return t = n.join(""), 0 < e.length && (t = t + ", '_ko_property_writers' : { " + e.join("") + " } "), t
            }, Eb: function (e, t) {
                for (var n = 0; n < e.length; n++)if (O.a.D(e[n].key) == t)return o;
                return s
            }, ea: function (e, t, n, i, r) {
                e && O.Ra(e) ? (!r || e.t() !== i) && e(i) : (e = t()._ko_property_writers) && e[n] && e[n](i)
            }}, O.b("expressionRewriting", O.g), O.b("expressionRewriting.bindingRewriteValidators", O.g.Q), O.b("expressionRewriting.parseObjectLiteral", O.g.aa), O.b("expressionRewriting.preProcessBindings", O.g.ba), O.b("jsonExpressionRewriting", O.g), O.b("jsonExpressionRewriting.insertPropertyAccessorsIntoJson", O.g.ba);
            var k = "<!--test-->" === l.createComment("test").text, U = k ? /^\x3c!--\s*ko(?:\s+(.+\s*\:[\s\S]*))?\s*--\x3e$/ : /^\s*ko(?:\s+(.+\s*\:[\s\S]*))?\s*$/, q = k ? /^\x3c!--\s*\/ko\s*--\x3e$/ : /^\s*\/ko\s*$/, W = {ul: o, ol: o};
            O.e = {I: {}, childNodes: function (e) {
                return T(e) ? S(e) : e.childNodes
            }, Y: function (e) {
                if (T(e)) {
                    e = O.e.childNodes(e);
                    for (var t = 0, n = e.length; n > t; t++)O.removeNode(e[t])
                } else O.a.ka(e)
            }, N: function (e, t) {
                if (T(e)) {
                    O.e.Y(e);
                    for (var n = e.nextSibling, i = 0, r = t.length; r > i; i++)n.parentNode.insertBefore(t[i], n)
                } else O.a.N(e, t)
            }, Va: function (e, t) {
                T(e) ? e.parentNode.insertBefore(t, e.nextSibling) : e.firstChild ? e.insertBefore(t, e.firstChild) : e.appendChild(t)
            }, Pa: function (e, t, n) {
                n ? T(e) ? e.parentNode.insertBefore(t, n.nextSibling) : n.nextSibling ? e.insertBefore(t, n.nextSibling) : e.appendChild(t) : O.e.Va(e, t)
            }, firstChild: function (e) {
                return T(e) ? !e.nextSibling || b(e.nextSibling) ? a : e.nextSibling : e.firstChild
            }, nextSibling: function (e) {
                return T(e) && (e = x(e)), e.nextSibling && b(e.nextSibling) ? a : e.nextSibling
            }, jb: function (e) {
                return(e = T(e)) ? e[1] : a
            }, Ta: function (e) {
                if (W[O.a.u(e)]) {
                    var t = e.firstChild;
                    if (t)do if (1 === t.nodeType) {
                        var n;
                        n = t.firstChild;
                        var i = a;
                        if (n)do if (i)i.push(n); else if (T(n)) {
                            var r = x(n, o);
                            r ? n = r : i = [n]
                        } else b(n) && (i = [n]); while (n = n.nextSibling);
                        if (n = i)for (i = t.nextSibling, r = 0; r < n.length; r++)i ? e.insertBefore(n[r], i) : e.appendChild(n[r])
                    } while (t = t.nextSibling)
                }
            }}, O.b("virtualElements", O.e), O.b("virtualElements.allowedBindings", O.e.I), O.b("virtualElements.emptyNode", O.e.Y), O.b("virtualElements.insertAfter", O.e.Pa), O.b("virtualElements.prepend", O.e.Va), O.b("virtualElements.setDomNodeChildren", O.e.N), O.J = function () {
                this.Ha = {}
            }, O.a.extend(O.J.prototype, {nodeHasBindings: function (e) {
                switch (e.nodeType) {
                    case 1:
                        return e.getAttribute("data-bind") != a;
                    case 8:
                        return O.e.jb(e) != a;
                    default:
                        return s
                }
            }, getBindings: function (e, t) {
                var n = this.getBindingsString(e, t);
                return n ? this.parseBindingsString(n, t, e) : a
            }, getBindingsString: function (e) {
                switch (e.nodeType) {
                    case 1:
                        return e.getAttribute("data-bind");
                    case 8:
                        return O.e.jb(e);
                    default:
                        return a
                }
            }, parseBindingsString: function (t, n, i) {
                try {
                    var r;
                    if (!(r = this.Ha[t])) {
                        var o, a = this.Ha, s = "with($context){with($data||{}){return{" + O.g.ba(t) + "}}}";
                        o = new Function("$context", "$element", s), r = a[t] = o
                    }
                    return r(n, i)
                } catch (u) {
                    e(Error("Unable to parse bindings.\nMessage: " + u + ";\nBindings value: " + t))
                }
            }}), O.J.instance = new O.J, O.b("bindingProvider", O.J), O.c = {}, O.z = function (e, t, n) {
                t ? (O.a.extend(this, t), this.$parentContext = t, this.$parent = t.$data, this.$parents = (t.$parents || []).slice(0), this.$parents.unshift(this.$parent)) : (this.$parents = [], this.$root = e, this.ko = O), this.$data = e, n && (this[n] = e)
            }, O.z.prototype.createChildContext = function (e, t) {
                return new O.z(e, this, t)
            }, O.z.prototype.extend = function (e) {
                var t = O.a.extend(new O.z, this);
                return O.a.extend(t, e)
            }, O.eb = function (e, t) {
                return 2 != arguments.length ? O.a.f.get(e, "__ko_bindingContext__") : (O.a.f.set(e, "__ko_bindingContext__", t), void 0)
            }, O.Fa = function (e, t, n) {
                return 1 === e.nodeType && O.e.Ta(e), _(e, t, n, o)
            }, O.Ea = function (e, t) {
                (1 === t.nodeType || 8 === t.nodeType) && C(e, t, o)
            }, O.Da = function (t, n) {
                n && 1 !== n.nodeType && 8 !== n.nodeType && e(Error("ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node")), n = n || u.document.body, w(t, n, o)
            }, O.ja = function (e) {
                switch (e.nodeType) {
                    case 1:
                    case 8:
                        var t = O.eb(e);
                        if (t)return t;
                        if (e.parentNode)return O.ja(e.parentNode)
                }
                return f
            }, O.pb = function (e) {
                return(e = O.ja(e)) ? e.$data : f
            }, O.b("bindingHandlers", O.c), O.b("applyBindings", O.Da), O.b("applyBindingsToDescendants", O.Ea), O.b("applyBindingsToNode", O.Fa), O.b("contextFor", O.ja), O.b("dataFor", O.pb);
            var H = {"class": "className", "for": "htmlFor"};
            O.c.attr = {update: function (e, t) {
                var n, i = O.a.d(t()) || {};
                for (n in i)if ("string" == typeof n) {
                    var r = O.a.d(i[n]), o = r === s || r === a || r === f;
                    o && e.removeAttribute(n), 8 >= O.a.Z && n in H ? (n = H[n], o ? e.removeAttribute(n) : e[n] = r) : o || e.setAttribute(n, r.toString()), "name" === n && O.a.ab(e, o ? "" : r.toString())
                }
            }}, O.c.checked = {init: function (e, t, n) {
                O.a.n(e, "click", function () {
                    var i;
                    if ("checkbox" == e.type)i = e.checked; else {
                        if ("radio" != e.type || !e.checked)return;
                        i = e.value
                    }
                    var r = t(), a = O.a.d(r);
                    "checkbox" == e.type && a instanceof Array ? (i = O.a.i(a, e.value), e.checked && 0 > i ? r.push(e.value) : !e.checked && i >= 0 && r.splice(i, 1)) : O.g.ea(r, n, "checked", i, o)
                }), "radio" == e.type && !e.name && O.c.uniqueName.init(e, i(o))
            }, update: function (e, t) {
                var n = O.a.d(t());
                "checkbox" == e.type ? e.checked = n instanceof Array ? 0 <= O.a.i(n, e.value) : n : "radio" == e.type && (e.checked = e.value == n)
            }}, O.c.css = {update: function (e, t) {
                var n = O.a.d(t());
                if ("object" == typeof n)for (var i in n) {
                    var r = O.a.d(n[i]);
                    O.a.da(e, i, r)
                } else n = String(n || ""), O.a.da(e, e.__ko__cssValue, s), e.__ko__cssValue = n, O.a.da(e, n, o)
            }}, O.c.enable = {update: function (e, t) {
                var n = O.a.d(t());
                n && e.disabled ? e.removeAttribute("disabled") : !n && !e.disabled && (e.disabled = o)
            }}, O.c.disable = {update: function (e, t) {
                O.c.enable.update(e, function () {
                    return!O.a.d(t())
                })
            }}, O.c.event = {init: function (e, t, n, i) {
                var r, a = t() || {};
                for (r in a)!function () {
                    var a = r;
                    "string" == typeof a && O.a.n(e, a, function (e) {
                        var r, u = t()[a];
                        if (u) {
                            var l = n();
                            try {
                                var c = O.a.L(arguments);
                                c.unshift(i), r = u.apply(i, c)
                            } finally {
                                r !== o && (e.preventDefault ? e.preventDefault() : e.returnValue = s)
                            }
                            l[a + "Bubble"] === s && (e.cancelBubble = o, e.stopPropagation && e.stopPropagation())
                        }
                    })
                }()
            }}, O.c.foreach = {Sa: function (e) {
                return function () {
                    var t = e(), n = O.a.ua(t);
                    return n && "number" != typeof n.length ? (O.a.d(t), {foreach: n.data, as: n.as, includeDestroyed: n.includeDestroyed, afterAdd: n.afterAdd, beforeRemove: n.beforeRemove, afterRender: n.afterRender, beforeMove: n.beforeMove, afterMove: n.afterMove, templateEngine: O.C.oa}) : {foreach: t, templateEngine: O.C.oa}
                }
            }, init: function (e, t) {
                return O.c.template.init(e, O.c.foreach.Sa(t))
            }, update: function (e, t, n, i, r) {
                return O.c.template.update(e, O.c.foreach.Sa(t), n, i, r)
            }}, O.g.Q.foreach = s, O.e.I.foreach = o, O.c.hasfocus = {init: function (e, t, n) {
                function i(i) {
                    e.__ko_hasfocusUpdating = o;
                    var r = e.ownerDocument;
                    "activeElement"in r && (i = r.activeElement === e), r = t(), O.g.ea(r, n, "hasfocus", i, o), e.__ko_hasfocusUpdating = s
                }

                var r = i.bind(a, o), u = i.bind(a, s);
                O.a.n(e, "focus", r), O.a.n(e, "focusin", r), O.a.n(e, "blur", u), O.a.n(e, "focusout", u)
            }, update: function (e, t) {
                var n = O.a.d(t());
                e.__ko_hasfocusUpdating || (n ? e.focus() : e.blur(), O.r.K(O.a.Ba, a, [e, n ? "focusin" : "focusout"]))
            }}, O.c.html = {init: function () {
                return{controlsDescendantBindings: o}
            }, update: function (e, t) {
                O.a.ca(e, t())
            }};
            var G = "__ko_withIfBindingData";
            I("if"), I("ifnot", s, o), I("with", o, s, function (e, t) {
                return e.createChildContext(t)
            }), O.c.options = {update: function (t, n, i) {
                "select" !== O.a.u(t) && e(Error("options binding applies only to SELECT elements"));
                for (var r = 0 == t.length, a = O.a.V(O.a.fa(t.childNodes, function (e) {
                    return e.tagName && "option" === O.a.u(e) && e.selected
                }), function (e) {
                    return O.k.q(e) || e.innerText || e.textContent
                }), s = t.scrollTop, u = O.a.d(n()); 0 < t.length;)O.A(t.options[0]), t.remove(0);
                if (u) {
                    i = i();
                    var c = i.optionsIncludeDestroyed;
                    if ("number" != typeof u.length && (u = [u]), i.optionsCaption) {
                        var d = l.createElement("option");
                        O.a.ca(d, i.optionsCaption), O.k.T(d, f), t.appendChild(d)
                    }
                    n = 0;
                    for (var h = u.length; h > n; n++) {
                        var p = u[n];
                        if (!p || !p._destroy || c) {
                            var d = l.createElement("option"), m = function (e, t, n) {
                                var i = typeof t;
                                return"function" == i ? t(e) : "string" == i ? e[t] : n
                            }, y = m(p, i.optionsValue, p);
                            O.k.T(d, O.a.d(y)), p = m(p, i.optionsText, y), O.a.cb(d, p), t.appendChild(d)
                        }
                    }
                    for (u = t.getElementsByTagName("option"), n = c = 0, h = u.length; h > n; n++)0 <= O.a.i(a, O.k.q(u[n])) && (O.a.bb(u[n], o), c++);
                    t.scrollTop = s, r && "value"in i && P(t, O.a.ua(i.value), o), O.a.ub(t)
                }
            }}, O.c.options.sa = "__ko.optionValueDomData__", O.c.selectedOptions = {init: function (e, t, n) {
                O.a.n(e, "change", function () {
                    var i = t(), r = [];
                    O.a.o(e.getElementsByTagName("option"), function (e) {
                        e.selected && r.push(O.k.q(e))
                    }), O.g.ea(i, n, "value", r)
                })
            }, update: function (t, n) {
                "select" != O.a.u(t) && e(Error("values binding applies only to SELECT elements"));
                var i = O.a.d(n());
                i && "number" == typeof i.length && O.a.o(t.getElementsByTagName("option"), function (e) {
                    var t = 0 <= O.a.i(i, O.k.q(e));
                    O.a.bb(e, t)
                })
            }}, O.c.style = {update: function (e, t) {
                var n, i = O.a.d(t() || {});
                for (n in i)if ("string" == typeof n) {
                    var r = O.a.d(i[n]);
                    e.style[n] = r || ""
                }
            }}, O.c.submit = {init: function (t, n, i, r) {
                "function" != typeof n() && e(Error("The value for a submit binding must be a function")), O.a.n(t, "submit", function (e) {
                    var i, a = n();
                    try {
                        i = a.call(r, t)
                    } finally {
                        i !== o && (e.preventDefault ? e.preventDefault() : e.returnValue = s)
                    }
                })
            }}, O.c.text = {update: function (e, t) {
                O.a.cb(e, t())
            }}, O.e.I.text = o, O.c.uniqueName = {init: function (e, t) {
                if (t()) {
                    var n = "ko_unique_" + ++O.c.uniqueName.ob;
                    O.a.ab(e, n)
                }
            }}, O.c.uniqueName.ob = 0, O.c.value = {init: function (e, t, n) {
                function i() {
                    u = s;
                    var i = t(), r = O.k.q(e);
                    O.g.ea(i, n, "value", r)
                }

                var r = ["change"], a = n().valueUpdate, u = s;
                a && ("string" == typeof a && (a = [a]), O.a.P(r, a), r = O.a.Ga(r)), !O.a.Z || "input" != e.tagName.toLowerCase() || "text" != e.type || "off" == e.autocomplete || e.form && "off" == e.form.autocomplete || -1 != O.a.i(r, "propertychange") || (O.a.n(e, "propertychange", function () {
                    u = o
                }), O.a.n(e, "blur", function () {
                    u && i()
                })), O.a.o(r, function (t) {
                    var n = i;
                    O.a.Ob(t, "after") && (n = function () {
                        setTimeout(i, 0)
                    }, t = t.substring(5)), O.a.n(e, t, n)
                })
            }, update: function (e, t) {
                var n = "select" === O.a.u(e), i = O.a.d(t()), r = O.k.q(e), a = i != r;
                0 === i && 0 !== r && "0" !== r && (a = o), a && (r = function () {
                    O.k.T(e, i)
                }, r(), n && setTimeout(r, 0)), n && 0 < e.length && P(e, i, s)
            }}, O.c.visible = {update: function (e, t) {
                var n = O.a.d(t()), i = "none" != e.style.display;
                n && !i ? e.style.display = "" : !n && i && (e.style.display = "none")
            }}, O.c.click = {init: function (e, t, n, i) {
                return O.c.event.init.call(this, e, function () {
                    var e = {};
                    return e.click = t(), e
                }, n, i)
            }}, O.v = function () {
            }, O.v.prototype.renderTemplateSource = function () {
                e(Error("Override renderTemplateSource"))
            }, O.v.prototype.createJavaScriptEvaluatorBlock = function () {
                e(Error("Override createJavaScriptEvaluatorBlock"))
            }, O.v.prototype.makeTemplateSource = function (t, n) {
                if ("string" == typeof t) {
                    n = n || l;
                    var i = n.getElementById(t);
                    return i || e(Error("Cannot find template with ID " + t)), new O.l.h(i)
                }
                return 1 == t.nodeType || 8 == t.nodeType ? new O.l.O(t) : (e(Error("Unknown template type: " + t)), void 0)
            }, O.v.prototype.renderTemplate = function (e, t, n, i) {
                return e = this.makeTemplateSource(e, i), this.renderTemplateSource(e, t, n)
            }, O.v.prototype.isTemplateRewritten = function (e, t) {
                return this.allowTemplateRewriting === s ? o : this.makeTemplateSource(e, t).data("isRewritten")
            }, O.v.prototype.rewriteTemplate = function (e, t, n) {
                e = this.makeTemplateSource(e, n), t = t(e.text()), e.text(t), e.data("isRewritten", o)
            }, O.b("templateEngine", O.v);
            var j = /(<[a-z]+\d*(\s+(?!data-bind=)[a-z0-9\-]+(=(\"[^\"]*\"|\'[^\']*\'))?)*\s+)data-bind=(["'])([\s\S]*?)\5/gi, Y = /\x3c!--\s*ko\b\s*([\s\S]*?)\s*--\x3e/g;
            O.za = {vb: function (e, t, n) {
                t.isTemplateRewritten(e, n) || t.rewriteTemplate(e, function (e) {
                    return O.za.Gb(e, t)
                }, n)
            }, Gb: function (e, t) {
                return e.replace(j,function (e, n, i, r, o, a, s) {
                    return g(s, n, t)
                }).replace(Y, function (e, n) {
                    return g(n, "<!-- ko -->", t)
                })
            }, kb: function (e) {
                return O.s.ra(function (t, n) {
                    t.nextSibling && O.Fa(t.nextSibling, e, n)
                })
            }}, O.b("__tr_ambtns", O.za.kb), O.l = {}, O.l.h = function (e) {
                this.h = e
            }, O.l.h.prototype.text = function () {
                var e = O.a.u(this.h), e = "script" === e ? "text" : "textarea" === e ? "value" : "innerHTML";
                if (0 == arguments.length)return this.h[e];
                var t = arguments[0];
                "innerHTML" === e ? O.a.ca(this.h, t) : this.h[e] = t
            }, O.l.h.prototype.data = function (e) {
                return 1 === arguments.length ? O.a.f.get(this.h, "templateSourceData_" + e) : (O.a.f.set(this.h, "templateSourceData_" + e, arguments[1]), void 0)
            }, O.l.O = function (e) {
                this.h = e
            }, O.l.O.prototype = new O.l.h, O.l.O.prototype.text = function () {
                if (0 == arguments.length) {
                    var e = O.a.f.get(this.h, "__ko_anon_template__") || {};
                    return e.Aa === f && e.ia && (e.Aa = e.ia.innerHTML), e.Aa
                }
                O.a.f.set(this.h, "__ko_anon_template__", {Aa: arguments[0]})
            }, O.l.h.prototype.nodes = function () {
                return 0 == arguments.length ? (O.a.f.get(this.h, "__ko_anon_template__") || {}).ia : (O.a.f.set(this.h, "__ko_anon_template__", {ia: arguments[0]}), void 0)
            }, O.b("templateSources", O.l), O.b("templateSources.domElement", O.l.h), O.b("templateSources.anonymousTemplate", O.l.O);
            var X;
            O.wa = function (t) {
                t != f && !(t instanceof O.v) && e(Error("templateEngine must inherit from ko.templateEngine")), X = t
            }, O.va = function (t, n, i, r, o) {
                if (i = i || {}, (i.templateEngine || X) == f && e(Error("Set a template engine before calling renderTemplate")), o = o || "replaceChildren", r) {
                    var s = m(r);
                    return O.j(function () {
                        var e = n && n instanceof O.z ? n : new O.z(O.a.d(n)), a = "function" == typeof t ? t(e.$data, e) : t, e = p(r, o, a, e, i);
                        "replaceNode" == o && (r = e, s = m(r))
                    }, a, {Ka: function () {
                        return!s || !O.a.X(s)
                    }, W: s && "replaceNode" == o ? s.parentNode : s})
                }
                return O.s.ra(function (e) {
                    O.va(t, n, i, e, "replaceNode")
                })
            }, O.Mb = function (e, t, n, i, r) {
                function o(e, t) {
                    y(t, u), n.afterRender && n.afterRender(t, e)
                }

                function s(t, i) {
                    u = r.createChildContext(O.a.d(t), n.as), u.$index = i;
                    var o = "function" == typeof e ? e(t, u) : e;
                    return p(a, "ignoreTargetNode", o, u, n)
                }

                var u;
                return O.j(function () {
                    var e = O.a.d(t) || [];
                    "undefined" == typeof e.length && (e = [e]), e = O.a.fa(e, function (e) {
                        return n.includeDestroyed || e === f || e === a || !O.a.d(e._destroy)
                    }), O.r.K(O.a.$a, a, [i, e, s, n, o])
                }, a, {W: i})
            }, O.c.template = {init: function (e, t) {
                var n = O.a.d(t());
                return"string" == typeof n || n.name || 1 != e.nodeType && 8 != e.nodeType || (n = 1 == e.nodeType ? e.childNodes : O.e.childNodes(e), n = O.a.Hb(n), new O.l.O(e).nodes(n)), {controlsDescendantBindings: o}
            }, update: function (e, t, n, i, r) {
                t = O.a.d(t()), n = {}, i = o;
                var s, u = a;
                "string" != typeof t && (n = t, t = n.name, "if"in n && (i = O.a.d(n["if"])), i && "ifnot"in n && (i = !O.a.d(n.ifnot)), s = O.a.d(n.data)), "foreach"in n ? u = O.Mb(t || e, i && n.foreach || [], n, e, r) : i ? (r = "data"in n ? r.createChildContext(s, n.as) : r, u = O.va(t || e, r, n, e)) : O.e.Y(e), r = u, (s = O.a.f.get(e, "__ko__templateComputedDomDataKey__")) && "function" == typeof s.B && s.B(), O.a.f.set(e, "__ko__templateComputedDomDataKey__", r && r.pa() ? r : f)
            }}, O.g.Q.template = function (e) {
                return e = O.g.aa(e), 1 == e.length && e[0].unknown || O.g.Eb(e, "name") ? a : "This template engine does not support anonymous templates nested within its templates"
            }, O.e.I.template = o, O.b("setTemplateEngine", O.wa), O.b("renderTemplate", O.va), O.a.Ja = function (e, t, n) {
                return e = e || [], t = t || [], e.length <= t.length ? h(e, t, "added", "deleted", n) : h(t, e, "deleted", "added", n)
            }, O.b("utils.compareArrays", O.a.Ja), O.a.$a = function (e, t, i, a, s) {
                function u(e, t) {
                    w = d[t], v !== t && (S[e] = w), w.na(v++), r(w.M), m.push(w), _.push(w)
                }

                function l(e, t) {
                    if (e)for (var n = 0, i = t.length; i > n; n++)t[n] && O.a.o(t[n].M, function (i) {
                        e(i, n, t[n].U)
                    })
                }

                t = t || [], a = a || {};
                var c = O.a.f.get(e, "setDomNodeChildrenFromArrayMapping_lastMappingResult") === f, d = O.a.f.get(e, "setDomNodeChildrenFromArrayMapping_lastMappingResult") || [], h = O.a.V(d, function (e) {
                    return e.U
                }), p = O.a.Ja(h, t), m = [], y = 0, v = 0, g = [], _ = [];
                t = [];
                for (var w, C, x, S = [], h = [], b = 0; C = p[b]; b++)switch (x = C.moved, C.status) {
                    case"deleted":
                        x === f && (w = d[y], w.j && w.j.B(), g.push.apply(g, r(w.M)), a.beforeRemove && (t[b] = w, _.push(w))), y++;
                        break;
                    case"retained":
                        u(b, y++);
                        break;
                    case"added":
                        x !== f ? u(b, x) : (w = {U: C.value, na: O.m(v++)}, m.push(w), _.push(w), c || (h[b] = w))
                }
                l(a.beforeMove, S), O.a.o(g, a.beforeRemove ? O.A : O.removeNode);
                for (var T, b = 0, c = O.e.firstChild(e); w = _[b]; b++) {
                    for (w.M || O.a.extend(w, n(e, i, w.U, s, w.na)), y = 0; p = w.M[y]; c = p.nextSibling, T = p, y++)p !== c && O.e.Pa(e, p, T);
                    !w.Ab && s && (s(w.U, w.M, w.na), w.Ab = o)
                }
                l(a.beforeRemove, t), l(a.afterMove, S), l(a.afterAdd, h), O.a.f.set(e, "setDomNodeChildrenFromArrayMapping_lastMappingResult", m)
            }, O.b("utils.setDomNodeChildrenFromArrayMapping", O.a.$a), O.C = function () {
                this.allowTemplateRewriting = s
            }, O.C.prototype = new O.v, O.C.prototype.renderTemplateSource = function (e) {
                var t = 9 > O.a.Z || !e.nodes ? a : e.nodes();
                return t ? O.a.L(t.cloneNode(o).childNodes) : (e = e.text(), O.a.ta(e))
            }, O.C.oa = new O.C, O.wa(O.C.oa), O.b("nativeTemplateEngine", O.C), O.qa = function () {
                var t = this.Db = function () {
                    if ("undefined" == typeof d || !d.tmpl)return 0;
                    try {
                        if (0 <= d.tmpl.tag.tmpl.open.toString().indexOf("__"))return 2
                    } catch (e) {
                    }
                    return 1
                }();
                this.renderTemplateSource = function (n, i, r) {
                    r = r || {}, 2 > t && e(Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later."));
                    var o = n.data("precompiled");
                    return o || (o = n.text() || "", o = d.template(a, "{{ko_with $item.koBindingContext}}" + o + "{{/ko_with}}"), n.data("precompiled", o)), n = [i.$data], i = d.extend({koBindingContext: i}, r.templateOptions), i = d.tmpl(o, n, i), i.appendTo(l.createElement("div")), d.fragments = {}, i
                }, this.createJavaScriptEvaluatorBlock = function (e) {
                    return"{{ko_code ((function() { return " + e + " })()) }}"
                }, this.addTemplate = function (e, t) {
                    l.write("<script type='text/html' id='" + e + "'>" + t + "</script>")
                }, t > 0 && (d.tmpl.tag.ko_code = {open: "__.push($1 || '');"}, d.tmpl.tag.ko_with = {open: "with($1) {", close: "} "})
            }, O.qa.prototype = new O.v, t = new O.qa, 0 < t.Db && O.wa(t), O.b("jqueryTmplTemplateEngine", O.qa)
        }

        var o = !0, a = null, s = !1, u = window, l = document, c = navigator, d = window.jQuery, f = void 0;
        "function" == typeof t && "object" == typeof exports && "object" == typeof module ? r(module.exports || exports) : "function" == typeof n && n.amd ? n("ThirdParty/knockout-2.2.1", ["exports"], r) : r(u.ko = {})
    }(), n("ThirdParty/weakmap", ["exports"], function (e) {
        var t = function () {
            try {
                return"x"in Object.defineProperty({}, "x", {})
            } catch (e) {
                return!1
            }
        }(), n = Array.prototype.forEach ? Array.prototype.forEach : function (e, t) {
            for (var n = 0, i = this.length; i > n; ++n)e.call(t, this[n], n, this)
        };
        void function (i, r, o) {
            function a(e, t, n) {
                return"function" == typeof t && (n = t, t = s(n).replace(/_$/, "")), d(e, t, {configurable: !0, writable: !0, value: n})
            }

            function s(e) {
                return"function" != typeof e ? "" : "_name"in e ? e._name : "name"in e ? e.name : f.call(e).match(m)[1]
            }

            function u(e, t) {
                return t._name = e, t
            }

            function l(e) {
                function t(t, i) {
                    return i || 2 === arguments.length ? n.set(t, i) : (i = n.get(t), i === o && (i = e(t), n.set(t, i))), i
                }

                var n = new v;
                return e || (e = g), t
            }

            var c = Object.getOwnPropertyNames, d = t ? Object.defineProperty : function (e) {
                return e
            }, f = Function.prototype.toString, h = Object.create ? Object.create : function (e) {
                function t() {
                }

                return t.prototype = e, new t
            }, p = Object.prototype.hasOwnProperty, m = /^\n?function\s?(\w*)?_?\(/, y = function () {
                function e() {
                    var e = r(), i = {};
                    this.unlock = function (r) {
                        var o = l(r);
                        if (p.call(o, e))return o[e](i);
                        var a = h(null, t);
                        return d(o, e, {value: new Function("s", "l", n)(i, a)}), a
                    }
                }

                var t = {value: {writable: !0, value: o}}, n = "return function(k){if(k===s)return l}", i = h(null), r = function () {
                    var e = Math.random().toString(36).slice(2);
                    return e in i ? r() : i[e] = e
                }, s = r(), l = function (e) {
                    if (p.call(e, s))return e[s];
                    if (!Object.isExtensible(e))throw new TypeError("Object must be extensible");
                    var t = h(null);
                    return d(e, s, {value: t}), t
                };
                return a(Object, u("getOwnPropertyNames", function (e) {
                    var t = c(e);
                    return p.call(e, s) && t.splice(t.indexOf(s), 1), t
                })), a(e.prototype, u("get", function (e) {
                    return this.unlock(e).value
                })), a(e.prototype, u("set", function (e, t) {
                    this.unlock(e).value = t
                })), e
            }(), v = function (e) {
                function t(e) {
                    return this === i || null == this || this === t.prototype ? new t(e) : (m(this, new y), g(this, e), void 0)
                }

                function l(e) {
                    p(e);
                    var t = v(this).get(e);
                    return t === r ? o : t
                }

                function c(e, t) {
                    p(e), v(this).set(e, t === o ? r : t)
                }

                function d(e) {
                    return p(e), v(this).get(e) !== o
                }

                function f(e) {
                    p(e);
                    var t = v(this), n = t.get(e) !== o;
                    return t.set(e, o), n
                }

                function h() {
                    return v(this), "[object WeakMap]"
                }

                var p = function (e) {
                    if (null == e || "object" != typeof e && "function" != typeof e)throw new TypeError("Invalid WeakMap key")
                }, m = function (t, n) {
                    var i = e.unlock(t);
                    if (i.value)throw new TypeError("Object is already a WeakMap");
                    i.value = n
                }, v = function (t) {
                    var n = e.unlock(t).value;
                    if (!n)throw new TypeError("WeakMap is not generic");
                    return n
                }, g = function (e, t) {
                    null !== t && "object" == typeof t && "function" == typeof t.forEach && t.forEach(function (n, i) {
                        n instanceof Array && 2 === n.length && c.call(e, t[i][0], t[i][1])
                    })
                };
                l._name = "get", c._name = "set", d._name = "has", h._name = "toString";
                try {
                    var _ = ("return " + f).replace("e_", "\\u0065"), w = new Function("unwrap", "validate", _)(v, p)
                } catch (C) {
                    var w = f
                }
                var _ = ("" + Object).split("Object"), x = u("toString", function () {
                    return _[0] + s(this) + _[1]
                });
                a(x, x);
                var S = {__proto__: []}instanceof Array ? function (e) {
                    e.__proto__ = x
                } : function (e) {
                    a(e, x)
                };
                return S(t), n.call([h, l, c, d, w], function (e) {
                    a(t.prototype, e), S(e)
                }), t
            }(new y), g = Object.create ? function () {
                return Object.create(null)
            } : function () {
                return{}
            };
            "undefined" != typeof module ? module.exports = v : "undefined" != typeof e ? e.WeakMap = v : "WeakMap"in i || (i.WeakMap = v), v.createStorage = l, i.WeakMap && (i.WeakMap.createStorage = l)
        }((0, eval)("this"))
    }), n("ThirdParty/knockout-es5", ["./weakmap", "exports"], function (e, n) {
        !function (i, r) {
            "use strict";
            function o(e, t) {
                if (!e)throw new Error("When calling ko.track, you must pass an object as the first parameter.");
                var n = this, i = a(e, !0);
                return t = t || Object.getOwnPropertyNames(e), t.forEach(function (t) {
                    if (!(t in i)) {
                        var o = e[t], a = o instanceof Array, s = n.isObservable(o) ? o : a ? n.observableArray(o) : n.observable(o);
                        Object.defineProperty(e, t, {configurable: !0, enumerable: !0, get: s, set: n.isWriteableObservable(s) ? s : r}), i[t] = s, a && u(n, s)
                    }
                }), e
            }

            function a(e, t) {
                v || (v = _());
                var n = v.get(e);
                return!n && t && (n = {}, v.set(e, n)), n
            }

            function s(e, t, n) {
                var i = this, r = {owner: e, deferEvaluation: !0};
                if ("function" == typeof n)r.read = n; else {
                    if ("value"in n)throw new Error('For ko.defineProperty, you must not specify a "value" for the property. You must provide a "get" function.');
                    if ("function" != typeof n.get)throw new Error('For ko.defineProperty, the third parameter must be either an evaluator function, or an options object containing a function called "get".');
                    r.read = n.get, r.write = n.set
                }
                return e[t] = i.computed(r), o.call(i, e, [t]), e
            }

            function u(e, t) {
                var n = null;
                e.computed(function () {
                    n && (n.dispose(), n = null);
                    var i = t();
                    i instanceof Array && (n = l(e, t, i))
                })
            }

            function l(e, t, n) {
                var i = c(e, n);
                return i.subscribe(t)
            }

            function c(e, t) {
                g || (g = _());
                var n = g.get(t);
                if (!n) {
                    n = new e.subscribable, g.set(t, n);
                    var i = {};
                    d(t, n, i), f(e, t, n, i)
                }
                return n
            }

            function d(e, t, n) {
                ["pop", "push", "reverse", "shift", "sort", "splice", "unshift"].forEach(function (i) {
                    var r = e[i];
                    e[i] = function () {
                        var e = r.apply(this, arguments);
                        return n.pause !== !0 && t.notifySubscribers(this), e
                    }
                })
            }

            function f(e, t, n, i) {
                ["remove", "removeAll", "destroy", "destroyAll", "replace"].forEach(function (r) {
                    Object.defineProperty(t, r, {enumerable: !1, value: function () {
                        var o;
                        i.pause = !0;
                        try {
                            o = e.observableArray.fn[r].apply(e.observableArray(t), arguments)
                        } finally {
                            i.pause = !1
                        }
                        return n.notifySubscribers(t), o
                    }})
                })
            }

            function h(e, t) {
                if (!e)return null;
                var n = a(e, !1);
                return n && n[t] || null
            }

            function p(e, t) {
                var n = h(e, t);
                n && n.valueHasMutated()
            }

            function m(e) {
                e.track = o, e.getObservable = h, e.valueHasMutated = p, e.defineProperty = s
            }

            function y() {
                if ("undefined" != typeof module) {
                    var r = t("knockout"), o = t("weakmap");
                    m(r), _ = function () {
                        return new o
                    }, module.exports = r
                } else"ko"in i ? (m(i.ko), _ = function () {
                    return new i.WeakMap
                }) : "undefined" != typeof e && (_ = function () {
                    return new e.WeakMap
                }, n.attachToKo = m)
            }

            var v, g, _;
            y()
        }(this)
    }), n("ThirdParty/knockout", ["./knockout-2.2.1", "./knockout-es5"], function (e, t) {
        "use strict";
        return t.attachToKo(e), e
    }), n("Widgets/getElement", ["../Core/DeveloperError"], function (e) {
        "use strict";
        var t = function (t) {
            if ("string" == typeof t) {
                var n = document.getElementById(t);
                if (null === n)throw new e('Element with id "' + t + '" does not exist in the document.');
                t = n
            }
            return t
        };
        return t
    }), n("Widgets/Animation/Animation", ["../../Core/defaultValue", "../../Core/defineProperties", "../../Core/destroyObject", "../../Core/DeveloperError", "../../Core/Color", "../getElement", "../../ThirdParty/knockout"], function (e, t, n, i, r, o, a) {
        "use strict";
        function s(e) {
            return r.fromCssColorString(window.getComputedStyle(e).getPropertyValue("color"))
        }

        function u(e, t, n, i) {
            return n.call(i, e[t]), a.getObservable(e, t).subscribe(n, i)
        }

        function l(e) {
            var t = document.createElementNS(v, e.tagName);
            for (var n in e)if (e.hasOwnProperty(n) && "tagName" !== n)if ("children" === n) {
                var i, r = e.children.length;
                for (i = 0; r > i; ++i)t.appendChild(l(e.children[i]))
            } else 0 === n.indexOf("xlink:") ? t.setAttributeNS(g, n.substring(6), e[n]) : "textContent" === n ? t.textContent = e[n] : t.setAttribute(n, e[n]);
            return t
        }

        function c(e, t, n) {
            var i = document.createElementNS(v, "text");
            i.setAttribute("x", e), i.setAttribute("y", t), i.setAttribute("class", "cesium-animation-svgText");
            var r = document.createElementNS(v, "tspan");
            return r.textContent = n, i.appendChild(r), i
        }

        function d(e, t, n) {
            e.setAttribute("transform", "translate(100,100) rotate(" + n + ")"), t.setAttribute("transform", "rotate(" + n + ")")
        }

        function f(e, t) {
            var n = t.alpha, i = 1 - n;
            return A.red = e.red * i + t.red * n, A.green = e.green * i + t.green * n, A.blue = e.blue * i + t.blue * n, A.toCssColorString()
        }

        function h(e, t, n) {
            var i = {tagName: "g", "class": "cesium-animation-rectButton", transform: "translate(" + e + "," + t + ")", children: [
                {tagName: "rect", "class": "cesium-animation-buttonGlow", width: 32, height: 32, rx: 2, ry: 2},
                {tagName: "rect", "class": "cesium-animation-buttonMain", width: 32, height: 32, rx: 4, ry: 4},
                {tagName: "use", "class": "cesium-animation-buttonPath", "xlink:href": n},
                {tagName: "title", textContent: ""}
            ]};
            return l(i)
        }

        function p(e, t, n) {
            var i = {tagName: "g", "class": "cesium-animation-rectButton", transform: "translate(" + e + "," + t + ")", children: [
                {tagName: "use", "class": "cesium-animation-buttonGlow", "xlink:href": "#animation_pathWingButton"},
                {tagName: "use", "class": "cesium-animation-buttonMain", "xlink:href": "#animation_pathWingButton"},
                {tagName: "use", "class": "cesium-animation-buttonPath", "xlink:href": n},
                {tagName: "title", textContent: ""}
            ]};
            return l(i)
        }

        function m(e, t) {
            var n = e._viewModel, i = n.shuttleRingDragging;
            if (!i || y === e)if ("mousedown" === t.type || i && "mousemove" === t.type || "touchstart" === t.type && 1 === t.touches.length || i && "touchmove" === t.type && 1 === t.touches.length) {
                var r, o, a = e._centerX, s = e._centerY, u = e._svgNode, l = u.getBoundingClientRect();
                if ("touchstart" === t.type || "touchmove" === t.type ? (r = t.touches[0].clientX, o = t.touches[0].clientY) : (r = t.clientX, o = t.clientY), !i && (r > l.right || r < l.left || o < l.top || o > l.bottom))return;
                var c = e._shuttleRingPointer.getBoundingClientRect(), d = r - a - l.left, f = o - s - l.top, h = 180 * Math.atan2(f, d) / Math.PI + 90;
                h > 180 && (h -= 360);
                var p = n.shuttleRingAngle;
                i || r < c.right && r > c.left && o > c.top && o < c.bottom ? (y = e, n.shuttleRingDragging = !0, n.shuttleRingAngle = h) : p > h ? n.slower() : h > p && n.faster(), t.preventDefault()
            } else y = void 0, n.shuttleRingDragging = !1
        }

        var y, v = "http://www.w3.org/2000/svg", g = "http://www.w3.org/1999/xlink", _ = r.fromCssColorString("rgba(247,250,255,0.384)"), w = r.fromCssColorString("rgba(143,191,255,0.216)"), C = r.fromCssColorString("rgba(153,197,255,0.098)"), x = r.fromCssColorString("rgba(255,255,255,0.086)"), S = r.fromCssColorString("rgba(255,255,255,0.267)"), b = r.fromCssColorString("rgba(255,255,255,0)"), T = r.fromCssColorString("rgba(66,67,68,0.3)"), E = r.fromCssColorString("rgba(0,0,0,0.5)"), A = new r, M = function (e, t) {
            this._viewModel = t, this.svgElement = e, this._enabled = void 0, this._toggled = void 0;
            var n = this;
            this._clickFunction = function () {
                var e = n._viewModel.command;
                e.canExecute && e()
            }, e.addEventListener("click", this._clickFunction, !0), this._subscriptions = [u(t, "toggled", this.setToggled, this), u(t, "tooltip", this.setTooltip, this), u(t.command, "canExecute", this.setEnabled, this)]
        };
        M.prototype.destroy = function () {
            this.svgElement.removeEventListener("click", this._clickFunction, !0);
            for (var e = this._subscriptions, t = 0, i = e.length; i > t; t++)e[t].dispose();
            n(this)
        }, M.prototype.isDestroyed = function () {
            return!1
        }, M.prototype.setEnabled = function (e) {
            if (this._enabled !== e) {
                if (this._enabled = e, !e)return this.svgElement.setAttribute("class", "cesium-animation-buttonDisabled"), void 0;
                if (this._toggled)return this.svgElement.setAttribute("class", "cesium-animation-rectButton cesium-animation-buttonToggled"), void 0;
                this.svgElement.setAttribute("class", "cesium-animation-rectButton")
            }
        }, M.prototype.setToggled = function (e) {
            this._toggled !== e && (this._toggled = e, this._enabled && (e ? this.svgElement.setAttribute("class", "cesium-animation-rectButton cesium-animation-buttonToggled") : this.svgElement.setAttribute("class", "cesium-animation-rectButton")))
        }, M.prototype.setTooltip = function (e) {
            this.svgElement.getElementsByTagName("title")[0].textContent = e
        };
        var D = function (e, t) {
            if ("undefined" == typeof e)throw new i("container is required.");
            if ("undefined" == typeof t)throw new i("viewModel is required.");
            e = o(e), this._viewModel = t, this._container = e, this._centerX = 0, this._centerY = 0, this._defsElement = void 0, this._svgNode = void 0, this._topG = void 0, this._lastHeight = void 0, this._lastWidth = void 0;
            var n = document.createElement("style");
            n.textContent = ".cesium-animation-rectButton .cesium-animation-buttonGlow { filter: url(#animation_blurred); }.cesium-animation-rectButton .cesium-animation-buttonMain { fill: url(#animation_buttonNormal); }.cesium-animation-buttonToggled .cesium-animation-buttonMain { fill: url(#animation_buttonToggled); }.cesium-animation-rectButton:hover .cesium-animation-buttonMain { fill: url(#animation_buttonHovered); }.cesium-animation-buttonDisabled .cesium-animation-buttonMain { fill: url(#animation_buttonDisabled); }.cesium-animation-shuttleRingG .cesium-animation-shuttleRingSwoosh { fill: url(#animation_shuttleRingSwooshGradient); }.cesium-animation-shuttleRingG:hover .cesium-animation-shuttleRingSwoosh { fill: url(#animation_shuttleRingSwooshHovered); }.cesium-animation-shuttleRingPointer { fill: url(#animation_shuttleRingPointerGradient); }.cesium-animation-shuttleRingPausePointer { fill: url(#animation_shuttleRingPointerPaused); }.cesium-animation-knobOuter { fill: url(#animation_knobOuter); }.cesium-animation-knobInner { fill: url(#animation_knobInner); }", document.head.insertBefore(n, document.head.childNodes[0]);
            var r = document.createElement("div");
            r.className = "cesium-animation-theme", r.innerHTML = '<div class="cesium-animation-themeNormal"></div><div class="cesium-animation-themeHover"></div><div class="cesium-animation-themeSelect"></div><div class="cesium-animation-themeDisabled"></div><div class="cesium-animation-themeKnob"></div><div class="cesium-animation-themePointer"></div><div class="cesium-animation-themeSwoosh"></div><div class="cesium-animation-themeSwooshHover"></div>', this._theme = r, this._themeNormal = r.childNodes[0], this._themeHover = r.childNodes[1], this._themeSelect = r.childNodes[2], this._themeDisabled = r.childNodes[3], this._themeKnob = r.childNodes[4], this._themePointer = r.childNodes[5], this._themeSwoosh = r.childNodes[6], this._themeSwooshHover = r.childNodes[7];
            var a = document.createElementNS(v, "svg:svg");
            this._svgNode = a, a.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", g);
            var s = document.createElementNS(v, "g");
            this._topG = s, this._realtimeSVG = new M(p(3, 4, "#animation_pathClock"), t.playRealtimeViewModel), this._playReverseSVG = new M(h(44, 99, "#animation_pathPlayReverse"), t.playReverseViewModel), this._playForwardSVG = new M(h(124, 99, "#animation_pathPlay"), t.playForwardViewModel), this._pauseSVG = new M(h(84, 99, "#animation_pathPause"), t.pauseViewModel);
            var f = document.createElementNS(v, "g");
            f.appendChild(this._realtimeSVG.svgElement), f.appendChild(this._playReverseSVG.svgElement), f.appendChild(this._playForwardSVG.svgElement), f.appendChild(this._pauseSVG.svgElement);
            var y = l({tagName: "circle", "class": "cesium-animation-shuttleRingBack", cx: 100, cy: 100, r: 99});
            this._shuttleRingBackPanel = y;
            var _ = l({tagName: "g", "class": "cesium-animation-shuttleRingSwoosh", children: [
                {tagName: "use", transform: "translate(100,97) scale(-1,1)", "xlink:href": "#animation_pathSwooshFX"},
                {tagName: "use", transform: "translate(100,97)", "xlink:href": "#animation_pathSwooshFX"},
                {tagName: "line", x1: 100, y1: 8, x2: 100, y2: 22}
            ]});
            this._shuttleRingSwooshG = _, this._shuttleRingPointer = l({tagName: "use", "class": "cesium-animation-shuttleRingPointer", "xlink:href": "#animation_pathPointer"});
            var w = l({tagName: "g", transform: "translate(100,100)"});
            this._knobOuter = l({tagName: "circle", "class": "cesium-animation-knobOuter", cx: 0, cy: 0, r: 71});
            var C = 61, x = l({tagName: "circle", "class": "cesium-animation-knobInner", cx: 0, cy: 0, r: C});
            this._knobDate = c(0, -24, ""), this._knobTime = c(0, -7, ""), this._knobStatus = c(0, -41, "");
            var S = l({tagName: "circle", "class": "cesium-animation-blank", cx: 0, cy: 0, r: C}), b = document.createElementNS(v, "g");
            b.setAttribute("class", "cesium-animation-shuttleRingG"), e.appendChild(r), s.appendChild(b), s.appendChild(w), s.appendChild(f), b.appendChild(y), b.appendChild(_), b.appendChild(this._shuttleRingPointer), w.appendChild(this._knobOuter), w.appendChild(x), w.appendChild(this._knobDate), w.appendChild(this._knobTime), w.appendChild(this._knobStatus), w.appendChild(S), a.appendChild(s), e.appendChild(a);
            var T = this, E = function (e) {
                m(T, e)
            };
            this._mouseCallback = E, y.addEventListener("mousedown", E, !0), y.addEventListener("touchstart", E, !0), _.addEventListener("mousedown", E, !0), _.addEventListener("touchstart", E, !0), document.addEventListener("mousemove", E, !0), document.addEventListener("touchmove", E, !0), document.addEventListener("mouseup", E, !0), document.addEventListener("touchend", E, !0), this._shuttleRingPointer.addEventListener("mousedown", E, !0), this._shuttleRingPointer.addEventListener("touchstart", E, !0), this._knobOuter.addEventListener("mousedown", E, !0), this._knobOuter.addEventListener("touchstart", E, !0);
            var A, D = this._knobTime.childNodes[0], I = this._knobDate.childNodes[0], P = this._knobStatus.childNodes[0];
            this._subscriptions = [u(t.pauseViewModel, "toggled", function (e) {
                A !== e && (A = e, A ? T._shuttleRingPointer.setAttribute("class", "cesium-animation-shuttleRingPausePointer") : T._shuttleRingPointer.setAttribute("class", "cesium-animation-shuttleRingPointer"))
            }), u(t, "shuttleRingAngle", function (e) {
                d(T._shuttleRingPointer, T._knobOuter, e)
            }), u(t, "dateLabel", function (e) {
                I.textContent !== e && (I.textContent = e)
            }), u(t, "timeLabel", function (e) {
                D.textContent !== e && (D.textContent = e)
            }), u(t, "multiplierLabel", function (e) {
                P.textContent !== e && (P.textContent = e)
            })], this.applyThemeChanges(), this.resize()
        };
        return t(D.prototype, {container: {get: function () {
            return this._container
        }}, viewModel: {get: function () {
            return this._viewModel
        }}}), D.prototype.isDestroyed = function () {
            return!1
        }, D.prototype.destroy = function () {
            var e = this._mouseCallback;
            this._shuttleRingBackPanel.removeEventListener("mousedown", e, !0), this._shuttleRingBackPanel.removeEventListener("touchstart", e, !0), this._shuttleRingSwooshG.removeEventListener("mousedown", e, !0), this._shuttleRingSwooshG.removeEventListener("touchstart", e, !0), document.removeEventListener("mousemove", e, !0), document.removeEventListener("touchmove", e, !0), document.removeEventListener("mouseup", e, !0), document.removeEventListener("touchend", e, !0), this._shuttleRingPointer.removeEventListener("mousedown", e, !0), this._shuttleRingPointer.removeEventListener("touchstart", e, !0), this._knobOuter.removeEventListener("mousedown", e, !0), this._knobOuter.removeEventListener("touchstart", e, !0), this._container.removeChild(this._svgNode), this._container.removeChild(this._theme), this._realtimeSVG.destroy(), this._playReverseSVG.destroy(), this._playForwardSVG.destroy(), this._pauseSVG.destroy();
            for (var t = this._subscriptions, i = 0, r = t.length; r > i; i++)t[i].dispose();
            return n(this)
        }, D.prototype.resize = function () {
            var e = this._container.clientWidth, t = this._container.clientHeight;
            if (e !== this._lastWidth || t !== this._lastHeight) {
                var n = this._svgNode, i = 200, r = 132, o = e, a = t;
                0 === e && 0 === t ? (o = i, a = r) : 0 === e ? (a = t, o = i * (t / r)) : 0 === t && (o = e, a = r * (e / i));
                var s = o / i, u = a / r;
                n.style.cssText = "width: " + o + "px; height: " + a + "px; position: absolute; bottom: 0; left: 0;", n.setAttribute("width", o), n.setAttribute("height", a), n.setAttribute("viewBox", "0 0 " + o + " " + a), this._topG.setAttribute("transform", "scale(" + s + "," + u + ")"), this._centerX = Math.max(1, 100 * s), this._centerY = Math.max(1, 100 * u), this._lastHeight = e, this._lastWidth = t
            }
        }, D.prototype.applyThemeChanges = function () {
            var e = s(this._themeNormal), t = s(this._themeHover), n = s(this._themeSelect), i = s(this._themeDisabled), r = s(this._themeKnob), o = s(this._themePointer), a = s(this._themeSwoosh), u = s(this._themeSwooshHover), c = l({tagName: "defs", children: [
                {id: "animation_buttonNormal", tagName: "linearGradient", x1: "50%", y1: "0%", x2: "50%", y2: "100%", children: [
                    {tagName: "stop", offset: "0%", "stop-color": f(e, _)},
                    {tagName: "stop", offset: "12%", "stop-color": f(e, w)},
                    {tagName: "stop", offset: "46%", "stop-color": f(e, C)},
                    {tagName: "stop", offset: "81%", "stop-color": f(e, x)}
                ]},
                {id: "animation_buttonHovered", tagName: "linearGradient", x1: "50%", y1: "0%", x2: "50%", y2: "100%", children: [
                    {tagName: "stop", offset: "0%", "stop-color": f(t, _)},
                    {tagName: "stop", offset: "12%", "stop-color": f(t, w)},
                    {tagName: "stop", offset: "46%", "stop-color": f(t, C)},
                    {tagName: "stop", offset: "81%", "stop-color": f(t, x)}
                ]},
                {id: "animation_buttonToggled", tagName: "linearGradient", x1: "50%", y1: "0%", x2: "50%", y2: "100%", children: [
                    {tagName: "stop", offset: "0%", "stop-color": f(n, _)},
                    {tagName: "stop", offset: "12%", "stop-color": f(n, w)},
                    {tagName: "stop", offset: "46%", "stop-color": f(n, C)},
                    {tagName: "stop", offset: "81%", "stop-color": f(n, x)}
                ]},
                {id: "animation_buttonDisabled", tagName: "linearGradient", x1: "50%", y1: "0%", x2: "50%", y2: "100%", children: [
                    {tagName: "stop", offset: "0%", "stop-color": f(i, S)},
                    {tagName: "stop", offset: "75%", "stop-color": f(i, b)}
                ]},
                {id: "animation_blurred", tagName: "filter", width: "200%", height: "200%", x: "-50%", y: "-50%", children: [
                    {tagName: "feGaussianBlur", stdDeviation: 4, "in": "SourceGraphic"}
                ]},
                {id: "animation_shuttleRingSwooshGradient", tagName: "linearGradient", x1: "50%", y1: "0%", x2: "50%", y2: "100%", children: [
                    {tagName: "stop", offset: "0%", "stop-opacity": .2, "stop-color": a.toCssColorString()},
                    {tagName: "stop", offset: "85%", "stop-opacity": .85, "stop-color": a.toCssColorString()},
                    {tagName: "stop", offset: "95%", "stop-opacity": .05, "stop-color": a.toCssColorString()}
                ]},
                {id: "animation_shuttleRingSwooshHovered", tagName: "linearGradient", x1: "50%", y1: "0%", x2: "50%", y2: "100%", children: [
                    {tagName: "stop", offset: "0%", "stop-opacity": .2, "stop-color": u.toCssColorString()},
                    {tagName: "stop", offset: "85%", "stop-opacity": .85, "stop-color": u.toCssColorString()},
                    {tagName: "stop", offset: "95%", "stop-opacity": .05, "stop-color": u.toCssColorString()}
                ]},
                {id: "animation_shuttleRingPointerGradient", tagName: "linearGradient", x1: "0%", y1: "50%", x2: "100%", y2: "50%", children: [
                    {tagName: "stop", offset: "0%", "stop-color": o.toCssColorString()},
                    {tagName: "stop", offset: "40%", "stop-color": o.toCssColorString()},
                    {tagName: "stop", offset: "60%", "stop-color": f(o, E)},
                    {tagName: "stop", offset: "100%", "stop-color": f(o, E)}
                ]},
                {id: "animation_shuttleRingPointerPaused", tagName: "linearGradient", x1: "0%", y1: "50%", x2: "100%", y2: "50%", children: [
                    {tagName: "stop", offset: "0%", "stop-color": "#CCC"},
                    {tagName: "stop", offset: "40%", "stop-color": "#CCC"},
                    {tagName: "stop", offset: "60%", "stop-color": "#555"},
                    {tagName: "stop", offset: "100%", "stop-color": "#555"}
                ]},
                {id: "animation_knobOuter", tagName: "linearGradient", x1: "20%", y1: "0%", x2: "90%", y2: "100%", children: [
                    {tagName: "stop", offset: "5%", "stop-color": f(r, _)},
                    {tagName: "stop", offset: "60%", "stop-color": f(r, T)},
                    {tagName: "stop", offset: "85%", "stop-color": f(r, w)}
                ]},
                {id: "animation_knobInner", tagName: "linearGradient", x1: "20%", y1: "0%", x2: "90%", y2: "100%", children: [
                    {tagName: "stop", offset: "5%", "stop-color": f(r, T)},
                    {tagName: "stop", offset: "60%", "stop-color": f(r, _)},
                    {tagName: "stop", offset: "85%", "stop-color": f(r, x)}
                ]},
                {id: "animation_pathReset", tagName: "path", transform: "translate(16,16) scale(0.85) translate(-16,-16)", d: "M24.316,5.318,9.833,13.682,9.833,5.5,5.5,5.5,5.5,25.5,9.833,25.5,9.833,17.318,24.316,25.682z"},
                {id: "animation_pathPause", tagName: "path", transform: "translate(16,16) scale(0.85) translate(-16,-16)", d: "M13,5.5,7.5,5.5,7.5,25.5,13,25.5zM24.5,5.5,19,5.5,19,25.5,24.5,25.5z"},
                {id: "animation_pathPlay", tagName: "path", transform: "translate(16,16) scale(0.85) translate(-16,-16)", d: "M6.684,25.682L24.316,15.5L6.684,5.318V25.682z"},
                {id: "animation_pathPlayReverse", tagName: "path", transform: "translate(16,16) scale(-0.85,0.85) translate(-16,-16)", d: "M6.684,25.682L24.316,15.5L6.684,5.318V25.682z"},
                {id: "animation_pathLoop", tagName: "path", transform: "translate(16,16) scale(0.85) translate(-16,-16)", d: "M24.249,15.499c-0.009,4.832-3.918,8.741-8.75,8.75c-2.515,0-4.768-1.064-6.365-2.763l2.068-1.442l-7.901-3.703l0.744,8.694l2.193-1.529c2.244,2.594,5.562,4.242,9.26,4.242c6.767,0,12.249-5.482,12.249-12.249H24.249zM15.499,6.75c2.516,0,4.769,1.065,6.367,2.764l-2.068,1.443l7.901,3.701l-0.746-8.693l-2.192,1.529c-2.245-2.594-5.562-4.245-9.262-4.245C8.734,3.25,3.25,8.734,3.249,15.499H6.75C6.758,10.668,10.668,6.758,15.499,6.75z"},
                {id: "animation_pathClock", tagName: "path", transform: "translate(16,16) scale(0.85) translate(-16,-15.5)", d: "M15.5,2.374C8.251,2.375,2.376,8.251,2.374,15.5C2.376,22.748,8.251,28.623,15.5,28.627c7.249-0.004,13.124-5.879,13.125-13.127C28.624,8.251,22.749,2.375,15.5,2.374zM15.5,25.623C9.909,25.615,5.385,21.09,5.375,15.5C5.385,9.909,9.909,5.384,15.5,5.374c5.59,0.01,10.115,4.535,10.124,10.125C25.615,21.09,21.091,25.615,15.5,25.623zM8.625,15.5c-0.001-0.552-0.448-0.999-1.001-1c-0.553,0-1,0.448-1,1c0,0.553,0.449,1,1,1C8.176,16.5,8.624,16.053,8.625,15.5zM8.179,18.572c-0.478,0.277-0.642,0.889-0.365,1.367c0.275,0.479,0.889,0.641,1.365,0.365c0.479-0.275,0.643-0.887,0.367-1.367C9.27,18.461,8.658,18.297,8.179,18.572zM9.18,10.696c-0.479-0.276-1.09-0.112-1.366,0.366s-0.111,1.09,0.365,1.366c0.479,0.276,1.09,0.113,1.367-0.366C9.821,11.584,9.657,10.973,9.18,10.696zM22.822,12.428c0.478-0.275,0.643-0.888,0.366-1.366c-0.275-0.478-0.89-0.642-1.366-0.366c-0.479,0.278-0.642,0.89-0.366,1.367C21.732,12.54,22.344,12.705,22.822,12.428zM12.062,21.455c-0.478-0.275-1.089-0.111-1.366,0.367c-0.275,0.479-0.111,1.09,0.366,1.365c0.478,0.277,1.091,0.111,1.365-0.365C12.704,22.344,12.54,21.732,12.062,21.455zM12.062,9.545c0.479-0.276,0.642-0.888,0.366-1.366c-0.276-0.478-0.888-0.642-1.366-0.366s-0.642,0.888-0.366,1.366C10.973,9.658,11.584,9.822,12.062,9.545zM22.823,18.572c-0.48-0.275-1.092-0.111-1.367,0.365c-0.275,0.479-0.112,1.092,0.367,1.367c0.477,0.275,1.089,0.113,1.365-0.365C23.464,19.461,23.3,18.848,22.823,18.572zM19.938,7.813c-0.477-0.276-1.091-0.111-1.365,0.366c-0.275,0.48-0.111,1.091,0.366,1.367s1.089,0.112,1.366-0.366C20.581,8.702,20.418,8.089,19.938,7.813zM23.378,14.5c-0.554,0.002-1.001,0.45-1.001,1c0.001,0.552,0.448,1,1.001,1c0.551,0,1-0.447,1-1C24.378,14.949,23.929,14.5,23.378,14.5zM15.501,6.624c-0.552,0-1,0.448-1,1l-0.466,7.343l-3.004,1.96c-0.478,0.277-0.642,0.889-0.365,1.365c0.275,0.479,0.889,0.643,1.365,0.367l3.305-1.676C15.39,16.99,15.444,17,15.501,17c0.828,0,1.5-0.671,1.5-1.5l-0.5-7.876C16.501,7.072,16.053,6.624,15.501,6.624zM15.501,22.377c-0.552,0-1,0.447-1,1s0.448,1,1,1s1-0.447,1-1S16.053,22.377,15.501,22.377zM18.939,21.455c-0.479,0.277-0.643,0.889-0.366,1.367c0.275,0.477,0.888,0.643,1.366,0.365c0.478-0.275,0.642-0.889,0.366-1.365C20.028,21.344,19.417,21.18,18.939,21.455z"},
                {id: "animation_pathWingButton", tagName: "path", d: "m 4.5,0.5 c -2.216,0 -4,1.784 -4,4 l 0,24 c 0,2.216 1.784,4 4,4 l 13.71875,0 C 22.478584,27.272785 27.273681,22.511272 32.5,18.25 l 0,-13.75 c 0,-2.216 -1.784,-4 -4,-4 l -24,0 z"},
                {id: "animation_pathPointer", tagName: "path", d: "M-15,-65,-15,-55,15,-55,15,-65,0,-95z"},
                {id: "animation_pathSwooshFX", tagName: "path", d: "m 85,0 c 0,16.617 -4.813944,35.356 -13.131081,48.4508 h 6.099803 c 8.317138,-13.0948 13.13322,-28.5955 13.13322,-45.2124 0,-46.94483 -38.402714,-85.00262 -85.7743869,-85.00262 -1.0218522,0 -2.0373001,0.0241 -3.0506131,0.0589 45.958443,1.59437 82.723058,35.77285 82.723058,81.70532 z"}
            ]});
            "undefined" == typeof this._defsElement ? this._svgNode.appendChild(c) : this._svgNode.replaceChild(c, this._defsElement), this._defsElement = c
        }, D
    }), n("Widgets/createCommand", ["../Core/defaultValue", "../Core/defineProperties", "../Core/DeveloperError", "../Core/Event", "../ThirdParty/knockout"], function (e, t, n, i, r) {
        "use strict";
        var o = function (o, a) {
            function s() {
                if (!s.canExecute)throw new n("Cannot execute command, canExecute is false.");
                var e, t = {args: arguments, cancel: !1};
                return u.raiseEvent(t), t.cancel || (e = o.apply(null, arguments), l.raiseEvent(e)), e
            }

            if ("undefined" == typeof o)throw new n("func is required.");
            a = e(a, !0);
            var u = new i, l = new i;
            return s.canExecute = a, r.track(s, ["canExecute"]), t(s, {beforeExecute: {value: u}, afterExecute: {value: l}}), s
        };
        return o
    }), n("Widgets/ToggleButtonViewModel", ["../Core/defaultValue", "../Core/defineProperties", "../Core/DeveloperError", "../ThirdParty/knockout"], function (e, t, n, i) {
        "use strict";
        var r = function (t, r) {
            if ("undefined" == typeof t)throw new n("command is required.");
            this._command = t, r = e(r, e.EMPTY_OBJECT), this.toggled = e(r.toggled, !1), this.tooltip = e(r.tooltip, ""), i.track(this, ["toggled", "tooltip"])
        };
        return t(r.prototype, {command: {get: function () {
            return this._command
        }}}), r
    }), n("Widgets/Animation/AnimationViewModel", ["../../Core/binarySearch", "../../Core/ClockStep", "../../Core/ClockRange", "../../Core/defineProperties", "../../Core/DeveloperError", "../createCommand", "../ToggleButtonViewModel", "../../ThirdParty/sprintf", "../../ThirdParty/knockout"], function (e, t, n, i, r, o, a, s, u) {
        "use strict";
        function l(e) {
            e.clockStep === t.SYSTEM_CLOCK && (e.clockStep = t.SYSTEM_CLOCK_MULTIPLIER, e.multiplier = 1)
        }

        function c(e) {
            l(e), e.shouldAnimate = !0
        }

        function d(e, t) {
            return e - t
        }

        function f(t, n) {
            var i = e(n, t, d);
            return 0 > i ? ~i : i
        }

        function h(e, t) {
            if (Math.abs(e) <= y)return e / y;
            var n, i, r = y, o = v, a = 0;
            return e > 0 ? (n = Math.log(t[t.length - 1]), i = (n - a) / (o - r), Math.exp(a + i * (e - r))) : (n = Math.log(-t[0]), i = (n - a) / (o - r), -Math.exp(a + i * (Math.abs(e) - r)))
        }

        function p(e, n, i) {
            if (i.clockStep === t.SYSTEM_CLOCK)return y;
            if (Math.abs(e) <= 1)return e * y;
            var r, o, a = y, s = v, u = 0;
            return e > 0 ? (r = Math.log(n[n.length - 1]), o = (r - u) / (s - a), (Math.log(e) - u) / o + a) : (r = Math.log(-n[0]), o = (r - u) / (s - a), -((Math.log(Math.abs(e)) - u) / o + a))
        }

        var m = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], y = 15, v = 105, g = function (e) {
            if ("undefined" == typeof e)throw new r("clockViewModel is required.");
            var i = this;
            this._clockViewModel = e, this._allShuttleRingTicks = [], this._dateFormatter = g.defaultDateFormatter, this._timeFormatter = g.defaultTimeFormatter, this.shuttleRingDragging = !1, this.snapToTicks = !1, u.track(this, ["_allShuttleRingTicks", "_dateFormatter", "_timeFormatter", "shuttleRingDragging", "snapToTicks"]), this._sortedFilteredPositiveTicks = [], this.setShuttleRingTicks(g.defaultTicks), this.timeLabel = void 0, u.defineProperty(this, "timeLabel", function () {
                return i._timeFormatter(i._clockViewModel.currentTime, i)
            }), this.dateLabel = void 0, u.defineProperty(this, "dateLabel", function () {
                return i._dateFormatter(i._clockViewModel.currentTime, i)
            }), this.multiplierLabel = void 0, u.defineProperty(this, "multiplierLabel", function () {
                var e = i._clockViewModel;
                if (e.clockStep === t.SYSTEM_CLOCK)return"Today";
                var n = e.multiplier;
                return 0 === n % 1 ? n.toFixed(0) + "x" : n.toFixed(3).replace(/0{0,3}$/, "") + "x"
            }), this.shuttleRingAngle = void 0, u.defineProperty(this, "shuttleRingAngle", {get: function () {
                return p(e.multiplier, i._allShuttleRingTicks, e)
            }, set: function (e) {
                e = Math.max(Math.min(e, v), -v);
                var n = i._allShuttleRingTicks, r = i._clockViewModel;
                if (r.clockStep = t.SYSTEM_CLOCK_MULTIPLIER, Math.abs(e) === v)return r.multiplier = e > 0 ? n[n.length - 1] : n[0], void 0;
                var o = h(e, n);
                if (i.snapToTicks)o = n[f(o, n)]; else if (0 !== o) {
                    var a = Math.abs(o);
                    if (a > 100) {
                        var s = a.toFixed(0).length - 2, u = Math.pow(10, s);
                        o = 0 | Math.round(o / u) * u
                    } else a > y ? o = Math.round(o) : a > 1 ? o = +o.toFixed(1) : a > 0 && (o = +o.toFixed(2))
                }
                r.multiplier = o
            }}), this._canAnimate = void 0, u.defineProperty(this, "_canAnimate", function () {
                var e = i._clockViewModel, t = e.clockRange;
                if (i.shuttleRingDragging || t === n.UNBOUNDED)return!0;
                var r = e.multiplier, o = e.currentTime, a = e.startTime, s = !1;
                if (t === n.LOOP_STOP)s = o.greaterThan(a) || o.equals(a) && r > 0; else {
                    var u = e.stopTime;
                    s = o.greaterThan(a) && o.lessThan(u) || o.equals(a) && r > 0 || o.equals(u) && 0 > r
                }
                return s || (e.shouldAnimate = !1), s
            }), this._isSystemTimeAvailable = void 0, u.defineProperty(this, "_isSystemTimeAvailable", function () {
                var e = i._clockViewModel, t = e.clockRange;
                if (t === n.UNBOUNDED)return!0;
                var r = e.systemTime;
                return r.greaterThanOrEquals(e.startTime) && r.lessThanOrEquals(e.stopTime)
            }), this._isAnimating = void 0, u.defineProperty(this, "_isAnimating", function () {
                return i._clockViewModel.shouldAnimate && (i._canAnimate || i.shuttleRingDragging)
            });
            var s = o(function () {
                var e = i._clockViewModel;
                e.shouldAnimate ? (l(e), e.shouldAnimate = !1) : i._canAnimate && c(e)
            });
            this._pauseViewModel = new a(s, {toggled: u.computed(function () {
                return!i._isAnimating
            }), tooltip: "Pause"});
            var d = o(function () {
                var e = i._clockViewModel;
                l(e);
                var t = e.multiplier;
                t > 0 && (e.multiplier = -t), e.shouldAnimate = !0
            });
            this._playReverseViewModel = new a(d, {toggled: u.computed(function () {
                return i._isAnimating && e.multiplier < 0
            }), tooltip: "Play Reverse"});
            var m = o(function () {
                var e = i._clockViewModel;
                l(e);
                var t = e.multiplier;
                0 > t && (e.multiplier = -t), e.shouldAnimate = !0
            });
            this._playForwardViewModel = new a(m, {toggled: u.computed(function () {
                return i._isAnimating && e.multiplier > 0 && e.clockStep !== t.SYSTEM_CLOCK
            }), tooltip: "Play Forward"});
            var _ = o(function () {
                var e = i._clockViewModel;
                e.clockStep = t.SYSTEM_CLOCK, e.multiplier = 1, e.shouldAnimate = !0
            }, u.getObservable(this, "_isSystemTimeAvailable"));
            this._playRealtimeViewModel = new a(_, {toggled: u.computed(function () {
                return e.shouldAnimate && e.clockStep === t.SYSTEM_CLOCK
            }), tooltip: u.computed(function () {
                return i._isSystemTimeAvailable ? "Today (real-time)" : "Current time not in range"
            })}), this._slower = o(function () {
                var e = i._clockViewModel;
                l(e);
                var t = i._allShuttleRingTicks, n = e.multiplier, r = f(n, t) - 1;
                r >= 0 && (e.multiplier = t[r])
            }), this._faster = o(function () {
                var e = i._clockViewModel;
                l(e);
                var t = i._allShuttleRingTicks, n = e.multiplier, r = f(n, t) + 1;
                r < t.length && (e.multiplier = t[r])
            })
        };
        return g.defaultDateFormatter = function (e) {
            var t = e.toGregorianDate();
            return m[t.month - 1] + " " + t.day + " " + t.year
        }, g.defaultTicks = [.001, .002, .005, .01, .02, .05, .1, .25, .5, 1, 2, 5, 10, 15, 30, 60, 120, 300, 600, 900, 1800, 3600, 7200, 14400, 21600, 43200, 86400, 172800, 345600, 604800], g.defaultTimeFormatter = function (e, t) {
            var n = e.toGregorianDate(), i = Math.round(n.millisecond);
            return Math.abs(t._clockViewModel.multiplier) < 1 ? s("%02d:%02d:%02d.%03d", n.hour, n.minute, n.second, i) : s("%02d:%02d:%02d UTC", n.hour, n.minute, n.second)
        }, g.prototype.getShuttleRingTicks = function () {
            return this._sortedFilteredPositiveTicks.slice(0)
        }, g.prototype.setShuttleRingTicks = function (e) {
            if ("undefined" == typeof e)throw new r("positiveTicks is required.");
            var t, n, i, o = {}, a = this._sortedFilteredPositiveTicks;
            for (a.length = 0, t = 0, n = e.length; n > t; ++t)i = e[t], o.hasOwnProperty(i) || (o[i] = !0, a.push(i));
            a.sort(d);
            var s = [];
            for (n = a.length, t = n - 1; t >= 0; --t)i = a[t], 0 !== i && s.push(-i);
            Array.prototype.push.apply(s, a), this._allShuttleRingTicks = s
        }, i(g.prototype, {slower: {get: function () {
            return this._slower
        }}, faster: {get: function () {
            return this._faster
        }}, clockViewModel: {get: function () {
            return this._clockViewModel
        }}, pauseViewModel: {get: function () {
            return this._pauseViewModel
        }}, playReverseViewModel: {get: function () {
            return this._playReverseViewModel
        }}, playForwardViewModel: {get: function () {
            return this._playForwardViewModel
        }}, playRealtimeViewModel: {get: function () {
            return this._playRealtimeViewModel
        }}, dateFormatter: {get: function () {
            return this._dateFormatter
        }, set: function (e) {
            if ("function" != typeof e)throw new r("dateFormatter must be a function");
            this._dateFormatter = e
        }}, timeFormatter: {get: function () {
            return this._timeFormatter
        }, set: function (e) {
            if ("function" != typeof e)throw new r("timeFormatter must be a function");
            this._timeFormatter = e
        }}}), g._maxShuttleRingAngle = v, g._realtimeShuttleRingAngle = y, g
    }), n("Widgets/BaseLayerPicker/BaseLayerPickerViewModel", ["../../Core/defineProperties", "../../Core/DeveloperError", "../createCommand", "../../ThirdParty/knockout"], function (e, t, n, i) {
        "use strict";
        var r = function (e, r) {
            if ("undefined" == typeof e)throw new t("imageryLayers is required");
            if ("undefined" == typeof r)r = []; else if (!Array.isArray(r))throw new t("imageryProviderViewModels must be an array");
            var o = this;
            this._imageryLayers = e, this.imageryProviderViewModels = r.slice(0), this.dropDownVisible = !1, i.track(this, ["imageryProviderViewModels", "dropDownVisible"]), this.selectedName = void 0, i.defineProperty(this, "selectedName", function () {
                var e = o.selectedItem;
                return"undefined" != typeof e ? e.name : void 0
            }), this.selectedIconUrl = void 0, i.defineProperty(this, "selectedIconUrl", function () {
                var e = o.selectedItem;
                return"undefined" != typeof e ? e.iconUrl : void 0
            }), this.selectedItem = void 0;
            var a = i.observable();
            this._currentProviders = [], i.defineProperty(this, "selectedItem", {get: function () {
                return a()
            }, set: function (t) {
                var n, i = o._currentProviders, r = i.length;
                for (n = 0; r > n; n++)for (var s = e.getLength(), u = 0; s > u; u++) {
                    var l = e.get(u);
                    if (l.getImageryProvider() === i[n]) {
                        e.remove(l);
                        break
                    }
                }
                if ("undefined" != typeof t) {
                    var c = t.creationCommand();
                    if (Array.isArray(c)) {
                        var d = c.length;
                        for (n = d - 1; n >= 0; n--)e.addImageryProvider(c[n], 0);
                        o._currentProviders = c.slice(0)
                    } else o._currentProviders = [c], e.addImageryProvider(c, 0);
                    a(t)
                }
                o.dropDownVisible = !1
            }}), this._toggleDropDown = n(function () {
                o.dropDownVisible = !o.dropDownVisible
            })
        };
        return e(r.prototype, {toggleDropDown: {get: function () {
            return this._toggleDropDown
        }}, imageryLayers: {get: function () {
            return this._imageryLayers
        }}}), r
    }), n("Widgets/BaseLayerPicker/BaseLayerPicker", ["../../Core/defineProperties", "../../Core/destroyObject", "../../Core/DeveloperError", "../getElement", "./BaseLayerPickerViewModel", "../../ThirdParty/knockout"], function (e, t, n, i, r, o) {
        "use strict";
        var a = function (e, t, a) {
            if ("undefined" == typeof e)throw new n("container is required.");
            if ("undefined" == typeof t)throw new n("imageryLayers is required.");
            e = i(e);
            var s = new r(t, a);
            this._viewModel = s, this._container = e, this._element = document.createElement("img");
            var u = this._element;
            u.setAttribute("draggable", "false"), u.className = "cesium-baseLayerPicker-selected", u.setAttribute("data-bind", "                attr: {title: selectedName, src: selectedIconUrl},                click: toggleDropDown"), e.appendChild(u);
            var l = document.createElement("div");
            this._choices = l, l.className = "cesium-baseLayerPicker-dropDown", l.setAttribute("data-bind", '                css: { "cesium-baseLayerPicker-visible" : dropDownVisible,                       "cesium-baseLayerPicker-hidden" : !dropDownVisible },                foreach: imageryProviderViewModels'), e.appendChild(l);
            var c = document.createElement("div");
            c.className = "cesium-baseLayerPicker-item", c.setAttribute("data-bind", '                css: {"cesium-baseLayerPicker-selectedItem" : $data === $parent.selectedItem},                attr: {title: tooltip},                visible: creationCommand.canExecute,                click: function($data) { $parent.selectedItem = $data }'), l.appendChild(c);
            var d = document.createElement("img");
            d.className = "cesium-baseLayerPicker-itemIcon", d.setAttribute("data-bind", "attr: { src: iconUrl }"), d.setAttribute("draggable", "false"), c.appendChild(d);
            var f = document.createElement("div");
            f.className = "cesium-baseLayerPicker-itemLabel", f.setAttribute("data-bind", "text: name"), c.appendChild(f), o.applyBindings(s, e), this._closeDropDown = function (t) {
                e.contains(t.target) || (s.dropDownVisible = !1)
            }, document.addEventListener("mousedown", this._closeDropDown, !0), document.addEventListener("touchstart", this._closeDropDown, !0)
        };
        return e(a.prototype, {container: {get: function () {
            return this._container
        }}, viewModel: {get: function () {
            return this._viewModel
        }}}), a.prototype.isDestroyed = function () {
            return!1
        }, a.prototype.destroy = function () {
            document.removeEventListener("mousedown", this._closeDropDown, !0), document.removeEventListener("touchstart", this._closeDropDown, !0);
            var e = this._container;
            return o.cleanNode(e), e.removeChild(this._element), e.removeChild(this._choices), t(this)
        }, a
    }), n("Widgets/BaseLayerPicker/ImageryProviderViewModel", ["../../Core/defineProperties", "../../Core/DeveloperError", "../createCommand", "../../ThirdParty/knockout"], function (e, t, n, i) {
        "use strict";
        var r = function (e) {
            if ("undefined" == typeof e.name)throw new t("description.name is required.");
            if ("undefined" == typeof e.tooltip)throw new t("description.tooltip is required.");
            if ("undefined" == typeof e.iconUrl)throw new t("description.iconUrl is required.");
            if ("function" != typeof e.creationFunction)throw new t("description.creationFunction is required.");
            var r = e.creationFunction;
            "undefined" == typeof r.canExecute && (r = n(r)), this._creationCommand = r, this.name = e.name, this.tooltip = e.tooltip, this.iconUrl = e.iconUrl, i.track(this, ["name", "tooltip", "iconUrl"])
        };
        return e(r.prototype, {creationCommand: {get: function () {
            return this._creationCommand
        }}}), r
    }), n("Widgets/BaseLayerPicker/createDefaultBaseLayers", ["require", "../BaseLayerPicker/ImageryProviderViewModel", "../../Core/buildModuleUrl", "../../Core/FeatureDetection", "../../Core/DefaultProxy", "../../Scene/BingMapsImageryProvider", "../../Scene/BingMapsStyle", "../../Scene/ArcGisMapServerImageryProvider", "../../Scene/OpenStreetMapImageryProvider", "../../Scene/TileMapServiceImageryProvider"], function (e, t, n, i, r, o, a, s, u, l) {
        "use strict";
        function c() {
            var e = new r("http://cesium.agi.com/proxy/"), c = i.supportsCrossOriginImagery() ? void 0 : e, d = [];
            return d.push(new t({name: "Bing Maps Aerial", iconUrl: n("Widgets/Images/ImageryProviders/bingAerial.png"), tooltip: "Bing Maps aerial imagery \nhttp://www.bing.com/maps", creationFunction: function () {
                return new o({url: "http://dev.virtualearth.net", mapStyle: a.AERIAL, proxy: c})
            }})), d.push(new t({name: "Bing Maps Aerial with Labels", iconUrl: n("Widgets/Images/ImageryProviders/bingAerialLabels.png"), tooltip: "Bing Maps aerial imagery with label overlays \nhttp://www.bing.com/maps", creationFunction: function () {
                return new o({url: "http://dev.virtualearth.net", mapStyle: a.AERIAL_WITH_LABELS, proxy: c})
            }})), d.push(new t({name: "Bing Maps Roads", iconUrl: n("Widgets/Images/ImageryProviders/bingRoads.png"), tooltip: "Bing Maps standard road maps\nhttp://www.bing.com/maps", creationFunction: function () {
                return new o({url: "http://dev.virtualearth.net", mapStyle: a.ROAD, proxy: c})
            }})), d.push(new t({name: "ESRI World Imagery", iconUrl: n("Widgets/Images/ImageryProviders/esriWorldImagery.png"), tooltip: "World Imagery provides one meter or better satellite and aerial imagery in many parts of the world and lower resolution satellite imagery worldwide.  The map includes NASA Blue Marble: Next Generation 500m resolution imagery at small scales (above 1:1,000,000), i-cubed 15m eSAT imagery at medium-to-large scales (down to 1:70,000) for the world, and USGS 15m Landsat imagery for Antarctica. The map features 0.3m resolution imagery in the continental United States and 0.6m resolution imagery in parts of Western Europe from DigitalGlobe. In other parts of the world, 1 meter resolution imagery is available from GeoEye IKONOS, i-cubed Nationwide Prime, Getmapping, AeroGRID, IGN Spain, and IGP Portugal.  Additionally, imagery at different resolutions has been contributed by the GIS User Community.\nhttp://www.esri.com", creationFunction: function () {
                return new s({url: "http://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer", proxy: e})
            }})), d.push(new t({name: "ESRI World Street Map", iconUrl: n("Widgets/Images/ImageryProviders/esriWorldStreetMap.png"), tooltip: "This worldwide street map presents highway-level data for the world. Street-level data includes the United States; much of Canada; Japan; most countries in Europe; Australia and New Zealand; India; parts of South America including Argentina, Brazil, Chile, Colombia, and Venezuela; Ghana; and parts of southern Africa including Botswana, Lesotho, Namibia, South Africa, and Swaziland.\nhttp://www.esri.com", creationFunction: function () {
                return new s({url: "http://services.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer", proxy: e})
            }})), d.push(new t({name: "ESRI National Geographic", iconUrl: n("Widgets/Images/ImageryProviders/esriNationalGeographic.png"), tooltip: "This web map contains the National Geographic World Map service. This map service is designed to be used as a general reference map for informational and educational purposes as well as a basemap by GIS professionals and other users for creating web maps and web mapping applications.\nhttp://www.esri.com", creationFunction: function () {
                return new s({url: "http://services.arcgisonline.com/ArcGIS/rest/services/NatGeo_World_Map/MapServer/", proxy: e})
            }})), d.push(new t({name: "Open­Street­Map", iconUrl: n("Widgets/Images/ImageryProviders/openStreetMap.png"), tooltip: "OpenStreetMap (OSM) is a collaborative project to create a free editable map of the world.\nhttp://www.openstreetmap.org", creationFunction: function () {
                return new u({url: "http://tile.openstreetmap.org/", proxy: c})
            }})), d.push(new t({name: "Stamen Watercolor", iconUrl: n("Widgets/Images/ImageryProviders/stamenWatercolor.png"), tooltip: "Reminiscent of hand drawn maps, Stamen watercolor maps apply raster effect area washes and organic edges over a paper texture to add warm pop to any map.\nhttp://maps.stamen.com", creationFunction: function () {
                return new u({url: "http://tile.stamen.com/watercolor/", credit: "Map tiles by Stamen Design, under CC BY 3.0. Data by OpenStreetMap, under CC BY SA.", proxy: c})
            }})), d.push(new t({name: "Stamen Toner", iconUrl: n("Widgets/Images/ImageryProviders/stamenToner.png"), tooltip: "A high contrast black and white map.\nhttp://maps.stamen.com", creationFunction: function () {
                return new u({url: "http://tile.stamen.com/toner/", credit: "Map tiles by Stamen Design, under CC BY 3.0. Data by OpenStreetMap, under CC BY SA.", proxy: c})
            }})), d.push(new t({name: "MapQuest Open­Street­Map", iconUrl: n("Widgets/Images/ImageryProviders/mapQuestOpenStreetMap.png"), tooltip: "OpenStreetMap (OSM) is a collaborative project to create a free editable map of the world.\nhttp://www.openstreetmap.org", creationFunction: function () {
                return new u({url: "http://otile1.mqcdn.com/tiles/1.0.0/osm/", proxy: c})
            }})), d.push(new t({name: "The Black Marble", iconUrl: n("Widgets/Images/ImageryProviders/blackMarble.png"), tooltip: "The lights of cities and villages trace the outlines of civilization in this global view of the Earth at night as seen by NASA/NOAA's Suomi NPP satellite.", creationFunction: function () {
                return new l({url: "http://cesium.agi.com/blackmarble", maximumLevel: 8, credit: "Black Marble imagery courtesy NASA Earth Observatory", proxy: c})
            }})), d.push(new t({name: "Natural Earth II", iconUrl: n("Widgets/Images/ImageryProviders/naturalEarthII.png"), tooltip: "Natural Earth II, darkened for contrast.\nhttp://www.naturalearthdata.com/", creationFunction: function () {
                return new l({url: n("Assets/Textures/NaturalEarthII")})
            }})), d
        }

        return c
    }), n("Widgets/CesiumWidget/CesiumWidget", ["../../Core/buildModuleUrl", "../../Core/Cartesian2", "../../Core/Cartesian3", "../../Core/Clock", "../../Core/DefaultProxy", "../../Core/defaultValue", "../../Core/defineProperties", "../../Core/destroyObject", "../../Core/DeveloperError", "../../Core/Ellipsoid", "../../Core/FeatureDetection", "../../Core/requestAnimationFrame", "../../Core/ScreenSpaceEventHandler", "../../Scene/BingMapsImageryProvider", "../../Scene/CentralBody", "../../Scene/Credit", "../../Scene/Scene", "../../Scene/SceneMode", "../../Scene/SceneTransitioner", "../../Scene/SkyAtmosphere", "../../Scene/SkyBox", "../../Scene/Sun", "../getElement"], function (e, t, n, i, r, o, a, s, u, l, c, d, f, h, p, m, y, v, g, _, w, C, x) {
        "use strict";
        function S(t) {
            return e("Assets/Textures/SkyBox/tycho2t3_80_" + t + ".jpg")
        }

        function b(e) {
            function t() {
                try {
                    e._useDefaultRenderLoop ? (e.resize(), e.render(), d(t)) : e._renderLoopRunning = !1
                } catch (n) {
                    e._useDefaultRenderLoop = !1, e._renderLoopRunning = !1, e.onRenderLoopError.raiseEvent(e, n)
                }
            }

            e._renderLoopRunning = !0, d(t)
        }

        var T = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHYAAAAaCAYAAABikagwAAAAAXNSR0IArs4c6QAAAAlwSFlzAAAN1wAADdcBQiibeAAAAAd0SU1FB9wGGRQyF371QVsAABOHSURBVGje7Vp5cFTHmf91v2Nm3owGnYMuEEJCOBiEjDlsDMYQjGMOOwmXcWxiLywpJ9iuTXZd612corJssFOxi8LerXizxEGUvWsivNxxHHCQ8WYBYSFzmUMCCXQjaUajOd/V+4f6Kc14kI/KZv/xq+p6M/PmO15/9/c1wa0vwpcMQAHgBuAFoPG7mz8jAGwASQBxADFhJQGYACwAjK+vrr/AJQ8jVMqfuwH4AGQByAaQnTNqXGHWqHGFbq8/g1BJsgw9GQ12Bds/qWsxEvEeAEEAfQDCAKKCgPGVcP//BOsIVQHgAZAJIACgsHTqvDvK7150T2bR2DFaZm6W4slwUypR20yaiUg4OtDbcaP36rlPPt6/7f2B3q5mAB0AeriAE18J9y93kVu4X4W73BwAhQBK5v/gZ98ZVXXvDG92IJMx569MQDEoK0tPmOHu1s4L7799sH7vtvcAXAPQCaCfu2qLu+7h+Eh3sS8Bcyt48iVgPos2+4J7jS+BIx2etDBSynfH/Xq46y0CUL70n3/zXMmUuXepWoZHFCQhFIQARCBFJYV6/Nn+QHnVBH9Ovq/51JFWADpfJhcqEzyDcx9ukTTr/xr2VnDpng0nuHR0h1u3wvWF6EspgBIAFYAfQAGAsuU/rfm7kePvvJ0QiTj6QSgBISS9ujEGSikkxaXklIwfK8uK2Xru2HVurWKspZyezGmmWwp/LqVsupPQub4grPQ5YIejKQvPJAGflLLJSBGmxPEqKXhU4XdJEBq7BR5Z+L+DKx3MTTHWEaybx9WCud/btCJQMeX2Qevk+NPoks0YPArF/RUj0NyXxOmO2CAy1a1OmL9yUVfTmatXTx52EildYFQVNlgRmBR1xQJgCBbPBAVUhcw8lTObLz0FVk4RIEmJJyJNZzFBiCTFBRL+f50rriFUATRFiZSU/XYEAw6X5LlIUghZqXvl5p8pfycRZsgjymlKGw1Adm7JbRUVs785nwGghP5pp9mfFMOxWstmuC3gwdcrRqA/buJUWwyKRMAYgydrZNZt9337623njn+ixyN9nAmdM5nBvYOPfxc3mnEmTQ4T5VZv8hfz8aUKnocJd5tvVhxAhOMADzNefleFjRUFa/D/xzi8LQhIEpTG4VXnNBzlZYISufk7juCfqaAoLkHYcZ6HBAEM8O+ObJz3HcFDpJfDJwWYfiHMMTklviocKHv6I3+zRFLdKhEEatmALBFIBIibNhQ6KFyJEjT2JHDoUj/a+nVIVIBhBGOnzptWXzhmTFfT2TZBOH4AgSeeeGJqRUVFqdfr9btcLnVQXwapmqZpJZPJRCgUCh47duzie++9dwWAXl5enrlp06bF0WhUM01TYYwRrmg2vzNKqS3Lsunz+Yy6urpTP//5z09blkVLSkryVq9ePT03NzegqqqbUnqTGyOEMNM0k319fX2///3vz9bW1l4DYD700EPFy5Ytm65pmvbBBx9c2rp166Wnnnqq7MEHH5zAGIu8/vrr+w8ePPgJVwrRO2gAcg8cOLA2mUx62tvbB9avX39s+fLlo++///5JXNiwbXugpqam9tChQ2cEj6NzuQwlsi+//PKSzMzMQtu2qcfjMZqbm09v2LDht4J3sQEQOU2Jo8mKKzt7VEU5lSgFBi3PZkBZrgv3lGbCo1Jc7I7iSGN40JcQgoGkhXdO94ESQJEoGI+1k/M9mDKqQHEv++akl186e45rNAAE3njjjccWLFhwfyAQyJEkiabGbcc7JJNJva2trX3Lli3vvPbaa+eKi4uLV6xY8d10cf5TcZ8x5OXl5b366qs9lFLtrbfeWldVVXW7pmkuxhjS0SSEIJlMGitXrrz2/PPPv1lTU3NtypQp0x955JG/kmVZdrlcR7du3WrOnTt33pIlS+YDwNGjR68ePHiwjVtukm+wI9ichQsXPgUAHR0d3evXr78xc+bMu9asWbOQUjpENz8/v/jQoUP/IiiH40UzAeQvW7Zs1rp16/7a5/NpDr/19fWlGzZsOM4tNsphkc5iPaXTvl6uuDUvY4MZLwNQ4Ffw+LR8+KQQTCuJSQUFcMsEe88FoSkSKCFwyWSISQbg9pEefHdGAJHIdUydVjFecL3K448/Pm3hwoUPBAKBHFGIlmU5pRCRpMGEze12q2PHjh2zatWqeTt37gwODAxkOQIJhUJ6Y2Njn6IojFJqE0KYsGyPx0POnTvXnUgkfGvXrr1j5syZU7iFsKampv5YLBZ34GzbJgAwatSo7MzMTE95eXnZT37yk0dramr+PRQKZSQSCdPn88nBYNADID8UCmkAYBiGGQ6Hna6cksbdZliWZUuSRKPRKAAUBINBfywWM30+n+yEtenTp9+5YsWKGTt37oxwz+a44RwARc8+++xSr9eriQrY398v8311CUncTTHN0Q7Vl1OQJymq4iBwyxQPT8qDVwri1d1/i8ttp/AP39mOBeMn41pQx9mOGFSZ3qT52ZqMR6aMRGvXKfzbgX9Ea3PnSLEdOWXKlK/5/X4/AFy8ePHG6tWr90QikS5VVaOEEIsxRhljngcffLBi8+bNjxBCUFJSMrKkpMRvGIbboXP27Nn+2bNn/3cgEIgSQmKEEAOARQixKKVxRVEioVAoYtu2dMcdd4x24Hbv3t3+ox/96ONoNBqklMa4ppNkMinNnz8///nnn6/y+Xw0mUxaANy6rrsdl28YhguAX9d1F98jwn9TUjJkJ5N1DWV0ti0ByDAMw+PsbzQatX0+Hy0oKMhcvnz5nP3791+IxWJRIUaPfO655+ZVVlaOA4BoNGprmkZ5uJJThZouKyYAqOrWVEKoE7cwszQDlQUK3jr8S5y++iEIIXh55/fwylOH8e3KHHSEdfQnLFBuRbJEsLQyF27Sh3eO/iuudV+EaSuqkJF6MjMzs9xutwIAv/rVr06eOHHiEwCtPBHQOaPaxYsXLxcXF8cKCwtzOzo6+ltbW4OFhYU+h2nDMAgAqbu7W8xkLSEBcsos1bbtocZIIBBQs7Ky5Pb2dkvXdV1wfaipqemsqak5yF1bFABljNEU4Sj87nia1LKHCJWGLLh6AkDhiksAoLq6um/VqlWZWVlZ8gMPPHDHwoULK2tqasJcYJ7y8vKyb33rW/f4/X43YwybNm26vnnz5pIUb0tvVe44maSVjEfizDJtmwFlOS4srczGiQvv4ncnd4ASAkIo+mN92LLrB/j7Vb/GQxOz8Z/1PTDsQXc6p3QEqopU7Dr6S5y8fAiKpCKhs6SQSUqyLKsO4d7e3j4AvbxD1csFQQF4EolEaP369TVCFjuiqKiogG8w5s6dm8sY++ZwcfbZZ5/dvHXr1isnT55scVz+rFmz8urr6xc4Ls22bZZIJExd181oNGr09PREDx06dPmFF144Ho/HTVGIjiE4guECoyl1LYTPcppGEAghDAAikUjixRdfbHnppZfKfD6fa82aNfMOHz7cHgwGbwBwr1ix4u677rqrgsfU4I4dO66lCPZTXSkqpOaMa60e7mjuosw0RmYoWHf3SLT3NOKt91+CbsZBeOlDCcX5luP4rw9fw4wSH+4p9cMlU3xtpAfLJmej/vIR7PnjLyDRwXeKhoxubokWAOYkDXxTLE5brB11oTZMCrWoNQgymJwZhsHC4bAZjUaNaDRqxGIx3VnxeDzJky8TQGLHjh3n9u3bd6ytrS3U2dkZ6e3tjfX398cHBgYS8XjcIIQQr9frKioq8ldWVhb88Ic/vHfbtm3zAXhs25aHUx7uEt1COeXEXM3JfAWLvWnSxRhLbNu2rampqSlMCME3vvGNyXPmzKkCUFZeXn776tWr72WMwbZtvPDCCx+5XK6wo6BcOdhwQ4Chuu/KR39onDGS9T80u9ivkgiqD/0UbT2NcKvelMaEhXfrqlGaPwEPT5qH0lwvqopcaOtpxPb3/gmGmYBEFRBC0HUlfp67tQQALxMKYsaYU+tlcSadNN8NIOO+++4bnZ2d7Q+Hw+zIkSNJxtiQ9TQ1NUW3bNnSmJWVlZBlWaeUWs5SVTUxYsSIRF1dXScAwzTN2MMPP7w3Pz//ZFVVVUFubq7L6/VKmqZRl8ulKIriVlVVmz59ev6cOXMCLpeLLliwYDyAOpGm08SglA659mQy6eHTrwiPtRYXbi6vP2/yjI61AoDL5Ur09vZ2bt++/ezGjRvvppSSjRs3Lti9e/fvnnzyyfHjx48fyRjDwYMHL9TW1jYWFhZ6xfIs3UhUTlPQRwGE9Gv/c/ba9YGi2rPv0FONf/iUUB3Lj8SDqD60GYtmdGBcYSVOnL+K39b9Gp19zVDkwZzBSpLY9Qv9Z3lKHgOgmaYZd9zg1KlTS994441L3G3lcD6oo/1btmxZFwgEctrb27vWrFlzwLIs2cmKW1pa4q+//vp1AbchdIKiPGZHAJDFixcHpk+ffnsoFNLefvvt3ra2Nl0YSDhdt4zy8vLwsWPHsl0ul6ooigSACuEZXKBJwzAMxhhUVZW8Xm8uH5hQ3mCwOf95VVVVYx03yQVhUEpNQbBxADfefPPN6NKlS8dUVlYWVlZW5r344osz1q1bV8IYQzAYjFVXV5+IxWIdkiTlpfDCUgcC6Sw2CqBvw4ZN+7/9d+Wzo1avT5HU9N1tMpj4dfU14z/efxletx9xPYpIPAhVccO2bVBKcf189I/h3mSLkBi5b9y40RWLxZJer9f12GOPTa6oqMjq6enpJYQYlFLGyx21tLQ0MGnSpDGEECQSCZMQIjuNCF6aqI8++mheVlZWJrdYkzcoLEVREj6fL1FfX39x165dzfPnzy/7/ve/v1LXdWvlypVde/bsuRKLxQyn1LEsS2aMeebNm1fs8/lkxhgsy7IAJBRF0Yc2TZZ1AANNTU0djoJt2rRpzqxZs/K6urq6JUnSCSHMMAxZ07SsxYsXV1JKCWMMAwMDMQBhVVWTjtU6gr1y5Yq1d+/ej8aNG5eraZr6zDPPjPV4PBJjDLW1ted27dr1MYCYqqpDcpMkyRIaEyydxToxNgagr7e3t+XEe0rNxPkjnvhTznNr4Sb0KBL6YO9BovJQnRXptTqaPgr9wTLsDgAhTkOurq4+unz58vs1TRvl9/vVuXPnljHGxgqxw2GcEjLYJLlw4cKV06dPd06bNo04+MePH+/ftm3bNNG1iW5KVVVl//79ew4cONC8d+/ey88884ysKIp85513jpo8eXJh2pHX4EUIITh58uRFAN1utzvHcb0ejycGoKuurk5vbW29u7i4ODB69OisJ5988i4xxDhsKIoiEUJgmqZ94MCBOgBdmqaVODxrmhbhiaP+4x//+N2lS5dOmjBhwhiPxyMBQFdXV191dfX7tm23AdBdLtdQzFYUxWmb3iRcmqbh7vQfOz9+v/PdjvP6kcHuE288MJZWuM4Smw1mgkQvHw/v6Wga+BjADY53AEDfmTNnLq9du/Znp06datB13RA3ROwGmaZphcPhgX379v326aefftO27Tafz9fJGGOmadqMMSbLMpEkiaZbjDFommYQQsK1tbWNr7zyymvhcLifEIJbwRBCmGVZ1vHjxz9atGjRLwA0Z2dndzpdHb/fHwTQcuLEiYann3761fPnz3+i67pBCCGUUkoIofwjpZQS27ZZd3f3ja1bt1Zv3LhxL4CrmZmZPYQQkxCCjIyMEIB2AG0Amrdv3/6beDweNwzD1nXdPHXq1Indu3cf48+7MjIyupw98ng8EW4wCWH4kHbQLgsnJ4oAlN332Ji1hbeps6lEaLohQLrhQCJi9zcei77TcLh9H4CrALp4rLN5LBvBE4scAP6JEyfmBQIBL6VUopSCMcYGBgYSly5dCvX19YW5QkQAmD6fz3PvvfeWxmIxr2EYHqFXPBRrKKWWJEmG1+uNtbW1dTU0NNzgz7wA/OXl5bkFBQV+XsYQwVpZMpk0jh8/3snpRQCYo0aN8k6YMCHX5XLRa9euBRsaGnr4Jnp458c7ceLEbK/X6xL5MQzDbGhoCNq2HeO4YgBYWVmZv6KiIkdVVbS0tHQ3NDR0CsORrDlz5oyllHoYY3p9ff31cDjczeGhaVrGkiVLSg3DkLu7u/s+/PDDFn4UKeJYLhnmAJvGs9QCAKOnLMhfNHqSNl/LlHOpTORbWa4et2ORXqv1wgf9NVfO9B7nTYcuPvlICq02t9CJ8ggjOJomodOF0ZQtHNvxCC08pBnbmcIhO53jdA7mpXaKUkOSWGoxYaaKlIa7IozT0uET+XDGehDGhhBGb6bTmBHezeb8OyNPCPQk/ptzeHConCSfcZDNI1hWQXaBVl5254hZmSPVce4MKUdxEQ+VJMnUbcNIWJFoyOzoa02eOX2k+yg/79TFNWkgZchOUobe4vA63WzUEmpYsa+dCoM0Izgz5aQkTUOPpGvUpKFJBaUR8Q03cLdT8NkppyEgPGOCYcnCiNASsn2SwrstDA2Gxnbkc5xSdHGrcmaBWYoqZ+YUe4pcXuqXJCobupWIhaze3vZohzAfdOaKN2mSwPxwR0ZSZ6uptZoIN9yxFCYIiqV5v3THStgwNNPhvtXxFgzDP9K8q52Cj6ZRNnaLffoUDfI5zhVLgrvxCN0Ux5URYXYYF84Wf2qqf4uDV591ZuiLHir7c8F+mZOU5M+Iazg8n3mYjnxORkV3I6dxg6KrMQW3Yaexlq+uv8D1v2IL+t4z3B/NAAAAAElFTkSuQmCC", E = function (e, t) {
            if ("undefined" == typeof e)throw new u("container is required.");
            e = x(e), t = o(t, {});
            var a = document.createElement("div");
            a.className = "cesium-widget", e.appendChild(a);
            var s = document.createElement("canvas");
            s.oncontextmenu = function () {
                return!1
            }, s.onselectstart = function () {
                return!1
            }, a.appendChild(s);
            var d = document.createElement("div");
            d.className = "cesium-widget-credits", a.appendChild(d);
            var b = new y(s, t.contextOptions, d);
            b.getCamera().controller.constrainedAxis = n.UNIT_Z;
            var E = l.WGS84, A = b.getFrameState().creditDisplay, M = new m("Cesium", T, "http://cesium.agi.com/");
            A.addDefaultCredit(M);
            var D = new p(E);
            b.getPrimitives().setCentralBody(D), b.skyBox = new w({positiveX: S("px"), negativeX: S("mx"), positiveY: S("py"), negativeY: S("my"), positiveZ: S("pz"), negativeZ: S("mz")}), b.skyAtmosphere = new _(E), b.sun = new C;
            var I = t.imageryProvider;
            "undefined" == typeof I && (I = new h({url: "http://dev.virtualearth.net", proxy: c.supportsCrossOriginImagery() ? void 0 : new r("http://cesium.agi.com/proxy/")})), I !== !1 && D.getImageryLayers().addImageryProvider(I), "undefined" != typeof t.terrainProvider && (D.terrainProvider = t.terrainProvider), this._element = a, this._container = e, this._canvas = s, this._canvasWidth = s.width, this._canvasHeight = s.height, this._scene = b, this._centralBody = D, this._clock = o(t.clock, new i), this._transitioner = new g(b, E), this._screenSpaceEventHandler = new f(s), this._useDefaultRenderLoop = void 0, this._renderLoopRunning = !1, this._creditContainer = d, this._canRender = !1, t.sceneMode && (t.sceneMode === v.SCENE2D && this._transitioner.to2D(), t.sceneMode === v.COLUMBUS_VIEW && this._transitioner.toColumbusView()), this.useDefaultRenderLoop = o(t.useDefaultRenderLoop, !0)
        };
        return a(E.prototype, {container: {get: function () {
            return this._container
        }}, sceneTransitioner: {get: function () {
            return this._transitioner
        }}, canvas: {get: function () {
            return this._canvas
        }}, creditContainer: {get: function () {
            return this._creditContainer
        }}, scene: {get: function () {
            return this._scene
        }}, centralBody: {get: function () {
            return this._centralBody
        }}, clock: {get: function () {
            return this._clock
        }}, screenSpaceEventHandler: {get: function () {
            return this._screenSpaceEventHandler
        }}, onRenderLoopError: {get: function () {
            return this._onRenderLoopError
        }}, useDefaultRenderLoop: {get: function () {
            return this._useDefaultRenderLoop
        }, set: function (e) {
            this._useDefaultRenderLoop !== e && (this._useDefaultRenderLoop = e, e && !this._renderLoopRunning && b(this))
        }}}), E.prototype.isDestroyed = function () {
            return!1
        }, E.prototype.destroy = function () {
            this._container.removeChild(this._element), s(this)
        }, E.prototype.resize = function () {
            var e = this._canvas, t = e.clientWidth, n = e.clientHeight;
            if (this._canvasWidth !== t || this._canvasHeight !== n) {
                e.width = this._canvasWidth = t, e.height = this._canvasHeight = n;
                var i = 0 !== t && 0 !== n;
                if (this._canRender = i, i) {
                    var r = this._scene.getCamera().frustum;
                    "undefined" != typeof r.aspectRatio ? r.aspectRatio = t / n : (r.top = r.right * (n / t), r.bottom = -r.top)
                }
            }
        }, E.prototype.render = function () {
            this._scene.initializeFrame();
            var e = this._clock.tick();
            this._canRender && this._scene.render(e)
        }, E
    }), n("Widgets/ClockViewModel", ["../Core/Clock", "../Core/defaultValue", "../Core/defineProperties", "../Core/destroyObject", "../Core/EventHelper", "../Core/JulianDate", "../ThirdParty/knockout"], function (e, t, n, i, r, o, a) {
        "use strict";
        var s = function (n) {
            n = t(n, new e), this._clock = n, this._eventHelper = new r, this._eventHelper.add(n.onTick, this.synchronize, this);
            var i = a.observable(n.startTime);
            i.equalityComparer = o.equals, this.systemTime = a.observable(new o), this.systemTime.equalityComparer = o.equals, a.track(this, ["systemTime"]), this.startTime = void 0, a.defineProperty(this, "startTime", {get: i, set: function (e) {
                i(e), n.startTime = e
            }});
            var s = a.observable(n.stopTime);
            s.equalityComparer = o.equals, this.stopTime = void 0, a.defineProperty(this, "stopTime", {get: s, set: function (e) {
                n.stopTime = e, s(e)
            }});
            var u = a.observable(n.currentTime);
            u.equalityComparer = o.equals, this.currentTime = void 0, a.defineProperty(this, "currentTime", {get: u, set: function (e) {
                n.currentTime = e, u(e)
            }});
            var l = a.observable(n.multiplier);
            this.multiplier = void 0, a.defineProperty(this, "multiplier", {get: l, set: function (e) {
                n.multiplier = e, l(e)
            }});
            var c = a.observable(n.clockStep);
            c.equalityComparer = function (e, t) {
                return e === t
            }, this.clockStep = void 0, a.defineProperty(this, "clockStep", {get: c, set: function (e) {
                c(e), n.clockStep = e
            }});
            var d = a.observable(n.clockRange);
            d.equalityComparer = function (e, t) {
                return e === t
            }, this.clockRange = void 0, a.defineProperty(this, "clockRange", {get: d, set: function (e) {
                d(e), n.clockRange = e
            }});
            var f = a.observable(n.shouldAnimate);
            this.shouldAnimate = void 0, a.defineProperty(this, "shouldAnimate", {get: f, set: function (e) {
                f(e), n.shouldAnimate = e
            }})
        };
        return n(s.prototype, {clock: {get: function () {
            return this._clock
        }}}), s.prototype.synchronize = function () {
            var e = this._clock, t = e.startTime, n = e.stopTime, i = e.currentTime, r = e.multiplier, a = e.clockStep, s = e.clockRange, u = e.shouldAnimate;
            this.systemTime = new o, this.startTime = t, this.stopTime = n, this.currentTime = i, this.multiplier = r, this.clockStep = a, this.clockRange = s, this.shouldAnimate = u
        }, s.prototype.isDestroyed = function () {
            return!1
        }, s.prototype.destroy = function () {
            this._eventHelper.removeAll(), i(this)
        }, s
    }), n("Widgets/Command", ["../Core/DeveloperError"], function (e) {
        "use strict";
        var t = function () {
            throw this.canExecute = void 0, this.beforeExecute = void 0, this.afterExecute = void 0, new e("This type should not be instantiated directly.")
        };
        return t
    }), n("Widgets/FullscreenButton/FullscreenButtonViewModel", ["../../Core/defaultValue", "../../Core/defineProperties", "../../Core/destroyObject", "../../Core/DeveloperError", "../../Core/Fullscreen", "../createCommand", "../../ThirdParty/knockout"], function (e, t, n, i, r, o, a) {
        "use strict";
        var s = function (t) {
            var n = this, i = a.observable(r.isFullscreen()), s = a.observable(r.isFullscreenEnabled());
            this.isFullscreen = void 0, a.defineProperty(this, "isFullscreen", {get: function () {
                return i()
            }}), this.isFullscreenEnabled = void 0, a.defineProperty(this, "isFullscreenEnabled", {get: function () {
                return s()
            }, set: function (e) {
                s(e && r.isFullscreenEnabled())
            }}), this.tooltip = void 0, a.defineProperty(this, "tooltip", function () {
                return this.isFullscreenEnabled ? i() ? "Exit full screen" : "Full screen" : "Full screen unavailable"
            }), this._command = o(function () {
                r.isFullscreen() ? r.exitFullscreen() : r.requestFullscreen(n._fullscreenElement)
            }, a.getObservable(this, "isFullscreenEnabled")), this._fullscreenElement = e(t, document.body), this._callback = function () {
                i(r.isFullscreen())
            }, document.addEventListener(r.getFullscreenChangeEventName(), this._callback)
        };
        return t(s.prototype, {fullscreenElement: {get: function () {
            return this._fullscreenElement
        }, set: function (e) {
            if (!(e instanceof Element))throw new i("value must be a valid Element.");
            this._fullscreenElement = e
        }}, command: {get: function () {
            return this._command
        }}}), s.prototype.isDestroyed = function () {
            return!1
        }, s.prototype.destroy = function () {
            document.removeEventListener(r.getFullscreenChangeEventName(), this._callback), n(this)
        }, s
    }), n("Widgets/FullscreenButton/FullscreenButton", ["../../Core/defineProperties", "../../Core/DeveloperError", "../../Core/destroyObject", "../getElement", "./FullscreenButtonViewModel", "../../ThirdParty/knockout"], function (e, t, n, i, r, o) {
        "use strict";
        var a = function (e, n) {
            if ("undefined" == typeof e)throw new t("container is required.");
            e = i(e), this._container = e, this._viewModel = new r(n), this._element = document.createElement("button"), this._element.className = "cesium-fullscreenButton", this._element.setAttribute("data-bind", 'attr: { title: tooltip }, css: { "cesium-fullscreenButton-exit": isFullscreen }, click: command, enable: isFullscreenEnabled'), e.appendChild(this._element), o.applyBindings(this._viewModel, this._element)
        };
        return e(a.prototype, {container: {get: function () {
            return this._container
        }}, viewModel: {get: function () {
            return this._viewModel
        }}}), a.prototype.isDestroyed = function () {
            return!1
        }, a.prototype.destroy = function () {
            var e = this._container;
            return o.cleanNode(e), this._viewModel.destroy(), e.removeChild(this._element), n(this)
        }, a
    }), n("Widgets/HomeButton/HomeButtonViewModel", ["../../Core/Cartesian3", "../../Core/defaultValue", "../../Core/defineProperties", "../../Core/DeveloperError", "../../Core/Ellipsoid", "../../Core/Extent", "../../Core/Math", "../../Core/Matrix4", "../../Scene/Camera", "../../Scene/CameraColumbusViewMode", "../../Scene/CameraFlightPath", "../../Scene/PerspectiveFrustum", "../../Scene/SceneMode", "../createCommand", "../../ThirdParty/knockout"], function (e, t, n, i, r, o, a, s, u, l, c, d, f, h, p) {
        "use strict";
        function m(t, n, i, r) {
            function a() {
                p.enableLook = m, p.enableRotate = y, p.enableTilt = v, p.enableTranslate = g, p.enableZoom = _
            }

            var d = t.mode, h = t.getCamera();
            h.controller.constrainedAxis = e.UNIT_Z;
            var p = t.getScreenSpaceCameraController(), m = p.enableLook, y = p.enableRotate, v = p.enableTilt, g = p.enableTranslate, _ = p.enableZoom;
            p.enableLook = !1, p.enableRotate = !1, p.enableTilt = !1, p.enableTranslate = !1, p.enableZoom = !1, p.setEllipsoid(n), p.columbusViewMode = l.FREE;
            var w = t.getCanvas();
            "undefined" != typeof i && d === f.MORPHING && i.completeMorph();
            var C, x;
            if (d === f.SCENE2D)h.transform = new s(0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1), x = {destination: o.MAX_VALUE, duration: r, onComplete: a}, C = c.createAnimationExtent(t.getFrameState(), x), t.getAnimations().add(C); else if (d === f.SCENE3D) {
                e.add(h.position, s.getTranslation(h.transform), h.position);
                var S = s.getRotation(h.transform);
                S.multiplyByVector(h.direction, h.direction), S.multiplyByVector(h.up, h.up), S.multiplyByVector(h.right, h.right), h.transform = s.IDENTITY.clone();
                var b = new u(w);
                x = {destination: b.position, duration: r, up: b.up, direction: b.direction, onComplete: a}, C = c.createAnimation(t.getFrameState(), x), t.getAnimations().add(C)
            } else if (d === f.COLUMBUS_VIEW) {
                h.transform = new s(0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1);
                var T = n.getMaximumRadius(), E = new e(0, -1, 1).normalize().multiplyByScalar(5 * T), A = e.ZERO.subtract(E).normalize(), M = A.cross(e.UNIT_Z), D = M.cross(A);
                x = {destination: E, duration: r, up: D, direction: A, onComplete: a}, C = c.createAnimation(t.getFrameState(), x), t.getAnimations().add(C)
            }
        }

        var y = function (e, n, o, a) {
            if ("undefined" == typeof e)throw new i("scene is required.");
            o = t(o, r.WGS84), a = t(a, 1500), this._scene = e, this._ellipsoid = o, this._transitioner = n, this._flightDuration = a;
            var s = this;
            this._command = h(function () {
                m(s._scene, s._ellipsoid, s._transitioner, s._flightDuration)
            }), this.tooltip = "View Home", p.track(this, ["tooltip"])
        };
        return n(y.prototype, {sceneTransitioner: {get: function () {
            return this._transitioner
        }}, scene: {get: function () {
            return this._scene
        }}, ellipsoid: {get: function () {
            return this._ellipsoid
        }}, command: {get: function () {
            return this._command
        }}, flightDuration: {get: function () {
            return this._flightDuration
        }, set: function (e) {
            if (0 > e)throw new i("value must be positive.");
            this._flightDuration = e
        }}}), y
    }), n("Widgets/HomeButton/HomeButton", ["../../Core/defineProperties", "../../Core/destroyObject", "../../Core/DeveloperError", "../getElement", "./HomeButtonViewModel", "../../ThirdParty/knockout"], function (e, t, n, i, r, o) {
        "use strict";
        var a = function (e, t, a, s, u) {
            if ("undefined" == typeof e)throw new n("container is required.");
            e = i(e), this._container = e, this._viewModel = new r(t, a, s, u), this._element = document.createElement("span"), this._element.className = "cesium-homeButton", this._element.setAttribute("data-bind", "attr: { title: tooltip }, click: command"), e.appendChild(this._element), o.applyBindings(this._viewModel, this._element)
        };
        return e(a.prototype, {container: {get: function () {
            return this._container
        }}, viewModel: {get: function () {
            return this._viewModel
        }}}), a.prototype.isDestroyed = function () {
            return!1
        }, a.prototype.destroy = function () {
            var e = this._container;
            return o.cleanNode(e), e.removeChild(this._element), t(this)
        }, a
    }), n("Widgets/Observable", ["../Core/DeveloperError"], function (e) {
        "use strict";
        var t = function () {
            throw new e("This type should not be instantiated directly.")
        };
        return t
    }), n("Widgets/SceneModePicker/SceneModePickerViewModel", ["../../Core/defineProperties", "../../Core/destroyObject", "../../Core/DeveloperError", "../../Core/EventHelper", "../../Scene/SceneMode", "../createCommand", "../../ThirdParty/knockout"], function (e, t, n, i, r, o, a) {
        "use strict";
        var s = function (e) {
            if ("undefined" == typeof e)throw new n("transitioner is required.");
            this._transitioner = e;
            var t = this, s = function (e, n, i) {
                t.sceneMode = i, t.dropDownVisible = !1
            };
            this._eventHelper = new i, this._eventHelper.add(e.onTransitionStart, s), this.sceneMode = e.getScene().mode, this.dropDownVisible = !1, this.tooltip2D = "2D", this.tooltip3D = "3D", this.tooltipColumbusView = "Columbus View", a.track(this, ["sceneMode", "dropDownVisible", "tooltip2D", "tooltip3D", "tooltipColumbusView"]), this.selectedTooltip = void 0, a.defineProperty(this, "selectedTooltip", function () {
                var e = t.sceneMode;
                return e === r.SCENE2D ? t.tooltip2D : e === r.SCENE3D ? t.tooltip3D : t.tooltipColumbusView
            }), this._toggleDropDown = o(function () {
                t.dropDownVisible = !t.dropDownVisible
            }), this._morphTo2D = o(function () {
                e.morphTo2D()
            }), this._morphTo3D = o(function () {
                e.morphTo3D()
            }), this._morphToColumbusView = o(function () {
                e.morphToColumbusView()
            }), this._sceneMode = r
        };
        return e(s.prototype, {sceneTransitioner: {get: function () {
            return this._transitioner
        }}, toggleDropDown: {get: function () {
            return this._toggleDropDown
        }}, morphTo2D: {get: function () {
            return this._morphTo2D
        }}, morphTo3D: {get: function () {
            return this._morphTo3D
        }}, morphToColumbusView: {get: function () {
            return this._morphToColumbusView
        }}}), s.prototype.isDestroyed = function () {
            return!1
        }, s.prototype.destroy = function () {
            this._eventHelper.removeAll(), t(this)
        }, s
    }), n("Widgets/SceneModePicker/SceneModePicker", ["../../Core/defineProperties", "../../Core/destroyObject", "../../Core/DeveloperError", "../getElement", "./SceneModePickerViewModel", "../../ThirdParty/knockout"], function (e, t, n, i, r, o) {
        "use strict";
        var a = function (e, t) {
            if ("undefined" == typeof e)throw new n("container is required.");
            if ("undefined" == typeof t)throw new n("transitioner is required.");
            e = i(e);
            var a = new r(t);
            this._viewModel = a, this._container = e, this._element = document.createElement("span");
            var s = this._element;
            s.className = "cesium-sceneModePicker-button", s.setAttribute("data-bind", '                                 css: { "cesium-sceneModePicker-button2D": sceneMode === _sceneMode.SCENE2D,                                        "cesium-sceneModePicker-button3D": sceneMode === _sceneMode.SCENE3D,                                        "cesium-sceneModePicker-buttonColumbusView": sceneMode === _sceneMode.COLUMBUS_VIEW,                                        "cesium-sceneModePicker-selected": dropDownVisible},                                 attr: { title: selectedTooltip }, click: toggleDropDown'), e.appendChild(s);
            var u = document.createElement("span");
            u.className = "cesium-sceneModePicker-button cesium-sceneModePicker-button3D", u.setAttribute("data-bind", '                             css: { "cesium-sceneModePicker-visible" : (dropDownVisible && (sceneMode !== _sceneMode.SCENE3D)) || (!dropDownVisible && (sceneMode === _sceneMode.SCENE3D)),                                    "cesium-sceneModePicker-none" : sceneMode === _sceneMode.SCENE3D,                                    "cesium-sceneModePicker-hidden" : !dropDownVisible},                             attr: { title: tooltip3D },                             click: morphTo3D'), e.appendChild(u), this._node3D = u;
            var l = document.createElement("span");
            l.className = "cesium-sceneModePicker-button cesium-sceneModePicker-button2D", l.setAttribute("data-bind", '                             css: { "cesium-sceneModePicker-visible" : (dropDownVisible && (sceneMode !== _sceneMode.SCENE2D)),                                    "cesium-sceneModePicker-none" : sceneMode === _sceneMode.SCENE2D,                                    "cesium-sceneModePicker-hidden" : !dropDownVisible},                             attr: { title: tooltip2D },                             click: morphTo2D'), e.appendChild(l), this._node2D = l;
            var c = document.createElement("span");
            c.className = "cesium-sceneModePicker-button cesium-sceneModePicker-buttonColumbusView", c.setAttribute("data-bind", '                                   css: { "cesium-sceneModePicker-visible" : (dropDownVisible && (sceneMode !== _sceneMode.COLUMBUS_VIEW)) || (!dropDownVisible && (sceneMode === _sceneMode.COLUMBUS_VIEW)),                                          "cesium-sceneModePicker-none" : sceneMode === _sceneMode.COLUMBUS_VIEW,                                          "cesium-sceneModePicker-hidden" : !dropDownVisible},                                   attr: { title: tooltipColumbusView },                                   click: morphToColumbusView'), e.appendChild(c), this._nodeColumbus = c, o.applyBindings(a, e), this._closeDropDown = function (t) {
                e.contains(t.target) || (a.dropDownVisible = !1)
            }, document.addEventListener("mousedown", this._closeDropDown, !0), document.addEventListener("touchstart", this._closeDropDown, !0)
        };
        return e(a.prototype, {container: {get: function () {
            return this._container
        }}, viewModel: {get: function () {
            return this._viewModel
        }}}), a.prototype.isDestroyed = function () {
            return!1
        }, a.prototype.destroy = function () {
            this._viewModel.destroy(), document.removeEventListener("mousedown", this._closeDropDown, !0), document.removeEventListener("touchstart", this._closeDropDown, !0);
            var e = this._container;
            return o.cleanNode(e), e.removeChild(this._element), e.removeChild(this._node3D), e.removeChild(this._node2D), e.removeChild(this._nodeColumbus), t(this)
        }, a
    }), n("Widgets/Timeline/TimelineTrack", ["../../Core/Color"], function (e) {
        "use strict";
        function t(t, n, i, r) {
            this.interval = t, this.height = n, this.color = i || new e(.5, .5, .5, 1), this.backgroundColor = r || new e(0, 0, 0, 0)
        }

        return t.prototype.render = function (e, t) {
            var n = this.interval.start, i = this.interval.stop, r = t.startJulian, o = t.startJulian.addSeconds(t.duration);
            if (n.lessThan(r) && i.greaterThan(o))e.fillStyle = this.color.toCssColorString(), e.fillRect(0, t.y, t.timeBarWidth, this.height); else if (n.lessThanOrEquals(o) && i.greaterThanOrEquals(r)) {
                var a, s, u;
                for (a = 0; a < t.timeBarWidth; ++a) {
                    var l = t.startJulian.addSeconds(a / t.timeBarWidth * t.duration);
                    "undefined" == typeof s && l.greaterThanOrEquals(n) ? s = a : "undefined" == typeof u && l.greaterThanOrEquals(i) && (u = a)
                }
                e.fillStyle = this.backgroundColor.toCssColorString(), e.fillRect(0, t.y, t.timeBarWidth, this.height), "undefined" != typeof s && ("undefined" == typeof u && (u = t.timeBarWidth), e.fillStyle = this.color.toCssColorString(), e.fillRect(s, t.y, Math.max(u - s, 1), this.height))
            }
        }, t
    }), n("Widgets/Timeline/TimelineHighlightRange", [], function () {
        "use strict";
        function e(e, t) {
            this._color = e, this._height = t
        }

        return e.prototype.getHeight = function () {
            return this._height
        }, e.prototype.getStartTime = function () {
            return this._start
        }, e.prototype.getStopTime = function () {
            return this._stop
        }, e.prototype.setRange = function (e, t) {
            this._start = e, this._stop = t
        }, e.prototype.render = function (e) {
            var t = "";
            if (this._start && this._stop && this._color) {
                var n = e.epochJulian.getSecondsDifference(this._start), i = Math.round(e.timeBarWidth * e.getAlpha(n)), r = e.epochJulian.getSecondsDifference(this._stop), o = Math.round(e.timeBarWidth * e.getAlpha(r)) - i;
                0 > i && (o += i, i = 0), i + o > e.timeBarWidth && (o = e.timeBarWidth - i), o > 0 && (t = '<span class="cesium-timeline-highlight" style="left: ' + i.toString() + "px; width: " + o.toString() + "px; bottom: " + e.y.toString() + "px; height: " + this._height + "px; background-color: " + this._color + ';"></span>')
            }
            return e.y += this._height, t
        }, e
    }), n("Widgets/Timeline/Timeline", ["../../Core/DeveloperError", "../../Core/ClockRange", "../../Core/destroyObject", "../../Core/JulianDate", "../getElement", "./TimelineTrack", "./TimelineHighlightRange"], function (e, t, n, i, r, o, a) {
        "use strict";
        function s(t, n) {
            if ("undefined" == typeof t)throw new e("container is required.");
            if ("undefined" == typeof n)throw new e("clock is required.");
            t = r(t), this.container = t;
            var i = document.createElement("div");
            i.className = "cesium-timeline-main", t.appendChild(i), this._topDiv = i, this._endJulian = void 0, this._epochJulian = void 0, this._lastXPos = void 0, this._scrubElement = void 0, this._startJulian = void 0, this._timeBarSecondsSpan = void 0, this._clock = n, this._scrubJulian = n.currentTime, this._mainTicSpan = -1, this._mouseMode = v.none, this._touchMode = g.none, this._touchState = {centerX: 0, spanX: 0}, this._mouseX = 0, this._timelineDrag = 0, this._timelineDragLocation = void 0, this._lastHeight = void 0, this._lastWidth = void 0, this._topDiv.innerHTML = '<div class="cesium-timeline-bar"></div><div class="cesium-timeline-trackContainer"><canvas class="cesium-timeline-tracks" width="10" height="1"></canvas></div><div class="cesium-timeline-needle"></div><span class="cesium-timeline-ruler"></span>', this._timeBarEle = this._topDiv.childNodes[0], this._trackContainer = this._topDiv.childNodes[1], this._trackListEle = this._topDiv.childNodes[1].childNodes[0], this._needleEle = this._topDiv.childNodes[2], this._rulerEle = this._topDiv.childNodes[3], this._context = this._trackListEle.getContext("2d"), this._trackList = [], this._highlightRanges = [], this.zoomTo(n.startTime, n.stopTime), this._onMouseDown = l(this), this._onMouseUp = c(this), this._onMouseMove = d(this), this._onMouseWheel = f(this), this._onTouchStart = h(this), this._onTouchMove = m(this), this._onTouchEnd = p(this);
            var o = this._timeBarEle;
            document.addEventListener("mouseup", this._onMouseUp, !1), document.addEventListener("mousemove", this._onMouseMove, !1), o.addEventListener("mousedown", this._onMouseDown, !1), o.addEventListener("DOMMouseScroll", this._onMouseWheel, !1), o.addEventListener("mousewheel", this._onMouseWheel, !1), o.addEventListener("touchstart", this._onTouchStart, !1), o.addEventListener("touchmove", this._onTouchMove, !1), o.addEventListener("touchend", this._onTouchEnd, !1), this._topDiv.oncontextmenu = function () {
                return!1
            }, n.onTick.addEventListener(this.updateFromClock, this), this.updateFromClock()
        }

        function u(e) {
            return 10 > e ? "0" + e.toString() : e.toString()
        }

        function l(e) {
            return function (t) {
                e._mouseMode !== v.touchOnly && (0 === t.button ? (e._mouseMode = v.scrub, e._scrubElement && (e._scrubElement.style.backgroundPosition = "-16px 0"), e._onMouseMove(t)) : (e._mouseX = t.clientX, e._mouseMode = 2 === t.button ? v.zoom : v.slide)), t.preventDefault()
            }
        }

        function c(e) {
            return function () {
                e._mouseMode = v.none, e._scrubElement && (e._scrubElement.style.backgroundPosition = "0px 0px"), e._timelineDrag = 0, e._timelineDragLocation = void 0
            }
        }

        function d(e) {
            return function (t) {
                var n;
                if (e._mouseMode === v.scrub) {
                    t.preventDefault();
                    var i = t.clientX - e._topDiv.getBoundingClientRect().left;
                    0 > i ? (e._timelineDragLocation = 0, e._timelineDrag = -.01 * e._timeBarSecondsSpan) : i > e._topDiv.clientWidth ? (e._timelineDragLocation = e._topDiv.clientWidth, e._timelineDrag = .01 * e._timeBarSecondsSpan) : (e._timelineDragLocation = void 0, e._setTimeBarTime(i, i * e._timeBarSecondsSpan / e._topDiv.clientWidth))
                } else if (e._mouseMode === v.slide) {
                    if (n = e._mouseX - t.clientX, e._mouseX = t.clientX, 0 !== n) {
                        var r = n * e._timeBarSecondsSpan / e._topDiv.clientWidth;
                        e.zoomTo(e._startJulian.addSeconds(r), e._endJulian.addSeconds(r))
                    }
                } else e._mouseMode === v.zoom && (n = e._mouseX - t.clientX, e._mouseX = t.clientX, 0 !== n && e.zoomFrom(Math.pow(1.01, n)))
            }
        }

        function f(e) {
            return function (t) {
                var n = t.wheelDeltaY || t.wheelDelta || -t.detail;
                y = Math.max(Math.min(Math.abs(n), y), 1), n /= y, e.zoomFrom(Math.pow(1.05, -n))
            }
        }

        function h(e) {
            return function (t) {
                var n, i, r = t.touches.length, o = e._topDiv.getBoundingClientRect().left;
                t.preventDefault(), e._mouseMode = v.touchOnly, 1 === r ? (n = e._startJulian.getSecondsDifference(e._scrubJulian), i = Math.round(n * e._topDiv.clientWidth / e._timeBarSecondsSpan + o), Math.abs(t.touches[0].clientX - i) < 50 ? (e._touchMode = g.scrub, e._scrubElement && (e._scrubElement.style.backgroundPosition = 1 === r ? "-16px 0" : "0 0")) : (e._touchMode = g.singleTap, e._touchState.centerX = t.touches[0].clientX - o)) : 2 === r ? (e._touchMode = g.slideZoom, e._touchState.centerX = .5 * (t.touches[0].clientX + t.touches[1].clientX) - o, e._touchState.spanX = Math.abs(t.touches[0].clientX - t.touches[1].clientX)) : e._touchMode = g.ignore
            }
        }

        function p(e) {
            return function (t) {
                var n = t.touches.length, i = e._topDiv.getBoundingClientRect().left;
                e._touchMode === g.singleTap ? (e._touchMode = g.scrub, e._handleTouchMove(t)) : e._touchMode === g.scrub && e._handleTouchMove(t), e._mouseMode = v.touchOnly, 1 !== n ? e._touchMode = n > 0 ? g.ignore : g.none : e._touchMode === g.slideZoom && (e._touchState.centerX = t.touches[0].clientX - i), e._scrubElement && (e._scrubElement.style.backgroundPosition = "0 0")
            }
        }

        function m(e) {
            return function (t) {
                var n, i, r, o, a, s, u = 1, l = e._topDiv.getBoundingClientRect().left;
                e._touchMode === g.singleTap && (e._touchMode = g.slideZoom), e._mouseMode = v.touchOnly, e._touchMode === g.scrub ? (t.preventDefault(), 1 === t.changedTouches.length && (i = t.changedTouches[0].clientX - l, i >= 0 && i <= e._topDiv.clientWidth && e._setTimeBarTime(i, i * e._timeBarSecondsSpan / e._topDiv.clientWidth))) : e._touchMode === g.slideZoom && (r = t.touches.length, 2 === r ? (o = .5 * (t.touches[0].clientX + t.touches[1].clientX) - l, a = Math.abs(t.touches[0].clientX - t.touches[1].clientX)) : 1 === r && (o = t.touches[0].clientX - l, a = 0), "undefined" != typeof o && (a > 0 && e._touchState.spanX > 0 ? (u = e._touchState.spanX / a, s = e._startJulian.addSeconds((e._touchState.centerX * e._timeBarSecondsSpan - o * e._timeBarSecondsSpan * u) / e._topDiv.clientWidth)) : (n = e._touchState.centerX - o, s = e._startJulian.addSeconds(n * e._timeBarSecondsSpan / e._topDiv.clientWidth)), e.zoomTo(s, s.addSeconds(e._timeBarSecondsSpan * u)), e._touchState.centerX = o, e._touchState.spanX = a))
            }
        }

        var y = 1e12, v = {none: 0, scrub: 1, slide: 2, zoom: 3, touchOnly: 4}, g = {none: 0, scrub: 1, slideZoom: 2, singleTap: 3, ignore: 4}, _ = [.001, .002, .005, .01, .02, .05, .1, .25, .5, 1, 2, 5, 10, 15, 30, 60, 120, 300, 600, 900, 1800, 3600, 7200, 14400, 21600, 43200, 86400, 172800, 345600, 604800, 1296e3, 2592e3, 5184e3, 7776e3, 15552e3, 31536e3, 63072e3, 126144e3, 15768e4, 31536e4, 63072e4, 126144e4, 15768e5, 31536e5, 63072e5, 126144e5, 15768e6, 31536e6], w = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        return s.prototype.addEventListener = function (e, t, n) {
            this._topDiv.addEventListener(e, t, n)
        }, s.prototype.removeEventListener = function (e, t, n) {
            this._topDiv.removeEventListener(e, t, n)
        }, s.prototype.isDestroyed = function () {
            return!1
        }, s.prototype.destroy = function () {
            this._clock.onTick.removeEventListener(this.updateFromClock, this), document.removeEventListener("mouseup", this._onMouseUp, !1), document.removeEventListener("mousemove", this._onMouseMove, !1);
            var e = this._timeBarEle;
            e.removeEventListener("mousedown", this._onMouseDown, !1), e.removeEventListener("DOMMouseScroll", this._onMouseWheel, !1), e.removeEventListener("mousewheel", this._onMouseWheel, !1), e.removeEventListener("touchstart", this._onTouchStart, !1), e.removeEventListener("touchmove", this._onTouchMove, !1), e.removeEventListener("touchend", this._onTouchEnd, !1), this.container.removeChild(this._topDiv), n(this)
        }, s.prototype.addHighlightRange = function (e, t) {
            var n = new a(e, t);
            return this._highlightRanges.push(n), this.resize(), n
        }, s.prototype.addTrack = function (e, t, n, i) {
            var r = new o(e, t, n, i);
            return this._trackList.push(r), this.resize(), r
        }, s.prototype.zoomTo = function (n, i) {
            if (this._timeBarSecondsSpan = n.getSecondsDifference(i), this._timeBarSecondsSpan <= 0)throw new e("Start time must come before end time.");
            if (this._startJulian = n, this._endJulian = i, this._clock && this._clock.clockRange !== t.UNBOUNDED) {
                var r = this._clock.startTime, o = this._clock.stopTime, a = r.getSecondsDifference(o), s = this._startJulian.getSecondsDifference(r), u = this._endJulian.getSecondsDifference(o);
                this._timeBarSecondsSpan >= a ? (this._timeBarSecondsSpan = a, this._startJulian = this._clock.startTime, this._endJulian = this._clock.stopTime) : s > 0 ? (this._endJulian = this._endJulian.addSeconds(s), this._startJulian = r, this._timeBarSecondsSpan = this._startJulian.getSecondsDifference(this._endJulian)) : 0 > u && (this._startJulian = this._startJulian.addSeconds(u), this._endJulian = o, this._timeBarSecondsSpan = this._startJulian.getSecondsDifference(this._endJulian))
            }
            this._makeTics();
            var l = document.createEvent("Event");
            l.initEvent("setzoom", !0, !0), l.startJulian = this._startJulian, l.endJulian = this._endJulian, l.epochJulian = this._epochJulian, l.totalSpan = this._timeBarSecondsSpan, l.mainTicSpan = this._mainTicSpan, this._topDiv.dispatchEvent(l)
        }, s.prototype.zoomFrom = function (e) {
            var t = this._startJulian.getSecondsDifference(this._scrubJulian);
            e > 1 || 0 > t || t > this._timeBarSecondsSpan ? t = .5 * this._timeBarSecondsSpan : t += t - .5 * this._timeBarSecondsSpan;
            var n = this._timeBarSecondsSpan - t;
            this.zoomTo(this._startJulian.addSeconds(t - t * e), this._endJulian.addSeconds(n * e - n))
        }, s.prototype.makeLabel = function (e) {
            var t = e.toGregorianDate(), n = t.millisecond, i = " UTC";
            if (n > 0 && this._timeBarSecondsSpan < 3600) {
                for (i = Math.floor(n).toString(); i.length < 3;)i = "0" + i;
                i = "." + i
            }
            return w[t.month - 1] + " " + t.day + " " + t.year + " " + u(t.hour) + ":" + u(t.minute) + ":" + u(t.second) + i
        }, s.prototype.smallestTicInPixels = 7, s.prototype._makeTics = function () {
            function e(e) {
                return Math.floor(x / e) * e
            }

            function t(e, t) {
                return Math.ceil(e / t + .5) * t
            }

            function n(e) {
                return(e - x) / y
            }

            function r(e, t) {
                return e - t * Math.round(e / t)
            }

            var o, a = this._timeBarEle, s = this._startJulian.getSecondsDifference(this._scrubJulian), u = Math.round(s * this._topDiv.clientWidth / this._timeBarSecondsSpan), l = u - 8, c = this;
            this._needleEle.style.left = u.toString() + "px";
            var d = '<span class="cesium-timeline-icon16" style="left:' + l + 'px;bottom:0;background-position: 0px 0px;"></span>', f = .01, h = 31536e6, p = 1e-10, m = 0, y = this._timeBarSecondsSpan;
            f > y ? (y = f, this._timeBarSecondsSpan = f, this._endJulian = this._startJulian.addSeconds(f)) : y > h && (y = h, this._timeBarSecondsSpan = h, this._endJulian = this._startJulian.addSeconds(h));
            var v = this._timeBarEle.clientWidth;
            10 > v && (v = 10);
            var g, w = this._startJulian, C = Math.min(1e-5 * (y / v), .4);
            g = y > 31536e4 ? i.fromIso8601(w.toDate().toISOString().substring(0, 2) + "00-01-01T00:00:00Z") : y > 31536e3 ? i.fromIso8601(w.toDate().toISOString().substring(0, 3) + "0-01-01T00:00:00Z") : y > 86400 ? i.fromIso8601(w.toDate().toISOString().substring(0, 4) + "-01-01T00:00:00Z") : i.fromIso8601(w.toDate().toISOString().substring(0, 10) + "T00:00:00Z");
            var x = g.addSeconds(C).getSecondsDifference(this._startJulian), S = x + y;
            this._epochJulian = g, this._rulerEle.innerHTML = this.makeLabel(this._endJulian.addSeconds(-f));
            var b = this._rulerEle.offsetWidth + 20, T = m;
            m -= p;
            var E = {y: 0, startTime: x, startJulian: w, epochJulian: g, duration: y, timeBarWidth: v, getAlpha: n};
            this._highlightRanges.forEach(function (e) {
                d += e.render(E)
            });
            var A = 0, M = 0, D = 0, I = b / v;
            I > 1 && (I = 1), I *= this._timeBarSecondsSpan;
            var P, O = -1, R = -1, z = _.length;
            for (P = 0; z > P; ++P) {
                var L = _[P];
                if (++O, A = L, L > I && L > m)break;
                0 > R && v * (L / this._timeBarSecondsSpan) >= this.smallestTicInPixels && (R = O)
            }
            if (O > 0) {
                for (; O > 0;)if (--O, Math.abs(r(A, _[O])) < 1e-5) {
                    _[O] >= m && (M = _[O]);
                    break
                }
                if (R >= 0)for (; O > R;) {
                    if (Math.abs(r(M, _[R])) < 1e-5 && _[R] >= m) {
                        D = _[R];
                        break
                    }
                    ++R
                }
            }
            m = T, m > p && 1e-5 > D && Math.abs(m - A) > p && (D = m, A + p >= m && (M = 0));
            var N, F = -999999;
            if (v * (D / this._timeBarSecondsSpan) >= 3)for (o = e(D); S >= o; o = t(o, D))d += '<span class="cesium-timeline-ticTiny" style="left: ' + Math.round(v * n(o)).toString() + 'px;"></span>';
            if (v * (M / this._timeBarSecondsSpan) >= 3)for (o = e(M); S >= o; o = t(o, M))d += '<span class="cesium-timeline-ticSub" style="left: ' + Math.round(v * n(o)).toString() + 'px;"></span>';
            if (v * (A / this._timeBarSecondsSpan) >= 2) {
                this._mainTicSpan = A, S += A, o = e(A);
                for (var V = g.getTaiMinusUtc(); S >= o;) {
                    var B = w.addSeconds(o - x);
                    if (A > 2.1) {
                        var k = B.getTaiMinusUtc();
                        Math.abs(k - V) > .1 && (o += k - V, B = w.addSeconds(o - x))
                    }
                    var U = Math.round(v * n(o)), q = this.makeLabel(B);
                    this._rulerEle.innerHTML = q, N = this._rulerEle.offsetWidth;
                    var W = U - (N / 2 - 1);
                    W > F ? (F = W + N + 5, d += '<span class="cesium-timeline-ticMain" style="left: ' + U.toString() + 'px;"></span>' + '<span class="cesium-timeline-ticLabel" style="left: ' + W.toString() + 'px;">' + q + "</span>") : d += '<span class="cesium-timeline-ticSub" style="left: ' + U.toString() + 'px;"></span>', o = t(o, A)
                }
            } else this._mainTicSpan = -1;
            a.innerHTML = d, this._scrubElement = a.childNodes[0], E.y = 0, this._trackList.forEach(function (e) {
                e.render(c._context, E), E.y += e.height
            })
        }, s.prototype.updateFromClock = function () {
            this._scrubJulian = this._clock.currentTime;
            var e = this._scrubElement;
            if ("undefined" != typeof this._scrubElement) {
                var t = this._startJulian.getSecondsDifference(this._scrubJulian), n = Math.round(t * this._topDiv.clientWidth / this._timeBarSecondsSpan);
                this._lastXPos !== n && (this._lastXPos = n, e.style.left = n - 8 + "px", this._needleEle.style.left = n + "px")
            }
            "undefined" != typeof this._timelineDragLocation && (this._setTimeBarTime(this._timelineDragLocation, this._timelineDragLocation * this._timeBarSecondsSpan / this._topDiv.clientWidth), this.zoomTo(this._startJulian.addSeconds(this._timelineDrag), this._endJulian.addSeconds(this._timelineDrag)))
        }, s.prototype._setTimeBarTime = function (e, t) {
            if (e = Math.round(e), this._scrubJulian = this._startJulian.addSeconds(t), this._scrubElement) {
                var n = e - 8;
                this._scrubElement.style.left = n.toString() + "px", this._needleEle.style.left = e.toString() + "px"
            }
            var i = document.createEvent("Event");
            i.initEvent("settime", !0, !0), i.clientX = e, i.timeSeconds = t, i.timeJulian = this._scrubJulian, i.clock = this._clock, this._topDiv.dispatchEvent(i)
        }, s.prototype.resize = function () {
            var e = this.container.clientWidth, t = this.container.clientHeight;
            if (e !== this._lastWidth || t !== this._lastHeight) {
                this._trackContainer.style.height = t + "px";
                var n = 1;
                this._trackList.forEach(function (e) {
                    n += e.height
                }), this._trackListEle.style.height = n.toString() + "px", this._trackListEle.width = this._trackListEle.clientWidth, this._trackListEle.height = n, this._makeTics(), this._lastWidth = e, this._lastHeight = t
            }
        }, s
    }), n("Widgets/Viewer/Viewer", ["../../Core/Cartesian2", "../../Core/defaultValue", "../../Core/DeveloperError", "../../Core/defineProperties", "../../Core/destroyObject", "../../Core/Event", "../../Core/EventHelper", "../../Core/requestAnimationFrame", "../../Core/ScreenSpaceEventType", "../../DynamicScene/DataSourceDisplay", "../Animation/Animation", "../Animation/AnimationViewModel", "../BaseLayerPicker/BaseLayerPicker", "../BaseLayerPicker/createDefaultBaseLayers", "../CesiumWidget/CesiumWidget", "../ClockViewModel", "../FullscreenButton/FullscreenButton", "../getElement", "../HomeButton/HomeButton", "../SceneModePicker/SceneModePicker", "../Timeline/Timeline", "../../ThirdParty/knockout"], function (e, t, n, i, r, o, a, s, u, l, c, d, f, h, p, m, y, v, g, _, w, C) {
        "use strict";
        function x(e) {
            var t = e.clock;
            t.currentTime = e.timeJulian, t.shouldAnimate = !1
        }

        function S(e) {
            function t() {
                try {
                    e._useDefaultRenderLoop ? (e.resize(), e.render(), s(t)) : e._renderLoopRunning = !1
                } catch (n) {
                    e._useDefaultRenderLoop = !1, e._renderLoopRunning = !1, e.onRenderLoopError.raiseEvent(e, n)
                }
            }

            e._renderLoopRunning = !0, s(t)
        }

        var b = function (e, i) {
            function r(e) {
                T.update(e.currentTime)
            }

            if ("undefined" == typeof e)throw new n("container is required.");
            e = v(e), i = t(i, t.EMPTY_OBJECT);
            var s = "undefined" == typeof i.baseLayerPicker || i.baseLayerPicker !== !1;
            if (s && "undefined" != typeof i.imageryProvider)throw new n("options.imageryProvider is not available when using the BaseLayerPicker widget. Either specify options.selectedImageryProviderViewModel instead or set options.baseLayerPicker to false.");
            if (!s && "undefined" != typeof i.selectedImageryProviderViewModel)throw new n("options.selectedImageryProviderViewModel is not available when not using the BaseLayerPicker widget. Either specify options.imageryProvider instead or set options.baseLayerPicker to true.");
            var u = document.createElement("div");
            u.className = "cesium-viewer", e.appendChild(u);
            var S = document.createElement("div");
            S.className = "cesium-viewer-cesiumWidgetContainer", u.appendChild(S);
            var b = new p(S, {terrainProvider: i.terrainProvider, imageryProvider: s ? !1 : i.imageryProvider, sceneMode: i.sceneMode, contextOptions: i.contextOptions, useDefaultRenderLoop: !1}), T = new l(b.scene);
            this._dataSourceDisplay = T;
            var E = b.clock;
            this._eventHelper = new a, this._eventHelper.add(E.onTick, r), this._clockViewModel = new m(E);
            var A = document.createElement("div");
            A.className = "cesium-viewer-toolbar", u.appendChild(A);
            var M;
            if ("undefined" == typeof i.homeButton || i.homeButton !== !1) {
                var D = document.createElement("div");
                D.className = "cesium-viewer-homeButtonContainer", A.appendChild(D), M = new g(D, b.scene, b.sceneTransitioner, b.centralBody.getEllipsoid())
            }
            var I;
            if ("undefined" == typeof i.sceneModePicker || i.sceneModePicker !== !1) {
                var P = document.createElement("div");
                P.className = "cesium-viewer-sceneModePickerContainer", A.appendChild(P), I = new _(P, b.sceneTransitioner)
            }
            var O;
            if (s) {
                var R = document.createElement("div");
                R.className = "cesium-viewer-baseLayerPickerContainer", A.appendChild(R);
                var z = t(i.imageryProviderViewModels, h());
                O = new f(R, b.centralBody.getImageryLayers(), z), O.viewModel.selectedItem = t(i.selectedImageryProviderViewModel, z[0]);
                var L = R.getElementsByClassName("cesium-baseLayerPicker-dropDown");
                this._baseLayerPickerDropDown = L[0]
            }
            var N;
            if ("undefined" == typeof i.animation || i.animation !== !1) {
                var F = document.createElement("div");
                F.className = "cesium-viewer-animationContainer", u.appendChild(F), N = new c(F, new d(this._clockViewModel))
            }
            var V;
            if ("undefined" == typeof i.timeline || i.timeline !== !1) {
                var B = document.createElement("div");
                B.className = "cesium-viewer-timelineContainer", u.appendChild(B), V = new w(B, E), V.addEventListener("settime", x, !1), V.zoomTo(E.startTime, E.stopTime)
            }
            var k;
            if ("undefined" == typeof i.fullscreenButton || i.fullscreenButton !== !1) {
                var U = document.createElement("div");
                U.className = "cesium-viewer-fullscreenContainer", u.appendChild(U), k = new y(U, t(i.fullscreenElement, e));
                var q = function (e) {
                    U.style.display = e ? "block" : "none", "undefined" != typeof V && (V.container.style.right = U.clientWidth + "px", V.resize())
                };
                this._fullscreenSubscription = C.getObservable(k.viewModel, "isFullscreenEnabled").subscribe(q), q(k.viewModel.isFullscreenEnabled)
            } else"undefined" != typeof V && (V.container.style.right = 0);
            this._container = e, this._viewerContainer = u, this._cesiumWidget = b, this._toolbar = A, this._homeButton = M, this._sceneModePicker = I, this._baseLayerPicker = O, this._animation = N, this._timeline = V, this._fullscreenButton = k, this._lastWidth = 0, this._lastHeight = 0, this._useDefaultRenderLoop = void 0, this._renderLoopRunning = !1, this._onRenderLoopError = new o, this.useDefaultRenderLoop = t(i.useDefaultRenderLoop, !0)
        };
        return i(b.prototype, {container: {get: function () {
            return this._container
        }}, cesiumWidget: {get: function () {
            return this._cesiumWidget
        }}, homeButton: {get: function () {
            return this._homeButton
        }}, sceneModePicker: {get: function () {
            return this._sceneModePicker
        }}, baseLayerPicker: {get: function () {
            return this._baseLayerPicker
        }}, animation: {get: function () {
            return this._animation
        }}, timeline: {get: function () {
            return this._timeline
        }}, fullscreenButton: {get: function () {
            return this._fullscreenButton
        }}, dataSourceDisplay: {get: function () {
            return this._dataSourceDisplay
        }}, dataSources: {get: function () {
            return this._dataSourceDisplay.getDataSources()
        }}, canvas: {get: function () {
            return this._cesiumWidget.canvas
        }}, cesiumLogo: {get: function () {
            return this._cesiumWidget.cesiumLogo
        }}, scene: {get: function () {
            return this._cesiumWidget.scene
        }}, centralBody: {get: function () {
            return this._cesiumWidget.centralBody
        }}, clock: {get: function () {
            return this._cesiumWidget.clock
        }}, sceneTransitioner: {get: function () {
            return this._cesiumWidget.sceneTransitioner
        }}, screenSpaceEventHandler: {get: function () {
            return this._cesiumWidget.screenSpaceEventHandler
        }}, onRenderLoopError: {get: function () {
            return this._onRenderLoopError
        }}, useDefaultRenderLoop: {get: function () {
            return this._useDefaultRenderLoop
        }, set: function (e) {
            this._useDefaultRenderLoop !== e && (this._useDefaultRenderLoop = e, e && !this._renderLoopRunning && S(this))
        }}}), b.prototype.extend = function (e, t) {
            if ("undefined" == typeof e)throw new n("mixin is required.");
            e(this, t)
        }, b.prototype.resize = function () {
            var e = this._cesiumWidget;
            e.resize();
            var t = this._container, n = t.clientWidth, i = t.clientHeight;
            if (n !== this._lastWidth || i !== this._lastHeight) {
                var r = this._baseLayerPickerDropDown;
                if ("undefined" != typeof r) {
                    var o = i - 125;
                    r.style.maxHeight = o + "px"
                }
                var a, s = "undefined" != typeof this._timeline, u = "undefined" != typeof this._animation, l = !u, c = 0;
                if (u) {
                    var d = this._lastWidth;
                    a = this._animation.container, n > 900 ? 900 >= d && (c = 169, a.style.width = "169px", a.style.height = "112px", l = !0, this._animation.resize()) : n >= 600 ? (600 > d || d > 900) && (c = 136, a.style.width = "136px", a.style.height = "90px", l = !0, this._animation.resize()) : (d > 600 || 0 === d) && (c = 106, a.style.width = "106px", a.style.height = "70px", l = !0, this._animation.resize())
                }
                if (l) {
                    var f = 0, h = c + 5;
                    if (s && (f = this._timeline.container.clientHeight + 3, this._timeline.container.style.left = c + "px"), s || u) {
                        var p = e.creditContainer;
                        p.style.bottom = f + "px", p.style.left = h + "px"
                    }
                }
                s && this._timeline.resize(), this._lastWidth = n, this._lastHeight = i
            }
        }, b.prototype.render = function () {
            this._cesiumWidget.render()
        }, b.prototype.isDestroyed = function () {
            return!1
        }, b.prototype.destroy = function () {
            return this._container.removeChild(this._viewerContainer), this._viewerContainer.removeChild(this._toolbar), this._eventHelper.removeAll(), "undefined" != typeof this._homeButton && (this._homeButton = this._homeButton.destroy()), "undefined" != typeof this._sceneModePicker && (this._sceneModePicker = this._sceneModePicker.destroy()), "undefined" != typeof this._baseLayerPicker && (this._baseLayerPicker = this._baseLayerPicker.destroy()), "undefined" != typeof this._animation && (this._viewerContainer.removeChild(this._animation.container), this._animation = this._animation.destroy()), "undefined" != typeof this._timeline && (this._timeline.removeEventListener("settime", x, !1), this._viewerContainer.removeChild(this._timeline.container), this._timeline = this._timeline.destroy()), "undefined" != typeof this._fullscreenButton && (this._fullscreenSubscription.dispose(), this._viewerContainer.removeChild(this._fullscreenButton.container), this._fullscreenButton = this._fullscreenButton.destroy()), this._clockViewModel = this._clockViewModel.destroy(), this._dataSourceDisplay = this._dataSourceDisplay.destroy(), this._cesiumWidget = this._cesiumWidget.destroy(), r(this)
        }, b
    }), n("Widgets/Viewer/viewerDragDropMixin", ["../../Core/defaultValue", "../../Core/DeveloperError", "../../Core/defineProperties", "../../Core/Event", "../../Core/wrapFunction", "../../DynamicScene/CzmlDataSource", "../../DynamicScene/GeoJsonDataSource", "../../ThirdParty/when", "../getElement"], function (e, t, n, i, r, o, a, s, u) {
        "use strict";
        function l(e) {
            e.stopPropagation(), e.preventDefault()
        }

        function c(e, t) {
            var n = e;
            "undefined" != typeof n && (n.removeEventListener("drop", t, !1), n.removeEventListener("dragenter", l, !1), n.removeEventListener("dragover", l, !1), n.removeEventListener("dragexit", l, !1))
        }

        function d(e, t) {
            e.addEventListener("drop", t, !1), e.addEventListener("dragenter", l, !1), e.addEventListener("dragover", l, !1), e.addEventListener("dragexit", l, !1)
        }

        function f(e, t) {
            var n = e.length, i = t.length;
            return n > i && -1 !== e.indexOf(t, n - i)
        }

        function h(e, t, n) {
            var i, r = t.toUpperCase();
            return f(r, ".CZML") ? i = o : f(r, ".GEOJSON") || f(r, ".JSON") || f(r, ".TOPOJSON") ? i = a : e.onDropError.raiseEvent(e, t, "Unrecognized file extension: " + t), function (r) {
                var o = new i;
                try {
                    s(o.load(JSON.parse(r.target.result), t), function () {
                        if (e.dataSources.add(o), n) {
                            var t = o.getClock();
                            "undefined" != typeof t && (t.clone(e.clock), "undefined" != typeof e.timeline && (e.timeline.updateFromClock(), e.timeline.zoomTo(t.startTime, t.stopTime)))
                        }
                    }, function (n) {
                        e.onDropError.raiseEvent(e, t, n)
                    })
                } catch (a) {
                    e.onDropError.raiseEvent(e, t, a)
                }
            }
        }

        function p(e, t) {
            return function (n) {
                e.onDropError.raiseEvent(e, t, n.target.error)
            }
        }

        var m = function (o, a) {
            function s(e) {
                l(e), y && o.dataSources.removeAll();
                for (var t = e.dataTransfer.files, n = t.length, i = 0; n > i; i++) {
                    var r = t[i], a = new FileReader;
                    a.onload = h(o, r.name, 0 === i), a.onerror = p(o, r.name), a.readAsText(r)
                }
            }

            if ("undefined" == typeof o)throw new t("viewer is required.");
            if (o.hasOwnProperty("dropTarget"))throw new t("dropTarget is already defined by another mixin.");
            if (o.hasOwnProperty("dropEnabled"))throw new t("dropEnabled is already defined by another mixin.");
            if (o.hasOwnProperty("onDropError"))throw new t("onDropError is already defined by another mixin.");
            if (o.hasOwnProperty("clearOnDrop"))throw new t("clearOnDrop is already defined by another mixin.");
            a = e(a, e.EMPTY_OBJECT);
            var f = !0, m = new i, y = e(a.clearOnDrop, !0), v = e(a.dropTarget, o.container);
            v = u(v), n(o, {dropTarget: {get: function () {
                return v
            }, set: function (e) {
                if ("undefined" == typeof e)throw new t("value is required.");
                c(v, s), v = e, d(v, s)
            }}, dropEnabled: {get: function () {
                return f
            }, set: function (e) {
                e !== f && (e ? d(v, s) : c(v, s), f = e)
            }}, onDropError: {get: function () {
                return m
            }}, clearOnDrop: {get: function () {
                return y
            }, set: function (e) {
                y = e
            }}}), d(v, s), o.destroy = r(o, o.destroy, function () {
                o.dropEnabled = !1
            }), o._handleDrop = s
        };
        return m
    }), n("Widgets/Viewer/viewerDynamicObjectMixin", ["../../Core/defaultValue", "../../Core/DeveloperError", "../../Core/defineProperties", "../../Core/EventHelper", "../../Core/ScreenSpaceEventType", "../../Core/wrapFunction", "../../Scene/SceneMode", "../../DynamicScene/DynamicObjectView"], function (e, t, n, i, r, o, a, s) {
        "use strict";
        var u = function (e) {
            function u(e) {
                "undefined" != typeof f && f.update(e.currentTime)
            }

            function l(t) {
                var n = e.scene.pick(t.position);
                "undefined" != typeof n && "undefined" != typeof n.dynamicObject && "undefined" != typeof n.dynamicObject.position && (e.trackedObject = n.dynamicObject)
            }

            function c() {
                e.trackedObject = void 0
            }

            if ("undefined" == typeof e)throw new t("viewer is required.");
            if (e.hasOwnProperty("trackedObject"))throw new t("trackedObject is already defined by another mixin.");
            var d, f, h = new i;
            h.add(e.clock.onTick, u), "undefined" != typeof e.homeButton && h.add(e.homeButton.viewModel.command.beforeExecute, c), e.screenSpaceEventHandler.setInputAction(l, r.LEFT_CLICK), n(e, {trackedObject: {get: function () {
                return d
            }, set: function (t) {
                d !== t && (d = t, f = "undefined" != typeof t ? new s(t, e.scene, e.centralBody.getEllipsoid()) : void 0);
                var n = e.scene.getFrameState().mode;
                (n === a.COLUMBUS_VIEW || n === a.SCENE2D) && (e.scene.getScreenSpaceCameraController().enableTranslate = "undefined" == typeof t), (n === a.COLUMBUS_VIEW || n === a.SCENE3D) && (e.scene.getScreenSpaceCameraController().enableTilt = "undefined" == typeof t)
            }}}), e.destroy = o(e, e.destroy, function () {
                h.removeAll(), e.screenSpaceEventHandler.removeInputAction(r.LEFT_CLICK)
            })
        };
        return u
    }), n("Widgets/checkForChromeFrame", ["../Core/FeatureDetection", "./getElement", "../ThirdParty/when"], function (e, t, n) {
        "use strict";
        function i(e) {
            e = t(e);
            var n = document.createElement("div");
            n.className = "cesium-widget-chromeFrameOverlay";
            var i = document.createElement("div");
            n.appendChild(i), i.innerHTML = 'Cesium requires WebGL, an open standard for displaying 3D content in a web browser. To enable WebGL in Internet Explorer, we recommend installing <a href="https://developers.google.com/chrome/chrome-frame/" target="_blank">Google Chrome Frame</a>, a free, unobtrusive plug-in offered by Google. To learn more about WebGL, visit <a href="http://www.khronos.org/webgl/" target="_blank">http://www.khronos.org/webgl/</a>.<p>Would you like to install Chrome Frame now?</p>';
            var r = document.createElement("p");
            i.appendChild(r);
            var o = document.createElement("a");
            o.href = "#", o.innerHTML = "Yes, install Google Chrome Frame", o.onclick = function () {
                window.CFInstall.check({mode: "overlay", destination: document.URL}), e.removeChild(n)
            }, r.appendChild(o), r = document.createElement("p"), i.appendChild(r);
            var a = document.createElement("a");
            a.href = "#", a.innerHTML = "No, not at this time", a.onclick = function () {
                e.removeChild(n)
            }, r.appendChild(a), e.appendChild(n)
        }

        var r = function (t) {
            var r = n.defer();
            if (e.isInternetExplorer()) {
                var o = document.createElement("script");
                o.type = "text/javascript", o.src = "//ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js";
                var a = document.getElementsByTagName("head")[0];
                a.appendChild(o);
                var s = setInterval(function () {
                    if (window.CFInstall) {
                        clearInterval(s);
                        var e = !1;
                        window.CFInstall.check({mode: "overlay", preventPrompt: !0, onmissing: function () {
                            e = !0
                        }}), e && i(t), r.resolve(e)
                    }
                }, 50)
            } else r.resolve(!1);
            return r.promise
        };
        return r
    }), n("Cesium", ["./Core/AxisAlignedBoundingBox", "./Core/BoundingRectangle", "./Core/BoundingSphere", "./Core/BoxGeometry", "./Core/Cartesian2", "./Core/Cartesian3", "./Core/Cartesian4", "./Core/Cartographic", "./Core/CatmullRomSpline", "./Core/CircleGeometry", "./Core/Clock", "./Core/ClockRange", "./Core/ClockStep", "./Core/Color", "./Core/ColorGeometryInstanceAttribute", "./Core/ComponentDatatype", "./Core/CubicRealPolynomial", "./Core/CylinderGeometry", "./Core/DefaultProxy", "./Core/DeveloperError", "./Core/EarthOrientationParameters", "./Core/EarthOrientationParametersSample", "./Core/EllipseGeometry", "./Core/Ellipsoid", "./Core/EllipsoidGeometry", "./Core/EllipsoidTangentPlane", "./Core/EllipsoidalOccluder", "./Core/EncodedCartesian3", "./Core/Enumeration", "./Core/Event", "./Core/EventHelper", "./Core/Extent", "./Core/ExtentGeometry", "./Core/FAR", "./Core/FeatureDetection", "./Core/Fullscreen", "./Core/GeographicProjection", "./Core/Geometry", "./Core/GeometryAttribute", "./Core/GeometryAttributes", "./Core/GeometryInstance", "./Core/GeometryInstanceAttribute", "./Core/GeometryPipeline", "./Core/HeightmapTessellator", "./Core/HermitePolynomialApproximation", "./Core/HermiteSpline", "./Core/Iau2006XysData", "./Core/Iau2006XysSample", "./Core/IndexDatatype", "./Core/Intersect", "./Core/IntersectionTests", "./Core/Interval", "./Core/Iso8601", "./Core/JulianDate", "./Core/KeyboardEventModifier", "./Core/LagrangePolynomialApproximation", "./Core/LeapSecond", "./Core/LinearApproximation", "./Core/Math", "./Core/Matrix2", "./Core/Matrix3", "./Core/Matrix4", "./Core/Occluder", "./Core/OrientationInterpolator", "./Core/Plane", "./Core/PolygonGeometry", "./Core/PolygonPipeline", "./Core/PolylinePipeline", "./Core/PrimitiveType", "./Core/QuadraticRealPolynomial", "./Core/QuarticRealPolynomial", "./Core/Quaternion", "./Core/Queue", "./Core/Ray", "./Core/ReferenceFrame", "./Core/RequestErrorEvent", "./Core/RuntimeError", "./Core/ScreenSpaceEventHandler", "./Core/ScreenSpaceEventType", "./Core/Shapes", "./Core/ShowGeometryInstanceAttribute", "./Core/Simon1994PlanetaryPositions", "./Core/SimplePolylineGeometry", "./Core/SphereGeometry", "./Core/Spherical", "./Core/TaskProcessor", "./Core/TimeConstants", "./Core/TimeInterval", "./Core/TimeIntervalCollection", "./Core/TimeStandard", "./Core/Tipsify", "./Core/Transforms", "./Core/TridiagonalSystemSolver", "./Core/VertexFormat", "./Core/Visibility", "./Core/WallGeometry", "./Core/WebMercatorProjection", "./Core/WindingOrder", "./Core/barycentricCoordinates", "./Core/binarySearch", "./Core/buildModuleUrl", "./Core/cancelAnimationFrame", "./Core/clone", "./Core/combine", "./Core/createGuid", "./Core/defaultValue", "./Core/defineProperties", "./Core/defined", "./Core/destroyObject", "./Core/freezeObject", "./Core/getImagePixels", "./Core/isCrossOriginUrl", "./Core/isLeapYear", "./Core/jsonp", "./Core/loadArrayBuffer", "./Core/loadBlob", "./Core/loadImage", "./Core/loadImageViaBlob", "./Core/loadJson", "./Core/loadText", "./Core/loadWithXhr", "./Core/loadXML", "./Core/pointInsideTriangle", "./Core/requestAnimationFrame", "./Core/throttleRequestByServer", "./Core/wrapFunction", "./Core/writeTextToCanvas", "./DynamicScene/CompositeDynamicObjectCollection", "./DynamicScene/ConstantProperty", "./DynamicScene/CzmlBoolean", "./DynamicScene/CzmlCartesian2", "./DynamicScene/CzmlCartesian3", "./DynamicScene/CzmlColor", "./DynamicScene/CzmlDataSource", "./DynamicScene/CzmlDefaults", "./DynamicScene/CzmlDirection", "./DynamicScene/CzmlHorizontalOrigin", "./DynamicScene/CzmlImage", "./DynamicScene/CzmlLabelStyle", "./DynamicScene/CzmlNumber", "./DynamicScene/CzmlPosition", "./DynamicScene/CzmlString", "./DynamicScene/CzmlUnitCartesian3", "./DynamicScene/CzmlUnitQuaternion", "./DynamicScene/CzmlUnitSpherical", "./DynamicScene/CzmlVerticalOrigin", "./DynamicScene/DataSource", "./DynamicScene/DataSourceCollection", "./DynamicScene/DataSourceDisplay", "./DynamicScene/DynamicBillboard", "./DynamicScene/DynamicBillboardVisualizer", "./DynamicScene/DynamicClock", "./DynamicScene/DynamicColorMaterial", "./DynamicScene/DynamicCone", "./DynamicScene/DynamicConeVisualizerUsingCustomSensor", "./DynamicScene/DynamicDirectionsProperty", "./DynamicScene/DynamicEllipse", "./DynamicScene/DynamicEllipsoid", "./DynamicScene/DynamicEllipsoidVisualizer", "./DynamicScene/DynamicGridMaterial", "./DynamicScene/DynamicImageMaterial", "./DynamicScene/DynamicLabel", "./DynamicScene/DynamicLabelVisualizer", "./DynamicScene/DynamicMaterialProperty", "./DynamicScene/DynamicObject", "./DynamicScene/DynamicObjectCollection", "./DynamicScene/DynamicObjectView", "./DynamicScene/DynamicPath", "./DynamicScene/DynamicPathVisualizer", "./DynamicScene/DynamicPoint", "./DynamicScene/DynamicPointVisualizer", "./DynamicScene/DynamicPolygon", "./DynamicScene/DynamicPolygonVisualizer", "./DynamicScene/DynamicPolyline", "./DynamicScene/DynamicPolylineVisualizer", "./DynamicScene/DynamicPositionProperty", "./DynamicScene/DynamicProperty", "./DynamicScene/DynamicPyramid", "./DynamicScene/DynamicPyramidVisualizer", "./DynamicScene/DynamicVector", "./DynamicScene/DynamicVectorVisualizer", "./DynamicScene/DynamicVertexPositionsProperty", "./DynamicScene/GeoJsonDataSource", "./DynamicScene/ReferenceProperty", "./DynamicScene/VisualizerCollection", "./DynamicScene/processCzml", "./Renderer/BlendEquation", "./Renderer/BlendFunction", "./Renderer/BlendingState", "./Renderer/Buffer", "./Renderer/BufferUsage", "./Renderer/ClearCommand", "./Renderer/CommandLists", "./Renderer/Context", "./Renderer/CubeMap", "./Renderer/CubeMapFace", "./Renderer/CullFace", "./Renderer/DepthFunction", "./Renderer/DrawCommand", "./Renderer/Framebuffer", "./Renderer/MipmapHint", "./Renderer/PassState", "./Renderer/PickFramebuffer", "./Renderer/PixelDatatype", "./Renderer/PixelFormat", "./Renderer/RenderState", "./Renderer/Renderbuffer", "./Renderer/RenderbufferFormat", "./Renderer/ShaderCache", "./Renderer/ShaderProgram", "./Renderer/StencilFunction", "./Renderer/StencilOperation", "./Renderer/Texture", "./Renderer/TextureAtlas", "./Renderer/TextureAtlasBuilder", "./Renderer/TextureMagnificationFilter", "./Renderer/TextureMinificationFilter", "./Renderer/TextureWrap", "./Renderer/UniformDatatype", "./Renderer/UniformState", "./Renderer/VertexArray", "./Renderer/VertexArrayFacade", "./Renderer/VertexLayout", "./Renderer/createPickFragmentShaderSource", "./Renderer/loadCubeMap", "./Scene/AnimationCollection", "./Scene/Appearance", "./Scene/ArcGisImageServerTerrainProvider", "./Scene/ArcGisMapServerImageryProvider", "./Scene/Billboard", "./Scene/BillboardCollection", "./Scene/BingMapsImageryProvider", "./Scene/BingMapsStyle", "./Scene/Camera", "./Scene/CameraColumbusViewMode", "./Scene/CameraController", "./Scene/CameraEventAggregator", "./Scene/CameraEventType", "./Scene/CameraFlightPath", "./Scene/CentralBody", "./Scene/CentralBodySurface", "./Scene/CentralBodySurfaceShaderSet", "./Scene/CesiumTerrainProvider", "./Scene/CompositePrimitive", "./Scene/Credit", "./Scene/CreditDisplay", "./Scene/CullingVolume", "./Scene/CustomSensorVolume", "./Scene/DebugAppearance", "./Scene/DiscardMissingTileImagePolicy", "./Scene/EllipsoidPrimitive", "./Scene/EllipsoidSurfaceAppearance", "./Scene/EllipsoidTerrainProvider", "./Scene/ExtentPrimitive", "./Scene/FrameState", "./Scene/FrustumCommands", "./Scene/GeographicTilingScheme", "./Scene/GridImageryProvider", "./Scene/HeightmapTerrainData", "./Scene/HorizontalOrigin", "./Scene/Imagery", "./Scene/ImageryLayer", "./Scene/ImageryLayerCollection", "./Scene/ImageryProvider", "./Scene/ImageryState", "./Scene/Label", "./Scene/LabelCollection", "./Scene/LabelStyle", "./Scene/Material", "./Scene/MaterialAppearance", "./Scene/NeverTileDiscardPolicy", "./Scene/OpenStreetMapImageryProvider", "./Scene/OrthographicFrustum", "./Scene/PerInstanceColorAppearance", "./Scene/PerformanceDisplay", "./Scene/PerspectiveFrustum", "./Scene/PerspectiveOffCenterFrustum", "./Scene/Polygon", "./Scene/Polyline", "./Scene/PolylineCollection", "./Scene/Primitive", "./Scene/RectangularPyramidSensorVolume", "./Scene/Scene", "./Scene/SceneMode", "./Scene/SceneTransforms", "./Scene/SceneTransitioner", "./Scene/ScreenSpaceCameraController", "./Scene/SensorVolumeCollection", "./Scene/SingleTileImageryProvider", "./Scene/SkyAtmosphere", "./Scene/SkyBox", "./Scene/Sun", "./Scene/SunPostProcess", "./Scene/TerrainData", "./Scene/TerrainMesh", "./Scene/TerrainProvider", "./Scene/TerrainState", "./Scene/TexturePool", "./Scene/Tile", "./Scene/TileCoordinatesImageryProvider", "./Scene/TileDiscardPolicy", "./Scene/TileImagery", "./Scene/TileMapServiceImageryProvider", "./Scene/TileProviderError", "./Scene/TileReplacementQueue", "./Scene/TileState", "./Scene/TileTerrain", "./Scene/TilingScheme", "./Scene/VRTheWorldTerrainProvider", "./Scene/VerticalOrigin", "./Scene/ViewportQuad", "./Scene/WebMapServiceImageryProvider", "./Scene/WebMercatorTilingScheme", "./Scene/createTangentSpaceDebugPrimitive", "./Scene/sampleTerrain", "./Shaders/Appearances/AllMaterialAppearanceFS", "./Shaders/Appearances/AllMaterialAppearanceVS", "./Shaders/Appearances/BasicMaterialAppearanceFS", "./Shaders/Appearances/BasicMaterialAppearanceVS", "./Shaders/Appearances/EllipsoidSurfaceAppearanceFS", "./Shaders/Appearances/EllipsoidSurfaceAppearanceVS", "./Shaders/Appearances/PerInstanceColorAppearanceFS", "./Shaders/Appearances/PerInstanceColorAppearanceVS", "./Shaders/Appearances/PerInstanceFlatColorAppearanceFS", "./Shaders/Appearances/PerInstanceFlatColorAppearanceVS", "./Shaders/Appearances/TexturedMaterialAppearanceFS", "./Shaders/Appearances/TexturedMaterialAppearanceVS", "./Shaders/BillboardCollectionFS", "./Shaders/BillboardCollectionVS", "./Shaders/BuiltinFunctions", "./Shaders/CentralBodyFS", "./Shaders/CentralBodyFSDepth", "./Shaders/CentralBodyFSPole", "./Shaders/CentralBodyVS", "./Shaders/CentralBodyVSDepth", "./Shaders/CentralBodyVSPole", "./Shaders/CustomSensorVolumeFS", "./Shaders/CustomSensorVolumeVS", "./Shaders/EllipsoidFS", "./Shaders/EllipsoidVS", "./Shaders/Materials/AsphaltMaterial", "./Shaders/Materials/BlobMaterial", "./Shaders/Materials/BrickMaterial", "./Shaders/Materials/BumpMapMaterial", "./Shaders/Materials/CementMaterial", "./Shaders/Materials/CheckerboardMaterial", "./Shaders/Materials/DotMaterial", "./Shaders/Materials/ErosionMaterial", "./Shaders/Materials/FacetMaterial", "./Shaders/Materials/FadeMaterial", "./Shaders/Materials/FresnelMaterial", "./Shaders/Materials/GrassMaterial", "./Shaders/Materials/GridMaterial", "./Shaders/Materials/NormalMapMaterial", "./Shaders/Materials/PolylineArrowMaterial", "./Shaders/Materials/PolylineGlowMaterial", "./Shaders/Materials/PolylineOutlineMaterial", "./Shaders/Materials/ReflectionMaterial", "./Shaders/Materials/RefractionMaterial", "./Shaders/Materials/RimLightingMaterial", "./Shaders/Materials/StripeMaterial", "./Shaders/Materials/TieDyeMaterial", "./Shaders/Materials/Water", "./Shaders/Materials/WoodMaterial", "./Shaders/PolylineFS", "./Shaders/PolylineVS", "./Shaders/PostProcessFilters/AdditiveBlend", "./Shaders/PostProcessFilters/BrightPass", "./Shaders/PostProcessFilters/GaussianBlur1D", "./Shaders/PostProcessFilters/PassThrough", "./Shaders/ReprojectWebMercatorFS", "./Shaders/ReprojectWebMercatorVS", "./Shaders/SensorVolume", "./Shaders/SkyAtmosphereFS", "./Shaders/SkyAtmosphereVS", "./Shaders/SkyBoxFS", "./Shaders/SkyBoxVS", "./Shaders/SunFS", "./Shaders/SunVS", "./Shaders/ViewportQuadFS", "./Shaders/ViewportQuadVS", "./ThirdParty/Tween", "./ThirdParty/Uri", "./ThirdParty/knockout-2.2.1", "./ThirdParty/knockout-es5", "./ThirdParty/knockout", "./ThirdParty/measureText", "./ThirdParty/sprintf", "./ThirdParty/topojson", "./ThirdParty/weakmap", "./ThirdParty/when", "./Widgets/Animation/Animation", "./Widgets/Animation/AnimationViewModel", "./Widgets/BaseLayerPicker/BaseLayerPicker", "./Widgets/BaseLayerPicker/BaseLayerPickerViewModel", "./Widgets/BaseLayerPicker/ImageryProviderViewModel", "./Widgets/BaseLayerPicker/createDefaultBaseLayers", "./Widgets/CesiumWidget/CesiumWidget", "./Widgets/ClockViewModel", "./Widgets/Command", "./Widgets/FullscreenButton/FullscreenButton", "./Widgets/FullscreenButton/FullscreenButtonViewModel", "./Widgets/HomeButton/HomeButton", "./Widgets/HomeButton/HomeButtonViewModel", "./Widgets/Observable", "./Widgets/SceneModePicker/SceneModePicker", "./Widgets/SceneModePicker/SceneModePickerViewModel", "./Widgets/Timeline/Timeline", "./Widgets/Timeline/TimelineHighlightRange", "./Widgets/Timeline/TimelineTrack", "./Widgets/ToggleButtonViewModel", "./Widgets/Viewer/Viewer", "./Widgets/Viewer/viewerDragDropMixin", "./Widgets/Viewer/viewerDynamicObjectMixin", "./Widgets/checkForChromeFrame", "./Widgets/createCommand", "./Widgets/getElement"], function (e, t, n, i, r, o, a, s, u, l, c, d, f, h, p, m, y, v, g, _, w, C, x, S, b, T, E, A, M, D, I, P, O, R, z, L, N, F, V, B, k, U, q, W, H, G, j, Y, X, Z, K, J, Q, $, et, tt, nt, it, rt, ot, at, st, ut, lt, ct, dt, ft, ht, pt, mt, yt, vt, gt, _t, wt, Ct, xt, St, bt, Tt, Et, At, Mt, Dt, It, Pt, Ot, Rt, zt, Lt, Nt, Ft, Vt, Bt, kt, Ut, qt, Wt, Ht, Gt, jt, Yt, Xt, Zt, Kt, Jt, Qt, $t, en, tn, nn, rn, on, an, sn, un, ln, cn, dn, fn, hn, pn, mn, yn, vn, gn, _n, wn, Cn, xn, Sn, bn, Tn, En, An, Mn, Dn, In, Pn, On, Rn, zn, Ln, Nn, Fn, Vn, Bn, kn, Un, qn, Wn, Hn, Gn, jn, Yn, Xn, Zn, Kn, Jn, Qn, $n, ei, ti, ni, ii, ri, oi, ai, si, ui, li, ci, di, fi, hi, pi, mi, yi, vi, gi, _i, wi, Ci, xi, Si, bi, Ti, Ei, Ai, Mi, Di, Ii, Pi, Oi, Ri, zi, Li, Ni, Fi, Vi, Bi, ki, Ui, qi, Wi, Hi, Gi, ji, Yi, Xi, Zi, Ki, Ji, Qi, $i, er, tr, nr, ir, rr, or, ar, sr, ur, lr, cr, dr, fr, hr, pr, mr, yr, vr, gr, _r, wr, Cr, xr, Sr, br, Tr, Er, Ar, Mr, Dr, Ir, Pr, Or, Rr, zr, Lr, Nr, Fr, Vr, Br, kr, Ur, qr, Wr, Hr, Gr, jr, Yr, Xr, Zr, Kr, Jr, Qr, $r, eo, to, no, io, ro, oo, ao, so, uo, lo, co, fo, ho, po, mo, yo, vo, go, _o, wo, Co, xo, So, bo, To, Eo, Ao, Mo, Do, Io, Po, Oo, Ro, zo, Lo, No, Fo, Vo, Bo, ko, Uo, qo, Wo, Ho, Go, jo, Yo, Xo, Zo, Ko, Jo, Qo, $o, ea, ta, na, ia, ra, oa, aa, sa, ua, la, ca, da, fa, ha, pa, ma, ya, va, ga, _a, wa, Ca, xa, Sa, ba, Ta, Ea, Aa, Ma, Da, Ia, Pa, Oa, Ra, za, La, Na, Fa, Va, Ba, ka, Ua, qa, Wa, Ha, Ga, ja, Ya, Xa, Za, Ka, Ja, Qa, $a, es, ts, ns, is, rs, os, as, ss, us, ls, cs, ds, fs, hs, ps, ms, ys, vs, gs, _s, ws, Cs, xs, Ss, bs, Ts, Es, As, Ms, Ds, Is, Ps, Os, Rs, zs, Ls, Ns, Fs, Vs, Bs, ks) {
        "use strict";
        var Us = {_shaders: {}};
        return Us.AxisAlignedBoundingBox = e, Us.BoundingRectangle = t, Us.BoundingSphere = n, Us.BoxGeometry = i, Us.Cartesian2 = r, Us.Cartesian3 = o, Us.Cartesian4 = a, Us.Cartographic = s, Us.CatmullRomSpline = u, Us.CircleGeometry = l, Us.Clock = c, Us.ClockRange = d, Us.ClockStep = f, Us.Color = h, Us.ColorGeometryInstanceAttribute = p, Us.ComponentDatatype = m, Us.CubicRealPolynomial = y, Us.CylinderGeometry = v, Us.DefaultProxy = g, Us.DeveloperError = _, Us.EarthOrientationParameters = w, Us.EarthOrientationParametersSample = C, Us.EllipseGeometry = x, Us.Ellipsoid = S, Us.EllipsoidGeometry = b, Us.EllipsoidTangentPlane = T, Us.EllipsoidalOccluder = E, Us.EncodedCartesian3 = A, Us.Enumeration = M, Us.Event = D, Us.EventHelper = I, Us.Extent = P, Us.ExtentGeometry = O, Us.FAR = R, Us.FeatureDetection = z, Us.Fullscreen = L, Us.GeographicProjection = N, Us.Geometry = F, Us.GeometryAttribute = V, Us.GeometryAttributes = B, Us.GeometryInstance = k, Us.GeometryInstanceAttribute = U, Us.GeometryPipeline = q, Us.HeightmapTessellator = W, Us.HermitePolynomialApproximation = H, Us.HermiteSpline = G, Us.Iau2006XysData = j, Us.Iau2006XysSample = Y, Us.IndexDatatype = X, Us.Intersect = Z, Us.IntersectionTests = K, Us.Interval = J, Us.Iso8601 = Q, Us.JulianDate = $, Us.KeyboardEventModifier = et, Us.LagrangePolynomialApproximation = tt, Us.LeapSecond = nt, Us.LinearApproximation = it, Us.Math = rt, Us.Matrix2 = ot, Us.Matrix3 = at, Us.Matrix4 = st, Us.Occluder = ut, Us.OrientationInterpolator = lt, Us.Plane = ct, Us.PolygonGeometry = dt, Us.PolygonPipeline = ft, Us.PolylinePipeline = ht, Us.PrimitiveType = pt, Us.QuadraticRealPolynomial = mt, Us.QuarticRealPolynomial = yt, Us.Quaternion = vt, Us.Queue = gt, Us.Ray = _t, Us.ReferenceFrame = wt, Us.RequestErrorEvent = Ct, Us.RuntimeError = xt, Us.ScreenSpaceEventHandler = St, Us.ScreenSpaceEventType = bt, Us.Shapes = Tt, Us.ShowGeometryInstanceAttribute = Et, Us.Simon1994PlanetaryPositions = At, Us.SimplePolylineGeometry = Mt, Us.SphereGeometry = Dt, Us.Spherical = It, Us.TaskProcessor = Pt, Us.TimeConstants = Ot, Us.TimeInterval = Rt, Us.TimeIntervalCollection = zt, Us.TimeStandard = Lt, Us.Tipsify = Nt, Us.Transforms = Ft, Us.TridiagonalSystemSolver = Vt, Us.VertexFormat = Bt, Us.Visibility = kt, Us.WallGeometry = Ut, Us.WebMercatorProjection = qt, Us.WindingOrder = Wt, Us.barycentricCoordinates = Ht, Us.binarySearch = Gt, Us.buildModuleUrl = jt, Us.cancelAnimationFrame = Yt, Us.clone = Xt, Us.combine = Zt, Us.createGuid = Kt, Us.defaultValue = Jt, Us.defineProperties = Qt, Us.defined = $t, Us.destroyObject = en, Us.freezeObject = tn, Us.getImagePixels = nn, Us.isCrossOriginUrl = rn, Us.isLeapYear = on, Us.jsonp = an, Us.loadArrayBuffer = sn, Us.loadBlob = un, Us.loadImage = ln, Us.loadImageViaBlob = cn, Us.loadJson = dn, Us.loadText = fn, Us.loadWithXhr = hn, Us.loadXML = pn, Us.pointInsideTriangle = mn, Us.requestAnimationFrame = yn, Us.throttleRequestByServer = vn, Us.wrapFunction = gn, Us.writeTextToCanvas = _n, Us.CompositeDynamicObjectCollection = wn, Us.ConstantProperty = Cn, Us.CzmlBoolean = xn, Us.CzmlCartesian2 = Sn, Us.CzmlCartesian3 = bn, Us.CzmlColor = Tn, Us.CzmlDataSource = En, Us.CzmlDefaults = An, Us.CzmlDirection = Mn, Us.CzmlHorizontalOrigin = Dn, Us.CzmlImage = In, Us.CzmlLabelStyle = Pn, Us.CzmlNumber = On, Us.CzmlPosition = Rn, Us.CzmlString = zn, Us.CzmlUnitCartesian3 = Ln, Us.CzmlUnitQuaternion = Nn, Us.CzmlUnitSpherical = Fn, Us.CzmlVerticalOrigin = Vn, Us.DataSource = Bn, Us.DataSourceCollection = kn, Us.DataSourceDisplay = Un, Us.DynamicBillboard = qn, Us.DynamicBillboardVisualizer = Wn, Us.DynamicClock = Hn, Us.DynamicColorMaterial = Gn, Us.DynamicCone = jn, Us.DynamicConeVisualizerUsingCustomSensor = Yn, Us.DynamicDirectionsProperty = Xn, Us.DynamicEllipse = Zn, Us.DynamicEllipsoid = Kn, Us.DynamicEllipsoidVisualizer = Jn, Us.DynamicGridMaterial = Qn, Us.DynamicImageMaterial = $n, Us.DynamicLabel = ei, Us.DynamicLabelVisualizer = ti, Us.DynamicMaterialProperty = ni, Us.DynamicObject = ii, Us.DynamicObjectCollection = ri, Us.DynamicObjectView = oi, Us.DynamicPath = ai, Us.DynamicPathVisualizer = si, Us.DynamicPoint = ui, Us.DynamicPointVisualizer = li, Us.DynamicPolygon = ci, Us.DynamicPolygonVisualizer = di, Us.DynamicPolyline = fi, Us.DynamicPolylineVisualizer = hi, Us.DynamicPositionProperty = pi, Us.DynamicProperty = mi, Us.DynamicPyramid = yi, Us.DynamicPyramidVisualizer = vi, Us.DynamicVector = gi, Us.DynamicVectorVisualizer = _i, Us.DynamicVertexPositionsProperty = wi, Us.GeoJsonDataSource = Ci, Us.ReferenceProperty = xi, Us.VisualizerCollection = Si, Us.processCzml = bi, Us.BlendEquation = Ti, Us.BlendFunction = Ei, Us.BlendingState = Ai, Us.Buffer = Mi, Us.BufferUsage = Di, Us.ClearCommand = Ii, Us.CommandLists = Pi, Us.Context = Oi, Us.CubeMap = Ri, Us.CubeMapFace = zi, Us.CullFace = Li, Us.DepthFunction = Ni, Us.DrawCommand = Fi, Us.Framebuffer = Vi, Us.MipmapHint = Bi, Us.PassState = ki, Us.PickFramebuffer = Ui, Us.PixelDatatype = qi, Us.PixelFormat = Wi, Us.RenderState = Hi, Us.Renderbuffer = Gi, Us.RenderbufferFormat = ji, Us.ShaderCache = Yi, Us.ShaderProgram = Xi, Us.StencilFunction = Zi, Us.StencilOperation = Ki, Us.Texture = Ji, Us.TextureAtlas = Qi, Us.TextureAtlasBuilder = $i, Us.TextureMagnificationFilter = er, Us.TextureMinificationFilter = tr, Us.TextureWrap = nr, Us.UniformDatatype = ir, Us.UniformState = rr, Us.VertexArray = or, Us.VertexArrayFacade = ar, Us.VertexLayout = sr, Us.createPickFragmentShaderSource = ur, Us.loadCubeMap = lr, Us.AnimationCollection = cr, Us.Appearance = dr, Us.ArcGisImageServerTerrainProvider = fr, Us.ArcGisMapServerImageryProvider = hr, Us.Billboard = pr, Us.BillboardCollection = mr, Us.BingMapsImageryProvider = yr, Us.BingMapsStyle = vr, Us.Camera = gr, Us.CameraColumbusViewMode = _r, Us.CameraController = wr, Us.CameraEventAggregator = Cr, Us.CameraEventType = xr, Us.CameraFlightPath = Sr, Us.CentralBody = br, Us.CentralBodySurface = Tr, Us.CentralBodySurfaceShaderSet = Er, Us.CesiumTerrainProvider = Ar, Us.CompositePrimitive = Mr, Us.Credit = Dr, Us.CreditDisplay = Ir, Us.CullingVolume = Pr, Us.CustomSensorVolume = Or, Us.DebugAppearance = Rr, Us.DiscardMissingTileImagePolicy = zr, Us.EllipsoidPrimitive = Lr, Us.EllipsoidSurfaceAppearance = Nr, Us.EllipsoidTerrainProvider = Fr, Us.ExtentPrimitive = Vr, Us.FrameState = Br, Us.FrustumCommands = kr, Us.GeographicTilingScheme = Ur, Us.GridImageryProvider = qr, Us.HeightmapTerrainData = Wr, Us.HorizontalOrigin = Hr, Us.Imagery = Gr, Us.ImageryLayer = jr, Us.ImageryLayerCollection = Yr, Us.ImageryProvider = Xr, Us.ImageryState = Zr, Us.Label = Kr, Us.LabelCollection = Jr, Us.LabelStyle = Qr, Us.Material = $r, Us.MaterialAppearance = eo, Us.NeverTileDiscardPolicy = to, Us.OpenStreetMapImageryProvider = no, Us.OrthographicFrustum = io, Us.PerInstanceColorAppearance = ro, Us.PerformanceDisplay = oo, Us.PerspectiveFrustum = ao, Us.PerspectiveOffCenterFrustum = so, Us.Polygon = uo, Us.Polyline = lo, Us.PolylineCollection = co, Us.Primitive = fo, Us.RectangularPyramidSensorVolume = ho, Us.Scene = po, Us.SceneMode = mo, Us.SceneTransforms = yo, Us.SceneTransitioner = vo, Us.ScreenSpaceCameraController = go, Us.SensorVolumeCollection = _o, Us.SingleTileImageryProvider = wo, Us.SkyAtmosphere = Co, Us.SkyBox = xo, Us.Sun = So, Us.SunPostProcess = bo, Us.TerrainData = To, Us.TerrainMesh = Eo, Us.TerrainProvider = Ao, Us.TerrainState = Mo, Us.TexturePool = Do, Us.Tile = Io, Us.TileCoordinatesImageryProvider = Po, Us.TileDiscardPolicy = Oo, Us.TileImagery = Ro, Us.TileMapServiceImageryProvider = zo, Us.TileProviderError = Lo, Us.TileReplacementQueue = No, Us.TileState = Fo, Us.TileTerrain = Vo, Us.TilingScheme = Bo, Us.VRTheWorldTerrainProvider = ko, Us.VerticalOrigin = Uo, Us.ViewportQuad = qo, Us.WebMapServiceImageryProvider = Wo, Us.WebMercatorTilingScheme = Ho, Us.createTangentSpaceDebugPrimitive = Go, Us.sampleTerrain = jo, Us._shaders.AllMaterialAppearanceFS = Yo, Us._shaders.AllMaterialAppearanceVS = Xo, Us._shaders.BasicMaterialAppearanceFS = Zo, Us._shaders.BasicMaterialAppearanceVS = Ko, Us._shaders.EllipsoidSurfaceAppearanceFS = Jo, Us._shaders.EllipsoidSurfaceAppearanceVS = Qo, Us._shaders.PerInstanceColorAppearanceFS = $o, Us._shaders.PerInstanceColorAppearanceVS = ea, Us._shaders.PerInstanceFlatColorAppearanceFS = ta, Us._shaders.PerInstanceFlatColorAppearanceVS = na, Us._shaders.TexturedMaterialAppearanceFS = ia, Us._shaders.TexturedMaterialAppearanceVS = ra, Us._shaders.BillboardCollectionFS = oa, Us._shaders.BillboardCollectionVS = aa, Us._shaders.BuiltinFunctions = sa, Us._shaders.CentralBodyFS = ua, Us._shaders.CentralBodyFSDepth = la, Us._shaders.CentralBodyFSPole = ca, Us._shaders.CentralBodyVS = da, Us._shaders.CentralBodyVSDepth = fa, Us._shaders.CentralBodyVSPole = ha, Us._shaders.CustomSensorVolumeFS = pa, Us._shaders.CustomSensorVolumeVS = ma, Us._shaders.EllipsoidFS = ya, Us._shaders.EllipsoidVS = va, Us._shaders.AsphaltMaterial = ga, Us._shaders.BlobMaterial = _a, Us._shaders.BrickMaterial = wa, Us._shaders.BumpMapMaterial = Ca, Us._shaders.CementMaterial = xa, Us._shaders.CheckerboardMaterial = Sa, Us._shaders.DotMaterial = ba, Us._shaders.ErosionMaterial = Ta, Us._shaders.FacetMaterial = Ea, Us._shaders.FadeMaterial = Aa, Us._shaders.FresnelMaterial = Ma, Us._shaders.GrassMaterial = Da, Us._shaders.GridMaterial = Ia, Us._shaders.NormalMapMaterial = Pa, Us._shaders.PolylineArrowMaterial = Oa, Us._shaders.PolylineGlowMaterial = Ra, Us._shaders.PolylineOutlineMaterial = za, Us._shaders.ReflectionMaterial = La, Us._shaders.RefractionMaterial = Na, Us._shaders.RimLightingMaterial = Fa, Us._shaders.StripeMaterial = Va, Us._shaders.TieDyeMaterial = Ba, Us._shaders.Water = ka, Us._shaders.WoodMaterial = Ua, Us._shaders.PolylineFS = qa, Us._shaders.PolylineVS = Wa, Us._shaders.AdditiveBlend = Ha, Us._shaders.BrightPass = Ga, Us._shaders.GaussianBlur1D = ja, Us._shaders.PassThrough = Ya, Us._shaders.ReprojectWebMercatorFS = Xa, Us._shaders.ReprojectWebMercatorVS = Za, Us._shaders.SensorVolume = Ka, Us._shaders.SkyAtmosphereFS = Ja, Us._shaders.SkyAtmosphereVS = Qa, Us._shaders.SkyBoxFS = $a, Us._shaders.SkyBoxVS = es, Us._shaders.SunFS = ts, Us._shaders.SunVS = ns, Us._shaders.ViewportQuadFS = is, Us._shaders.ViewportQuadVS = rs, Us.Tween = os, Us.Uri = as, Us.knockout_2_2_1 = ss, Us.knockout_es5 = us, Us.knockout = ls, Us.measureText = cs, Us.sprintf = ds, Us.topojson = fs, Us.weakmap = hs, Us.when = ps, Us.Animation = ms, Us.AnimationViewModel = ys, Us.BaseLayerPicker = vs, Us.BaseLayerPickerViewModel = gs, Us.ImageryProviderViewModel = _s, Us.createDefaultBaseLayers = ws, Us.CesiumWidget = Cs, Us.ClockViewModel = xs, Us.Command = Ss, Us.FullscreenButton = bs, Us.FullscreenButtonViewModel = Ts, Us.HomeButton = Es, Us.HomeButtonViewModel = As, Us.Observable = Ms, Us.SceneModePicker = Ds, Us.SceneModePickerViewModel = Is, Us.Timeline = Ps, Us.TimelineHighlightRange = Os, Us.TimelineTrack = Rs, Us.ToggleButtonViewModel = zs, Us.Viewer = Ls, Us.viewerDragDropMixin = Ns, Us.viewerDynamicObjectMixin = Fs, Us.checkForChromeFrame = Vs, Us.createCommand = Bs, Us.getElement = ks, Us
    }), t(["Cesium"], function (e) {
        "use strict";
        var t = "undefined" != typeof window ? window : "undefined" != typeof self ? self : {};
        t.Cesium = e
    }, void 0, !0)
}();